[tool-version] Z3 4.8.7
[mk-app] #1 true
[mk-app] #2 false
[mk-app] #1 true
[mk-app] #2 false
[mk-app] #3 pi
[mk-app] #4 euler
[mk-var] datatype#0 0
[mk-var] datatype#1 1
[mk-app] datatype#2 insert datatype#0 datatype#1
[mk-app] datatype#3 pattern datatype#2
[mk-app] datatype#4 head datatype#2
[mk-app] datatype#5 = datatype#0 datatype#4
[mk-quant] datatype#6 constructor_accessor_axiom 2 datatype#3 datatype#5
[attach-var-names] datatype#6 (;k!0) (;List)
[mk-app] datatype#7 tail datatype#2
[mk-app] datatype#8 = datatype#1 datatype#7
[mk-quant] datatype#9 constructor_accessor_axiom 2 datatype#3 datatype#8
[attach-var-names] datatype#9 (;k!0) (;List)
[mk-app] #5 bv
[attach-meaning] #5 bv #b1
[mk-app] #6 bv
[attach-meaning] #6 bv #b0
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #6 bv #b0
[mk-var] #7 0
[mk-var] #8 1
[mk-var] #9 2
[mk-var] #10 3
[mk-var] #11 4
[mk-var] #12 5
[mk-var] #13 6
[mk-var] #14 7
[mk-var] #15 8
[mk-var] #16 9
[mk-var] #17 10
[mk-var] #18 11
[mk-var] #19 12
[mk-var] #20 13
[mk-var] #21 14
[mk-app] #22 + #15 #13
[mk-proof] #23 true-axiom #1
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[mk-var] #23 0
[mk-var] #15 1
[mk-var] #13 2
[mk-var] #22 3
[mk-var] #7 4
[mk-var] #21 5
[mk-var] #20 6
[mk-var] #19 7
[mk-var] #18 8
[mk-var] #17 9
[mk-var] #16 10
[mk-var] #14 11
[mk-var] #12 12
[mk-var] #11 13
[mk-var] #10 14
[mk-app] #9 + #18 #20
[mk-proof] #8 true-axiom #1
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[mk-var] datatype#10 0
[mk-var] datatype#11 1
[mk-app] datatype#12 $Snap.combine datatype#10 datatype#11
[mk-app] datatype#13 pattern datatype#12
[mk-app] datatype#14 $Snap.first datatype#12
[mk-app] datatype#15 = datatype#10 datatype#14
[mk-quant] datatype#16 constructor_accessor_axiom 2 datatype#13 datatype#15
[attach-var-names] datatype#16 (;$Snap) (;$Snap)
[mk-app] datatype#17 $Snap.second datatype#12
[mk-app] datatype#18 = datatype#11 datatype#17
[mk-quant] datatype#19 constructor_accessor_axiom 2 datatype#13 datatype#18
[attach-var-names] datatype#19 (;$Snap) (;$Snap)
[mk-app] #24 Real
[attach-meaning] #24 arith 1
[mk-app] #25 Real
[attach-meaning] #25 arith 0
[mk-app] #26 <= #25 #23
[mk-app] #27 = #23 #25
[mk-app] #28 not #27
[mk-app] #29 and #26 #28
[mk-app] #30 <= #15 #23
[mk-app] #31 if #30 #15 #23
[mk-var] #32 1
[mk-var] #33 0
[mk-app] #34 <= #32 #33
[mk-app] #35 if #34 #32 #33
[mk-app] #36 Int
[attach-meaning] #36 arith 0
[mk-app] #37 < #33 #36
[mk-app] #38 if #37 #36 #33
[mk-app] #39 $SortWrappers.IntTo$Snap #33
[mk-app] #40 $SortWrappers.$SnapToInt #39
[mk-app] #41 = #33 #40
[mk-app] #42 pattern #39
[mk-quant] #43 $Snap.$SnapToIntTo$Snap 1 #42 #41
[attach-var-names] #43 (|x| ; |Int|)
[mk-proof] #44 asserted #43
[mk-app] #45 = #43 #43
[mk-proof] #46 refl #45
[mk-var] #45 0
[mk-app] #46 $SortWrappers.$SnapToInt #45
[mk-app] #47 $SortWrappers.IntTo$Snap #46
[mk-app] #48 = #45 #47
[mk-app] #49 pattern #46
[mk-quant] #50 $Snap.IntTo$SnapToInt 1 #49 #48
[attach-var-names] #50 (|x| ; |$Snap|)
[mk-proof] #51 asserted #50
[mk-app] #52 = #50 #50
[mk-proof] #53 refl #52
[mk-var] #52 0
[mk-app] #53 $SortWrappers.BoolTo$Snap #52
[mk-app] #54 $SortWrappers.$SnapToBool #53
[mk-app] #55 = #52 #54
[mk-app] #56 pattern #53
[mk-quant] #57 $Snap.$SnapToBoolTo$Snap 1 #56 #55
[attach-var-names] #57 (|x| ; |Bool|)
[mk-proof] #58 asserted #57
[mk-app] #59 = #57 #57
[mk-proof] #60 refl #59
[mk-app] #59 $SortWrappers.$SnapToBool #45
[mk-app] #60 $SortWrappers.BoolTo$Snap #59
[mk-app] #61 = #45 #60
[mk-app] #62 pattern #59
[mk-quant] #63 $Snap.BoolTo$SnapToBool 1 #62 #61
[attach-var-names] #63 (|x| ; |$Snap|)
[mk-proof] #64 asserted #63
[mk-app] #65 = #63 #63
[mk-proof] #66 refl #65
[mk-var] #65 0
[mk-app] #66 $SortWrappers.$RefTo$Snap #65
[mk-app] #67 $SortWrappers.$SnapTo$Ref #66
[mk-app] #68 = #65 #67
[mk-app] #69 pattern #66
[mk-quant] #70 $Snap.$SnapTo$RefTo$Snap 1 #69 #68
[attach-var-names] #70 (|x| ; |$Ref|)
[mk-proof] #71 asserted #70
[mk-app] #72 = #70 #70
[mk-proof] #73 refl #72
[mk-app] #72 $SortWrappers.$SnapTo$Ref #45
[mk-app] #73 $SortWrappers.$RefTo$Snap #72
[mk-app] #74 = #45 #73
[mk-app] #75 pattern #72
[mk-quant] #76 $Snap.$RefTo$SnapTo$Ref 1 #75 #74
[attach-var-names] #76 (|x| ; |$Snap|)
[mk-proof] #77 asserted #76
[mk-app] #78 = #76 #76
[mk-proof] #79 refl #78
[mk-app] #78 $SortWrappers.$PermTo$Snap #23
[mk-app] #79 $SortWrappers.$SnapTo$Perm #78
[mk-app] #80 = #23 #79
[mk-app] #81 pattern #78
[mk-quant] #82 $Snap.$SnapTo$PermTo$Snap 1 #81 #80
[attach-var-names] #82 (|x| ; |Real|)
[mk-proof] #83 asserted #82
[mk-app] #84 = #82 #82
[mk-proof] #85 refl #84
[mk-app] #84 $SortWrappers.$SnapTo$Perm #45
[mk-app] #85 $SortWrappers.$PermTo$Snap #84
[mk-app] #86 = #45 #85
[mk-app] #87 pattern #84
[mk-quant] #88 $Snap.$PermTo$SnapTo$Perm 1 #87 #86
[attach-var-names] #88 (|x| ; |$Snap|)
[mk-proof] #89 asserted #88
[mk-app] #90 = #88 #88
[mk-proof] #91 refl #90
[mk-var] #90 0
[mk-app] #91 $SortWrappers.Seq<Int>To$Snap #90
[mk-app] #92 $SortWrappers.$SnapToSeq<Int> #91
[mk-app] #93 = #90 #92
[mk-app] #94 pattern #91
[mk-quant] #95 $Snap.$SnapToSeq<Int>To$Snap 1 #94 #93
[attach-var-names] #95 (|x| ; |Seq<Int>|)
[mk-proof] #96 asserted #95
[mk-app] #97 = #95 #95
[mk-proof] #98 refl #97
[mk-app] #97 $SortWrappers.$SnapToSeq<Int> #45
[mk-app] #98 $SortWrappers.Seq<Int>To$Snap #97
[mk-app] #99 = #45 #98
[mk-app] #100 pattern #97
[mk-quant] #101 $Snap.Seq<Int>To$SnapToSeq<Int> 1 #100 #99
[attach-var-names] #101 (|x| ; |$Snap|)
[mk-proof] #102 asserted #101
[mk-app] #103 = #101 #101
[mk-proof] #104 refl #103
[mk-var] #103 0
[mk-app] #104 $SortWrappers.Ptr32To$Snap #103
[mk-app] #105 $SortWrappers.$SnapToPtr32 #104
[mk-app] #106 = #103 #105
[mk-app] #107 pattern #104
[mk-quant] #108 $Snap.$SnapToPtr32To$Snap 1 #107 #106
[attach-var-names] #108 (|x| ; |Ptr32|)
[mk-proof] #109 asserted #108
[mk-app] #110 = #108 #108
[mk-proof] #111 refl #110
[mk-app] #110 $SortWrappers.$SnapToPtr32 #45
[mk-app] #111 $SortWrappers.Ptr32To$Snap #110
[mk-app] #112 = #45 #111
[mk-app] #113 pattern #110
[mk-quant] #114 $Snap.Ptr32To$SnapToPtr32 1 #113 #112
[attach-var-names] #114 (|x| ; |$Snap|)
[mk-proof] #115 asserted #114
[mk-app] #116 = #114 #114
[mk-proof] #117 refl #116
[mk-app] #116 Seq_length #90
[mk-app] #117 <= #36 #116
[mk-app] #118 pattern #116
[mk-quant] #119 k!133 1 #118 #117
[attach-var-names] #119 (|s| ; |Seq<Int>|)
[mk-proof] #120 asserted #119
[mk-app] #121 Int
[attach-meaning] #121 arith (- 1)
[mk-app] #122 * #121 #116
[mk-app] #123 >= #116 #36
[inst-discovered] theory-solving 0x0 arith# ; #117
[mk-app] #121 = #117 #123
[mk-proof] #122 rewrite #121
[instance] 0x0 #121
[end-of-instance]
[mk-quant] #124 k!133 1 #118 #123
[attach-var-names] #124 (|s| ; |Seq<Int>|)
[mk-lambda] #125 null 1 #122
[mk-proof] #126 proof-bind #125
[mk-app] #127 = #119 #124
[mk-proof] #128 quant-intro #126 #127
[mk-proof] #129 mp #120 #128 #124
[mk-app] #130 Seq_empty
[mk-app] #131 Seq_length #130
[mk-app] #132 = #131 #36
[mk-proof] #133 asserted #132
[mk-app] #134 = #132 #132
[mk-proof] #135 refl #134
[mk-app] #134 = #116 #36
[mk-app] #135 = #90 #130
[mk-app] #136 => #134 #135
[mk-quant] #137 k!138 1 #118 #136
[attach-var-names] #137 (|s| ; |Seq<Int>|)
[mk-proof] #138 asserted #137
[mk-app] #139 not #134
[mk-app] #140 or #139 #135
[inst-discovered] theory-solving 0x0 basic# ; #136
[mk-app] #141 = #136 #140
[mk-proof] #142 rewrite #141
[instance] 0x0 #141
[end-of-instance]
[mk-quant] #143 k!138 1 #118 #140
[attach-var-names] #143 (|s| ; |Seq<Int>|)
[mk-lambda] #144 null 1 #142
[mk-proof] #145 proof-bind #144
[mk-app] #146 = #137 #143
[mk-proof] #147 quant-intro #145 #146
[mk-proof] #148 mp #138 #147 #143
[mk-app] #149 Seq_singleton #33
[mk-app] #150 Seq_length #149
[mk-app] #151 Int
[attach-meaning] #151 arith 1
[mk-app] #152 = #150 #151
[mk-app] #153 pattern #149
[mk-quant] #154 k!142 1 #153 #152
[attach-var-names] #154 (|e| ; |Int|)
[mk-proof] #155 asserted #154
[mk-app] #156 = #154 #154
[mk-proof] #157 refl #156
[mk-var] #156 1
[mk-app] #157 = #156 #130
[mk-app] #158 not #157
[mk-app] #159 not #135
[mk-app] #160 and #158 #159
[mk-app] #161 Seq_append #156 #90
[mk-app] #162 Seq_length #161
[mk-app] #163 Seq_length #156
[mk-app] #164 + #163 #116
[mk-app] #165 = #162 #164
[mk-app] #166 => #160 #165
[mk-app] #167 pattern #162
[mk-quant] #168 k!150 2 #167 #166
[attach-var-names] #168 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-proof] #169 asserted #168
[mk-app] #170 + #116 #163
[inst-discovered] theory-solving 0x0 arith# ; #164
[mk-app] #171 = #164 #170
[mk-proof] #172 rewrite #171
[instance] 0x0 #171
[end-of-instance]
[mk-app] #173 = #162 #170
[mk-app] #174 = #165 #173
[mk-proof] #175 monotonicity #172 #174
[mk-app] #176 Int
[attach-meaning] #176 arith (- 1)
[mk-app] #177 * #176 #116
[attach-meaning] #176 arith (- 1)
[mk-app] #178 * #176 #163
[mk-app] #179 + #177 #162 #178
[attach-meaning] #176 arith (- 1)
[mk-app] #180 * #176 #162
[mk-app] #181 + #116 #180 #163
[mk-app] #177 = #181 #36
[inst-discovered] theory-solving 0x0 arith# ; #173
[mk-app] #178 = #173 #177
[mk-proof] #179 rewrite #178
[instance] 0x0 #178
[end-of-instance]
[mk-app] #182 = #165 #177
[mk-proof] #183 trans #175 #179 #182
[mk-app] #184 => #160 #177
[mk-app] #185 = #166 #184
[mk-proof] #186 monotonicity #183 #185
[mk-app] #187 not #160
[mk-app] #188 or #187 #177
[inst-discovered] theory-solving 0x0 basic# ; #184
[mk-app] #189 = #184 #188
[mk-proof] #190 rewrite #189
[instance] 0x0 #189
[end-of-instance]
[mk-app] #191 = #166 #188
[mk-proof] #192 trans #186 #190 #191
[mk-quant] #193 k!150 2 #167 #188
[attach-var-names] #193 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #194 null 2 #192
[mk-proof] #195 proof-bind #194
[mk-app] #196 = #168 #193
[mk-proof] #197 quant-intro #195 #196
[mk-proof] #198 mp #169 #197 #193
[mk-app] #199 = #161 #90
[mk-app] #200 => #157 #199
[mk-app] #201 = #161 #156
[mk-app] #202 => #135 #201
[mk-app] #203 and #200 #202
[mk-app] #204 pattern #161
[mk-quant] #205 k!156 2 #204 #203
[attach-var-names] #205 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-proof] #206 asserted #205
[mk-app] #207 or #158 #199
[inst-discovered] theory-solving 0x0 basic# ; #200
[mk-app] #208 = #200 #207
[mk-proof] #209 rewrite #208
[instance] 0x0 #208
[end-of-instance]
[mk-app] #210 or #159 #201
[inst-discovered] theory-solving 0x0 basic# ; #202
[mk-app] #211 = #202 #210
[mk-proof] #212 rewrite #211
[instance] 0x0 #211
[end-of-instance]
[mk-app] #213 and #207 #210
[mk-app] #214 = #203 #213
[mk-proof] #215 monotonicity #209 #212 #214
[mk-quant] #216 k!156 2 #204 #213
[attach-var-names] #216 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #217 null 2 #215
[mk-proof] #218 proof-bind #217
[mk-app] #219 = #205 #216
[mk-proof] #220 quant-intro #218 #219
[mk-proof] #221 mp #206 #220 #216
[mk-app] #222 Seq_index #149 #36
[mk-app] #223 = #222 #33
[mk-quant] #224 k!160 1 #153 #223
[attach-var-names] #224 (|e| ; |Int|)
[mk-proof] #225 asserted #224
[mk-app] #226 = #224 #224
[mk-proof] #227 refl #226
[mk-app] #226 Seq_add #32 #33
[mk-app] #227 + #32 #33
[mk-app] #228 = #226 #227
[mk-app] #229 pattern #226
[mk-quant] #230 k!164 2 #229 #228
[attach-var-names] #230 (|j| ; |Int|) (|i| ; |Int|)
[mk-proof] #231 asserted #230
[attach-meaning] #176 arith (- 1)
[mk-app] #232 * #176 #32
[attach-meaning] #176 arith (- 1)
[mk-app] #233 * #176 #33
[mk-app] #234 + #232 #233 #226
[attach-meaning] #176 arith (- 1)
[mk-app] #235 * #176 #226
[mk-app] #236 + #32 #33 #235
[mk-app] #232 = #236 #36
[inst-discovered] theory-solving 0x0 arith# ; #228
[mk-app] #233 = #228 #232
[mk-proof] #234 rewrite #233
[instance] 0x0 #233
[end-of-instance]
[mk-quant] #237 k!164 2 #229 #232
[attach-var-names] #237 (|j| ; |Int|) (|i| ; |Int|)
[mk-lambda] #238 null 2 #234
[mk-proof] #239 proof-bind #238
[mk-app] #240 = #230 #237
[mk-proof] #241 quant-intro #239 #240
[mk-proof] #242 mp #231 #241 #237
[mk-app] #243 Seq_sub #32 #33
[mk-app] #244 - #32 #33
[mk-app] #245 = #243 #244
[mk-app] #246 pattern #243
[mk-quant] #247 k!168 2 #246 #245
[attach-var-names] #247 (|j| ; |Int|) (|i| ; |Int|)
[mk-proof] #248 asserted #247
[attach-meaning] #176 arith (- 1)
[mk-app] #249 * #176 #33
[mk-app] #250 + #32 #249
[inst-discovered] theory-solving 0x0 arith# ; #244
[mk-app] #251 = #244 #250
[mk-proof] #252 rewrite #251
[instance] 0x0 #251
[end-of-instance]
[mk-app] #253 = #243 #250
[mk-app] #254 = #245 #253
[mk-proof] #255 monotonicity #252 #254
[attach-meaning] #176 arith (- 1)
[mk-app] #256 * #176 #32
[mk-app] #257 + #256 #33 #243
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #258 * #176 #243
[mk-app] #259 + #32 #249 #258
[mk-app] #256 = #259 #36
[inst-discovered] theory-solving 0x0 arith# ; #253
[mk-app] #257 = #253 #256
[mk-proof] #260 rewrite #257
[instance] 0x0 #257
[end-of-instance]
[mk-app] #261 = #245 #256
[mk-proof] #262 trans #255 #260 #261
[mk-quant] #263 k!168 2 #246 #256
[attach-var-names] #263 (|j| ; |Int|) (|i| ; |Int|)
[mk-lambda] #264 null 2 #262
[mk-proof] #265 proof-bind #264
[mk-app] #266 = #247 #263
[mk-proof] #267 quant-intro #265 #266
[mk-proof] #268 mp #248 #267 #263
[mk-var] #269 2
[mk-app] #270 = #269 #130
[mk-app] #271 not #270
[mk-app] #272 <= #36 #33
[mk-app] #273 Seq_length #269
[mk-app] #274 < #33 #273
[mk-app] #275 and #272 #274
[mk-app] #276 and #158 #275
[mk-app] #277 and #271 #276
[mk-app] #278 Seq_append #269 #156
[mk-app] #279 Seq_index #278 #33
[mk-app] #280 Seq_index #269 #33
[mk-app] #281 = #279 #280
[mk-app] #282 => #277 #281
[mk-app] #283 pattern #279
[mk-app] #284 pattern #280 #278
[mk-quant] #285 k!179 3 #283 #284 #282
[attach-var-names] #285 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-proof] #286 asserted #285
[attach-meaning] #176 arith (- 1)
[mk-app] #287 >= #33 #36
[inst-discovered] theory-solving 0x0 arith# ; #272
[mk-app] #288 = #272 #287
[mk-proof] #289 rewrite #288
[instance] 0x0 #288
[end-of-instance]
[mk-app] #290 <= #273 #33
[mk-app] #291 not #290
[inst-discovered] theory-solving 0x0 arith# ; #274
[mk-app] #292 = #274 #291
[mk-proof] #293 rewrite #292
[instance] 0x0 #292
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #294 + #249 #273
[attach-meaning] #176 arith (- 1)
[mk-app] #295 * #176 #273
[mk-app] #296 + #33 #295
[mk-app] #294 >= #296 #36
[inst-discovered] theory-solving 0x0 arith# ; #290
[mk-app] #297 = #290 #294
[mk-proof] #298 rewrite #297
[instance] 0x0 #297
[end-of-instance]
[mk-app] #299 not #294
[mk-app] #300 = #291 #299
[mk-proof] #301 monotonicity #298 #300
[mk-app] #302 = #274 #299
[mk-proof] #303 trans #293 #301 #302
[mk-app] #304 and #287 #299
[mk-app] #305 = #275 #304
[mk-proof] #306 monotonicity #289 #303 #305
[mk-app] #307 and #158 #304
[mk-app] #308 = #276 #307
[mk-proof] #309 monotonicity #306 #308
[mk-app] #310 and #158 #287 #299
[inst-discovered] theory-solving 0x0 basic# ; #307
[mk-app] #311 = #307 #310
[mk-proof] #312 rewrite #311
[instance] 0x0 #311
[end-of-instance]
[mk-app] #313 = #276 #310
[mk-proof] #314 trans #309 #312 #313
[mk-app] #315 and #271 #310
[mk-app] #316 = #277 #315
[mk-proof] #317 monotonicity #314 #316
[mk-app] #318 and #271 #158 #287 #299
[inst-discovered] theory-solving 0x0 basic# ; #315
[mk-app] #319 = #315 #318
[mk-proof] #320 rewrite #319
[instance] 0x0 #319
[end-of-instance]
[mk-app] #321 = #277 #318
[mk-proof] #322 trans #317 #320 #321
[mk-app] #323 => #318 #281
[mk-app] #324 = #282 #323
[mk-proof] #325 monotonicity #322 #324
[mk-app] #326 not #318
[mk-app] #327 or #326 #281
[inst-discovered] theory-solving 0x0 basic# ; #323
[mk-app] #328 = #323 #327
[mk-proof] #329 rewrite #328
[instance] 0x0 #328
[end-of-instance]
[mk-app] #330 = #282 #327
[mk-proof] #331 trans #325 #329 #330
[mk-quant] #332 k!179 3 #283 #284 #327
[attach-var-names] #332 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #333 null 3 #331
[mk-proof] #334 proof-bind #333
[mk-app] #335 = #285 #332
[mk-proof] #336 quant-intro #334 #335
[mk-proof] #337 mp #286 #336 #332
[mk-app] #338 Seq_length #278
[mk-app] #339 < #33 #338
[mk-app] #340 and #290 #339
[mk-app] #341 and #158 #340
[mk-app] #342 and #271 #341
[mk-app] #343 Seq_sub #33 #273
[mk-app] #344 Seq_add #343 #273
[mk-app] #345 = #344 #33
[mk-app] #346 Seq_index #156 #343
[mk-app] #347 = #279 #346
[mk-app] #348 and #345 #347
[mk-app] #349 => #342 #348
[mk-quant] #350 k!193 3 #283 #349
[attach-var-names] #350 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-proof] #351 asserted #350
[attach-meaning] #176 arith (- 1)
[mk-app] #352 + #249 #273
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #290
[instance] 0x0 #297
[end-of-instance]
[mk-app] #352 <= #338 #33
[mk-app] #353 not #352
[inst-discovered] theory-solving 0x0 arith# ; #339
[mk-app] #354 = #339 #353
[mk-proof] #355 rewrite #354
[instance] 0x0 #354
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #356 + #249 #338
[attach-meaning] #176 arith (- 1)
[mk-app] #357 * #176 #338
[mk-app] #358 + #33 #357
[mk-app] #356 >= #358 #36
[inst-discovered] theory-solving 0x0 arith# ; #352
[mk-app] #359 = #352 #356
[mk-proof] #360 rewrite #359
[instance] 0x0 #359
[end-of-instance]
[mk-app] #361 not #356
[mk-app] #362 = #353 #361
[mk-proof] #363 monotonicity #360 #362
[mk-app] #364 = #339 #361
[mk-proof] #365 trans #355 #363 #364
[mk-app] #366 and #294 #361
[mk-app] #367 = #340 #366
[mk-proof] #368 monotonicity #298 #365 #367
[mk-app] #369 and #158 #366
[mk-app] #370 = #341 #369
[mk-proof] #371 monotonicity #368 #370
[mk-app] #372 and #158 #294 #361
[inst-discovered] theory-solving 0x0 basic# ; #369
[mk-app] #373 = #369 #372
[mk-proof] #374 rewrite #373
[instance] 0x0 #373
[end-of-instance]
[mk-app] #375 = #341 #372
[mk-proof] #376 trans #371 #374 #375
[mk-app] #377 and #271 #372
[mk-app] #378 = #342 #377
[mk-proof] #379 monotonicity #376 #378
[mk-app] #380 and #271 #158 #294 #361
[inst-discovered] theory-solving 0x0 basic# ; #377
[mk-app] #381 = #377 #380
[mk-proof] #382 rewrite #381
[instance] 0x0 #381
[end-of-instance]
[mk-app] #383 = #342 #380
[mk-proof] #384 trans #379 #382 #383
[mk-app] #385 => #380 #348
[mk-app] #386 = #349 #385
[mk-proof] #387 monotonicity #384 #386
[mk-app] #388 not #380
[mk-app] #389 or #388 #348
[inst-discovered] theory-solving 0x0 basic# ; #385
[mk-app] #390 = #385 #389
[mk-proof] #391 rewrite #390
[instance] 0x0 #390
[end-of-instance]
[mk-app] #392 = #349 #389
[mk-proof] #393 trans #387 #391 #392
[mk-quant] #394 k!193 3 #283 #389
[attach-var-names] #394 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #395 null 3 #393
[mk-proof] #396 proof-bind #395
[mk-app] #397 = #350 #394
[mk-proof] #398 quant-intro #396 #397
[mk-proof] #399 mp #351 #398 #394
[mk-app] #400 < #33 #163
[mk-app] #401 and #272 #400
[mk-app] #402 and #158 #401
[mk-app] #403 and #271 #402
[mk-app] #404 Seq_add #33 #273
[mk-app] #405 Seq_sub #404 #273
[mk-app] #406 = #405 #33
[mk-app] #407 Seq_index #278 #404
[mk-app] #408 Seq_index #156 #33
[mk-app] #409 = #407 #408
[mk-app] #410 and #406 #409
[mk-app] #411 => #403 #410
[mk-app] #412 pattern #408 #278
[mk-quant] #413 k!207 3 #412 #411
[attach-var-names] #413 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-proof] #414 asserted #413
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #272
[instance] 0x0 #288
[end-of-instance]
[mk-app] #415 <= #163 #33
[mk-app] #416 not #415
[inst-discovered] theory-solving 0x0 arith# ; #400
[mk-app] #417 = #400 #416
[mk-proof] #418 rewrite #417
[instance] 0x0 #417
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #419 + #249 #163
[attach-meaning] #176 arith (- 1)
[mk-app] #420 * #176 #163
[mk-app] #421 + #33 #420
[mk-app] #419 >= #421 #36
[inst-discovered] theory-solving 0x0 arith# ; #415
[mk-app] #422 = #415 #419
[mk-proof] #423 rewrite #422
[instance] 0x0 #422
[end-of-instance]
[mk-app] #424 not #419
[mk-app] #425 = #416 #424
[mk-proof] #426 monotonicity #423 #425
[mk-app] #427 = #400 #424
[mk-proof] #428 trans #418 #426 #427
[mk-app] #429 and #287 #424
[mk-app] #430 = #401 #429
[mk-proof] #431 monotonicity #289 #428 #430
[mk-app] #432 and #158 #429
[mk-app] #433 = #402 #432
[mk-proof] #434 monotonicity #431 #433
[mk-app] #435 and #158 #287 #424
[inst-discovered] theory-solving 0x0 basic# ; #432
[mk-app] #436 = #432 #435
[mk-proof] #437 rewrite #436
[instance] 0x0 #436
[end-of-instance]
[mk-app] #438 = #402 #435
[mk-proof] #439 trans #434 #437 #438
[mk-app] #440 and #271 #435
[mk-app] #441 = #403 #440
[mk-proof] #442 monotonicity #439 #441
[mk-app] #443 and #271 #158 #287 #424
[inst-discovered] theory-solving 0x0 basic# ; #440
[mk-app] #444 = #440 #443
[mk-proof] #445 rewrite #444
[instance] 0x0 #444
[end-of-instance]
[mk-app] #446 = #403 #443
[mk-proof] #447 trans #442 #445 #446
[mk-app] #448 => #443 #410
[mk-app] #449 = #411 #448
[mk-proof] #450 monotonicity #447 #449
[mk-app] #451 not #443
[mk-app] #452 or #451 #410
[inst-discovered] theory-solving 0x0 basic# ; #448
[mk-app] #453 = #448 #452
[mk-proof] #454 rewrite #453
[instance] 0x0 #453
[end-of-instance]
[mk-app] #455 = #411 #452
[mk-proof] #456 trans #450 #454 #455
[mk-quant] #457 k!207 3 #412 #452
[attach-var-names] #457 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #458 null 3 #456
[mk-proof] #459 proof-bind #458
[mk-app] #460 = #413 #457
[mk-proof] #461 quant-intro #459 #460
[mk-proof] #462 mp #414 #461 #457
[mk-app] #463 <= #36 #32
[mk-app] #464 < #32 #273
[mk-app] #465 and #463 #464
[mk-app] #466 Seq_update #269 #32 #33
[mk-app] #467 Seq_length #466
[mk-app] #468 = #467 #273
[mk-app] #469 => #465 #468
[mk-app] #470 pattern #467
[mk-app] #471 pattern #273 #466
[mk-quant] #472 k!214 3 #470 #471 #469
[attach-var-names] #472 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #473 asserted #472
[attach-meaning] #176 arith (- 1)
[mk-app] #474 * #176 #32
[mk-app] #475 >= #32 #36
[inst-discovered] theory-solving 0x0 arith# ; #463
[mk-app] #474 = #463 #475
[mk-proof] #476 rewrite #474
[instance] 0x0 #474
[end-of-instance]
[mk-app] #477 <= #273 #32
[mk-app] #478 not #477
[inst-discovered] theory-solving 0x0 arith# ; #464
[mk-app] #479 = #464 #478
[mk-proof] #480 rewrite #479
[instance] 0x0 #479
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #481 * #176 #32
[mk-app] #482 + #481 #273
[attach-meaning] #176 arith (- 1)
[mk-app] #483 + #32 #295
[mk-app] #481 >= #483 #36
[inst-discovered] theory-solving 0x0 arith# ; #477
[mk-app] #482 = #477 #481
[mk-proof] #484 rewrite #482
[instance] 0x0 #482
[end-of-instance]
[mk-app] #485 not #481
[mk-app] #486 = #478 #485
[mk-proof] #487 monotonicity #484 #486
[mk-app] #488 = #464 #485
[mk-proof] #489 trans #480 #487 #488
[mk-app] #490 and #475 #485
[mk-app] #491 = #465 #490
[mk-proof] #492 monotonicity #476 #489 #491
[mk-app] #493 => #490 #468
[mk-app] #494 = #469 #493
[mk-proof] #495 monotonicity #492 #494
[mk-app] #496 not #490
[mk-app] #497 or #496 #468
[inst-discovered] theory-solving 0x0 basic# ; #493
[mk-app] #498 = #493 #497
[mk-proof] #499 rewrite #498
[instance] 0x0 #498
[end-of-instance]
[mk-app] #500 = #469 #497
[mk-proof] #501 trans #495 #499 #500
[mk-quant] #502 k!214 3 #470 #471 #497
[attach-var-names] #502 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #503 null 3 #501
[mk-proof] #504 proof-bind #503
[mk-app] #505 = #472 #502
[mk-proof] #506 quant-intro #504 #505
[mk-proof] #507 mp #473 #506 #502
[mk-var] #508 3
[mk-var] #509 2
[mk-app] #510 Seq_length #508
[mk-app] #511 < #33 #510
[mk-app] #512 and #272 #511
[mk-app] #513 = #509 #33
[mk-app] #514 Seq_update #508 #509 #32
[mk-app] #515 Seq_index #514 #33
[mk-app] #516 = #515 #32
[mk-app] #517 => #513 #516
[mk-app] #518 not #513
[mk-app] #519 Seq_index #508 #33
[mk-app] #520 = #515 #519
[mk-app] #521 => #518 #520
[mk-app] #522 and #517 #521
[mk-app] #523 => #512 #522
[mk-app] #524 pattern #515
[mk-app] #525 pattern #519 #514
[mk-quant] #526 k!223 4 #524 #525 #523
[attach-var-names] #526 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #527 asserted #526
[mk-app] #528 <= #510 #33
[mk-app] #529 not #528
[inst-discovered] theory-solving 0x0 arith# ; #511
[mk-app] #530 = #511 #529
[mk-proof] #531 rewrite #530
[instance] 0x0 #530
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #532 + #249 #510
[attach-meaning] #176 arith (- 1)
[mk-app] #533 * #176 #510
[mk-app] #534 + #33 #533
[mk-app] #532 >= #534 #36
[inst-discovered] theory-solving 0x0 arith# ; #528
[mk-app] #535 = #528 #532
[mk-proof] #536 rewrite #535
[instance] 0x0 #535
[end-of-instance]
[mk-app] #537 not #532
[mk-app] #538 = #529 #537
[mk-proof] #539 monotonicity #536 #538
[mk-app] #540 = #511 #537
[mk-proof] #541 trans #531 #539 #540
[mk-app] #542 and #287 #537
[mk-app] #543 = #512 #542
[mk-proof] #544 monotonicity #289 #541 #543
[mk-app] #545 or #518 #516
[inst-discovered] theory-solving 0x0 basic# ; #517
[mk-app] #546 = #517 #545
[mk-proof] #547 rewrite #546
[instance] 0x0 #546
[end-of-instance]
[mk-app] #548 or #513 #520
[inst-discovered] theory-solving 0x0 basic# ; #521
[mk-app] #549 = #521 #548
[mk-proof] #550 rewrite #549
[instance] 0x0 #549
[end-of-instance]
[mk-app] #551 and #545 #548
[mk-app] #552 = #522 #551
[mk-proof] #553 monotonicity #547 #550 #552
[mk-app] #554 => #542 #551
[mk-app] #555 = #523 #554
[mk-proof] #556 monotonicity #544 #553 #555
[mk-app] #557 not #542
[mk-app] #558 or #557 #551
[inst-discovered] theory-solving 0x0 basic# ; #554
[mk-app] #559 = #554 #558
[mk-proof] #560 rewrite #559
[instance] 0x0 #559
[end-of-instance]
[mk-app] #561 = #523 #558
[mk-proof] #562 trans #556 #560 #561
[mk-quant] #563 k!223 4 #524 #525 #558
[attach-var-names] #563 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #564 null 4 #562
[mk-proof] #565 proof-bind #564
[mk-app] #566 = #526 #563
[mk-proof] #567 quant-intro #565 #566
[mk-proof] #568 mp #527 #567 #563
[mk-app] #569 <= #33 #163
[mk-app] #570 Seq_take #156 #33
[mk-app] #571 Seq_length #570
[mk-app] #572 = #571 #33
[mk-app] #573 => #569 #572
[mk-app] #574 < #163 #33
[mk-app] #575 = #571 #163
[mk-app] #576 => #574 #575
[mk-app] #577 and #573 #576
[mk-app] #578 => #272 #577
[mk-app] #579 = #571 #36
[mk-app] #580 => #37 #579
[mk-app] #581 and #578 #580
[mk-app] #582 pattern #571
[mk-app] #583 pattern #570 #163
[mk-quant] #584 k!234 2 #582 #583 #581
[attach-var-names] #584 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #585 asserted #584
[attach-meaning] #176 arith (- 1)
[mk-app] #586 <= #421 #36
[inst-discovered] theory-solving 0x0 arith# ; #569
[mk-app] #587 = #569 #586
[mk-proof] #588 rewrite #587
[instance] 0x0 #587
[end-of-instance]
[mk-app] #589 => #586 #572
[mk-app] #590 = #573 #589
[mk-proof] #591 monotonicity #588 #590
[mk-app] #592 not #586
[mk-app] #593 or #592 #572
[inst-discovered] theory-solving 0x0 basic# ; #589
[mk-app] #594 = #589 #593
[mk-proof] #595 rewrite #594
[instance] 0x0 #594
[end-of-instance]
[mk-app] #596 = #573 #593
[mk-proof] #597 trans #591 #595 #596
[mk-app] #598 not #569
[inst-discovered] theory-solving 0x0 arith# ; #574
[mk-app] #599 = #574 #598
[mk-proof] #600 rewrite #599
[instance] 0x0 #599
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #569
[instance] 0x0 #587
[end-of-instance]
[mk-app] #601 = #598 #592
[mk-proof] #602 monotonicity #588 #601
[mk-app] #603 = #574 #592
[mk-proof] #604 trans #600 #602 #603
[mk-app] #605 => #592 #575
[mk-app] #606 = #576 #605
[mk-proof] #607 monotonicity #604 #606
[mk-app] #608 or #575 #586
[inst-discovered] theory-solving 0x0 basic# ; #605
[mk-app] #609 = #605 #608
[mk-proof] #610 rewrite #609
[instance] 0x0 #609
[end-of-instance]
[mk-app] #611 = #576 #608
[mk-proof] #612 trans #607 #610 #611
[mk-app] #613 and #593 #608
[mk-app] #614 = #577 #613
[mk-proof] #615 monotonicity #597 #612 #614
[mk-app] #616 => #287 #613
[mk-app] #617 = #578 #616
[mk-proof] #618 monotonicity #289 #615 #617
[mk-app] #619 not #287
[mk-app] #620 or #619 #613
[inst-discovered] theory-solving 0x0 basic# ; #616
[mk-app] #621 = #616 #620
[mk-proof] #622 rewrite #621
[instance] 0x0 #621
[end-of-instance]
[mk-app] #623 = #578 #620
[mk-proof] #624 trans #618 #622 #623
[mk-app] #625 not #272
[inst-discovered] theory-solving 0x0 arith# ; #37
[mk-app] #626 = #37 #625
[mk-proof] #627 rewrite #626
[instance] 0x0 #626
[end-of-instance]
[mk-app] #628 = #625 #619
[mk-proof] #629 monotonicity #289 #628
[mk-app] #630 = #37 #619
[mk-proof] #631 trans #627 #629 #630
[mk-app] #632 => #619 #579
[mk-app] #633 = #580 #632
[mk-proof] #634 monotonicity #631 #633
[mk-app] #635 or #287 #579
[inst-discovered] theory-solving 0x0 basic# ; #632
[mk-app] #636 = #632 #635
[mk-proof] #637 rewrite #636
[instance] 0x0 #636
[end-of-instance]
[mk-app] #638 = #580 #635
[mk-proof] #639 trans #634 #637 #638
[mk-app] #640 and #620 #635
[mk-app] #641 = #581 #640
[mk-proof] #642 monotonicity #624 #639 #641
[mk-quant] #643 k!234 2 #582 #583 #640
[attach-var-names] #643 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #644 null 2 #642
[mk-proof] #645 proof-bind #644
[mk-app] #646 = #584 #643
[mk-proof] #647 quant-intro #645 #646
[mk-proof] #648 mp #585 #647 #643
[mk-app] #649 < #33 #32
[mk-app] #650 and #649 #274
[mk-app] #651 and #272 #650
[mk-app] #652 Seq_take #269 #32
[mk-app] #653 Seq_index #652 #33
[mk-app] #654 = #653 #280
[mk-app] #655 => #651 #654
[mk-app] #656 pattern #653
[mk-app] #657 pattern #280 #652
[mk-quant] #658 k!241 3 #656 #657 #655
[attach-var-names] #658 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #659 asserted #658
[mk-app] #660 not #34
[inst-discovered] theory-solving 0x0 arith# ; #649
[mk-app] #661 = #649 #660
[mk-proof] #662 rewrite #661
[instance] 0x0 #661
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #663 <= #250 #36
[inst-discovered] theory-solving 0x0 arith# ; #34
[mk-app] #664 = #34 #663
[mk-proof] #665 rewrite #664
[instance] 0x0 #664
[end-of-instance]
[mk-app] #666 not #663
[mk-app] #667 = #660 #666
[mk-proof] #668 monotonicity #665 #667
[mk-app] #669 = #649 #666
[mk-proof] #670 trans #662 #668 #669
[inst-discovered] theory-solving 0x0 arith# ; #274
[instance] 0x0 #292
[end-of-instance]
[mk-app] #671 and #666 #299
[mk-app] #672 = #650 #671
[mk-proof] #673 monotonicity #670 #303 #672
[mk-app] #674 and #287 #671
[mk-app] #675 = #651 #674
[mk-proof] #676 monotonicity #289 #673 #675
[mk-app] #677 and #287 #666 #299
[inst-discovered] theory-solving 0x0 basic# ; #674
[mk-app] #678 = #674 #677
[mk-proof] #679 rewrite #678
[instance] 0x0 #678
[end-of-instance]
[mk-app] #680 = #651 #677
[mk-proof] #681 trans #676 #679 #680
[mk-app] #682 => #677 #654
[mk-app] #683 = #655 #682
[mk-proof] #684 monotonicity #681 #683
[mk-app] #685 not #677
[mk-app] #686 or #685 #654
[inst-discovered] theory-solving 0x0 basic# ; #682
[mk-app] #687 = #682 #686
[mk-proof] #688 rewrite #687
[instance] 0x0 #687
[end-of-instance]
[mk-app] #689 = #655 #686
[mk-proof] #690 trans #684 #688 #689
[mk-quant] #691 k!241 3 #656 #657 #686
[attach-var-names] #691 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #692 null 3 #690
[mk-proof] #693 proof-bind #692
[mk-app] #694 = #658 #691
[mk-proof] #695 quant-intro #693 #694
[mk-proof] #696 mp #659 #695 #691
[mk-app] #697 Seq_drop #156 #33
[mk-app] #698 Seq_length #697
[mk-app] #699 - #163 #33
[mk-app] #700 = #698 #699
[mk-app] #701 => #569 #700
[mk-app] #702 = #698 #36
[mk-app] #703 => #574 #702
[mk-app] #704 and #701 #703
[mk-app] #705 => #272 #704
[mk-app] #706 = #698 #163
[mk-app] #707 => #37 #706
[mk-app] #708 and #705 #707
[mk-app] #709 pattern #698
[mk-app] #710 pattern #163 #697
[mk-quant] #711 k!254 2 #709 #710 #708
[attach-var-names] #711 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #712 asserted #711
[attach-meaning] #176 arith (- 1)
[mk-app] #713 + #163 #249
[inst-discovered] theory-solving 0x0 arith# ; #699
[mk-app] #714 = #699 #713
[mk-proof] #715 rewrite #714
[instance] 0x0 #714
[end-of-instance]
[mk-app] #716 + #249 #163
[inst-discovered] theory-solving 0x0 arith# ; #713
[mk-app] #717 = #713 #716
[mk-proof] #718 rewrite #717
[instance] 0x0 #717
[end-of-instance]
[mk-app] #719 = #699 #716
[mk-proof] #720 trans #715 #718 #719
[mk-app] #721 = #698 #716
[mk-app] #722 = #700 #721
[mk-proof] #723 monotonicity #720 #722
[attach-meaning] #176 arith (- 1)
[mk-app] #724 + #33 #420 #698
[mk-app] #725 = #724 #36
[inst-discovered] theory-solving 0x0 arith# ; #721
[mk-app] #726 = #721 #725
[mk-proof] #727 rewrite #726
[instance] 0x0 #726
[end-of-instance]
[mk-app] #728 = #700 #725
[mk-proof] #729 trans #723 #727 #728
[mk-app] #730 => #586 #725
[mk-app] #731 = #701 #730
[mk-proof] #732 monotonicity #588 #729 #731
[mk-app] #733 or #592 #725
[inst-discovered] theory-solving 0x0 basic# ; #730
[mk-app] #734 = #730 #733
[mk-proof] #735 rewrite #734
[instance] 0x0 #734
[end-of-instance]
[mk-app] #736 = #701 #733
[mk-proof] #737 trans #732 #735 #736
[inst-discovered] theory-solving 0x0 arith# ; #574
[instance] 0x0 #599
[end-of-instance]
[mk-app] #738 => #592 #702
[mk-app] #739 = #703 #738
[mk-proof] #740 monotonicity #604 #739
[mk-app] #741 or #586 #702
[inst-discovered] theory-solving 0x0 basic# ; #738
[mk-app] #742 = #738 #741
[mk-proof] #743 rewrite #742
[instance] 0x0 #742
[end-of-instance]
[mk-app] #744 = #703 #741
[mk-proof] #745 trans #740 #743 #744
[mk-app] #746 and #733 #741
[mk-app] #747 = #704 #746
[mk-proof] #748 monotonicity #737 #745 #747
[mk-app] #749 => #287 #746
[mk-app] #750 = #705 #749
[mk-proof] #751 monotonicity #289 #748 #750
[mk-app] #752 or #619 #746
[inst-discovered] theory-solving 0x0 basic# ; #749
[mk-app] #753 = #749 #752
[mk-proof] #754 rewrite #753
[instance] 0x0 #753
[end-of-instance]
[mk-app] #755 = #705 #752
[mk-proof] #756 trans #751 #754 #755
[mk-app] #757 => #619 #706
[mk-app] #758 = #707 #757
[mk-proof] #759 monotonicity #631 #758
[mk-app] #760 or #287 #706
[inst-discovered] theory-solving 0x0 basic# ; #757
[mk-app] #761 = #757 #760
[mk-proof] #762 rewrite #761
[instance] 0x0 #761
[end-of-instance]
[mk-app] #763 = #707 #760
[mk-proof] #764 trans #759 #762 #763
[mk-app] #765 and #752 #760
[mk-app] #766 = #708 #765
[mk-proof] #767 monotonicity #756 #764 #766
[mk-quant] #768 k!254 2 #709 #710 #765
[attach-var-names] #768 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #769 null 2 #767
[mk-proof] #770 proof-bind #769
[mk-app] #771 = #711 #768
[mk-proof] #772 quant-intro #770 #771
[mk-proof] #773 mp #712 #772 #768
[mk-app] #774 < #36 #32
[mk-app] #775 - #273 #32
[mk-app] #776 < #33 #775
[mk-app] #777 and #272 #776
[mk-app] #778 and #774 #777
[mk-app] #779 Seq_add #33 #32
[mk-app] #780 Seq_sub #779 #32
[mk-app] #781 = #780 #33
[mk-app] #782 Seq_drop #269 #32
[mk-app] #783 Seq_index #782 #33
[mk-app] #784 Seq_index #269 #779
[mk-app] #785 = #783 #784
[mk-app] #786 and #781 #785
[mk-app] #787 => #778 #786
[mk-app] #788 pattern #783
[mk-quant] #789 k!262 3 #788 #787
[attach-var-names] #789 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #790 asserted #789
[mk-app] #791 <= #32 #36
[mk-app] #792 not #791
[inst-discovered] theory-solving 0x0 arith# ; #774
[mk-app] #793 = #774 #792
[mk-proof] #794 rewrite #793
[instance] 0x0 #793
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #795 * #176 #32
[mk-app] #796 + #273 #795
[inst-discovered] theory-solving 0x0 arith# ; #775
[mk-app] #797 = #775 #796
[mk-proof] #798 rewrite #797
[instance] 0x0 #797
[end-of-instance]
[mk-app] #799 + #795 #273
[inst-discovered] theory-solving 0x0 arith# ; #796
[mk-app] #800 = #796 #799
[mk-proof] #801 rewrite #800
[instance] 0x0 #800
[end-of-instance]
[mk-app] #802 = #775 #799
[mk-proof] #803 trans #798 #801 #802
[mk-app] #804 < #33 #799
[mk-app] #805 = #776 #804
[mk-proof] #806 monotonicity #803 #805
[mk-app] #807 <= #799 #33
[mk-app] #808 not #807
[inst-discovered] theory-solving 0x0 arith# ; #804
[mk-app] #809 = #804 #808
[mk-proof] #810 rewrite #809
[instance] 0x0 #809
[end-of-instance]
[mk-app] #811 = #776 #808
[mk-proof] #812 trans #806 #810 #811
[attach-meaning] #176 arith (- 1)
[mk-app] #813 + #795 #249 #273
[attach-meaning] #176 arith (- 1)
[mk-app] #814 + #32 #33 #295
[mk-app] #813 >= #814 #36
[inst-discovered] theory-solving 0x0 arith# ; #807
[mk-app] #815 = #807 #813
[mk-proof] #816 rewrite #815
[instance] 0x0 #815
[end-of-instance]
[mk-app] #817 not #813
[mk-app] #818 = #808 #817
[mk-proof] #819 monotonicity #816 #818
[mk-app] #820 = #776 #817
[mk-proof] #821 trans #812 #819 #820
[mk-app] #822 and #287 #817
[mk-app] #823 = #777 #822
[mk-proof] #824 monotonicity #289 #821 #823
[mk-app] #825 and #792 #822
[mk-app] #826 = #778 #825
[mk-proof] #827 monotonicity #794 #824 #826
[mk-app] #828 and #792 #287 #817
[inst-discovered] theory-solving 0x0 basic# ; #825
[mk-app] #829 = #825 #828
[mk-proof] #830 rewrite #829
[instance] 0x0 #829
[end-of-instance]
[mk-app] #831 = #778 #828
[mk-proof] #832 trans #827 #830 #831
[mk-app] #833 => #828 #786
[mk-app] #834 = #787 #833
[mk-proof] #835 monotonicity #832 #834
[mk-app] #836 not #828
[mk-app] #837 or #836 #786
[inst-discovered] theory-solving 0x0 basic# ; #833
[mk-app] #838 = #833 #837
[mk-proof] #839 rewrite #838
[instance] 0x0 #838
[end-of-instance]
[mk-app] #840 = #787 #837
[mk-proof] #841 trans #835 #839 #840
[mk-quant] #842 k!262 3 #788 #837
[attach-var-names] #842 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #843 null 3 #841
[mk-proof] #844 proof-bind #843
[mk-app] #845 = #789 #842
[mk-proof] #846 quant-intro #844 #845
[mk-proof] #847 mp #790 #846 #842
[mk-app] #848 and #34 #274
[mk-app] #849 and #774 #848
[mk-app] #850 Seq_sub #33 #32
[mk-app] #851 Seq_add #850 #32
[mk-app] #852 = #851 #33
[mk-app] #853 Seq_index #782 #850
[mk-app] #854 = #853 #280
[mk-app] #855 and #852 #854
[mk-app] #856 => #849 #855
[mk-app] #857 pattern #782 #280
[mk-quant] #858 k!270 3 #857 #856
[attach-var-names] #858 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #859 asserted #858
[inst-discovered] theory-solving 0x0 arith# ; #774
[instance] 0x0 #793
[end-of-instance]
[mk-app] #860 and #663 #299
[mk-app] #861 = #848 #860
[mk-proof] #862 monotonicity #665 #303 #861
[mk-app] #863 and #792 #860
[mk-app] #864 = #849 #863
[mk-proof] #865 monotonicity #794 #862 #864
[mk-app] #866 and #792 #663 #299
[inst-discovered] theory-solving 0x0 basic# ; #863
[mk-app] #867 = #863 #866
[mk-proof] #868 rewrite #867
[instance] 0x0 #867
[end-of-instance]
[mk-app] #869 = #849 #866
[mk-proof] #870 trans #865 #868 #869
[mk-app] #871 => #866 #855
[mk-app] #872 = #856 #871
[mk-proof] #873 monotonicity #870 #872
[mk-app] #874 not #866
[mk-app] #875 or #874 #855
[inst-discovered] theory-solving 0x0 basic# ; #871
[mk-app] #876 = #871 #875
[mk-proof] #877 rewrite #876
[instance] 0x0 #876
[end-of-instance]
[mk-app] #878 = #856 #875
[mk-proof] #879 trans #873 #877 #878
[mk-quant] #880 k!270 3 #857 #875
[attach-var-names] #880 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #881 null 3 #879
[mk-proof] #882 proof-bind #881
[mk-app] #883 = #858 #880
[mk-proof] #884 quant-intro #882 #883
[mk-proof] #885 mp #859 #884 #880
[mk-app] #886 < #36 #33
[mk-app] #887 <= #33 #273
[mk-app] #888 and #886 #887
[mk-app] #889 Seq_take #278 #33
[mk-app] #890 Seq_take #269 #33
[mk-app] #891 = #889 #890
[mk-app] #892 => #888 #891
[mk-app] #893 pattern #889
[mk-quant] #894 k!276 3 #893 #892
[attach-var-names] #894 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-proof] #895 asserted #894
[mk-app] #896 <= #33 #36
[mk-app] #897 not #896
[inst-discovered] theory-solving 0x0 arith# ; #886
[mk-app] #898 = #886 #897
[mk-proof] #899 rewrite #898
[instance] 0x0 #898
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #900 <= #296 #36
[inst-discovered] theory-solving 0x0 arith# ; #887
[mk-app] #901 = #887 #900
[mk-proof] #902 rewrite #901
[instance] 0x0 #901
[end-of-instance]
[mk-app] #903 and #897 #900
[mk-app] #904 = #888 #903
[mk-proof] #905 monotonicity #899 #902 #904
[mk-app] #906 => #903 #891
[mk-app] #907 = #892 #906
[mk-proof] #908 monotonicity #905 #907
[mk-app] #909 not #903
[mk-app] #910 or #909 #891
[inst-discovered] theory-solving 0x0 basic# ; #906
[mk-app] #911 = #906 #910
[mk-proof] #912 rewrite #911
[instance] 0x0 #911
[end-of-instance]
[mk-app] #913 = #892 #910
[mk-proof] #914 trans #908 #912 #913
[mk-quant] #915 k!276 3 #893 #910
[attach-var-names] #915 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #916 null 3 #914
[mk-proof] #917 proof-bind #916
[mk-app] #918 = #894 #915
[mk-proof] #919 quant-intro #917 #918
[mk-proof] #920 mp #895 #919 #915
[mk-app] #921 > #33 #36
[mk-app] #922 > #33 #273
[mk-app] #923 and #922 #339
[mk-app] #924 and #921 #923
[mk-app] #925 Seq_take #156 #343
[mk-app] #926 Seq_append #269 #925
[mk-app] #927 = #889 #926
[mk-app] #928 and #345 #927
[mk-app] #929 => #924 #928
[mk-quant] #930 k!286 3 #893 #929
[attach-var-names] #930 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-proof] #931 asserted #930
[inst-discovered] theory-solving 0x0 arith# ; #921
[mk-app] #932 = #921 #897
[mk-proof] #933 rewrite #932
[instance] 0x0 #932
[end-of-instance]
[mk-app] #934 not #887
[inst-discovered] theory-solving 0x0 arith# ; #922
[mk-app] #935 = #922 #934
[mk-proof] #936 rewrite #935
[instance] 0x0 #935
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #887
[instance] 0x0 #901
[end-of-instance]
[mk-app] #937 not #900
[mk-app] #938 = #934 #937
[mk-proof] #939 monotonicity #902 #938
[mk-app] #940 = #922 #937
[mk-proof] #941 trans #936 #939 #940
[inst-discovered] theory-solving 0x0 arith# ; #339
[instance] 0x0 #354
[end-of-instance]
[mk-app] #942 and #937 #361
[mk-app] #943 = #923 #942
[mk-proof] #944 monotonicity #941 #365 #943
[mk-app] #945 and #897 #942
[mk-app] #946 = #924 #945
[mk-proof] #947 monotonicity #933 #944 #946
[mk-app] #948 and #897 #937 #361
[inst-discovered] theory-solving 0x0 basic# ; #945
[mk-app] #949 = #945 #948
[mk-proof] #950 rewrite #949
[instance] 0x0 #949
[end-of-instance]
[mk-app] #951 = #924 #948
[mk-proof] #952 trans #947 #950 #951
[mk-app] #953 => #948 #928
[mk-app] #954 = #929 #953
[mk-proof] #955 monotonicity #952 #954
[mk-app] #956 not #948
[mk-app] #957 or #956 #928
[inst-discovered] theory-solving 0x0 basic# ; #953
[mk-app] #958 = #953 #957
[mk-proof] #959 rewrite #958
[instance] 0x0 #958
[end-of-instance]
[mk-app] #960 = #929 #957
[mk-proof] #961 trans #955 #959 #960
[mk-quant] #962 k!286 3 #893 #957
[attach-var-names] #962 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #963 null 3 #961
[mk-proof] #964 proof-bind #963
[mk-app] #965 = #930 #962
[mk-proof] #966 quant-intro #964 #965
[mk-proof] #967 mp #931 #966 #962
[mk-app] #968 Seq_drop #278 #33
[mk-app] #969 Seq_drop #269 #33
[mk-app] #970 Seq_append #969 #156
[mk-app] #971 = #968 #970
[mk-app] #972 => #888 #971
[mk-app] #973 pattern #968
[mk-quant] #974 k!292 3 #973 #972
[attach-var-names] #974 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-proof] #975 asserted #974
[inst-discovered] theory-solving 0x0 arith# ; #886
[instance] 0x0 #898
[end-of-instance]
[mk-app] #976 => #903 #971
[mk-app] #977 = #972 #976
[mk-proof] #978 monotonicity #905 #977
[mk-app] #979 or #909 #971
[inst-discovered] theory-solving 0x0 basic# ; #976
[mk-app] #980 = #976 #979
[mk-proof] #981 rewrite #980
[instance] 0x0 #980
[end-of-instance]
[mk-app] #982 = #972 #979
[mk-proof] #983 trans #978 #981 #982
[mk-quant] #984 k!292 3 #973 #979
[attach-var-names] #984 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #985 null 3 #983
[mk-proof] #986 proof-bind #985
[mk-app] #987 = #974 #984
[mk-proof] #988 quant-intro #986 #987
[mk-proof] #989 mp #975 #988 #984
[mk-app] #990 and #921 #922
[mk-app] #991 Seq_drop #156 #343
[mk-app] #992 = #968 #991
[mk-app] #993 and #345 #992
[mk-app] #994 => #990 #993
[mk-quant] #995 k!300 3 #973 #994
[attach-var-names] #995 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-proof] #996 asserted #995
[inst-discovered] theory-solving 0x0 arith# ; #921
[instance] 0x0 #932
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #922
[instance] 0x0 #935
[end-of-instance]
[mk-app] #997 and #897 #937
[mk-app] #998 = #990 #997
[mk-proof] #999 monotonicity #933 #941 #998
[mk-app] #1000 => #997 #993
[mk-app] #1001 = #994 #1000
[mk-proof] #1002 monotonicity #999 #1001
[mk-app] #1003 not #997
[mk-app] #1004 or #1003 #993
[inst-discovered] theory-solving 0x0 basic# ; #1000
[mk-app] #1005 = #1000 #1004
[mk-proof] #1006 rewrite #1005
[instance] 0x0 #1005
[end-of-instance]
[mk-app] #1007 = #994 #1004
[mk-proof] #1008 trans #1002 #1006 #1007
[mk-quant] #1009 k!300 3 #973 #1004
[attach-var-names] #1009 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1010 null 3 #1008
[mk-proof] #1011 proof-bind #1010
[mk-app] #1012 = #995 #1009
[mk-proof] #1013 quant-intro #1011 #1012
[mk-proof] #1014 mp #996 #1013 #1009
[mk-app] #1015 = #570 #130
[mk-app] #1016 => #896 #1015
[mk-app] #1017 pattern #570
[mk-quant] #1018 k!304 2 #1017 #1016
[attach-var-names] #1018 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1019 asserted #1018
[mk-app] #1020 or #897 #1015
[inst-discovered] theory-solving 0x0 basic# ; #1016
[mk-app] #1021 = #1016 #1020
[mk-proof] #1022 rewrite #1021
[instance] 0x0 #1021
[end-of-instance]
[mk-quant] #1023 k!304 2 #1017 #1020
[attach-var-names] #1023 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1024 null 2 #1022
[mk-proof] #1025 proof-bind #1024
[mk-app] #1026 = #1018 #1023
[mk-proof] #1027 quant-intro #1025 #1026
[mk-proof] #1028 mp #1019 #1027 #1023
[mk-app] #1029 = #697 #156
[mk-app] #1030 => #896 #1029
[mk-app] #1031 pattern #697
[mk-quant] #1032 k!308 2 #1031 #1030
[attach-var-names] #1032 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1033 asserted #1032
[mk-app] #1034 or #897 #1029
[inst-discovered] theory-solving 0x0 basic# ; #1030
[mk-app] #1035 = #1030 #1034
[mk-proof] #1036 rewrite #1035
[instance] 0x0 #1035
[end-of-instance]
[mk-quant] #1037 k!308 2 #1031 #1034
[attach-var-names] #1037 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1038 null 2 #1036
[mk-proof] #1039 proof-bind #1038
[mk-app] #1040 = #1032 #1037
[mk-proof] #1041 quant-intro #1039 #1040
[mk-proof] #1042 mp #1033 #1041 #1037
[mk-app] #1043 >= #33 #163
[mk-app] #1044 = #570 #156
[mk-app] #1045 => #1043 #1044
[mk-quant] #1046 k!312 2 #1017 #1045
[attach-var-names] #1046 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1047 asserted #1046
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1043
[mk-app] #1048 = #1043 #419
[mk-proof] #1049 rewrite #1048
[instance] 0x0 #1048
[end-of-instance]
[mk-app] #1050 => #419 #1044
[mk-app] #1051 = #1045 #1050
[mk-proof] #1052 monotonicity #1049 #1051
[mk-app] #1053 or #424 #1044
[inst-discovered] theory-solving 0x0 basic# ; #1050
[mk-app] #1054 = #1050 #1053
[mk-proof] #1055 rewrite #1054
[instance] 0x0 #1054
[end-of-instance]
[mk-app] #1056 = #1045 #1053
[mk-proof] #1057 trans #1052 #1055 #1056
[mk-quant] #1058 k!312 2 #1017 #1053
[attach-var-names] #1058 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1059 null 2 #1057
[mk-proof] #1060 proof-bind #1059
[mk-app] #1061 = #1046 #1058
[mk-proof] #1062 quant-intro #1060 #1061
[mk-proof] #1063 mp #1047 #1062 #1058
[mk-app] #1064 = #697 #130
[mk-app] #1065 => #1043 #1064
[mk-quant] #1066 k!316 2 #1031 #1065
[attach-var-names] #1066 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1067 asserted #1066
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1043
[instance] 0x0 #1048
[end-of-instance]
[mk-app] #1068 => #419 #1064
[mk-app] #1069 = #1065 #1068
[mk-proof] #1070 monotonicity #1049 #1069
[mk-app] #1071 or #424 #1064
[inst-discovered] theory-solving 0x0 basic# ; #1068
[mk-app] #1072 = #1068 #1071
[mk-proof] #1073 rewrite #1072
[instance] 0x0 #1072
[end-of-instance]
[mk-app] #1074 = #1065 #1071
[mk-proof] #1075 trans #1070 #1073 #1074
[mk-quant] #1076 k!316 2 #1031 #1071
[attach-var-names] #1076 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1077 null 2 #1075
[mk-proof] #1078 proof-bind #1077
[mk-app] #1079 = #1066 #1076
[mk-proof] #1080 quant-intro #1078 #1079
[mk-proof] #1081 mp #1067 #1080 #1076
[mk-app] #1082 Seq_contains #156 #33
[mk-app] #1083 Seq_skolem #156 #33
[mk-app] #1084 <= #36 #1083
[mk-app] #1085 < #1083 #163
[mk-app] #1086 Seq_index #156 #1083
[mk-app] #1087 = #1086 #33
[mk-app] #1088 and #1085 #1087
[mk-app] #1089 and #1084 #1088
[mk-app] #1090 => #1082 #1089
[mk-app] #1091 pattern #1082
[mk-quant] #1092 k!326 2 #1091 #1090
[attach-var-names] #1092 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1093 asserted #1092
[attach-meaning] #176 arith (- 1)
[mk-app] #1094 * #176 #1083
[mk-app] #1095 >= #1083 #36
[inst-discovered] theory-solving 0x0 arith# ; #1084
[mk-app] #1094 = #1084 #1095
[mk-proof] #1096 rewrite #1094
[instance] 0x0 #1094
[end-of-instance]
[mk-app] #1097 <= #163 #1083
[mk-app] #1098 not #1097
[inst-discovered] theory-solving 0x0 arith# ; #1085
[mk-app] #1099 = #1085 #1098
[mk-proof] #1100 rewrite #1099
[instance] 0x0 #1099
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #1101 * #176 #1083
[mk-app] #1102 + #163 #1101
[mk-app] #1103 <= #1102 #36
[inst-discovered] theory-solving 0x0 arith# ; #1097
[mk-app] #1104 = #1097 #1103
[mk-proof] #1105 rewrite #1104
[instance] 0x0 #1104
[end-of-instance]
[mk-app] #1106 not #1103
[mk-app] #1107 = #1098 #1106
[mk-proof] #1108 monotonicity #1105 #1107
[mk-app] #1109 = #1085 #1106
[mk-proof] #1110 trans #1100 #1108 #1109
[mk-app] #1111 and #1106 #1087
[mk-app] #1112 = #1088 #1111
[mk-proof] #1113 monotonicity #1110 #1112
[mk-app] #1114 and #1095 #1111
[mk-app] #1115 = #1089 #1114
[mk-proof] #1116 monotonicity #1096 #1113 #1115
[mk-app] #1117 and #1095 #1106 #1087
[inst-discovered] theory-solving 0x0 basic# ; #1114
[mk-app] #1118 = #1114 #1117
[mk-proof] #1119 rewrite #1118
[instance] 0x0 #1118
[end-of-instance]
[mk-app] #1120 = #1089 #1117
[mk-proof] #1121 trans #1116 #1119 #1120
[mk-app] #1122 => #1082 #1117
[mk-app] #1123 = #1090 #1122
[mk-proof] #1124 monotonicity #1121 #1123
[mk-app] #1125 not #1082
[mk-app] #1126 or #1125 #1117
[inst-discovered] theory-solving 0x0 basic# ; #1122
[mk-app] #1127 = #1122 #1126
[mk-proof] #1128 rewrite #1127
[instance] 0x0 #1127
[end-of-instance]
[mk-app] #1129 = #1090 #1126
[mk-proof] #1130 trans #1124 #1128 #1129
[mk-quant] #1131 k!326 2 #1091 #1126
[attach-var-names] #1131 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1132 null 2 #1130
[mk-proof] #1133 proof-bind #1132
[mk-app] #1134 = #1092 #1131
[mk-proof] #1135 quant-intro #1133 #1134
[mk-proof] #1136 mp #1093 #1135 #1131
[mk-app] #1137 = #280 #32
[mk-app] #1138 and #274 #1137
[mk-app] #1139 and #272 #1138
[mk-app] #1140 Seq_contains #269 #32
[mk-app] #1141 => #1139 #1140
[mk-app] #1142 pattern #1140 #280
[mk-quant] #1143 k!332 3 #1142 #1141
[attach-var-names] #1143 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1144 asserted #1143
[mk-app] #1145 and #299 #1137
[mk-app] #1146 = #1138 #1145
[mk-proof] #1147 monotonicity #303 #1146
[mk-app] #1148 and #287 #1145
[mk-app] #1149 = #1139 #1148
[mk-proof] #1150 monotonicity #289 #1147 #1149
[mk-app] #1151 and #287 #299 #1137
[inst-discovered] theory-solving 0x0 basic# ; #1148
[mk-app] #1152 = #1148 #1151
[mk-proof] #1153 rewrite #1152
[instance] 0x0 #1152
[end-of-instance]
[mk-app] #1154 = #1139 #1151
[mk-proof] #1155 trans #1150 #1153 #1154
[mk-app] #1156 => #1151 #1140
[mk-app] #1157 = #1141 #1156
[mk-proof] #1158 monotonicity #1155 #1157
[mk-app] #1159 not #1151
[mk-app] #1160 or #1159 #1140
[inst-discovered] theory-solving 0x0 basic# ; #1156
[mk-app] #1161 = #1156 #1160
[mk-proof] #1162 rewrite #1161
[instance] 0x0 #1161
[end-of-instance]
[mk-app] #1163 = #1141 #1160
[mk-proof] #1164 trans #1158 #1162 #1163
[mk-quant] #1165 k!332 3 #1142 #1160
[attach-var-names] #1165 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1166 null 3 #1164
[mk-proof] #1167 proof-bind #1166
[mk-app] #1168 = #1143 #1165
[mk-proof] #1169 quant-intro #1167 #1168
[mk-proof] #1170 mp #1144 #1169 #1165
[mk-app] #1171 Seq_contains_trigger #156 #408
[mk-app] #1172 => #401 #1171
[mk-app] #1173 pattern #408
[mk-quant] #1174 k!338 2 #1173 #1172
[attach-var-names] #1174 (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-proof] #1175 asserted #1174
[inst-discovered] theory-solving 0x0 arith# ; #400
[instance] 0x0 #417
[end-of-instance]
[mk-app] #1176 => #429 #1171
[mk-app] #1177 = #1172 #1176
[mk-proof] #1178 monotonicity #431 #1177
[mk-app] #1179 not #429
[mk-app] #1180 or #1179 #1171
[inst-discovered] theory-solving 0x0 basic# ; #1176
[mk-app] #1181 = #1176 #1180
[mk-proof] #1182 rewrite #1181
[instance] 0x0 #1181
[end-of-instance]
[mk-app] #1183 = #1172 #1180
[mk-proof] #1184 trans #1178 #1182 #1183
[mk-quant] #1185 k!338 2 #1173 #1180
[attach-var-names] #1185 (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1186 null 2 #1184
[mk-proof] #1187 proof-bind #1186
[mk-app] #1188 = #1174 #1185
[mk-proof] #1189 quant-intro #1187 #1188
[mk-proof] #1190 mp #1175 #1189 #1185
[mk-app] #1191 = #156 #90
[mk-app] #1192 Seq_equal #156 #90
[mk-app] #1193 and #1191 #1192
[mk-app] #1194 not #1191
[mk-app] #1195 not #1192
[mk-app] #1196 = #163 #116
[mk-app] #1197 not #1196
[mk-app] #1198 and #1195 #1197
[mk-app] #1199 and #1194 #1198
[mk-app] #1200 Seq_skolem_diff #156 #90
[mk-app] #1201 Seq_skolem_diff #90 #156
[mk-app] #1202 = #1200 #1201
[mk-app] #1203 <= #36 #1200
[mk-app] #1204 < #1200 #163
[mk-app] #1205 Seq_index #156 #1200
[mk-app] #1206 Seq_index #90 #1200
[mk-app] #1207 = #1205 #1206
[mk-app] #1208 not #1207
[mk-app] #1209 and #1204 #1208
[mk-app] #1210 and #1203 #1209
[mk-app] #1211 and #1202 #1210
[mk-app] #1212 and #1196 #1211
[mk-app] #1213 and #1195 #1212
[mk-app] #1214 and #1194 #1213
[mk-app] #1215 or #1199 #1214
[mk-app] #1216 or #1193 #1215
[mk-app] #1217 pattern #1192
[mk-quant] #1218 k!363 2 #1217 #1216
[attach-var-names] #1218 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-proof] #1219 asserted #1218
[mk-app] #1220 and #1194 #1195 #1197
[inst-discovered] theory-solving 0x0 basic# ; #1199
[mk-app] #1221 = #1199 #1220
[mk-proof] #1222 rewrite #1221
[instance] 0x0 #1221
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #1223 * #176 #1200
[mk-app] #1224 >= #1200 #36
[inst-discovered] theory-solving 0x0 arith# ; #1203
[mk-app] #1223 = #1203 #1224
[mk-proof] #1225 rewrite #1223
[instance] 0x0 #1223
[end-of-instance]
[mk-app] #1226 <= #163 #1200
[mk-app] #1227 not #1226
[inst-discovered] theory-solving 0x0 arith# ; #1204
[mk-app] #1228 = #1204 #1227
[mk-proof] #1229 rewrite #1228
[instance] 0x0 #1228
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #1230 * #176 #1200
[mk-app] #1231 + #163 #1230
[mk-app] #1232 <= #1231 #36
[inst-discovered] theory-solving 0x0 arith# ; #1226
[mk-app] #1233 = #1226 #1232
[mk-proof] #1234 rewrite #1233
[instance] 0x0 #1233
[end-of-instance]
[mk-app] #1235 not #1232
[mk-app] #1236 = #1227 #1235
[mk-proof] #1237 monotonicity #1234 #1236
[mk-app] #1238 = #1204 #1235
[mk-proof] #1239 trans #1229 #1237 #1238
[mk-app] #1240 and #1235 #1208
[mk-app] #1241 = #1209 #1240
[mk-proof] #1242 monotonicity #1239 #1241
[mk-app] #1243 and #1224 #1240
[mk-app] #1244 = #1210 #1243
[mk-proof] #1245 monotonicity #1225 #1242 #1244
[mk-app] #1246 and #1224 #1235 #1208
[inst-discovered] theory-solving 0x0 basic# ; #1243
[mk-app] #1247 = #1243 #1246
[mk-proof] #1248 rewrite #1247
[instance] 0x0 #1247
[end-of-instance]
[mk-app] #1249 = #1210 #1246
[mk-proof] #1250 trans #1245 #1248 #1249
[mk-app] #1251 and #1202 #1246
[mk-app] #1252 = #1211 #1251
[mk-proof] #1253 monotonicity #1250 #1252
[mk-app] #1254 and #1202 #1224 #1235 #1208
[inst-discovered] theory-solving 0x0 basic# ; #1251
[mk-app] #1255 = #1251 #1254
[mk-proof] #1256 rewrite #1255
[instance] 0x0 #1255
[end-of-instance]
[mk-app] #1257 = #1211 #1254
[mk-proof] #1258 trans #1253 #1256 #1257
[mk-app] #1259 and #1196 #1254
[mk-app] #1260 = #1212 #1259
[mk-proof] #1261 monotonicity #1258 #1260
[mk-app] #1262 and #1196 #1202 #1224 #1235 #1208
[inst-discovered] theory-solving 0x0 basic# ; #1259
[mk-app] #1263 = #1259 #1262
[mk-proof] #1264 rewrite #1263
[instance] 0x0 #1263
[end-of-instance]
[mk-app] #1265 = #1212 #1262
[mk-proof] #1266 trans #1261 #1264 #1265
[mk-app] #1267 and #1195 #1262
[mk-app] #1268 = #1213 #1267
[mk-proof] #1269 monotonicity #1266 #1268
[mk-app] #1270 and #1195 #1196 #1202 #1224 #1235 #1208
[inst-discovered] theory-solving 0x0 basic# ; #1267
[mk-app] #1271 = #1267 #1270
[mk-proof] #1272 rewrite #1271
[instance] 0x0 #1271
[end-of-instance]
[mk-app] #1273 = #1213 #1270
[mk-proof] #1274 trans #1269 #1272 #1273
[mk-app] #1275 and #1194 #1270
[mk-app] #1276 = #1214 #1275
[mk-proof] #1277 monotonicity #1274 #1276
[mk-app] #1278 and #1194 #1195 #1196 #1202 #1224 #1235 #1208
[inst-discovered] theory-solving 0x0 basic# ; #1275
[mk-app] #1279 = #1275 #1278
[mk-proof] #1280 rewrite #1279
[instance] 0x0 #1279
[end-of-instance]
[mk-app] #1281 = #1214 #1278
[mk-proof] #1282 trans #1277 #1280 #1281
[mk-app] #1283 or #1220 #1278
[mk-app] #1284 = #1215 #1283
[mk-proof] #1285 monotonicity #1222 #1282 #1284
[mk-app] #1286 or #1193 #1283
[mk-app] #1287 = #1216 #1286
[mk-proof] #1288 monotonicity #1285 #1287
[mk-app] #1289 or #1193 #1220 #1278
[inst-discovered] theory-solving 0x0 basic# ; #1286
[mk-app] #1290 = #1286 #1289
[mk-proof] #1291 rewrite #1290
[instance] 0x0 #1290
[end-of-instance]
[mk-app] #1292 = #1216 #1289
[mk-proof] #1293 trans #1288 #1291 #1292
[mk-quant] #1294 k!363 2 #1217 #1289
[attach-var-names] #1294 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1295 null 2 #1293
[mk-proof] #1296 proof-bind #1295
[mk-app] #1297 = #1218 #1294
[mk-proof] #1298 quant-intro #1296 #1297
[mk-proof] #1299 mp #1219 #1298 #1294
[mk-app] #1300 => #1192 #1191
[mk-quant] #1301 k!367 2 #1217 #1300
[attach-var-names] #1301 (|b| ; |Seq<Int>|) (|a| ; |Seq<Int>|)
[mk-proof] #1302 asserted #1301
[mk-app] #1303 or #1195 #1191
[inst-discovered] theory-solving 0x0 basic# ; #1300
[mk-app] #1304 = #1300 #1303
[mk-proof] #1305 rewrite #1304
[instance] 0x0 #1304
[end-of-instance]
[mk-quant] #1306 k!367 2 #1217 #1303
[attach-var-names] #1306 (|b| ; |Seq<Int>|) (|a| ; |Seq<Int>|)
[mk-lambda] #1307 null 2 #1305
[mk-proof] #1308 proof-bind #1307
[mk-app] #1309 = #1301 #1306
[mk-proof] #1310 quant-intro #1308 #1309
[mk-proof] #1311 mp #1302 #1310 #1306
[mk-app] #1312 Seq_singleton #32
[mk-app] #1313 Seq_contains #1312 #33
[mk-app] #1314 = #32 #33
[mk-app] #1315 = #1313 #1314
[mk-app] #1316 pattern #1313
[mk-quant] #1317 k!371 2 #1316 #1315
[attach-var-names] #1317 (|y| ; |Int|) (|x| ; |Int|)
[mk-proof] #1318 asserted #1317
[mk-app] #1319 = #1317 #1317
[mk-proof] #1320 refl #1319
[mk-app] #1319 < #32 #33
[mk-app] #1320 Seq_range #32 #33
[mk-app] #1321 Seq_length #1320
[mk-app] #1322 - #33 #32
[mk-app] #1323 = #1321 #1322
[mk-app] #1324 => #1319 #1323
[mk-app] #1325 <= #33 #32
[mk-app] #1326 = #1321 #36
[mk-app] #1327 => #1325 #1326
[mk-app] #1328 and #1324 #1327
[mk-app] #1329 pattern #1321
[mk-quant] #1330 $Seq[Int]_prog.ranged_seq_length 2 #1329 #1328
[attach-var-names] #1330 (|max| ; |Int|) (|min_| ; |Int|)
[mk-proof] #1331 asserted #1330
[mk-app] #1332 not #1325
[inst-discovered] theory-solving 0x0 arith# ; #1319
[mk-app] #1333 = #1319 #1332
[mk-proof] #1334 rewrite #1333
[instance] 0x0 #1333
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #1335 + #795 #33
[attach-meaning] #176 arith (- 1)
[mk-app] #1335 >= #250 #36
[inst-discovered] theory-solving 0x0 arith# ; #1325
[mk-app] #1336 = #1325 #1335
[mk-proof] #1337 rewrite #1336
[instance] 0x0 #1336
[end-of-instance]
[mk-app] #1338 not #1335
[mk-app] #1339 = #1332 #1338
[mk-proof] #1340 monotonicity #1337 #1339
[mk-app] #1341 = #1319 #1338
[mk-proof] #1342 trans #1334 #1340 #1341
[attach-meaning] #176 arith (- 1)
[mk-app] #1343 + #33 #795
[inst-discovered] theory-solving 0x0 arith# ; #1322
[mk-app] #1344 = #1322 #1343
[mk-proof] #1345 rewrite #1344
[instance] 0x0 #1344
[end-of-instance]
[mk-app] #1346 + #795 #33
[inst-discovered] theory-solving 0x0 arith# ; #1343
[mk-app] #1347 = #1343 #1346
[mk-proof] #1348 rewrite #1347
[instance] 0x0 #1347
[end-of-instance]
[mk-app] #1349 = #1322 #1346
[mk-proof] #1350 trans #1345 #1348 #1349
[mk-app] #1351 = #1321 #1346
[mk-app] #1352 = #1323 #1351
[mk-proof] #1353 monotonicity #1350 #1352
[attach-meaning] #176 arith (- 1)
[mk-app] #1354 + #32 #249 #1321
[mk-app] #1355 = #1354 #36
[inst-discovered] theory-solving 0x0 arith# ; #1351
[mk-app] #1356 = #1351 #1355
[mk-proof] #1357 rewrite #1356
[instance] 0x0 #1356
[end-of-instance]
[mk-app] #1358 = #1323 #1355
[mk-proof] #1359 trans #1353 #1357 #1358
[mk-app] #1360 => #1338 #1355
[mk-app] #1361 = #1324 #1360
[mk-proof] #1362 monotonicity #1342 #1359 #1361
[mk-app] #1363 or #1335 #1355
[inst-discovered] theory-solving 0x0 basic# ; #1360
[mk-app] #1364 = #1360 #1363
[mk-proof] #1365 rewrite #1364
[instance] 0x0 #1364
[end-of-instance]
[mk-app] #1366 = #1324 #1363
[mk-proof] #1367 trans #1362 #1365 #1366
[mk-app] #1368 => #1335 #1326
[mk-app] #1369 = #1327 #1368
[mk-proof] #1370 monotonicity #1337 #1369
[mk-app] #1371 or #1338 #1326
[inst-discovered] theory-solving 0x0 basic# ; #1368
[mk-app] #1372 = #1368 #1371
[mk-proof] #1373 rewrite #1372
[instance] 0x0 #1372
[end-of-instance]
[mk-app] #1374 = #1327 #1371
[mk-proof] #1375 trans #1370 #1373 #1374
[mk-app] #1376 and #1363 #1371
[mk-app] #1377 = #1328 #1376
[mk-proof] #1378 monotonicity #1367 #1375 #1377
[mk-quant] #1379 $Seq[Int]_prog.ranged_seq_length 2 #1329 #1376
[attach-var-names] #1379 (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #1380 null 2 #1378
[mk-proof] #1381 proof-bind #1380
[mk-app] #1382 = #1330 #1379
[mk-proof] #1383 quant-intro #1381 #1382
[mk-proof] #1384 mp #1331 #1383 #1379
[mk-app] #1385 - #32 #509
[mk-app] #1386 < #33 #1385
[mk-app] #1387 and #272 #1386
[mk-app] #1388 Seq_range #509 #32
[mk-app] #1389 Seq_index #1388 #33
[mk-app] #1390 + #509 #33
[mk-app] #1391 = #1389 #1390
[mk-app] #1392 => #1387 #1391
[mk-app] #1393 pattern #1389
[mk-quant] #1394 $Seq[Int]_prog.ranged_seq_index 3 #1393 #1392
[attach-var-names] #1394 (|j| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-proof] #1395 asserted #1394
[attach-meaning] #176 arith (- 1)
[mk-app] #1396 * #176 #509
[mk-app] #1397 + #32 #1396
[inst-discovered] theory-solving 0x0 arith# ; #1385
[mk-app] #1398 = #1385 #1397
[mk-proof] #1399 rewrite #1398
[instance] 0x0 #1398
[end-of-instance]
[mk-app] #1400 < #33 #1397
[mk-app] #1401 = #1386 #1400
[mk-proof] #1402 monotonicity #1399 #1401
[mk-app] #1403 <= #1397 #33
[mk-app] #1404 not #1403
[inst-discovered] theory-solving 0x0 arith# ; #1400
[mk-app] #1405 = #1400 #1404
[mk-proof] #1406 rewrite #1405
[instance] 0x0 #1405
[end-of-instance]
[mk-app] #1407 = #1386 #1404
[mk-proof] #1408 trans #1402 #1406 #1407
[attach-meaning] #176 arith (- 1)
[mk-app] #1409 + #32 #249 #1396
[mk-app] #1410 <= #1409 #36
[inst-discovered] theory-solving 0x0 arith# ; #1403
[mk-app] #1411 = #1403 #1410
[mk-proof] #1412 rewrite #1411
[instance] 0x0 #1411
[end-of-instance]
[mk-app] #1413 not #1410
[mk-app] #1414 = #1404 #1413
[mk-proof] #1415 monotonicity #1412 #1414
[mk-app] #1416 = #1386 #1413
[mk-proof] #1417 trans #1408 #1415 #1416
[mk-app] #1418 and #287 #1413
[mk-app] #1419 = #1387 #1418
[mk-proof] #1420 monotonicity #289 #1417 #1419
[mk-app] #1421 + #33 #509
[inst-discovered] theory-solving 0x0 arith# ; #1390
[mk-app] #1422 = #1390 #1421
[mk-proof] #1423 rewrite #1422
[instance] 0x0 #1422
[end-of-instance]
[mk-app] #1424 = #1389 #1421
[mk-app] #1425 = #1391 #1424
[mk-proof] #1426 monotonicity #1423 #1425
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #1427 + #249 #1396 #1389
[attach-meaning] #176 arith (- 1)
[mk-app] #1428 * #176 #1389
[mk-app] #1429 + #33 #509 #1428
[mk-app] #1427 = #1429 #36
[inst-discovered] theory-solving 0x0 arith# ; #1424
[mk-app] #1430 = #1424 #1427
[mk-proof] #1431 rewrite #1430
[instance] 0x0 #1430
[end-of-instance]
[mk-app] #1432 = #1391 #1427
[mk-proof] #1433 trans #1426 #1431 #1432
[mk-app] #1434 => #1418 #1427
[mk-app] #1435 = #1392 #1434
[mk-proof] #1436 monotonicity #1420 #1433 #1435
[mk-app] #1437 not #1418
[mk-app] #1438 or #1437 #1427
[inst-discovered] theory-solving 0x0 basic# ; #1434
[mk-app] #1439 = #1434 #1438
[mk-proof] #1440 rewrite #1439
[instance] 0x0 #1439
[end-of-instance]
[mk-app] #1441 = #1392 #1438
[mk-proof] #1442 trans #1436 #1440 #1441
[mk-quant] #1443 $Seq[Int]_prog.ranged_seq_index 3 #1393 #1438
[attach-var-names] #1443 (|j| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #1444 null 3 #1442
[mk-proof] #1445 proof-bind #1444
[mk-app] #1446 = #1394 #1443
[mk-proof] #1447 quant-intro #1445 #1446
[mk-proof] #1448 mp #1395 #1447 #1443
[mk-app] #1449 Seq_contains #1388 #33
[mk-app] #1450 <= #509 #33
[mk-app] #1451 and #1450 #649
[mk-app] #1452 = #1449 #1451
[mk-app] #1453 pattern #1449
[mk-quant] #1454 $Seq[Int]_prog.ranged_seq_contains 3 #1453 #1452
[attach-var-names] #1454 (|v| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-proof] #1455 asserted #1454
[attach-meaning] #176 arith (- 1)
[mk-app] #1456 + #249 #509
[attach-meaning] #176 arith (- 1)
[mk-app] #1457 + #33 #1396
[mk-app] #1456 >= #1457 #36
[inst-discovered] theory-solving 0x0 arith# ; #1450
[mk-app] #1458 = #1450 #1456
[mk-proof] #1459 rewrite #1458
[instance] 0x0 #1458
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #649
[instance] 0x0 #661
[end-of-instance]
[mk-app] #1460 and #1456 #666
[mk-app] #1461 = #1451 #1460
[mk-proof] #1462 monotonicity #1459 #670 #1461
[mk-app] #1463 = #1449 #1460
[mk-app] #1464 = #1452 #1463
[mk-proof] #1465 monotonicity #1462 #1464
[mk-quant] #1466 $Seq[Int]_prog.ranged_seq_contains 3 #1453 #1463
[attach-var-names] #1466 (|v| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #1467 null 3 #1465
[mk-proof] #1468 proof-bind #1467
[mk-app] #1469 = #1454 #1466
[mk-proof] #1470 quant-intro #1468 #1469
[mk-proof] #1471 mp #1455 #1470 #1466
[mk-var] #1472 1
[mk-app] #1473 offset<Ptr32> #1472 #33
[mk-app] #1474 offset_inj<Int> #1473 #1472
[mk-app] #1475 = #1474 #33
[mk-app] #1476 pattern #1473
[mk-quant] #1477 prog.inj 2 #1476 #1475
[attach-var-names] #1477 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-proof] #1478 asserted #1477
[mk-app] #1479 = #1477 #1477
[mk-proof] #1480 refl #1479
[mk-app] #1479 next<Ptr32> #1473
[mk-app] #1480 + #33 #151
[mk-app] #1481 offset<Ptr32> #1472 #1480
[mk-app] #1482 = #1479 #1481
[mk-app] #1483 pattern #1479
[mk-quant] #1484 prog.next_offset 2 #1483 #1482
[attach-var-names] #1484 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-proof] #1485 asserted #1484
[mk-app] #1486 + #151 #33
[inst-discovered] theory-solving 0x0 arith# ; #1480
[mk-app] #1487 = #1480 #1486
[mk-proof] #1488 rewrite #1487
[instance] 0x0 #1487
[end-of-instance]
[mk-app] #1489 offset<Ptr32> #1472 #1486
[mk-app] #1490 = #1481 #1489
[mk-proof] #1491 monotonicity #1488 #1490
[mk-app] #1492 = #1479 #1489
[mk-app] #1493 = #1482 #1492
[mk-proof] #1494 monotonicity #1491 #1493
[mk-quant] #1495 prog.next_offset 2 #1483 #1492
[attach-var-names] #1495 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-lambda] #1496 null 2 #1494
[mk-proof] #1497 proof-bind #1496
[mk-app] #1498 = #1484 #1495
[mk-proof] #1499 quant-intro #1497 #1498
[mk-proof] #1500 mp #1485 #1499 #1495
[mk-app] #1501 address<Int> #1479
[mk-app] #1502 address<Int> #1473
[mk-app] #1503 Int
[attach-meaning] #1503 arith 4
[mk-app] #1504 + #1502 #1503
[mk-app] #1505 = #1501 #1504
[mk-app] #1506 pattern #1502
[mk-quant] #1507 prog.addr 2 #1506 #1505
[attach-var-names] #1507 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-proof] #1508 asserted #1507
[mk-app] #1509 + #1503 #1502
[inst-discovered] theory-solving 0x0 arith# ; #1504
[mk-app] #1510 = #1504 #1509
[mk-proof] #1511 rewrite #1510
[instance] 0x0 #1510
[end-of-instance]
[mk-app] #1512 = #1501 #1509
[mk-app] #1513 = #1505 #1512
[mk-proof] #1514 monotonicity #1511 #1513
[attach-meaning] #176 arith (- 1)
[mk-app] #1515 * #176 #1502
[mk-app] #1516 + #1501 #1515
[mk-app] #1517 = #1516 #1503
[inst-discovered] theory-solving 0x0 arith# ; #1512
[mk-app] #1518 = #1512 #1517
[mk-proof] #1519 rewrite #1518
[instance] 0x0 #1518
[end-of-instance]
[mk-app] #1520 = #1505 #1517
[mk-proof] #1521 trans #1514 #1519 #1520
[mk-quant] #1522 prog.addr 2 #1506 #1517
[attach-var-names] #1522 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-lambda] #1523 null 2 #1521
[mk-proof] #1524 proof-bind #1523
[mk-app] #1525 = #1507 #1522
[mk-proof] #1526 quant-intro #1524 #1525
[mk-proof] #1527 mp #1508 #1526 #1522
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[mk-app] #1528 = #43 #43
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #50 #50
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #57 #57
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #63 #63
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #70 #70
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #76 #76
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #82 #82
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #88 #88
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #95 #95
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #101 #101
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #108 #108
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #114 #114
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #119 #119
[mk-proof] #1529 refl #1528
[mk-app] #1528 = #132 #132
[mk-proof] #1529 refl #1528
[inst-discovered] theory-solving 0x0 basic# ; #136
[instance] 0x0 #141
[end-of-instance]
[mk-app] #1528 = #154 #154
[mk-proof] #1529 refl #1528
[mk-app] #1528 or #187 #165
[inst-discovered] theory-solving 0x0 basic# ; #166
[mk-app] #1529 = #166 #1528
[mk-proof] #1530 rewrite #1529
[instance] 0x0 #1529
[end-of-instance]
[mk-quant] #1531 k!150 2 #167 #1528
[attach-var-names] #1531 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1532 null 2 #1530
[mk-proof] #1533 proof-bind #1532
[mk-app] #1534 = #168 #1531
[mk-proof] #1535 quant-intro #1533 #1534
[mk-proof] #1536 mp #169 #1535 #1531
[inst-discovered] theory-solving 0x0 basic# ; #200
[instance] 0x0 #208
[end-of-instance]
[inst-discovered] theory-solving 0x0 basic# ; #202
[instance] 0x0 #211
[end-of-instance]
[mk-app] #1537 = #224 #224
[mk-proof] #1538 refl #1537
[mk-app] #1537 = #230 #230
[mk-proof] #1538 refl #1537
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #244
[instance] 0x0 #251
[end-of-instance]
[mk-quant] #1537 k!168 2 #246 #253
[attach-var-names] #1537 (|j| ; |Int|) (|i| ; |Int|)
[mk-lambda] #1538 null 2 #255
[mk-proof] #1539 proof-bind #1538
[mk-app] #1540 = #247 #1537
[mk-proof] #1541 quant-intro #1539 #1540
[mk-proof] #1542 mp #248 #1541 #1537
[inst-discovered] theory-solving 0x0 arith# ; #274
[instance] 0x0 #292
[end-of-instance]
[mk-app] #1543 and #272 #291
[mk-app] #1544 = #275 #1543
[mk-proof] #1545 monotonicity #293 #1544
[mk-app] #1546 and #158 #1543
[mk-app] #1547 = #276 #1546
[mk-proof] #1548 monotonicity #1545 #1547
[mk-app] #1549 and #158 #272 #291
[inst-discovered] theory-solving 0x0 basic# ; #1546
[mk-app] #1550 = #1546 #1549
[mk-proof] #1551 rewrite #1550
[instance] 0x0 #1550
[end-of-instance]
[mk-app] #1552 = #276 #1549
[mk-proof] #1553 trans #1548 #1551 #1552
[mk-app] #1554 and #271 #1549
[mk-app] #1555 = #277 #1554
[mk-proof] #1556 monotonicity #1553 #1555
[mk-app] #1557 and #271 #158 #272 #291
[inst-discovered] theory-solving 0x0 basic# ; #1554
[mk-app] #1558 = #1554 #1557
[mk-proof] #1559 rewrite #1558
[instance] 0x0 #1558
[end-of-instance]
[mk-app] #1560 = #277 #1557
[mk-proof] #1561 trans #1556 #1559 #1560
[mk-app] #1562 => #1557 #281
[mk-app] #1563 = #282 #1562
[mk-proof] #1564 monotonicity #1561 #1563
[mk-app] #1565 not #1557
[mk-app] #1566 or #1565 #281
[inst-discovered] theory-solving 0x0 basic# ; #1562
[mk-app] #1567 = #1562 #1566
[mk-proof] #1568 rewrite #1567
[instance] 0x0 #1567
[end-of-instance]
[mk-app] #1569 = #282 #1566
[mk-proof] #1570 trans #1564 #1568 #1569
[mk-quant] #1571 k!179 3 #283 #284 #1566
[attach-var-names] #1571 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1572 null 3 #1570
[mk-proof] #1573 proof-bind #1572
[mk-app] #1574 = #285 #1571
[mk-proof] #1575 quant-intro #1573 #1574
[mk-proof] #1576 mp #286 #1575 #1571
[inst-discovered] theory-solving 0x0 arith# ; #339
[instance] 0x0 #354
[end-of-instance]
[mk-app] #1577 and #290 #353
[mk-app] #1578 = #340 #1577
[mk-proof] #1579 monotonicity #355 #1578
[mk-app] #1580 and #158 #1577
[mk-app] #1581 = #341 #1580
[mk-proof] #1582 monotonicity #1579 #1581
[mk-app] #1583 and #158 #290 #353
[inst-discovered] theory-solving 0x0 basic# ; #1580
[mk-app] #1584 = #1580 #1583
[mk-proof] #1585 rewrite #1584
[instance] 0x0 #1584
[end-of-instance]
[mk-app] #1586 = #341 #1583
[mk-proof] #1587 trans #1582 #1585 #1586
[mk-app] #1588 and #271 #1583
[mk-app] #1589 = #342 #1588
[mk-proof] #1590 monotonicity #1587 #1589
[mk-app] #1591 and #271 #158 #290 #353
[inst-discovered] theory-solving 0x0 basic# ; #1588
[mk-app] #1592 = #1588 #1591
[mk-proof] #1593 rewrite #1592
[instance] 0x0 #1592
[end-of-instance]
[mk-app] #1594 = #342 #1591
[mk-proof] #1595 trans #1590 #1593 #1594
[mk-app] #1596 => #1591 #348
[mk-app] #1597 = #349 #1596
[mk-proof] #1598 monotonicity #1595 #1597
[mk-app] #1599 not #1591
[mk-app] #1600 or #1599 #348
[inst-discovered] theory-solving 0x0 basic# ; #1596
[mk-app] #1601 = #1596 #1600
[mk-proof] #1602 rewrite #1601
[instance] 0x0 #1601
[end-of-instance]
[mk-app] #1603 = #349 #1600
[mk-proof] #1604 trans #1598 #1602 #1603
[mk-quant] #1605 k!193 3 #283 #1600
[attach-var-names] #1605 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1606 null 3 #1604
[mk-proof] #1607 proof-bind #1606
[mk-app] #1608 = #350 #1605
[mk-proof] #1609 quant-intro #1607 #1608
[mk-proof] #1610 mp #351 #1609 #1605
[inst-discovered] theory-solving 0x0 arith# ; #400
[instance] 0x0 #417
[end-of-instance]
[mk-app] #1611 and #272 #416
[mk-app] #1612 = #401 #1611
[mk-proof] #1613 monotonicity #418 #1612
[mk-app] #1614 and #158 #1611
[mk-app] #1615 = #402 #1614
[mk-proof] #1616 monotonicity #1613 #1615
[mk-app] #1617 and #158 #272 #416
[inst-discovered] theory-solving 0x0 basic# ; #1614
[mk-app] #1618 = #1614 #1617
[mk-proof] #1619 rewrite #1618
[instance] 0x0 #1618
[end-of-instance]
[mk-app] #1620 = #402 #1617
[mk-proof] #1621 trans #1616 #1619 #1620
[mk-app] #1622 and #271 #1617
[mk-app] #1623 = #403 #1622
[mk-proof] #1624 monotonicity #1621 #1623
[mk-app] #1625 and #271 #158 #272 #416
[inst-discovered] theory-solving 0x0 basic# ; #1622
[mk-app] #1626 = #1622 #1625
[mk-proof] #1627 rewrite #1626
[instance] 0x0 #1626
[end-of-instance]
[mk-app] #1628 = #403 #1625
[mk-proof] #1629 trans #1624 #1627 #1628
[mk-app] #1630 => #1625 #410
[mk-app] #1631 = #411 #1630
[mk-proof] #1632 monotonicity #1629 #1631
[mk-app] #1633 not #1625
[mk-app] #1634 or #1633 #410
[inst-discovered] theory-solving 0x0 basic# ; #1630
[mk-app] #1635 = #1630 #1634
[mk-proof] #1636 rewrite #1635
[instance] 0x0 #1635
[end-of-instance]
[mk-app] #1637 = #411 #1634
[mk-proof] #1638 trans #1632 #1636 #1637
[mk-quant] #1639 k!207 3 #412 #1634
[attach-var-names] #1639 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1640 null 3 #1638
[mk-proof] #1641 proof-bind #1640
[mk-app] #1642 = #413 #1639
[mk-proof] #1643 quant-intro #1641 #1642
[mk-proof] #1644 mp #414 #1643 #1639
[inst-discovered] theory-solving 0x0 arith# ; #464
[instance] 0x0 #479
[end-of-instance]
[mk-app] #1645 and #463 #478
[mk-app] #1646 = #465 #1645
[mk-proof] #1647 monotonicity #480 #1646
[mk-app] #1648 => #1645 #468
[mk-app] #1649 = #469 #1648
[mk-proof] #1650 monotonicity #1647 #1649
[mk-app] #1651 not #1645
[mk-app] #1652 or #1651 #468
[inst-discovered] theory-solving 0x0 basic# ; #1648
[mk-app] #1653 = #1648 #1652
[mk-proof] #1654 rewrite #1653
[instance] 0x0 #1653
[end-of-instance]
[mk-app] #1655 = #469 #1652
[mk-proof] #1656 trans #1650 #1654 #1655
[mk-quant] #1657 k!214 3 #470 #471 #1652
[attach-var-names] #1657 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1658 null 3 #1656
[mk-proof] #1659 proof-bind #1658
[mk-app] #1660 = #472 #1657
[mk-proof] #1661 quant-intro #1659 #1660
[mk-proof] #1662 mp #473 #1661 #1657
[inst-discovered] theory-solving 0x0 arith# ; #511
[instance] 0x0 #530
[end-of-instance]
[mk-app] #1663 and #272 #529
[mk-app] #1664 = #512 #1663
[mk-proof] #1665 monotonicity #531 #1664
[inst-discovered] theory-solving 0x0 basic# ; #517
[instance] 0x0 #546
[end-of-instance]
[inst-discovered] theory-solving 0x0 basic# ; #521
[instance] 0x0 #549
[end-of-instance]
[mk-app] #1666 => #1663 #551
[mk-app] #1667 = #523 #1666
[mk-proof] #1668 monotonicity #1665 #553 #1667
[mk-app] #1669 not #1663
[mk-app] #1670 or #1669 #551
[inst-discovered] theory-solving 0x0 basic# ; #1666
[mk-app] #1671 = #1666 #1670
[mk-proof] #1672 rewrite #1671
[instance] 0x0 #1671
[end-of-instance]
[mk-app] #1673 = #523 #1670
[mk-proof] #1674 trans #1668 #1672 #1673
[mk-quant] #1675 k!223 4 #524 #525 #1670
[attach-var-names] #1675 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1676 null 4 #1674
[mk-proof] #1677 proof-bind #1676
[mk-app] #1678 = #526 #1675
[mk-proof] #1679 quant-intro #1677 #1678
[mk-proof] #1680 mp #527 #1679 #1675
[mk-app] #1681 or #598 #572
[inst-discovered] theory-solving 0x0 basic# ; #573
[mk-app] #1682 = #573 #1681
[mk-proof] #1683 rewrite #1682
[instance] 0x0 #1682
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #574
[instance] 0x0 #599
[end-of-instance]
[mk-app] #1684 => #598 #575
[mk-app] #1685 = #576 #1684
[mk-proof] #1686 monotonicity #600 #1685
[mk-app] #1687 or #569 #575
[inst-discovered] theory-solving 0x0 basic# ; #1684
[mk-app] #1688 = #1684 #1687
[mk-proof] #1689 rewrite #1688
[instance] 0x0 #1688
[end-of-instance]
[mk-app] #1690 = #576 #1687
[mk-proof] #1691 trans #1686 #1689 #1690
[mk-app] #1692 and #1681 #1687
[mk-app] #1693 = #577 #1692
[mk-proof] #1694 monotonicity #1683 #1691 #1693
[mk-app] #1695 => #272 #1692
[mk-app] #1696 = #578 #1695
[mk-proof] #1697 monotonicity #1694 #1696
[mk-app] #1698 or #625 #1692
[inst-discovered] theory-solving 0x0 basic# ; #1695
[mk-app] #1699 = #1695 #1698
[mk-proof] #1700 rewrite #1699
[instance] 0x0 #1699
[end-of-instance]
[mk-app] #1701 = #578 #1698
[mk-proof] #1702 trans #1697 #1700 #1701
[inst-discovered] theory-solving 0x0 arith# ; #37
[instance] 0x0 #626
[end-of-instance]
[mk-app] #1703 => #625 #579
[mk-app] #1704 = #580 #1703
[mk-proof] #1705 monotonicity #627 #1704
[mk-app] #1706 or #272 #579
[inst-discovered] theory-solving 0x0 basic# ; #1703
[mk-app] #1707 = #1703 #1706
[mk-proof] #1708 rewrite #1707
[instance] 0x0 #1707
[end-of-instance]
[mk-app] #1709 = #580 #1706
[mk-proof] #1710 trans #1705 #1708 #1709
[mk-app] #1711 and #1698 #1706
[mk-app] #1712 = #581 #1711
[mk-proof] #1713 monotonicity #1702 #1710 #1712
[mk-quant] #1714 k!234 2 #582 #583 #1711
[attach-var-names] #1714 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1715 null 2 #1713
[mk-proof] #1716 proof-bind #1715
[mk-app] #1717 = #584 #1714
[mk-proof] #1718 quant-intro #1716 #1717
[mk-proof] #1719 mp #585 #1718 #1714
[inst-discovered] theory-solving 0x0 arith# ; #649
[instance] 0x0 #661
[end-of-instance]
[mk-app] #1720 and #660 #291
[mk-app] #1721 = #650 #1720
[mk-proof] #1722 monotonicity #662 #293 #1721
[mk-app] #1723 and #272 #1720
[mk-app] #1724 = #651 #1723
[mk-proof] #1725 monotonicity #1722 #1724
[mk-app] #1726 and #272 #660 #291
[inst-discovered] theory-solving 0x0 basic# ; #1723
[mk-app] #1727 = #1723 #1726
[mk-proof] #1728 rewrite #1727
[instance] 0x0 #1727
[end-of-instance]
[mk-app] #1729 = #651 #1726
[mk-proof] #1730 trans #1725 #1728 #1729
[mk-app] #1731 => #1726 #654
[mk-app] #1732 = #655 #1731
[mk-proof] #1733 monotonicity #1730 #1732
[mk-app] #1734 not #1726
[mk-app] #1735 or #1734 #654
[inst-discovered] theory-solving 0x0 basic# ; #1731
[mk-app] #1736 = #1731 #1735
[mk-proof] #1737 rewrite #1736
[instance] 0x0 #1736
[end-of-instance]
[mk-app] #1738 = #655 #1735
[mk-proof] #1739 trans #1733 #1737 #1738
[mk-quant] #1740 k!241 3 #656 #657 #1735
[attach-var-names] #1740 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1741 null 3 #1739
[mk-proof] #1742 proof-bind #1741
[mk-app] #1743 = #658 #1740
[mk-proof] #1744 quant-intro #1742 #1743
[mk-proof] #1745 mp #659 #1744 #1740
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #699
[instance] 0x0 #714
[end-of-instance]
[mk-app] #1746 = #698 #713
[mk-app] #1747 = #700 #1746
[mk-proof] #1748 monotonicity #715 #1747
[mk-app] #1749 => #569 #1746
[mk-app] #1750 = #701 #1749
[mk-proof] #1751 monotonicity #1748 #1750
[mk-app] #1752 or #598 #1746
[inst-discovered] theory-solving 0x0 basic# ; #1749
[mk-app] #1753 = #1749 #1752
[mk-proof] #1754 rewrite #1753
[instance] 0x0 #1753
[end-of-instance]
[mk-app] #1755 = #701 #1752
[mk-proof] #1756 trans #1751 #1754 #1755
[mk-app] #1757 => #598 #702
[mk-app] #1758 = #703 #1757
[mk-proof] #1759 monotonicity #600 #1758
[mk-app] #1760 or #569 #702
[inst-discovered] theory-solving 0x0 basic# ; #1757
[mk-app] #1761 = #1757 #1760
[mk-proof] #1762 rewrite #1761
[instance] 0x0 #1761
[end-of-instance]
[mk-app] #1763 = #703 #1760
[mk-proof] #1764 trans #1759 #1762 #1763
[mk-app] #1765 and #1752 #1760
[mk-app] #1766 = #704 #1765
[mk-proof] #1767 monotonicity #1756 #1764 #1766
[mk-app] #1768 => #272 #1765
[mk-app] #1769 = #705 #1768
[mk-proof] #1770 monotonicity #1767 #1769
[mk-app] #1771 or #625 #1765
[inst-discovered] theory-solving 0x0 basic# ; #1768
[mk-app] #1772 = #1768 #1771
[mk-proof] #1773 rewrite #1772
[instance] 0x0 #1772
[end-of-instance]
[mk-app] #1774 = #705 #1771
[mk-proof] #1775 trans #1770 #1773 #1774
[mk-app] #1776 => #625 #706
[mk-app] #1777 = #707 #1776
[mk-proof] #1778 monotonicity #627 #1777
[mk-app] #1779 or #272 #706
[inst-discovered] theory-solving 0x0 basic# ; #1776
[mk-app] #1780 = #1776 #1779
[mk-proof] #1781 rewrite #1780
[instance] 0x0 #1780
[end-of-instance]
[mk-app] #1782 = #707 #1779
[mk-proof] #1783 trans #1778 #1781 #1782
[mk-app] #1784 and #1771 #1779
[mk-app] #1785 = #708 #1784
[mk-proof] #1786 monotonicity #1775 #1783 #1785
[mk-quant] #1787 k!254 2 #709 #710 #1784
[attach-var-names] #1787 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1788 null 2 #1786
[mk-proof] #1789 proof-bind #1788
[mk-app] #1790 = #711 #1787
[mk-proof] #1791 quant-intro #1789 #1790
[mk-proof] #1792 mp #712 #1791 #1787
[inst-discovered] theory-solving 0x0 arith# ; #774
[instance] 0x0 #793
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #775
[instance] 0x0 #797
[end-of-instance]
[mk-app] #1793 < #33 #796
[mk-app] #1794 = #776 #1793
[mk-proof] #1795 monotonicity #798 #1794
[mk-app] #1796 <= #796 #33
[mk-app] #1797 not #1796
[inst-discovered] theory-solving 0x0 arith# ; #1793
[mk-app] #1798 = #1793 #1797
[mk-proof] #1799 rewrite #1798
[instance] 0x0 #1798
[end-of-instance]
[mk-app] #1800 = #776 #1797
[mk-proof] #1801 trans #1795 #1799 #1800
[mk-app] #1802 and #272 #1797
[mk-app] #1803 = #777 #1802
[mk-proof] #1804 monotonicity #1801 #1803
[mk-app] #1805 and #792 #1802
[mk-app] #1806 = #778 #1805
[mk-proof] #1807 monotonicity #794 #1804 #1806
[mk-app] #1808 and #792 #272 #1797
[inst-discovered] theory-solving 0x0 basic# ; #1805
[mk-app] #1809 = #1805 #1808
[mk-proof] #1810 rewrite #1809
[instance] 0x0 #1809
[end-of-instance]
[mk-app] #1811 = #778 #1808
[mk-proof] #1812 trans #1807 #1810 #1811
[mk-app] #1813 => #1808 #786
[mk-app] #1814 = #787 #1813
[mk-proof] #1815 monotonicity #1812 #1814
[mk-app] #1816 not #1808
[mk-app] #1817 or #1816 #786
[inst-discovered] theory-solving 0x0 basic# ; #1813
[mk-app] #1818 = #1813 #1817
[mk-proof] #1819 rewrite #1818
[instance] 0x0 #1818
[end-of-instance]
[mk-app] #1820 = #787 #1817
[mk-proof] #1821 trans #1815 #1819 #1820
[mk-quant] #1822 k!262 3 #788 #1817
[attach-var-names] #1822 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1823 null 3 #1821
[mk-proof] #1824 proof-bind #1823
[mk-app] #1825 = #789 #1822
[mk-proof] #1826 quant-intro #1824 #1825
[mk-proof] #1827 mp #790 #1826 #1822
[mk-app] #1828 and #34 #291
[mk-app] #1829 = #848 #1828
[mk-proof] #1830 monotonicity #293 #1829
[mk-app] #1831 and #792 #1828
[mk-app] #1832 = #849 #1831
[mk-proof] #1833 monotonicity #794 #1830 #1832
[mk-app] #1834 and #792 #34 #291
[inst-discovered] theory-solving 0x0 basic# ; #1831
[mk-app] #1835 = #1831 #1834
[mk-proof] #1836 rewrite #1835
[instance] 0x0 #1835
[end-of-instance]
[mk-app] #1837 = #849 #1834
[mk-proof] #1838 trans #1833 #1836 #1837
[mk-app] #1839 => #1834 #855
[mk-app] #1840 = #856 #1839
[mk-proof] #1841 monotonicity #1838 #1840
[mk-app] #1842 not #1834
[mk-app] #1843 or #1842 #855
[inst-discovered] theory-solving 0x0 basic# ; #1839
[mk-app] #1844 = #1839 #1843
[mk-proof] #1845 rewrite #1844
[instance] 0x0 #1844
[end-of-instance]
[mk-app] #1846 = #856 #1843
[mk-proof] #1847 trans #1841 #1845 #1846
[mk-quant] #1848 k!270 3 #857 #1843
[attach-var-names] #1848 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1849 null 3 #1847
[mk-proof] #1850 proof-bind #1849
[mk-app] #1851 = #858 #1848
[mk-proof] #1852 quant-intro #1850 #1851
[mk-proof] #1853 mp #859 #1852 #1848
[inst-discovered] theory-solving 0x0 arith# ; #886
[instance] 0x0 #898
[end-of-instance]
[mk-app] #1854 and #897 #887
[mk-app] #1855 = #888 #1854
[mk-proof] #1856 monotonicity #899 #1855
[mk-app] #1857 => #1854 #891
[mk-app] #1858 = #892 #1857
[mk-proof] #1859 monotonicity #1856 #1858
[mk-app] #1860 not #1854
[mk-app] #1861 or #1860 #891
[inst-discovered] theory-solving 0x0 basic# ; #1857
[mk-app] #1862 = #1857 #1861
[mk-proof] #1863 rewrite #1862
[instance] 0x0 #1862
[end-of-instance]
[mk-app] #1864 = #892 #1861
[mk-proof] #1865 trans #1859 #1863 #1864
[mk-quant] #1866 k!276 3 #893 #1861
[attach-var-names] #1866 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1867 null 3 #1865
[mk-proof] #1868 proof-bind #1867
[mk-app] #1869 = #894 #1866
[mk-proof] #1870 quant-intro #1868 #1869
[mk-proof] #1871 mp #895 #1870 #1866
[inst-discovered] theory-solving 0x0 arith# ; #921
[instance] 0x0 #932
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #922
[instance] 0x0 #935
[end-of-instance]
[mk-app] #1872 and #934 #353
[mk-app] #1873 = #923 #1872
[mk-proof] #1874 monotonicity #936 #355 #1873
[mk-app] #1875 and #897 #1872
[mk-app] #1876 = #924 #1875
[mk-proof] #1877 monotonicity #933 #1874 #1876
[mk-app] #1878 and #897 #934 #353
[inst-discovered] theory-solving 0x0 basic# ; #1875
[mk-app] #1879 = #1875 #1878
[mk-proof] #1880 rewrite #1879
[instance] 0x0 #1879
[end-of-instance]
[mk-app] #1881 = #924 #1878
[mk-proof] #1882 trans #1877 #1880 #1881
[mk-app] #1883 => #1878 #928
[mk-app] #1884 = #929 #1883
[mk-proof] #1885 monotonicity #1882 #1884
[mk-app] #1886 not #1878
[mk-app] #1887 or #1886 #928
[inst-discovered] theory-solving 0x0 basic# ; #1883
[mk-app] #1888 = #1883 #1887
[mk-proof] #1889 rewrite #1888
[instance] 0x0 #1888
[end-of-instance]
[mk-app] #1890 = #929 #1887
[mk-proof] #1891 trans #1885 #1889 #1890
[mk-quant] #1892 k!286 3 #893 #1887
[attach-var-names] #1892 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1893 null 3 #1891
[mk-proof] #1894 proof-bind #1893
[mk-app] #1895 = #930 #1892
[mk-proof] #1896 quant-intro #1894 #1895
[mk-proof] #1897 mp #931 #1896 #1892
[mk-app] #1898 => #1854 #971
[mk-app] #1899 = #972 #1898
[mk-proof] #1900 monotonicity #1856 #1899
[mk-app] #1901 or #1860 #971
[inst-discovered] theory-solving 0x0 basic# ; #1898
[mk-app] #1902 = #1898 #1901
[mk-proof] #1903 rewrite #1902
[instance] 0x0 #1902
[end-of-instance]
[mk-app] #1904 = #972 #1901
[mk-proof] #1905 trans #1900 #1903 #1904
[mk-quant] #1906 k!292 3 #973 #1901
[attach-var-names] #1906 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1907 null 3 #1905
[mk-proof] #1908 proof-bind #1907
[mk-app] #1909 = #974 #1906
[mk-proof] #1910 quant-intro #1908 #1909
[mk-proof] #1911 mp #975 #1910 #1906
[mk-app] #1912 and #897 #934
[mk-app] #1913 = #990 #1912
[mk-proof] #1914 monotonicity #933 #936 #1913
[mk-app] #1915 => #1912 #993
[mk-app] #1916 = #994 #1915
[mk-proof] #1917 monotonicity #1914 #1916
[mk-app] #1918 not #1912
[mk-app] #1919 or #1918 #993
[inst-discovered] theory-solving 0x0 basic# ; #1915
[mk-app] #1920 = #1915 #1919
[mk-proof] #1921 rewrite #1920
[instance] 0x0 #1920
[end-of-instance]
[mk-app] #1922 = #994 #1919
[mk-proof] #1923 trans #1917 #1921 #1922
[mk-quant] #1924 k!300 3 #973 #1919
[attach-var-names] #1924 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1925 null 3 #1923
[mk-proof] #1926 proof-bind #1925
[mk-app] #1927 = #995 #1924
[mk-proof] #1928 quant-intro #1926 #1927
[mk-proof] #1929 mp #996 #1928 #1924
[inst-discovered] theory-solving 0x0 basic# ; #1016
[instance] 0x0 #1021
[end-of-instance]
[inst-discovered] theory-solving 0x0 basic# ; #1030
[instance] 0x0 #1035
[end-of-instance]
[mk-app] #1930 not #1043
[mk-app] #1931 or #1930 #1044
[inst-discovered] theory-solving 0x0 basic# ; #1045
[mk-app] #1932 = #1045 #1931
[mk-proof] #1933 rewrite #1932
[instance] 0x0 #1932
[end-of-instance]
[mk-quant] #1934 k!312 2 #1017 #1931
[attach-var-names] #1934 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1935 null 2 #1933
[mk-proof] #1936 proof-bind #1935
[mk-app] #1937 = #1046 #1934
[mk-proof] #1938 quant-intro #1936 #1937
[mk-proof] #1939 mp #1047 #1938 #1934
[mk-app] #1940 or #1930 #1064
[inst-discovered] theory-solving 0x0 basic# ; #1065
[mk-app] #1941 = #1065 #1940
[mk-proof] #1942 rewrite #1941
[instance] 0x0 #1941
[end-of-instance]
[mk-quant] #1943 k!316 2 #1031 #1940
[attach-var-names] #1943 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1944 null 2 #1942
[mk-proof] #1945 proof-bind #1944
[mk-app] #1946 = #1066 #1943
[mk-proof] #1947 quant-intro #1945 #1946
[mk-proof] #1948 mp #1067 #1947 #1943
[inst-discovered] theory-solving 0x0 arith# ; #1085
[instance] 0x0 #1099
[end-of-instance]
[mk-app] #1949 and #1098 #1087
[mk-app] #1950 = #1088 #1949
[mk-proof] #1951 monotonicity #1100 #1950
[mk-app] #1952 and #1084 #1949
[mk-app] #1953 = #1089 #1952
[mk-proof] #1954 monotonicity #1951 #1953
[mk-app] #1955 and #1084 #1098 #1087
[inst-discovered] theory-solving 0x0 basic# ; #1952
[mk-app] #1956 = #1952 #1955
[mk-proof] #1957 rewrite #1956
[instance] 0x0 #1956
[end-of-instance]
[mk-app] #1958 = #1089 #1955
[mk-proof] #1959 trans #1954 #1957 #1958
[mk-app] #1960 => #1082 #1955
[mk-app] #1961 = #1090 #1960
[mk-proof] #1962 monotonicity #1959 #1961
[mk-app] #1963 or #1125 #1955
[inst-discovered] theory-solving 0x0 basic# ; #1960
[mk-app] #1964 = #1960 #1963
[mk-proof] #1965 rewrite #1964
[instance] 0x0 #1964
[end-of-instance]
[mk-app] #1966 = #1090 #1963
[mk-proof] #1967 trans #1962 #1965 #1966
[mk-quant] #1968 k!326 2 #1091 #1963
[attach-var-names] #1968 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1969 null 2 #1967
[mk-proof] #1970 proof-bind #1969
[mk-app] #1971 = #1092 #1968
[mk-proof] #1972 quant-intro #1970 #1971
[mk-proof] #1973 mp #1093 #1972 #1968
[mk-app] #1974 and #291 #1137
[mk-app] #1975 = #1138 #1974
[mk-proof] #1976 monotonicity #293 #1975
[mk-app] #1977 and #272 #1974
[mk-app] #1978 = #1139 #1977
[mk-proof] #1979 monotonicity #1976 #1978
[mk-app] #1980 and #272 #291 #1137
[inst-discovered] theory-solving 0x0 basic# ; #1977
[mk-app] #1981 = #1977 #1980
[mk-proof] #1982 rewrite #1981
[instance] 0x0 #1981
[end-of-instance]
[mk-app] #1983 = #1139 #1980
[mk-proof] #1984 trans #1979 #1982 #1983
[mk-app] #1985 => #1980 #1140
[mk-app] #1986 = #1141 #1985
[mk-proof] #1987 monotonicity #1984 #1986
[mk-app] #1988 not #1980
[mk-app] #1989 or #1988 #1140
[inst-discovered] theory-solving 0x0 basic# ; #1985
[mk-app] #1990 = #1985 #1989
[mk-proof] #1991 rewrite #1990
[instance] 0x0 #1990
[end-of-instance]
[mk-app] #1992 = #1141 #1989
[mk-proof] #1993 trans #1987 #1991 #1992
[mk-quant] #1994 k!332 3 #1142 #1989
[attach-var-names] #1994 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1995 null 3 #1993
[mk-proof] #1996 proof-bind #1995
[mk-app] #1997 = #1143 #1994
[mk-proof] #1998 quant-intro #1996 #1997
[mk-proof] #1999 mp #1144 #1998 #1994
[mk-app] #2000 => #1611 #1171
[mk-app] #2001 = #1172 #2000
[mk-proof] #2002 monotonicity #1613 #2001
[mk-app] #2003 not #1611
[mk-app] #2004 or #2003 #1171
[inst-discovered] theory-solving 0x0 basic# ; #2000
[mk-app] #2005 = #2000 #2004
[mk-proof] #2006 rewrite #2005
[instance] 0x0 #2005
[end-of-instance]
[mk-app] #2007 = #1172 #2004
[mk-proof] #2008 trans #2002 #2006 #2007
[mk-quant] #2009 k!338 2 #1173 #2004
[attach-var-names] #2009 (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2010 null 2 #2008
[mk-proof] #2011 proof-bind #2010
[mk-app] #2012 = #1174 #2009
[mk-proof] #2013 quant-intro #2011 #2012
[mk-proof] #2014 mp #1175 #2013 #2009
[inst-discovered] theory-solving 0x0 basic# ; #1199
[instance] 0x0 #1221
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #1204
[instance] 0x0 #1228
[end-of-instance]
[mk-app] #2015 and #1227 #1208
[mk-app] #2016 = #1209 #2015
[mk-proof] #2017 monotonicity #1229 #2016
[mk-app] #2018 and #1203 #2015
[mk-app] #2019 = #1210 #2018
[mk-proof] #2020 monotonicity #2017 #2019
[mk-app] #2021 and #1203 #1227 #1208
[inst-discovered] theory-solving 0x0 basic# ; #2018
[mk-app] #2022 = #2018 #2021
[mk-proof] #2023 rewrite #2022
[instance] 0x0 #2022
[end-of-instance]
[mk-app] #2024 = #1210 #2021
[mk-proof] #2025 trans #2020 #2023 #2024
[mk-app] #2026 and #1202 #2021
[mk-app] #2027 = #1211 #2026
[mk-proof] #2028 monotonicity #2025 #2027
[mk-app] #2029 and #1202 #1203 #1227 #1208
[inst-discovered] theory-solving 0x0 basic# ; #2026
[mk-app] #2030 = #2026 #2029
[mk-proof] #2031 rewrite #2030
[instance] 0x0 #2030
[end-of-instance]
[mk-app] #2032 = #1211 #2029
[mk-proof] #2033 trans #2028 #2031 #2032
[mk-app] #2034 and #1196 #2029
[mk-app] #2035 = #1212 #2034
[mk-proof] #2036 monotonicity #2033 #2035
[mk-app] #2037 and #1196 #1202 #1203 #1227 #1208
[inst-discovered] theory-solving 0x0 basic# ; #2034
[mk-app] #2038 = #2034 #2037
[mk-proof] #2039 rewrite #2038
[instance] 0x0 #2038
[end-of-instance]
[mk-app] #2040 = #1212 #2037
[mk-proof] #2041 trans #2036 #2039 #2040
[mk-app] #2042 and #1195 #2037
[mk-app] #2043 = #1213 #2042
[mk-proof] #2044 monotonicity #2041 #2043
[mk-app] #2045 and #1195 #1196 #1202 #1203 #1227 #1208
[inst-discovered] theory-solving 0x0 basic# ; #2042
[mk-app] #2046 = #2042 #2045
[mk-proof] #2047 rewrite #2046
[instance] 0x0 #2046
[end-of-instance]
[mk-app] #2048 = #1213 #2045
[mk-proof] #2049 trans #2044 #2047 #2048
[mk-app] #2050 and #1194 #2045
[mk-app] #2051 = #1214 #2050
[mk-proof] #2052 monotonicity #2049 #2051
[mk-app] #2053 and #1194 #1195 #1196 #1202 #1203 #1227 #1208
[inst-discovered] theory-solving 0x0 basic# ; #2050
[mk-app] #2054 = #2050 #2053
[mk-proof] #2055 rewrite #2054
[instance] 0x0 #2054
[end-of-instance]
[mk-app] #2056 = #1214 #2053
[mk-proof] #2057 trans #2052 #2055 #2056
[mk-app] #2058 or #1220 #2053
[mk-app] #2059 = #1215 #2058
[mk-proof] #2060 monotonicity #1222 #2057 #2059
[mk-app] #2061 or #1193 #2058
[mk-app] #2062 = #1216 #2061
[mk-proof] #2063 monotonicity #2060 #2062
[mk-app] #2064 or #1193 #1220 #2053
[inst-discovered] theory-solving 0x0 basic# ; #2061
[mk-app] #2065 = #2061 #2064
[mk-proof] #2066 rewrite #2065
[instance] 0x0 #2065
[end-of-instance]
[mk-app] #2067 = #1216 #2064
[mk-proof] #2068 trans #2063 #2066 #2067
[mk-quant] #2069 k!363 2 #1217 #2064
[attach-var-names] #2069 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2070 null 2 #2068
[mk-proof] #2071 proof-bind #2070
[mk-app] #2072 = #1218 #2069
[mk-proof] #2073 quant-intro #2071 #2072
[mk-proof] #2074 mp #1219 #2073 #2069
[inst-discovered] theory-solving 0x0 basic# ; #1300
[instance] 0x0 #1304
[end-of-instance]
[mk-app] #2075 = #1317 #1317
[mk-proof] #2076 refl #2075
[inst-discovered] theory-solving 0x0 arith# ; #1319
[instance] 0x0 #1333
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1322
[instance] 0x0 #1344
[end-of-instance]
[mk-app] #2075 = #1321 #1343
[mk-app] #2076 = #1323 #2075
[mk-proof] #2077 monotonicity #1345 #2076
[mk-app] #2078 => #1332 #2075
[mk-app] #2079 = #1324 #2078
[mk-proof] #2080 monotonicity #1334 #2077 #2079
[mk-app] #2081 or #1325 #2075
[inst-discovered] theory-solving 0x0 basic# ; #2078
[mk-app] #2082 = #2078 #2081
[mk-proof] #2083 rewrite #2082
[instance] 0x0 #2082
[end-of-instance]
[mk-app] #2084 = #1324 #2081
[mk-proof] #2085 trans #2080 #2083 #2084
[mk-app] #2086 or #1332 #1326
[inst-discovered] theory-solving 0x0 basic# ; #1327
[mk-app] #2087 = #1327 #2086
[mk-proof] #2088 rewrite #2087
[instance] 0x0 #2087
[end-of-instance]
[mk-app] #2089 and #2081 #2086
[mk-app] #2090 = #1328 #2089
[mk-proof] #2091 monotonicity #2085 #2088 #2090
[mk-quant] #2092 $Seq[Int]_prog.ranged_seq_length 2 #1329 #2089
[attach-var-names] #2092 (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2093 null 2 #2091
[mk-proof] #2094 proof-bind #2093
[mk-app] #2095 = #1330 #2092
[mk-proof] #2096 quant-intro #2094 #2095
[mk-proof] #2097 mp #1331 #2096 #2092
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1385
[instance] 0x0 #1398
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #1400
[instance] 0x0 #1405
[end-of-instance]
[mk-app] #2098 and #272 #1404
[mk-app] #2099 = #1387 #2098
[mk-proof] #2100 monotonicity #1408 #2099
[mk-app] #2101 => #2098 #1391
[mk-app] #2102 = #1392 #2101
[mk-proof] #2103 monotonicity #2100 #2102
[mk-app] #2104 not #2098
[mk-app] #2105 or #2104 #1391
[inst-discovered] theory-solving 0x0 basic# ; #2101
[mk-app] #2106 = #2101 #2105
[mk-proof] #2107 rewrite #2106
[instance] 0x0 #2106
[end-of-instance]
[mk-app] #2108 = #1392 #2105
[mk-proof] #2109 trans #2103 #2107 #2108
[mk-quant] #2110 $Seq[Int]_prog.ranged_seq_index 3 #1393 #2105
[attach-var-names] #2110 (|j| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2111 null 3 #2109
[mk-proof] #2112 proof-bind #2111
[mk-app] #2113 = #1394 #2110
[mk-proof] #2114 quant-intro #2112 #2113
[mk-proof] #2115 mp #1395 #2114 #2110
[mk-app] #2116 and #1450 #660
[mk-app] #2117 = #1451 #2116
[mk-proof] #2118 monotonicity #662 #2117
[mk-app] #2119 = #1449 #2116
[mk-app] #2120 = #1452 #2119
[mk-proof] #2121 monotonicity #2118 #2120
[mk-quant] #2122 $Seq[Int]_prog.ranged_seq_contains 3 #1453 #2119
[attach-var-names] #2122 (|v| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2123 null 3 #2121
[mk-proof] #2124 proof-bind #2123
[mk-app] #2125 = #1454 #2122
[mk-proof] #2126 quant-intro #2124 #2125
[mk-proof] #2127 mp #1455 #2126 #2122
[mk-app] #2128 = #1477 #1477
[mk-proof] #2129 refl #2128
[inst-discovered] theory-solving 0x0 arith# ; #1480
[instance] 0x0 #1487
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #1504
[instance] 0x0 #1510
[end-of-instance]
[mk-quant] #2128 prog.addr 2 #1506 #1512
[attach-var-names] #2128 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-lambda] #2129 null 2 #1514
[mk-proof] #2130 proof-bind #2129
[mk-app] #2131 = #1507 #2128
[mk-proof] #2132 quant-intro #2130 #2131
[mk-proof] #2133 mp #1508 #2132 #2128
[mk-app] #2134 = #43 #43
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #50 #50
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #57 #57
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #63 #63
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #70 #70
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #76 #76
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #82 #82
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #88 #88
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #95 #95
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #101 #101
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #108 #108
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #114 #114
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #119 #119
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #132 #132
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #143 #143
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #154 #154
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1531 #1531
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #216 #216
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #224 #224
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #230 #230
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1537 #1537
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1571 #1571
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1605 #1605
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1639 #1639
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1657 #1657
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1675 #1675
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1714 #1714
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1740 #1740
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1787 #1787
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1822 #1822
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1848 #1848
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1866 #1866
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1892 #1892
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1906 #1906
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1924 #1924
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1023 #1023
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1037 #1037
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1934 #1934
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1943 #1943
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1968 #1968
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1994 #1994
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2009 #2009
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2069 #2069
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1306 #1306
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1317 #1317
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2092 #2092
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2110 #2110
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2122 #2122
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1477 #1477
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1495 #1495
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2128 #2128
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #43 #43
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #50 #50
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #57 #57
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #63 #63
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #70 #70
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #76 #76
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #82 #82
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #88 #88
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #95 #95
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #101 #101
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #108 #108
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #114 #114
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #119 #119
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #132 #132
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #143 #143
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #154 #154
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1531 #1531
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #216 #216
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #224 #224
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #230 #230
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1537 #1537
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1571 #1571
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1605 #1605
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1639 #1639
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1657 #1657
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1675 #1675
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1714 #1714
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1740 #1740
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1787 #1787
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1822 #1822
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1848 #1848
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1866 #1866
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1892 #1892
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1906 #1906
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1924 #1924
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1023 #1023
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1037 #1037
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1934 #1934
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1943 #1943
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1968 #1968
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1994 #1994
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2009 #2009
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2069 #2069
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1306 #1306
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1317 #1317
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2092 #2092
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2110 #2110
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2122 #2122
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1477 #1477
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #1495 #1495
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #2128 #2128
[mk-proof] #2135 refl #2134
[mk-app] #2134 = #43 #43
[mk-proof] #2135 rewrite #2134
[mk-proof] #2136 mp #44 #2135 #43
[mk-app] #2137 = #50 #50
[mk-proof] #2138 rewrite #2137
[mk-proof] #2139 mp #51 #2138 #50
[mk-app] #2140 = #57 #57
[mk-proof] #2141 rewrite #2140
[mk-proof] #2142 mp #58 #2141 #57
[mk-app] #2143 = #63 #63
[mk-proof] #2144 rewrite #2143
[mk-proof] #2145 mp #64 #2144 #63
[mk-app] #2146 = #70 #70
[mk-proof] #2147 rewrite #2146
[mk-proof] #2148 mp #71 #2147 #70
[mk-app] #2149 = #76 #76
[mk-proof] #2150 rewrite #2149
[mk-proof] #2151 mp #77 #2150 #76
[mk-app] #2152 = #82 #82
[mk-proof] #2153 rewrite #2152
[mk-proof] #2154 mp #83 #2153 #82
[mk-app] #2155 = #88 #88
[mk-proof] #2156 rewrite #2155
[mk-proof] #2157 mp #89 #2156 #88
[mk-app] #2158 = #95 #95
[mk-proof] #2159 rewrite #2158
[mk-proof] #2160 mp #96 #2159 #95
[mk-app] #2161 = #101 #101
[mk-proof] #2162 rewrite #2161
[mk-proof] #2163 mp #102 #2162 #101
[mk-app] #2164 = #108 #108
[mk-proof] #2165 rewrite #2164
[mk-proof] #2166 mp #109 #2165 #108
[mk-app] #2167 = #114 #114
[mk-proof] #2168 rewrite #2167
[mk-proof] #2169 mp #115 #2168 #114
[mk-app] #2170 = #119 #119
[mk-proof] #2171 rewrite #2170
[mk-proof] #2172 mp #120 #2171 #119
[mk-app] #2173 = #132 #132
[mk-proof] #2174 rewrite #2173
[mk-proof] #2175 mp #133 #2174 #132
[mk-app] #2176 = #143 #143
[mk-proof] #2177 rewrite #2176
[mk-proof] #2178 mp #148 #2177 #143
[mk-app] #2179 = #154 #154
[mk-proof] #2180 rewrite #2179
[mk-proof] #2181 mp #155 #2180 #154
[mk-app] #2182 = #1531 #1531
[mk-proof] #2183 rewrite #2182
[mk-proof] #2184 mp #1536 #2183 #1531
[mk-app] #2185 = #216 #216
[mk-proof] #2186 rewrite #2185
[mk-proof] #2187 mp #221 #2186 #216
[mk-app] #2188 = #224 #224
[mk-proof] #2189 rewrite #2188
[mk-proof] #2190 mp #225 #2189 #224
[mk-app] #2191 = #230 #230
[mk-proof] #2192 rewrite #2191
[mk-proof] #2193 mp #231 #2192 #230
[mk-app] #2194 = #1537 #1537
[mk-proof] #2195 rewrite #2194
[mk-proof] #2196 mp #1542 #2195 #1537
[mk-app] #2197 = #1571 #1571
[mk-proof] #2198 rewrite #2197
[mk-proof] #2199 mp #1576 #2198 #1571
[mk-app] #2200 = #1605 #1605
[mk-proof] #2201 rewrite #2200
[mk-proof] #2202 mp #1610 #2201 #1605
[mk-app] #2203 = #1639 #1639
[mk-proof] #2204 rewrite #2203
[mk-proof] #2205 mp #1644 #2204 #1639
[mk-app] #2206 = #1657 #1657
[mk-proof] #2207 rewrite #2206
[mk-proof] #2208 mp #1662 #2207 #1657
[mk-app] #2209 = #1675 #1675
[mk-proof] #2210 rewrite #2209
[mk-proof] #2211 mp #1680 #2210 #1675
[mk-app] #2212 = #1714 #1714
[mk-proof] #2213 rewrite #2212
[mk-proof] #2214 mp #1719 #2213 #1714
[mk-app] #2215 = #1740 #1740
[mk-proof] #2216 rewrite #2215
[mk-proof] #2217 mp #1745 #2216 #1740
[mk-app] #2218 = #1787 #1787
[mk-proof] #2219 rewrite #2218
[mk-proof] #2220 mp #1792 #2219 #1787
[mk-app] #2221 = #1822 #1822
[mk-proof] #2222 rewrite #2221
[mk-proof] #2223 mp #1827 #2222 #1822
[mk-app] #2224 = #1848 #1848
[mk-proof] #2225 rewrite #2224
[mk-proof] #2226 mp #1853 #2225 #1848
[mk-app] #2227 = #1866 #1866
[mk-proof] #2228 rewrite #2227
[mk-proof] #2229 mp #1871 #2228 #1866
[mk-app] #2230 = #1892 #1892
[mk-proof] #2231 rewrite #2230
[mk-proof] #2232 mp #1897 #2231 #1892
[mk-app] #2233 = #1906 #1906
[mk-proof] #2234 rewrite #2233
[mk-proof] #2235 mp #1911 #2234 #1906
[mk-app] #2236 = #1924 #1924
[mk-proof] #2237 rewrite #2236
[mk-proof] #2238 mp #1929 #2237 #1924
[mk-app] #2239 = #1023 #1023
[mk-proof] #2240 rewrite #2239
[mk-proof] #2241 mp #1028 #2240 #1023
[mk-app] #2242 = #1037 #1037
[mk-proof] #2243 rewrite #2242
[mk-proof] #2244 mp #1042 #2243 #1037
[mk-app] #2245 = #1934 #1934
[mk-proof] #2246 rewrite #2245
[mk-proof] #2247 mp #1939 #2246 #1934
[mk-app] #2248 = #1943 #1943
[mk-proof] #2249 rewrite #2248
[mk-proof] #2250 mp #1948 #2249 #1943
[mk-app] #2251 = #1968 #1968
[mk-proof] #2252 rewrite #2251
[mk-proof] #2253 mp #1973 #2252 #1968
[mk-app] #2254 = #1994 #1994
[mk-proof] #2255 rewrite #2254
[mk-proof] #2256 mp #1999 #2255 #1994
[mk-app] #2257 = #2009 #2009
[mk-proof] #2258 rewrite #2257
[mk-proof] #2259 mp #2014 #2258 #2009
[mk-app] #2260 = #2069 #2069
[mk-proof] #2261 rewrite #2260
[mk-proof] #2262 mp #2074 #2261 #2069
[mk-app] #2263 = #1306 #1306
[mk-proof] #2264 rewrite #2263
[mk-proof] #2265 mp #1311 #2264 #1306
[mk-app] #2266 = #1317 #1317
[mk-proof] #2267 rewrite #2266
[mk-proof] #2268 mp #1318 #2267 #1317
[mk-app] #2269 = #2092 #2092
[mk-proof] #2270 rewrite #2269
[mk-proof] #2271 mp #2097 #2270 #2092
[mk-app] #2272 = #2110 #2110
[mk-proof] #2273 rewrite #2272
[mk-proof] #2274 mp #2115 #2273 #2110
[mk-app] #2275 = #2122 #2122
[mk-proof] #2276 rewrite #2275
[mk-proof] #2277 mp #2127 #2276 #2122
[mk-app] #2278 = #1477 #1477
[mk-proof] #2279 rewrite #2278
[mk-proof] #2280 mp #1478 #2279 #1477
[mk-app] #2281 = #1495 #1495
[mk-proof] #2282 rewrite #2281
[mk-proof] #2283 mp #1500 #2282 #1495
[mk-app] #2284 = #2128 #2128
[mk-proof] #2285 rewrite #2284
[mk-proof] #2286 mp #2133 #2285 #2128
[mk-proof] #2287 refl #2134
[mk-proof] #2287 refl #2137
[mk-proof] #2287 refl #2140
[mk-proof] #2287 refl #2143
[mk-proof] #2287 refl #2146
[mk-proof] #2287 refl #2149
[mk-proof] #2287 refl #2152
[mk-proof] #2287 refl #2155
[mk-proof] #2287 refl #2158
[mk-proof] #2287 refl #2161
[mk-proof] #2287 refl #2164
[mk-proof] #2287 refl #2167
[mk-proof] #2287 refl #2170
[mk-proof] #2287 refl #2173
[mk-proof] #2287 refl #2176
[mk-proof] #2287 refl #2179
[inst-discovered] theory-solving 0x0 arith# ; #164
[mk-app] #2287 = #164 #164
[mk-proof] #2288 rewrite #2287
[instance] 0x0 #2287
[end-of-instance]
[mk-app] #2289 = #165 #165
[mk-proof] #2290 monotonicity #2288 #2289
[mk-app] #2291 = #1528 #1528
[mk-proof] #2292 monotonicity #2290 #2291
[mk-proof] #2293 refl #2182
[mk-proof] #2293 refl #2185
[mk-proof] #2293 refl #2188
[inst-discovered] theory-solving 0x0 arith# ; #227
[mk-app] #2293 = #227 #227
[mk-proof] #2294 rewrite #2293
[instance] 0x0 #2293
[end-of-instance]
[mk-app] #2295 = #228 #228
[mk-proof] #2296 monotonicity #2294 #2295
[mk-proof] #2297 refl #2191
[inst-discovered] theory-solving 0x0 arith# ; #250
[mk-app] #2297 = #250 #250
[mk-proof] #2298 rewrite #2297
[instance] 0x0 #2297
[end-of-instance]
[mk-app] #2299 = #253 #253
[mk-proof] #2300 monotonicity #2298 #2299
[mk-proof] #2301 refl #2194
[mk-proof] #2301 refl #2197
[mk-proof] #2301 refl #2200
[mk-proof] #2301 refl #2203
[mk-proof] #2301 refl #2206
[mk-proof] #2301 refl #2209
[mk-proof] #2301 refl #2212
[mk-proof] #2301 refl #2215
[inst-discovered] theory-solving 0x0 arith# ; #713
[mk-app] #2301 = #713 #713
[mk-proof] #2302 rewrite #2301
[instance] 0x0 #2301
[end-of-instance]
[mk-app] #2303 = #1746 #1746
[mk-proof] #2304 monotonicity #2302 #2303
[mk-app] #2305 = #1752 #1752
[mk-proof] #2306 monotonicity #2304 #2305
[mk-app] #2307 = #1765 #1765
[mk-proof] #2308 monotonicity #2306 #2307
[mk-app] #2309 = #1771 #1771
[mk-proof] #2310 monotonicity #2308 #2309
[mk-app] #2311 = #1784 #1784
[mk-proof] #2312 monotonicity #2310 #2311
[mk-proof] #2313 refl #2218
[inst-discovered] theory-solving 0x0 arith# ; #796
[mk-app] #2313 = #796 #796
[mk-proof] #2314 rewrite #2313
[instance] 0x0 #2313
[end-of-instance]
[mk-app] #2315 = #1796 #1796
[mk-proof] #2316 monotonicity #2314 #2315
[mk-app] #2317 = #1797 #1797
[mk-proof] #2318 monotonicity #2316 #2317
[mk-app] #2319 = #1808 #1808
[mk-proof] #2320 monotonicity #2318 #2319
[mk-app] #2321 = #1816 #1816
[mk-proof] #2322 monotonicity #2320 #2321
[mk-app] #2323 = #1817 #1817
[mk-proof] #2324 monotonicity #2322 #2323
[mk-proof] #2325 refl #2221
[mk-proof] #2325 refl #2224
[mk-proof] #2325 refl #2227
[mk-proof] #2325 refl #2230
[mk-proof] #2325 refl #2233
[mk-proof] #2325 refl #2236
[mk-proof] #2325 refl #2239
[mk-proof] #2325 refl #2242
[mk-proof] #2325 refl #2245
[mk-proof] #2325 refl #2248
[mk-proof] #2325 refl #2251
[mk-proof] #2325 refl #2254
[mk-proof] #2325 refl #2257
[mk-proof] #2325 refl #2260
[mk-proof] #2325 refl #2263
[mk-proof] #2325 refl #2266
[inst-discovered] theory-solving 0x0 arith# ; #1343
[mk-app] #2325 = #1343 #1343
[mk-proof] #2326 rewrite #2325
[instance] 0x0 #2325
[end-of-instance]
[mk-app] #2327 = #2075 #2075
[mk-proof] #2328 monotonicity #2326 #2327
[mk-app] #2329 = #2081 #2081
[mk-proof] #2330 monotonicity #2328 #2329
[mk-app] #2331 = #2089 #2089
[mk-proof] #2332 monotonicity #2330 #2331
[mk-proof] #2333 refl #2269
[inst-discovered] theory-solving 0x0 arith# ; #1397
[mk-app] #2333 = #1397 #1397
[mk-proof] #2334 rewrite #2333
[instance] 0x0 #2333
[end-of-instance]
[mk-app] #2335 = #1403 #1403
[mk-proof] #2336 monotonicity #2334 #2335
[mk-app] #2337 = #1404 #1404
[mk-proof] #2338 monotonicity #2336 #2337
[mk-app] #2339 = #2098 #2098
[mk-proof] #2340 monotonicity #2338 #2339
[mk-app] #2341 = #2104 #2104
[mk-proof] #2342 monotonicity #2340 #2341
[inst-discovered] theory-solving 0x0 arith# ; #1390
[mk-app] #2343 = #1390 #1390
[mk-proof] #2344 rewrite #2343
[instance] 0x0 #2343
[end-of-instance]
[mk-app] #2345 = #1391 #1391
[mk-proof] #2346 monotonicity #2344 #2345
[mk-app] #2347 = #2105 #2105
[mk-proof] #2348 monotonicity #2342 #2346 #2347
[mk-proof] #2349 refl #2272
[mk-proof] #2349 refl #2275
[mk-proof] #2349 refl #2278
[inst-discovered] theory-solving 0x0 arith# ; #1486
[mk-app] #2349 = #1486 #1486
[mk-proof] #2350 rewrite #2349
[instance] 0x0 #2349
[end-of-instance]
[mk-app] #2351 = #1489 #1489
[mk-proof] #2352 monotonicity #2350 #2351
[mk-app] #2353 = #1492 #1492
[mk-proof] #2354 monotonicity #2352 #2353
[mk-proof] #2355 refl #2281
[inst-discovered] theory-solving 0x0 arith# ; #1509
[mk-app] #2355 = #1509 #1509
[mk-proof] #2356 rewrite #2355
[instance] 0x0 #2355
[end-of-instance]
[mk-app] #2357 = #1512 #1512
[mk-proof] #2358 monotonicity #2356 #2357
[mk-proof] #2359 refl #2284
[mk-proof] #2349 refl #2134
[mk-proof] #2349 refl #2137
[mk-proof] #2349 refl #2140
[mk-proof] #2349 refl #2143
[mk-proof] #2349 refl #2146
[mk-proof] #2349 refl #2149
[mk-proof] #2349 refl #2152
[mk-proof] #2349 refl #2155
[mk-proof] #2349 refl #2158
[mk-proof] #2349 refl #2161
[mk-proof] #2349 refl #2164
[mk-proof] #2349 refl #2167
[mk-proof] #2349 refl #2170
[mk-proof] #2349 refl #2173
[mk-proof] #2349 refl #2176
[mk-proof] #2349 refl #2179
[mk-proof] #2349 refl #2182
[mk-proof] #2349 refl #2185
[mk-proof] #2349 refl #2188
[mk-proof] #2349 refl #2191
[mk-proof] #2349 refl #2194
[mk-proof] #2349 refl #2197
[mk-proof] #2349 refl #2200
[mk-proof] #2349 refl #2203
[mk-proof] #2349 refl #2206
[mk-proof] #2349 refl #2209
[mk-proof] #2349 refl #2212
[mk-proof] #2349 refl #2215
[mk-proof] #2349 refl #2218
[mk-proof] #2349 refl #2221
[mk-proof] #2349 refl #2224
[mk-proof] #2349 refl #2227
[mk-proof] #2349 refl #2230
[mk-proof] #2349 refl #2233
[mk-proof] #2349 refl #2236
[mk-proof] #2349 refl #2239
[mk-proof] #2349 refl #2242
[mk-proof] #2349 refl #2245
[mk-proof] #2349 refl #2248
[mk-proof] #2349 refl #2251
[mk-proof] #2349 refl #2254
[mk-proof] #2349 refl #2257
[mk-proof] #2349 refl #2260
[mk-proof] #2349 refl #2263
[mk-proof] #2349 refl #2266
[mk-proof] #2349 refl #2269
[mk-proof] #2349 refl #2272
[mk-proof] #2349 refl #2275
[mk-proof] #2349 refl #2278
[mk-proof] #2349 refl #2281
[mk-proof] #2349 refl #2284
[attach-meaning] #176 arith (- 1)
[mk-app] #2349 * #176 #40
[mk-app] #2350 + #33 #2349
[mk-app] #2351 = #2350 #36
[inst-discovered] theory-solving 0x0 arith# ; #41
[mk-app] #2352 = #41 #2351
[mk-proof] #2325 rewrite #2352
[instance] 0x0 #2352
[end-of-instance]
[mk-quant] #2326 $Snap.$SnapToIntTo$Snap 1 #42 #2351
[attach-var-names] #2326 (|x| ; |Int|)
[mk-lambda] #2327 null 1 #2325
[mk-proof] #2328 proof-bind #2327
[mk-app] #2329 = #43 #2326
[mk-proof] #2330 quant-intro #2328 #2329
[mk-proof] #2331 mp #2136 #2330 #2326
[mk-proof] #2332 refl #2137
[mk-proof] #2332 refl #2140
[mk-proof] #2332 refl #2143
[mk-proof] #2332 refl #2146
[mk-proof] #2332 refl #2149
[mk-app] #2332 Real
[attach-meaning] #2332 arith (- 1)
[mk-app] #2301 * #2332 #79
[mk-app] #2302 + #23 #2301
[mk-app] #2313 = #2302 #25
[inst-discovered] theory-solving 0x0 arith# ; #80
[mk-app] #2314 = #80 #2313
[mk-proof] #2333 rewrite #2314
[instance] 0x0 #2314
[end-of-instance]
[mk-quant] #2334 $Snap.$SnapTo$PermTo$Snap 1 #81 #2313
[attach-var-names] #2334 (|x| ; |Real|)
[mk-lambda] #2335 null 1 #2333
[mk-proof] #2336 proof-bind #2335
[mk-app] #2337 = #82 #2334
[mk-proof] #2338 quant-intro #2336 #2337
[mk-proof] #2293 mp #2154 #2338 #2334
[mk-proof] #2294 refl #2155
[mk-proof] #2294 refl #2158
[mk-proof] #2294 refl #2161
[mk-proof] #2294 refl #2164
[mk-proof] #2294 refl #2167
[attach-meaning] #176 arith (- 1)
[mk-app] #2294 * #176 #116
[inst-discovered] theory-solving 0x0 arith# ; #117
[instance] 0x0 #121
[end-of-instance]
[mk-proof] #2294 mp #2172 #128 #124
[mk-proof] #2295 refl #2173
[mk-proof] #2295 refl #2176
[mk-proof] #2295 refl #2179
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #2295 * #176 #116
[mk-app] #2296 + #162 #420 #2295
[mk-app] #2297 = #2296 #36
[inst-discovered] theory-solving 0x0 arith# ; #165
[mk-app] #2298 = #165 #2297
[mk-proof] #2353 rewrite #2298
[instance] 0x0 #2298
[end-of-instance]
[mk-app] #2354 or #187 #2297
[mk-app] #2303 = #1528 #2354
[mk-proof] #2304 monotonicity #2353 #2303
[mk-quant] #2305 k!150 2 #167 #2354
[attach-var-names] #2305 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2306 null 2 #2304
[mk-proof] #2307 proof-bind #2306
[mk-app] #2308 = #1531 #2305
[mk-proof] #2309 quant-intro #2307 #2308
[mk-proof] #2310 mp #2184 #2309 #2305
[mk-proof] #2311 refl #2185
[attach-meaning] #176 arith (- 1)
[mk-app] #2311 + #222 #249
[mk-app] #2312 = #2311 #36
[inst-discovered] theory-solving 0x0 arith# ; #223
[mk-app] #2343 = #223 #2312
[mk-proof] #2344 rewrite #2343
[instance] 0x0 #2343
[end-of-instance]
[mk-quant] #2355 k!160 1 #153 #2312
[attach-var-names] #2355 (|e| ; |Int|)
[mk-lambda] #2356 null 1 #2344
[mk-proof] #2339 proof-bind #2356
[mk-app] #2340 = #224 #2355
[mk-proof] #2341 quant-intro #2339 #2340
[mk-proof] #2342 mp #2190 #2341 #2355
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #2345 + #226 #795 #249
[mk-app] #2346 = #2345 #36
[inst-discovered] theory-solving 0x0 arith# ; #228
[mk-app] #2347 = #228 #2346
[mk-proof] #2348 rewrite #2347
[instance] 0x0 #2347
[end-of-instance]
[mk-quant] #2287 k!164 2 #229 #2346
[attach-var-names] #2287 (|j| ; |Int|) (|i| ; |Int|)
[mk-lambda] #2288 null 2 #2348
[mk-proof] #2315 proof-bind #2288
[mk-app] #2316 = #230 #2287
[mk-proof] #2317 quant-intro #2315 #2316
[mk-proof] #2318 mp #2193 #2317 #2287
[attach-meaning] #176 arith (- 1)
[mk-app] #2319 + #243 #795 #33
[mk-app] #2320 = #2319 #36
[inst-discovered] theory-solving 0x0 arith# ; #253
[mk-app] #2289 = #253 #2320
[mk-proof] #2290 rewrite #2289
[instance] 0x0 #2289
[end-of-instance]
[mk-quant] #2299 k!168 2 #246 #2320
[attach-var-names] #2299 (|j| ; |Int|) (|i| ; |Int|)
[mk-lambda] #2300 null 2 #2290
[mk-proof] #2291 proof-bind #2300
[mk-app] #2292 = #1537 #2299
[mk-proof] #2321 quant-intro #2291 #2292
[mk-proof] #2322 mp #2196 #2321 #2299
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #272
[instance] 0x0 #288
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2323 + #273 #249
[mk-app] #2324 <= #2323 #36
[inst-discovered] theory-solving 0x0 arith# ; #290
[mk-app] #2357 = #290 #2324
[mk-proof] #2358 rewrite #2357
[instance] 0x0 #2357
[end-of-instance]
[mk-app] #2359 not #2324
[mk-app] #2360 = #291 #2359
[mk-proof] #2361 monotonicity #2358 #2360
[mk-app] #2362 and #271 #158 #287 #2359
[mk-app] #2363 = #1557 #2362
[mk-proof] #2364 monotonicity #289 #2361 #2363
[mk-app] #2365 not #2362
[mk-app] #2366 = #1565 #2365
[mk-proof] #2367 monotonicity #2364 #2366
[attach-meaning] #176 arith (- 1)
[mk-app] #2368 * #176 #280
[mk-app] #2369 + #279 #2368
[mk-app] #2370 = #2369 #36
[inst-discovered] theory-solving 0x0 arith# ; #281
[mk-app] #2371 = #281 #2370
[mk-proof] #2372 rewrite #2371
[instance] 0x0 #2371
[end-of-instance]
[mk-app] #2373 or #2365 #2370
[mk-app] #2374 = #1566 #2373
[mk-proof] #2375 monotonicity #2367 #2372 #2374
[mk-quant] #2376 k!179 3 #283 #284 #2373
[attach-var-names] #2376 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2377 null 3 #2375
[mk-proof] #2378 proof-bind #2377
[mk-app] #2379 = #1571 #2376
[mk-proof] #2380 quant-intro #2378 #2379
[mk-proof] #2381 mp #2199 #2380 #2376
[attach-meaning] #176 arith (- 1)
[mk-app] #2382 + #338 #249
[mk-app] #2383 <= #2382 #36
[inst-discovered] theory-solving 0x0 arith# ; #352
[mk-app] #2384 = #352 #2383
[mk-proof] #2385 rewrite #2384
[instance] 0x0 #2384
[end-of-instance]
[mk-app] #2386 not #2383
[mk-app] #2387 = #353 #2386
[mk-proof] #2388 monotonicity #2385 #2387
[mk-app] #2389 and #271 #158 #2324 #2386
[mk-app] #2390 = #1591 #2389
[mk-proof] #2391 monotonicity #2358 #2388 #2390
[mk-app] #2392 not #2389
[mk-app] #2393 = #1599 #2392
[mk-proof] #2394 monotonicity #2391 #2393
[attach-meaning] #176 arith (- 1)
[mk-app] #2395 + #344 #249
[mk-app] #2396 = #2395 #36
[inst-discovered] theory-solving 0x0 arith# ; #345
[mk-app] #2397 = #345 #2396
[mk-proof] #2398 rewrite #2397
[instance] 0x0 #2397
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2399 * #176 #346
[mk-app] #2400 + #279 #2399
[mk-app] #2401 = #2400 #36
[inst-discovered] theory-solving 0x0 arith# ; #347
[mk-app] #2402 = #347 #2401
[mk-proof] #2403 rewrite #2402
[instance] 0x0 #2402
[end-of-instance]
[mk-app] #2404 and #2396 #2401
[mk-app] #2405 = #348 #2404
[mk-proof] #2406 monotonicity #2398 #2403 #2405
[mk-app] #2407 or #2392 #2404
[mk-app] #2408 = #1600 #2407
[mk-proof] #2409 monotonicity #2394 #2406 #2408
[mk-quant] #2410 k!193 3 #283 #2407
[attach-var-names] #2410 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2411 null 3 #2409
[mk-proof] #2412 proof-bind #2411
[mk-app] #2413 = #1605 #2410
[mk-proof] #2414 quant-intro #2412 #2413
[mk-proof] #2415 mp #2202 #2414 #2410
[attach-meaning] #176 arith (- 1)
[mk-app] #2416 <= #713 #36
[inst-discovered] theory-solving 0x0 arith# ; #415
[mk-app] #2417 = #415 #2416
[mk-proof] #2418 rewrite #2417
[instance] 0x0 #2417
[end-of-instance]
[mk-app] #2419 not #2416
[mk-app] #2420 = #416 #2419
[mk-proof] #2421 monotonicity #2418 #2420
[mk-app] #2422 and #271 #158 #287 #2419
[mk-app] #2423 = #1625 #2422
[mk-proof] #2424 monotonicity #289 #2421 #2423
[mk-app] #2425 not #2422
[mk-app] #2426 = #1633 #2425
[mk-proof] #2427 monotonicity #2424 #2426
[attach-meaning] #176 arith (- 1)
[mk-app] #2428 + #405 #249
[mk-app] #2429 = #2428 #36
[inst-discovered] theory-solving 0x0 arith# ; #406
[mk-app] #2430 = #406 #2429
[mk-proof] #2431 rewrite #2430
[instance] 0x0 #2430
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2432 * #176 #408
[mk-app] #2433 + #407 #2432
[mk-app] #2434 = #2433 #36
[inst-discovered] theory-solving 0x0 arith# ; #409
[mk-app] #2435 = #409 #2434
[mk-proof] #2436 rewrite #2435
[instance] 0x0 #2435
[end-of-instance]
[mk-app] #2437 and #2429 #2434
[mk-app] #2438 = #410 #2437
[mk-proof] #2439 monotonicity #2431 #2436 #2438
[mk-app] #2440 or #2425 #2437
[mk-app] #2441 = #1634 #2440
[mk-proof] #2442 monotonicity #2427 #2439 #2441
[mk-quant] #2443 k!207 3 #412 #2440
[attach-var-names] #2443 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2444 null 3 #2442
[mk-proof] #2445 proof-bind #2444
[mk-app] #2446 = #1639 #2443
[mk-proof] #2447 quant-intro #2445 #2446
[mk-proof] #2448 mp #2205 #2447 #2443
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #463
[instance] 0x0 #474
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2449 <= #796 #36
[inst-discovered] theory-solving 0x0 arith# ; #477
[mk-app] #2450 = #477 #2449
[mk-proof] #2451 rewrite #2450
[instance] 0x0 #2450
[end-of-instance]
[mk-app] #2452 not #2449
[mk-app] #2453 = #478 #2452
[mk-proof] #2454 monotonicity #2451 #2453
[mk-app] #2455 and #475 #2452
[mk-app] #2456 = #1645 #2455
[mk-proof] #2457 monotonicity #476 #2454 #2456
[mk-app] #2458 not #2455
[mk-app] #2459 = #1651 #2458
[mk-proof] #2460 monotonicity #2457 #2459
[attach-meaning] #176 arith (- 1)
[mk-app] #2461 + #467 #295
[mk-app] #2462 = #2461 #36
[inst-discovered] theory-solving 0x0 arith# ; #468
[mk-app] #2463 = #468 #2462
[mk-proof] #2464 rewrite #2463
[instance] 0x0 #2463
[end-of-instance]
[mk-app] #2465 or #2458 #2462
[mk-app] #2466 = #1652 #2465
[mk-proof] #2467 monotonicity #2460 #2464 #2466
[mk-quant] #2468 k!214 3 #470 #471 #2465
[attach-var-names] #2468 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2469 null 3 #2467
[mk-proof] #2470 proof-bind #2469
[mk-app] #2471 = #1657 #2468
[mk-proof] #2472 quant-intro #2470 #2471
[mk-proof] #2473 mp #2208 #2472 #2468
[attach-meaning] #176 arith (- 1)
[mk-app] #2474 + #510 #249
[mk-app] #2475 <= #2474 #36
[inst-discovered] theory-solving 0x0 arith# ; #528
[mk-app] #2476 = #528 #2475
[mk-proof] #2477 rewrite #2476
[instance] 0x0 #2476
[end-of-instance]
[mk-app] #2478 not #2475
[mk-app] #2479 = #529 #2478
[mk-proof] #2480 monotonicity #2477 #2479
[mk-app] #2481 and #287 #2478
[mk-app] #2482 = #1663 #2481
[mk-proof] #2483 monotonicity #289 #2480 #2482
[mk-app] #2484 not #2481
[mk-app] #2485 = #1669 #2484
[mk-proof] #2486 monotonicity #2483 #2485
[attach-meaning] #176 arith (- 1)
[mk-app] #2487 + #509 #249
[mk-app] #2488 = #2487 #36
[inst-discovered] theory-solving 0x0 arith# ; #513
[mk-app] #2489 = #513 #2488
[mk-proof] #2490 rewrite #2489
[instance] 0x0 #2489
[end-of-instance]
[mk-app] #2491 not #2488
[mk-app] #2492 = #518 #2491
[mk-proof] #2493 monotonicity #2490 #2492
[attach-meaning] #176 arith (- 1)
[mk-app] #2494 + #515 #795
[mk-app] #2495 = #2494 #36
[inst-discovered] theory-solving 0x0 arith# ; #516
[mk-app] #2496 = #516 #2495
[mk-proof] #2497 rewrite #2496
[instance] 0x0 #2496
[end-of-instance]
[mk-app] #2498 or #2491 #2495
[mk-app] #2499 = #545 #2498
[mk-proof] #2500 monotonicity #2493 #2497 #2499
[attach-meaning] #176 arith (- 1)
[mk-app] #2501 * #176 #519
[mk-app] #2502 + #515 #2501
[mk-app] #2503 = #2502 #36
[inst-discovered] theory-solving 0x0 arith# ; #520
[mk-app] #2504 = #520 #2503
[mk-proof] #2505 rewrite #2504
[instance] 0x0 #2504
[end-of-instance]
[mk-app] #2506 or #2488 #2503
[mk-app] #2507 = #548 #2506
[mk-proof] #2508 monotonicity #2490 #2505 #2507
[mk-app] #2509 and #2498 #2506
[mk-app] #2510 = #551 #2509
[mk-proof] #2511 monotonicity #2500 #2508 #2510
[mk-app] #2512 or #2484 #2509
[mk-app] #2513 = #1670 #2512
[mk-proof] #2514 monotonicity #2486 #2511 #2513
[mk-quant] #2515 k!223 4 #524 #525 #2512
[attach-var-names] #2515 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2516 null 4 #2514
[mk-proof] #2517 proof-bind #2516
[mk-app] #2518 = #1675 #2515
[mk-proof] #2519 quant-intro #2517 #2518
[mk-proof] #2520 mp #2211 #2519 #2515
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #569
[instance] 0x0 #587
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2521 + #571 #249
[mk-app] #2522 = #2521 #36
[inst-discovered] theory-solving 0x0 arith# ; #572
[mk-app] #2523 = #572 #2522
[mk-proof] #2524 rewrite #2523
[instance] 0x0 #2523
[end-of-instance]
[mk-app] #2525 or #592 #2522
[mk-app] #2526 = #1681 #2525
[mk-proof] #2527 monotonicity #602 #2524 #2526
[attach-meaning] #176 arith (- 1)
[mk-app] #2528 + #571 #420
[mk-app] #2529 = #2528 #36
[inst-discovered] theory-solving 0x0 arith# ; #575
[mk-app] #2530 = #575 #2529
[mk-proof] #2531 rewrite #2530
[instance] 0x0 #2530
[end-of-instance]
[mk-app] #2532 or #586 #2529
[mk-app] #2533 = #1687 #2532
[mk-proof] #2534 monotonicity #588 #2531 #2533
[mk-app] #2535 and #2525 #2532
[mk-app] #2536 = #1692 #2535
[mk-proof] #2537 monotonicity #2527 #2534 #2536
[mk-app] #2538 or #619 #2535
[mk-app] #2539 = #1698 #2538
[mk-proof] #2540 monotonicity #629 #2537 #2539
[mk-app] #2541 = #1706 #635
[mk-proof] #2542 monotonicity #289 #2541
[mk-app] #2543 and #2538 #635
[mk-app] #2544 = #1711 #2543
[mk-proof] #2545 monotonicity #2540 #2542 #2544
[mk-quant] #2546 k!234 2 #582 #583 #2543
[attach-var-names] #2546 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2547 null 2 #2545
[mk-proof] #2548 proof-bind #2547
[mk-app] #2549 = #1714 #2546
[mk-proof] #2550 quant-intro #2548 #2549
[mk-proof] #2551 mp #2214 #2550 #2546
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #34
[instance] 0x0 #664
[end-of-instance]
[mk-app] #2552 and #287 #666 #2359
[mk-app] #2553 = #1726 #2552
[mk-proof] #2554 monotonicity #289 #668 #2361 #2553
[mk-app] #2555 not #2552
[mk-app] #2556 = #1734 #2555
[mk-proof] #2557 monotonicity #2554 #2556
[attach-meaning] #176 arith (- 1)
[mk-app] #2558 + #653 #2368
[mk-app] #2559 = #2558 #36
[inst-discovered] theory-solving 0x0 arith# ; #654
[mk-app] #2560 = #654 #2559
[mk-proof] #2561 rewrite #2560
[instance] 0x0 #2560
[end-of-instance]
[mk-app] #2562 or #2555 #2559
[mk-app] #2563 = #1735 #2562
[mk-proof] #2564 monotonicity #2557 #2561 #2563
[mk-quant] #2565 k!241 3 #656 #657 #2562
[attach-var-names] #2565 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2566 null 3 #2564
[mk-proof] #2567 proof-bind #2566
[mk-app] #2568 = #1740 #2565
[mk-proof] #2569 quant-intro #2567 #2568
[mk-proof] #2570 mp #2217 #2569 #2565
[attach-meaning] #176 arith (- 1)
[mk-app] #2571 + #698 #420 #33
[mk-app] #2572 = #2571 #36
[inst-discovered] theory-solving 0x0 arith# ; #1746
[mk-app] #2573 = #1746 #2572
[mk-proof] #2574 rewrite #2573
[instance] 0x0 #2573
[end-of-instance]
[mk-app] #2575 or #592 #2572
[mk-app] #2576 = #1752 #2575
[mk-proof] #2577 monotonicity #602 #2574 #2576
[mk-app] #2578 = #1760 #741
[mk-proof] #2579 monotonicity #588 #2578
[inst-discovered] theory-solving 0x0 basic# ; #741
[mk-app] #2580 = #741 #741
[mk-proof] #2581 rewrite #2580
[instance] 0x0 #2580
[end-of-instance]
[mk-proof] #2582 trans #2579 #2581 #2578
[mk-app] #2583 and #2575 #741
[mk-app] #2584 = #1765 #2583
[mk-proof] #2585 monotonicity #2577 #2582 #2584
[mk-app] #2586 or #619 #2583
[mk-app] #2587 = #1771 #2586
[mk-proof] #2588 monotonicity #629 #2585 #2587
[attach-meaning] #176 arith (- 1)
[mk-app] #2589 + #698 #420
[mk-app] #2590 = #2589 #36
[inst-discovered] theory-solving 0x0 arith# ; #706
[mk-app] #2591 = #706 #2590
[mk-proof] #2592 rewrite #2591
[instance] 0x0 #2591
[end-of-instance]
[mk-app] #2593 or #287 #2590
[mk-app] #2594 = #1779 #2593
[mk-proof] #2595 monotonicity #289 #2592 #2594
[mk-app] #2596 and #2586 #2593
[mk-app] #2597 = #1784 #2596
[mk-proof] #2598 monotonicity #2588 #2595 #2597
[mk-quant] #2599 k!254 2 #709 #710 #2596
[attach-var-names] #2599 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2600 null 2 #2598
[mk-proof] #2601 proof-bind #2600
[mk-app] #2602 = #1787 #2599
[mk-proof] #2603 quant-intro #2601 #2602
[mk-proof] #2604 mp #2220 #2603 #2599
[attach-meaning] #176 arith (- 1)
[mk-app] #2605 + #273 #795 #249
[mk-app] #2606 <= #2605 #36
[inst-discovered] theory-solving 0x0 arith# ; #1796
[mk-app] #2607 = #1796 #2606
[mk-proof] #2608 rewrite #2607
[instance] 0x0 #2607
[end-of-instance]
[mk-app] #2609 not #2606
[mk-app] #2610 = #1797 #2609
[mk-proof] #2611 monotonicity #2608 #2610
[mk-app] #2612 and #792 #287 #2609
[mk-app] #2613 = #1808 #2612
[mk-proof] #2614 monotonicity #289 #2611 #2613
[mk-app] #2615 not #2612
[mk-app] #2616 = #1816 #2615
[mk-proof] #2617 monotonicity #2614 #2616
[attach-meaning] #176 arith (- 1)
[mk-app] #2618 + #780 #249
[mk-app] #2619 = #2618 #36
[inst-discovered] theory-solving 0x0 arith# ; #781
[mk-app] #2620 = #781 #2619
[mk-proof] #2621 rewrite #2620
[instance] 0x0 #2620
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2622 * #176 #784
[mk-app] #2623 + #783 #2622
[mk-app] #2624 = #2623 #36
[inst-discovered] theory-solving 0x0 arith# ; #785
[mk-app] #2625 = #785 #2624
[mk-proof] #2626 rewrite #2625
[instance] 0x0 #2625
[end-of-instance]
[mk-app] #2627 and #2619 #2624
[mk-app] #2628 = #786 #2627
[mk-proof] #2629 monotonicity #2621 #2626 #2628
[mk-app] #2630 or #2615 #2627
[mk-app] #2631 = #1817 #2630
[mk-proof] #2632 monotonicity #2617 #2629 #2631
[mk-quant] #2633 k!262 3 #788 #2630
[attach-var-names] #2633 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2634 null 3 #2632
[mk-proof] #2635 proof-bind #2634
[mk-app] #2636 = #1822 #2633
[mk-proof] #2637 quant-intro #2635 #2636
[mk-proof] #2638 mp #2223 #2637 #2633
[mk-app] #2639 and #792 #663 #2359
[mk-app] #2640 = #1834 #2639
[mk-proof] #2641 monotonicity #665 #2361 #2640
[mk-app] #2642 not #2639
[mk-app] #2643 = #1842 #2642
[mk-proof] #2644 monotonicity #2641 #2643
[attach-meaning] #176 arith (- 1)
[mk-app] #2645 + #851 #249
[mk-app] #2646 = #2645 #36
[inst-discovered] theory-solving 0x0 arith# ; #852
[mk-app] #2647 = #852 #2646
[mk-proof] #2648 rewrite #2647
[instance] 0x0 #2647
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2649 + #853 #2368
[mk-app] #2650 = #2649 #36
[inst-discovered] theory-solving 0x0 arith# ; #854
[mk-app] #2651 = #854 #2650
[mk-proof] #2652 rewrite #2651
[instance] 0x0 #2651
[end-of-instance]
[mk-app] #2653 and #2646 #2650
[mk-app] #2654 = #855 #2653
[mk-proof] #2655 monotonicity #2648 #2652 #2654
[mk-app] #2656 or #2642 #2653
[mk-app] #2657 = #1843 #2656
[mk-proof] #2658 monotonicity #2644 #2655 #2657
[mk-quant] #2659 k!270 3 #857 #2656
[attach-var-names] #2659 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2660 null 3 #2658
[mk-proof] #2661 proof-bind #2660
[mk-app] #2662 = #1848 #2659
[mk-proof] #2663 quant-intro #2661 #2662
[mk-proof] #2664 mp #2226 #2663 #2659
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #887
[instance] 0x0 #901
[end-of-instance]
[mk-app] #2665 = #1854 #903
[mk-proof] #2666 monotonicity #902 #2665
[mk-app] #2667 = #1860 #909
[mk-proof] #2668 monotonicity #2666 #2667
[mk-app] #2669 = #1861 #910
[mk-proof] #2670 monotonicity #2668 #2669
[mk-lambda] #2671 null 3 #2670
[mk-proof] #2672 proof-bind #2671
[mk-app] #2673 = #1866 #915
[mk-proof] #2674 quant-intro #2672 #2673
[mk-proof] #2675 mp #2229 #2674 #915
[mk-app] #2676 and #897 #937 #2386
[mk-app] #2677 = #1878 #2676
[mk-proof] #2678 monotonicity #939 #2388 #2677
[mk-app] #2679 not #2676
[mk-app] #2680 = #1886 #2679
[mk-proof] #2681 monotonicity #2678 #2680
[mk-app] #2682 and #2396 #927
[mk-app] #2683 = #928 #2682
[mk-proof] #2684 monotonicity #2398 #2683
[mk-app] #2685 or #2679 #2682
[mk-app] #2686 = #1887 #2685
[mk-proof] #2687 monotonicity #2681 #2684 #2686
[mk-quant] #2688 k!286 3 #893 #2685
[attach-var-names] #2688 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #2689 null 3 #2687
[mk-proof] #2690 proof-bind #2689
[mk-app] #2691 = #1892 #2688
[mk-proof] #2692 quant-intro #2690 #2691
[mk-proof] #2693 mp #2232 #2692 #2688
[mk-app] #2694 = #1901 #979
[mk-proof] #2695 monotonicity #2668 #2694
[mk-lambda] #2696 null 3 #2695
[mk-proof] #2697 proof-bind #2696
[mk-app] #2698 = #1906 #984
[mk-proof] #2699 quant-intro #2697 #2698
[mk-proof] #2700 mp #2235 #2699 #984
[mk-app] #2701 = #1912 #997
[mk-proof] #2702 monotonicity #939 #2701
[mk-app] #2703 = #1918 #1003
[mk-proof] #2704 monotonicity #2702 #2703
[mk-app] #2705 and #2396 #992
[mk-app] #2706 = #993 #2705
[mk-proof] #2707 monotonicity #2398 #2706
[mk-app] #2708 or #1003 #2705
[mk-app] #2709 = #1919 #2708
[mk-proof] #2710 monotonicity #2704 #2707 #2709
[mk-quant] #2711 k!300 3 #973 #2708
[attach-var-names] #2711 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #2712 null 3 #2710
[mk-proof] #2713 proof-bind #2712
[mk-app] #2714 = #1924 #2711
[mk-proof] #2715 quant-intro #2713 #2714
[mk-proof] #2716 mp #2238 #2715 #2711
[mk-proof] #2717 refl #2239
[mk-proof] #2717 refl #2242
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1043
[instance] 0x0 #1048
[end-of-instance]
[mk-app] #2717 = #1930 #424
[mk-proof] #2718 monotonicity #1049 #2717
[mk-app] #2719 = #1931 #1053
[mk-proof] #2720 monotonicity #2718 #2719
[mk-lambda] #2721 null 2 #2720
[mk-proof] #2722 proof-bind #2721
[mk-app] #2723 = #1934 #1058
[mk-proof] #2724 quant-intro #2722 #2723
[mk-proof] #2725 mp #2247 #2724 #1058
[mk-app] #2726 = #1940 #1071
[mk-proof] #2727 monotonicity #2718 #2726
[mk-lambda] #2728 null 2 #2727
[mk-proof] #2729 proof-bind #2728
[mk-app] #2730 = #1943 #1076
[mk-proof] #2731 quant-intro #2729 #2730
[mk-proof] #2732 mp #2250 #2731 #1076
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1084
[instance] 0x0 #1094
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1097
[instance] 0x0 #1104
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2733 + #1086 #249
[mk-app] #2734 = #2733 #36
[inst-discovered] theory-solving 0x0 arith# ; #1087
[mk-app] #2735 = #1087 #2734
[mk-proof] #2736 rewrite #2735
[instance] 0x0 #2735
[end-of-instance]
[mk-app] #2737 and #1095 #1106 #2734
[mk-app] #2738 = #1955 #2737
[mk-proof] #2739 monotonicity #1096 #1108 #2736 #2738
[mk-app] #2740 or #1125 #2737
[mk-app] #2741 = #1963 #2740
[mk-proof] #2742 monotonicity #2739 #2741
[mk-quant] #2743 k!326 2 #1091 #2740
[attach-var-names] #2743 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2744 null 2 #2742
[mk-proof] #2745 proof-bind #2744
[mk-app] #2746 = #1968 #2743
[mk-proof] #2747 quant-intro #2745 #2746
[mk-proof] #2748 mp #2253 #2747 #2743
[attach-meaning] #176 arith (- 1)
[mk-app] #2749 + #280 #795
[mk-app] #2750 = #2749 #36
[inst-discovered] theory-solving 0x0 arith# ; #1137
[mk-app] #2751 = #1137 #2750
[mk-proof] #2752 rewrite #2751
[instance] 0x0 #2751
[end-of-instance]
[mk-app] #2753 and #287 #2359 #2750
[mk-app] #2754 = #1980 #2753
[mk-proof] #2755 monotonicity #289 #2361 #2752 #2754
[mk-app] #2756 not #2753
[mk-app] #2757 = #1988 #2756
[mk-proof] #2758 monotonicity #2755 #2757
[mk-app] #2759 or #2756 #1140
[mk-app] #2760 = #1989 #2759
[mk-proof] #2761 monotonicity #2758 #2760
[mk-quant] #2762 k!332 3 #1142 #2759
[attach-var-names] #2762 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2763 null 3 #2761
[mk-proof] #2764 proof-bind #2763
[mk-app] #2765 = #1994 #2762
[mk-proof] #2766 quant-intro #2764 #2765
[mk-proof] #2767 mp #2256 #2766 #2762
[mk-app] #2768 and #287 #2419
[mk-app] #2769 = #1611 #2768
[mk-proof] #2770 monotonicity #289 #2421 #2769
[mk-app] #2771 not #2768
[mk-app] #2772 = #2003 #2771
[mk-proof] #2773 monotonicity #2770 #2772
[mk-app] #2774 or #2771 #1171
[mk-app] #2775 = #2004 #2774
[mk-proof] #2776 monotonicity #2773 #2775
[mk-quant] #2777 k!338 2 #1173 #2774
[attach-var-names] #2777 (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2778 null 2 #2776
[mk-proof] #2779 proof-bind #2778
[mk-app] #2780 = #2009 #2777
[mk-proof] #2781 quant-intro #2779 #2780
[mk-proof] #2782 mp #2259 #2781 #2777
[attach-meaning] #176 arith (- 1)
[mk-app] #2783 + #163 #2295
[mk-app] #2784 = #2783 #36
[inst-discovered] theory-solving 0x0 arith# ; #1196
[mk-app] #2785 = #1196 #2784
[mk-proof] #2786 rewrite #2785
[instance] 0x0 #2785
[end-of-instance]
[mk-app] #2787 not #2784
[mk-app] #2788 = #1197 #2787
[mk-proof] #2789 monotonicity #2786 #2788
[mk-app] #2790 and #1194 #1195 #2787
[mk-app] #2791 = #1220 #2790
[mk-proof] #2792 monotonicity #2789 #2791
[attach-meaning] #176 arith (- 1)
[mk-app] #2793 * #176 #1201
[mk-app] #2794 + #1200 #2793
[mk-app] #2795 = #2794 #36
[inst-discovered] theory-solving 0x0 arith# ; #1202
[mk-app] #2796 = #1202 #2795
[mk-proof] #2797 rewrite #2796
[instance] 0x0 #2796
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1203
[instance] 0x0 #1223
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1226
[instance] 0x0 #1233
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2798 * #176 #1206
[mk-app] #2799 + #1205 #2798
[mk-app] #2800 = #2799 #36
[inst-discovered] theory-solving 0x0 arith# ; #1207
[mk-app] #2801 = #1207 #2800
[mk-proof] #2802 rewrite #2801
[instance] 0x0 #2801
[end-of-instance]
[mk-app] #2803 not #2800
[mk-app] #2804 = #1208 #2803
[mk-proof] #2805 monotonicity #2802 #2804
[mk-app] #2806 and #1194 #1195 #2784 #2795 #1224 #1235 #2803
[mk-app] #2807 = #2053 #2806
[mk-proof] #2808 monotonicity #2786 #2797 #1225 #1237 #2805 #2807
[mk-app] #2809 or #1193 #2790 #2806
[mk-app] #2810 = #2064 #2809
[mk-proof] #2811 monotonicity #2792 #2808 #2810
[mk-quant] #2812 k!363 2 #1217 #2809
[attach-var-names] #2812 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2813 null 2 #2811
[mk-proof] #2814 proof-bind #2813
[mk-app] #2815 = #2069 #2812
[mk-proof] #2816 quant-intro #2814 #2815
[mk-proof] #2817 mp #2262 #2816 #2812
[mk-proof] #2818 refl #2263
[attach-meaning] #176 arith (- 1)
[mk-app] #2818 = #250 #36
[inst-discovered] theory-solving 0x0 arith# ; #1314
[mk-app] #2819 = #1314 #2818
[mk-proof] #2820 rewrite #2819
[instance] 0x0 #2819
[end-of-instance]
[mk-app] #2821 = #1313 #2818
[mk-app] #2822 = #1315 #2821
[mk-proof] #2823 monotonicity #2820 #2822
[mk-quant] #2824 k!371 2 #1316 #2821
[attach-var-names] #2824 (|y| ; |Int|) (|x| ; |Int|)
[mk-lambda] #2825 null 2 #2823
[mk-proof] #2826 proof-bind #2825
[mk-app] #2827 = #1317 #2824
[mk-proof] #2828 quant-intro #2826 #2827
[mk-proof] #2829 mp #2268 #2828 #2824
[attach-meaning] #176 arith (- 1)
[mk-app] #2830 <= #1343 #36
[inst-discovered] theory-solving 0x0 arith# ; #1325
[mk-app] #2831 = #1325 #2830
[mk-proof] #2832 rewrite #2831
[instance] 0x0 #2831
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #2833 + #1321 #249 #32
[mk-app] #2834 = #2833 #36
[inst-discovered] theory-solving 0x0 arith# ; #2075
[mk-app] #2835 = #2075 #2834
[mk-proof] #2836 rewrite #2835
[instance] 0x0 #2835
[end-of-instance]
[mk-app] #2837 or #2830 #2834
[mk-app] #2838 = #2081 #2837
[mk-proof] #2839 monotonicity #2832 #2836 #2838
[mk-app] #2840 not #2830
[mk-app] #2841 = #1332 #2840
[mk-proof] #2842 monotonicity #2832 #2841
[mk-app] #2843 or #2840 #1326
[mk-app] #2844 = #2086 #2843
[mk-proof] #2845 monotonicity #2842 #2844
[mk-app] #2846 and #2837 #2843
[mk-app] #2847 = #2089 #2846
[mk-proof] #2848 monotonicity #2839 #2845 #2847
[mk-quant] #2849 $Seq[Int]_prog.ranged_seq_length 2 #1329 #2846
[attach-var-names] #2849 (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2850 null 2 #2848
[mk-proof] #2851 proof-bind #2850
[mk-app] #2852 = #2092 #2849
[mk-proof] #2853 quant-intro #2851 #2852
[mk-proof] #2854 mp #2271 #2853 #2849
[attach-meaning] #176 arith (- 1)
[mk-app] #2855 + #32 #1396 #249
[mk-app] #2856 <= #2855 #36
[inst-discovered] theory-solving 0x0 arith# ; #1403
[mk-app] #2857 = #1403 #2856
[mk-proof] #2858 rewrite #2857
[instance] 0x0 #2857
[end-of-instance]
[mk-app] #2859 not #2856
[mk-app] #2860 = #1404 #2859
[mk-proof] #2861 monotonicity #2858 #2860
[mk-app] #2862 and #287 #2859
[mk-app] #2863 = #2098 #2862
[mk-proof] #2864 monotonicity #289 #2861 #2863
[mk-app] #2865 not #2862
[mk-app] #2866 = #2104 #2865
[mk-proof] #2867 monotonicity #2864 #2866
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #2868 + #1389 #1396 #249
[mk-app] #2869 = #2868 #36
[inst-discovered] theory-solving 0x0 arith# ; #1391
[mk-app] #2870 = #1391 #2869
[mk-proof] #2871 rewrite #2870
[instance] 0x0 #2870
[end-of-instance]
[mk-app] #2872 or #2865 #2869
[mk-app] #2873 = #2105 #2872
[mk-proof] #2874 monotonicity #2867 #2871 #2873
[mk-quant] #2875 $Seq[Int]_prog.ranged_seq_index 3 #1393 #2872
[attach-var-names] #2875 (|j| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2876 null 3 #2874
[mk-proof] #2877 proof-bind #2876
[mk-app] #2878 = #2110 #2875
[mk-proof] #2879 quant-intro #2877 #2878
[mk-proof] #2880 mp #2274 #2879 #2875
[attach-meaning] #176 arith (- 1)
[mk-app] #2881 <= #2487 #36
[inst-discovered] theory-solving 0x0 arith# ; #1450
[mk-app] #2882 = #1450 #2881
[mk-proof] #2883 rewrite #2882
[instance] 0x0 #2882
[end-of-instance]
[mk-app] #2884 and #2881 #666
[mk-app] #2885 = #2116 #2884
[mk-proof] #2886 monotonicity #2883 #668 #2885
[mk-app] #2887 = #1449 #2884
[mk-app] #2888 = #2119 #2887
[mk-proof] #2889 monotonicity #2886 #2888
[mk-quant] #2890 $Seq[Int]_prog.ranged_seq_contains 3 #1453 #2887
[attach-var-names] #2890 (|v| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2891 null 3 #2889
[mk-proof] #2892 proof-bind #2891
[mk-app] #2893 = #2122 #2890
[mk-proof] #2894 quant-intro #2892 #2893
[mk-proof] #2895 mp #2277 #2894 #2890
[attach-meaning] #176 arith (- 1)
[mk-app] #2896 + #1474 #249
[mk-app] #2897 = #2896 #36
[inst-discovered] theory-solving 0x0 arith# ; #1475
[mk-app] #2898 = #1475 #2897
[mk-proof] #2899 rewrite #2898
[instance] 0x0 #2898
[end-of-instance]
[mk-quant] #2900 prog.inj 2 #1476 #2897
[attach-var-names] #2900 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-lambda] #2901 null 2 #2899
[mk-proof] #2902 proof-bind #2901
[mk-app] #2903 = #1477 #2900
[mk-proof] #2904 quant-intro #2902 #2903
[mk-proof] #2905 mp #2280 #2904 #2900
[mk-proof] #2906 refl #2281
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #1512
[instance] 0x0 #1518
[end-of-instance]
[mk-lambda] #2906 null 2 #1519
[mk-proof] #2907 proof-bind #2906
[mk-app] #2908 = #2128 #1522
[mk-proof] #2909 quant-intro #2907 #2908
[mk-proof] #2910 mp #2286 #2909 #1522
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[mk-app] #2911 = #2326 #2326
[mk-proof] #2912 refl #2911
[mk-proof] #2911 refl #2137
[mk-proof] #2911 refl #2140
[mk-proof] #2911 refl #2143
[mk-proof] #2911 refl #2146
[mk-proof] #2911 refl #2149
[mk-app] #2911 = #2334 #2334
[mk-proof] #2912 refl #2911
[mk-proof] #2911 refl #2155
[mk-proof] #2911 refl #2158
[mk-proof] #2911 refl #2161
[mk-proof] #2911 refl #2164
[mk-proof] #2911 refl #2167
[mk-app] #2911 = #124 #124
[mk-proof] #2912 refl #2911
[mk-proof] #2911 refl #2173
[mk-proof] #2911 refl #2176
[mk-proof] #2911 refl #2179
[mk-app] #2911 + #2295 #162 #420
[inst-discovered] theory-solving 0x0 arith# ; #2296
[mk-app] #2912 = #2296 #2911
[mk-proof] #2913 rewrite #2912
[instance] 0x0 #2912
[end-of-instance]
[mk-app] #2914 = #2911 #36
[mk-app] #2915 = #2297 #2914
[mk-proof] #2916 monotonicity #2913 #2915
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #2914
[mk-app] #2917 = #2914 #177
[mk-proof] #2918 rewrite #2917
[instance] 0x0 #2917
[end-of-instance]
[mk-app] #2919 = #2297 #177
[mk-proof] #2920 trans #2916 #2918 #2919
[mk-app] #2921 = #2354 #188
[mk-proof] #2922 monotonicity #2920 #2921
[mk-lambda] #2923 null 2 #2922
[mk-proof] #2924 proof-bind #2923
[mk-app] #2925 = #2305 #193
[mk-proof] #2926 quant-intro #2924 #2925
[mk-proof] #2927 mp #2310 #2926 #193
[mk-proof] #2928 refl #2185
[mk-app] #2928 + #249 #222
[inst-discovered] theory-solving 0x0 arith# ; #2311
[mk-app] #2929 = #2311 #2928
[mk-proof] #2930 rewrite #2929
[instance] 0x0 #2929
[end-of-instance]
[mk-app] #2931 = #2928 #36
[mk-app] #2932 = #2312 #2931
[mk-proof] #2933 monotonicity #2930 #2932
[attach-meaning] #176 arith (- 1)
[mk-app] #2934 * #176 #222
[mk-app] #2935 + #33 #2934
[mk-app] #2936 = #2935 #36
[inst-discovered] theory-solving 0x0 arith# ; #2931
[mk-app] #2937 = #2931 #2936
[mk-proof] #2938 rewrite #2937
[instance] 0x0 #2937
[end-of-instance]
[mk-app] #2939 = #2312 #2936
[mk-proof] #2940 trans #2933 #2938 #2939
[mk-quant] #2941 k!160 1 #153 #2936
[attach-var-names] #2941 (|e| ; |Int|)
[mk-lambda] #2942 null 1 #2940
[mk-proof] #2943 proof-bind #2942
[mk-app] #2944 = #2355 #2941
[mk-proof] #2945 quant-intro #2943 #2944
[mk-proof] #2946 mp #2342 #2945 #2941
[mk-app] #2947 + #795 #249 #226
[inst-discovered] theory-solving 0x0 arith# ; #2345
[mk-app] #2948 = #2345 #2947
[mk-proof] #2949 rewrite #2948
[instance] 0x0 #2948
[end-of-instance]
[mk-app] #2950 = #2947 #36
[mk-app] #2951 = #2346 #2950
[mk-proof] #2952 monotonicity #2949 #2951
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #2950
[mk-app] #2953 = #2950 #232
[mk-proof] #2954 rewrite #2953
[instance] 0x0 #2953
[end-of-instance]
[mk-app] #2955 = #2346 #232
[mk-proof] #2956 trans #2952 #2954 #2955
[mk-lambda] #2957 null 2 #2956
[mk-proof] #2958 proof-bind #2957
[mk-app] #2959 = #2287 #237
[mk-proof] #2960 quant-intro #2958 #2959
[mk-proof] #2961 mp #2318 #2960 #237
[mk-app] #2962 + #795 #33 #243
[inst-discovered] theory-solving 0x0 arith# ; #2319
[mk-app] #2963 = #2319 #2962
[mk-proof] #2964 rewrite #2963
[instance] 0x0 #2963
[end-of-instance]
[mk-app] #2965 = #2962 #36
[mk-app] #2966 = #2320 #2965
[mk-proof] #2967 monotonicity #2964 #2966
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #2965
[mk-app] #2968 = #2965 #256
[mk-proof] #2969 rewrite #2968
[instance] 0x0 #2968
[end-of-instance]
[mk-app] #2970 = #2320 #256
[mk-proof] #2971 trans #2967 #2969 #2970
[mk-lambda] #2972 null 2 #2971
[mk-proof] #2973 proof-bind #2972
[mk-app] #2974 = #2299 #263
[mk-proof] #2975 quant-intro #2973 #2974
[mk-proof] #2976 mp #2322 #2975 #263
[mk-app] #2977 + #249 #273
[inst-discovered] theory-solving 0x0 arith# ; #2323
[mk-app] #2978 = #2323 #2977
[mk-proof] #2979 rewrite #2978
[instance] 0x0 #2978
[end-of-instance]
[mk-app] #2980 <= #2977 #36
[mk-app] #2981 = #2324 #2980
[mk-proof] #2982 monotonicity #2979 #2981
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #2980
[mk-app] #2983 = #2980 #294
[mk-proof] #2984 rewrite #2983
[instance] 0x0 #2983
[end-of-instance]
[mk-app] #2985 = #2324 #294
[mk-proof] #2986 trans #2982 #2984 #2985
[mk-app] #2987 = #2359 #299
[mk-proof] #2988 monotonicity #2986 #2987
[mk-app] #2989 = #2362 #318
[mk-proof] #2990 monotonicity #2988 #2989
[mk-app] #2991 = #2365 #326
[mk-proof] #2992 monotonicity #2990 #2991
[mk-app] #2993 or #326 #2370
[mk-app] #2994 = #2373 #2993
[mk-proof] #2995 monotonicity #2992 #2994
[mk-quant] #2996 k!179 3 #283 #284 #2993
[attach-var-names] #2996 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2997 null 3 #2995
[mk-proof] #2998 proof-bind #2997
[mk-app] #2999 = #2376 #2996
[mk-proof] #3000 quant-intro #2998 #2999
[mk-proof] #3001 mp #2381 #3000 #2996
[mk-app] #3002 + #249 #338
[inst-discovered] theory-solving 0x0 arith# ; #2382
[mk-app] #3003 = #2382 #3002
[mk-proof] #3004 rewrite #3003
[instance] 0x0 #3003
[end-of-instance]
[mk-app] #3005 <= #3002 #36
[mk-app] #3006 = #2383 #3005
[mk-proof] #3007 monotonicity #3004 #3006
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3005
[mk-app] #3008 = #3005 #356
[mk-proof] #3009 rewrite #3008
[instance] 0x0 #3008
[end-of-instance]
[mk-app] #3010 = #2383 #356
[mk-proof] #3011 trans #3007 #3009 #3010
[mk-app] #3012 = #2386 #361
[mk-proof] #3013 monotonicity #3011 #3012
[mk-app] #3014 = #2389 #380
[mk-proof] #3015 monotonicity #2986 #3013 #3014
[mk-app] #3016 = #2392 #388
[mk-proof] #3017 monotonicity #3015 #3016
[mk-app] #3018 + #249 #344
[inst-discovered] theory-solving 0x0 arith# ; #2395
[mk-app] #3019 = #2395 #3018
[mk-proof] #3020 rewrite #3019
[instance] 0x0 #3019
[end-of-instance]
[mk-app] #3021 = #3018 #36
[mk-app] #3022 = #2396 #3021
[mk-proof] #3023 monotonicity #3020 #3022
[attach-meaning] #176 arith (- 1)
[mk-app] #3024 * #176 #344
[mk-app] #3025 + #33 #3024
[mk-app] #3026 = #3025 #36
[inst-discovered] theory-solving 0x0 arith# ; #3021
[mk-app] #3027 = #3021 #3026
[mk-proof] #3028 rewrite #3027
[instance] 0x0 #3027
[end-of-instance]
[mk-app] #3029 = #2396 #3026
[mk-proof] #3030 trans #3023 #3028 #3029
[mk-app] #3031 and #3026 #2401
[mk-app] #3032 = #2404 #3031
[mk-proof] #3033 monotonicity #3030 #3032
[mk-app] #3034 or #388 #3031
[mk-app] #3035 = #2407 #3034
[mk-proof] #3036 monotonicity #3017 #3033 #3035
[mk-quant] #3037 k!193 3 #283 #3034
[attach-var-names] #3037 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #3038 null 3 #3036
[mk-proof] #3039 proof-bind #3038
[mk-app] #3040 = #2410 #3037
[mk-proof] #3041 quant-intro #3039 #3040
[mk-proof] #3042 mp #2415 #3041 #3037
[inst-discovered] theory-solving 0x0 arith# ; #713
[instance] 0x0 #717
[end-of-instance]
[mk-app] #3043 <= #716 #36
[mk-app] #3044 = #2416 #3043
[mk-proof] #3045 monotonicity #718 #3044
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3043
[mk-app] #3046 = #3043 #419
[mk-proof] #3047 rewrite #3046
[instance] 0x0 #3046
[end-of-instance]
[mk-app] #3048 = #2416 #419
[mk-proof] #3049 trans #3045 #3047 #3048
[mk-app] #3050 = #2419 #424
[mk-proof] #3051 monotonicity #3049 #3050
[mk-app] #3052 = #2422 #443
[mk-proof] #3053 monotonicity #3051 #3052
[mk-app] #3054 = #2425 #451
[mk-proof] #3055 monotonicity #3053 #3054
[mk-app] #3056 + #249 #405
[inst-discovered] theory-solving 0x0 arith# ; #2428
[mk-app] #3057 = #2428 #3056
[mk-proof] #3058 rewrite #3057
[instance] 0x0 #3057
[end-of-instance]
[mk-app] #3059 = #3056 #36
[mk-app] #3060 = #2429 #3059
[mk-proof] #3061 monotonicity #3058 #3060
[attach-meaning] #176 arith (- 1)
[mk-app] #3062 * #176 #405
[mk-app] #3063 + #33 #3062
[mk-app] #3064 = #3063 #36
[inst-discovered] theory-solving 0x0 arith# ; #3059
[mk-app] #3065 = #3059 #3064
[mk-proof] #3066 rewrite #3065
[instance] 0x0 #3065
[end-of-instance]
[mk-app] #3067 = #2429 #3064
[mk-proof] #3068 trans #3061 #3066 #3067
[mk-app] #3069 and #3064 #2434
[mk-app] #3070 = #2437 #3069
[mk-proof] #3071 monotonicity #3068 #3070
[mk-app] #3072 or #451 #3069
[mk-app] #3073 = #2440 #3072
[mk-proof] #3074 monotonicity #3055 #3071 #3073
[mk-quant] #3075 k!207 3 #412 #3072
[attach-var-names] #3075 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #3076 null 3 #3074
[mk-proof] #3077 proof-bind #3076
[mk-app] #3078 = #2443 #3075
[mk-proof] #3079 quant-intro #3077 #3078
[mk-proof] #3080 mp #2448 #3079 #3075
[inst-discovered] theory-solving 0x0 arith# ; #796
[instance] 0x0 #800
[end-of-instance]
[mk-app] #3081 <= #799 #36
[mk-app] #3082 = #2449 #3081
[mk-proof] #3083 monotonicity #801 #3082
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3081
[mk-app] #3084 = #3081 #481
[mk-proof] #3085 rewrite #3084
[instance] 0x0 #3084
[end-of-instance]
[mk-app] #3086 = #2449 #481
[mk-proof] #3087 trans #3083 #3085 #3086
[mk-app] #3088 = #2452 #485
[mk-proof] #3089 monotonicity #3087 #3088
[mk-app] #3090 = #2455 #490
[mk-proof] #3091 monotonicity #3089 #3090
[mk-app] #3092 = #2458 #496
[mk-proof] #3093 monotonicity #3091 #3092
[mk-app] #3094 + #295 #467
[inst-discovered] theory-solving 0x0 arith# ; #2461
[mk-app] #3095 = #2461 #3094
[mk-proof] #3096 rewrite #3095
[instance] 0x0 #3095
[end-of-instance]
[mk-app] #3097 = #3094 #36
[mk-app] #3098 = #2462 #3097
[mk-proof] #3099 monotonicity #3096 #3098
[attach-meaning] #176 arith (- 1)
[mk-app] #3100 * #176 #467
[mk-app] #3101 + #273 #3100
[mk-app] #3102 = #3101 #36
[inst-discovered] theory-solving 0x0 arith# ; #3097
[mk-app] #3103 = #3097 #3102
[mk-proof] #3104 rewrite #3103
[instance] 0x0 #3103
[end-of-instance]
[mk-app] #3105 = #2462 #3102
[mk-proof] #3106 trans #3099 #3104 #3105
[mk-app] #3107 or #496 #3102
[mk-app] #3108 = #2465 #3107
[mk-proof] #3109 monotonicity #3093 #3106 #3108
[mk-quant] #3110 k!214 3 #470 #471 #3107
[attach-var-names] #3110 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3111 null 3 #3109
[mk-proof] #3112 proof-bind #3111
[mk-app] #3113 = #2468 #3110
[mk-proof] #3114 quant-intro #3112 #3113
[mk-proof] #3115 mp #2473 #3114 #3110
[mk-app] #3116 + #249 #510
[inst-discovered] theory-solving 0x0 arith# ; #2474
[mk-app] #3117 = #2474 #3116
[mk-proof] #3118 rewrite #3117
[instance] 0x0 #3117
[end-of-instance]
[mk-app] #3119 <= #3116 #36
[mk-app] #3120 = #2475 #3119
[mk-proof] #3121 monotonicity #3118 #3120
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3119
[mk-app] #3122 = #3119 #532
[mk-proof] #3123 rewrite #3122
[instance] 0x0 #3122
[end-of-instance]
[mk-app] #3124 = #2475 #532
[mk-proof] #3125 trans #3121 #3123 #3124
[mk-app] #3126 = #2478 #537
[mk-proof] #3127 monotonicity #3125 #3126
[mk-app] #3128 = #2481 #542
[mk-proof] #3129 monotonicity #3127 #3128
[mk-app] #3130 = #2484 #557
[mk-proof] #3131 monotonicity #3129 #3130
[mk-app] #3132 + #249 #509
[inst-discovered] theory-solving 0x0 arith# ; #2487
[mk-app] #3133 = #2487 #3132
[mk-proof] #3134 rewrite #3133
[instance] 0x0 #3133
[end-of-instance]
[mk-app] #3135 = #3132 #36
[mk-app] #3136 = #2488 #3135
[mk-proof] #3137 monotonicity #3134 #3136
[attach-meaning] #176 arith (- 1)
[mk-app] #3138 = #1457 #36
[inst-discovered] theory-solving 0x0 arith# ; #3135
[mk-app] #3139 = #3135 #3138
[mk-proof] #3140 rewrite #3139
[instance] 0x0 #3139
[end-of-instance]
[mk-app] #3141 = #2488 #3138
[mk-proof] #3142 trans #3137 #3140 #3141
[mk-app] #3143 not #3138
[mk-app] #3144 = #2491 #3143
[mk-proof] #3145 monotonicity #3142 #3144
[mk-app] #3146 + #795 #515
[inst-discovered] theory-solving 0x0 arith# ; #2494
[mk-app] #3147 = #2494 #3146
[mk-proof] #3148 rewrite #3147
[instance] 0x0 #3147
[end-of-instance]
[mk-app] #3149 = #3146 #36
[mk-app] #3150 = #2495 #3149
[mk-proof] #3151 monotonicity #3148 #3150
[attach-meaning] #176 arith (- 1)
[mk-app] #3152 * #176 #515
[mk-app] #3153 + #32 #3152
[mk-app] #3154 = #3153 #36
[inst-discovered] theory-solving 0x0 arith# ; #3149
[mk-app] #3155 = #3149 #3154
[mk-proof] #3156 rewrite #3155
[instance] 0x0 #3155
[end-of-instance]
[mk-app] #3157 = #2495 #3154
[mk-proof] #3158 trans #3151 #3156 #3157
[mk-app] #3159 or #3143 #3154
[mk-app] #3160 = #2498 #3159
[mk-proof] #3161 monotonicity #3145 #3158 #3160
[mk-app] #3162 or #3138 #2503
[mk-app] #3163 = #2506 #3162
[mk-proof] #3164 monotonicity #3142 #3163
[mk-app] #3165 and #3159 #3162
[mk-app] #3166 = #2509 #3165
[mk-proof] #3167 monotonicity #3161 #3164 #3166
[mk-app] #3168 or #557 #3165
[mk-app] #3169 = #2512 #3168
[mk-proof] #3170 monotonicity #3131 #3167 #3169
[mk-quant] #3171 k!223 4 #524 #525 #3168
[attach-var-names] #3171 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3172 null 4 #3170
[mk-proof] #3173 proof-bind #3172
[mk-app] #3174 = #2515 #3171
[mk-proof] #3175 quant-intro #3173 #3174
[mk-proof] #3176 mp #2520 #3175 #3171
[mk-app] #3177 + #249 #571
[inst-discovered] theory-solving 0x0 arith# ; #2521
[mk-app] #3178 = #2521 #3177
[mk-proof] #3179 rewrite #3178
[instance] 0x0 #3178
[end-of-instance]
[mk-app] #3180 = #3177 #36
[mk-app] #3181 = #2522 #3180
[mk-proof] #3182 monotonicity #3179 #3181
[attach-meaning] #176 arith (- 1)
[mk-app] #3183 * #176 #571
[mk-app] #3184 + #33 #3183
[mk-app] #3185 = #3184 #36
[inst-discovered] theory-solving 0x0 arith# ; #3180
[mk-app] #3186 = #3180 #3185
[mk-proof] #3187 rewrite #3186
[instance] 0x0 #3186
[end-of-instance]
[mk-app] #3188 = #2522 #3185
[mk-proof] #3189 trans #3182 #3187 #3188
[mk-app] #3190 or #592 #3185
[mk-app] #3191 = #2525 #3190
[mk-proof] #3192 monotonicity #3189 #3191
[mk-app] #3193 + #420 #571
[inst-discovered] theory-solving 0x0 arith# ; #2528
[mk-app] #3194 = #2528 #3193
[mk-proof] #3195 rewrite #3194
[instance] 0x0 #3194
[end-of-instance]
[mk-app] #3196 = #3193 #36
[mk-app] #3197 = #2529 #3196
[mk-proof] #3198 monotonicity #3195 #3197
[attach-meaning] #176 arith (- 1)
[mk-app] #3199 + #163 #3183
[mk-app] #3200 = #3199 #36
[inst-discovered] theory-solving 0x0 arith# ; #3196
[mk-app] #3201 = #3196 #3200
[mk-proof] #3202 rewrite #3201
[instance] 0x0 #3201
[end-of-instance]
[mk-app] #3203 = #2529 #3200
[mk-proof] #3204 trans #3198 #3202 #3203
[mk-app] #3205 or #586 #3200
[mk-app] #3206 = #2532 #3205
[mk-proof] #3207 monotonicity #3204 #3206
[mk-app] #3208 and #3190 #3205
[mk-app] #3209 = #2535 #3208
[mk-proof] #3210 monotonicity #3192 #3207 #3209
[mk-app] #3211 or #619 #3208
[mk-app] #3212 = #2538 #3211
[mk-proof] #3213 monotonicity #3210 #3212
[mk-app] #3214 and #3211 #635
[mk-app] #3215 = #2543 #3214
[mk-proof] #3216 monotonicity #3213 #3215
[mk-quant] #3217 k!234 2 #582 #583 #3214
[attach-var-names] #3217 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3218 null 2 #3216
[mk-proof] #3219 proof-bind #3218
[mk-app] #3220 = #2546 #3217
[mk-proof] #3221 quant-intro #3219 #3220
[mk-proof] #3222 mp #2551 #3221 #3217
[mk-app] #3223 = #2552 #677
[mk-proof] #3224 monotonicity #2988 #3223
[mk-app] #3225 = #2555 #685
[mk-proof] #3226 monotonicity #3224 #3225
[mk-app] #3227 + #2368 #653
[inst-discovered] theory-solving 0x0 arith# ; #2558
[mk-app] #3228 = #2558 #3227
[mk-proof] #3229 rewrite #3228
[instance] 0x0 #3228
[end-of-instance]
[mk-app] #3230 = #3227 #36
[mk-app] #3231 = #2559 #3230
[mk-proof] #3232 monotonicity #3229 #3231
[attach-meaning] #176 arith (- 1)
[mk-app] #3233 * #176 #653
[mk-app] #3234 + #280 #3233
[mk-app] #3235 = #3234 #36
[inst-discovered] theory-solving 0x0 arith# ; #3230
[mk-app] #3236 = #3230 #3235
[mk-proof] #3237 rewrite #3236
[instance] 0x0 #3236
[end-of-instance]
[mk-app] #3238 = #2559 #3235
[mk-proof] #3239 trans #3232 #3237 #3238
[mk-app] #3240 or #685 #3235
[mk-app] #3241 = #2562 #3240
[mk-proof] #3242 monotonicity #3226 #3239 #3241
[mk-quant] #3243 k!241 3 #656 #657 #3240
[attach-var-names] #3243 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3244 null 3 #3242
[mk-proof] #3245 proof-bind #3244
[mk-app] #3246 = #2565 #3243
[mk-proof] #3247 quant-intro #3245 #3246
[mk-proof] #3248 mp #2570 #3247 #3243
[inst-discovered] theory-solving 0x0 arith# ; #2571
[mk-app] #3249 = #2571 #724
[mk-proof] #3250 rewrite #3249
[instance] 0x0 #3249
[end-of-instance]
[mk-app] #3251 = #2572 #725
[mk-proof] #3252 monotonicity #3250 #3251
[mk-app] #3253 = #2575 #733
[mk-proof] #3254 monotonicity #3252 #3253
[inst-discovered] theory-solving 0x0 basic# ; #741
[instance] 0x0 #2580
[end-of-instance]
[mk-app] #3255 = #2583 #746
[mk-proof] #3256 monotonicity #3254 #2581 #3255
[mk-app] #3257 = #2586 #752
[mk-proof] #3258 monotonicity #3256 #3257
[mk-app] #3259 + #420 #698
[inst-discovered] theory-solving 0x0 arith# ; #2589
[mk-app] #3260 = #2589 #3259
[mk-proof] #3261 rewrite #3260
[instance] 0x0 #3260
[end-of-instance]
[mk-app] #3262 = #3259 #36
[mk-app] #3263 = #2590 #3262
[mk-proof] #3264 monotonicity #3261 #3263
[attach-meaning] #176 arith (- 1)
[mk-app] #3265 * #176 #698
[mk-app] #3266 + #163 #3265
[mk-app] #3267 = #3266 #36
[inst-discovered] theory-solving 0x0 arith# ; #3262
[mk-app] #3268 = #3262 #3267
[mk-proof] #3269 rewrite #3268
[instance] 0x0 #3268
[end-of-instance]
[mk-app] #3270 = #2590 #3267
[mk-proof] #3271 trans #3264 #3269 #3270
[mk-app] #3272 or #287 #3267
[mk-app] #3273 = #2593 #3272
[mk-proof] #3274 monotonicity #3271 #3273
[mk-app] #3275 and #752 #3272
[mk-app] #3276 = #2596 #3275
[mk-proof] #3277 monotonicity #3258 #3274 #3276
[mk-quant] #3278 k!254 2 #709 #710 #3275
[attach-var-names] #3278 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3279 null 2 #3277
[mk-proof] #3280 proof-bind #3279
[mk-app] #3281 = #2599 #3278
[mk-proof] #3282 quant-intro #3280 #3281
[mk-proof] #3283 mp #2604 #3282 #3278
[mk-app] #3284 + #795 #249 #273
[inst-discovered] theory-solving 0x0 arith# ; #2605
[mk-app] #3285 = #2605 #3284
[mk-proof] #3286 rewrite #3285
[instance] 0x0 #3285
[end-of-instance]
[mk-app] #3287 <= #3284 #36
[mk-app] #3288 = #2606 #3287
[mk-proof] #3289 monotonicity #3286 #3288
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3287
[mk-app] #3290 = #3287 #813
[mk-proof] #3291 rewrite #3290
[instance] 0x0 #3290
[end-of-instance]
[mk-app] #3292 = #2606 #813
[mk-proof] #3293 trans #3289 #3291 #3292
[mk-app] #3294 = #2609 #817
[mk-proof] #3295 monotonicity #3293 #3294
[mk-app] #3296 = #2612 #828
[mk-proof] #3297 monotonicity #3295 #3296
[mk-app] #3298 = #2615 #836
[mk-proof] #3299 monotonicity #3297 #3298
[mk-app] #3300 + #249 #780
[inst-discovered] theory-solving 0x0 arith# ; #2618
[mk-app] #3301 = #2618 #3300
[mk-proof] #3302 rewrite #3301
[instance] 0x0 #3301
[end-of-instance]
[mk-app] #3303 = #3300 #36
[mk-app] #3304 = #2619 #3303
[mk-proof] #3305 monotonicity #3302 #3304
[attach-meaning] #176 arith (- 1)
[mk-app] #3306 * #176 #780
[mk-app] #3307 + #33 #3306
[mk-app] #3308 = #3307 #36
[inst-discovered] theory-solving 0x0 arith# ; #3303
[mk-app] #3309 = #3303 #3308
[mk-proof] #3310 rewrite #3309
[instance] 0x0 #3309
[end-of-instance]
[mk-app] #3311 = #2619 #3308
[mk-proof] #3312 trans #3305 #3310 #3311
[mk-app] #3313 and #3308 #2624
[mk-app] #3314 = #2627 #3313
[mk-proof] #3315 monotonicity #3312 #3314
[mk-app] #3316 or #836 #3313
[mk-app] #3317 = #2630 #3316
[mk-proof] #3318 monotonicity #3299 #3315 #3317
[mk-quant] #3319 k!262 3 #788 #3316
[attach-var-names] #3319 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3320 null 3 #3318
[mk-proof] #3321 proof-bind #3320
[mk-app] #3322 = #2633 #3319
[mk-proof] #3323 quant-intro #3321 #3322
[mk-proof] #3324 mp #2638 #3323 #3319
[mk-app] #3325 = #2639 #866
[mk-proof] #3326 monotonicity #2988 #3325
[mk-app] #3327 = #2642 #874
[mk-proof] #3328 monotonicity #3326 #3327
[mk-app] #3329 + #249 #851
[inst-discovered] theory-solving 0x0 arith# ; #2645
[mk-app] #3330 = #2645 #3329
[mk-proof] #3331 rewrite #3330
[instance] 0x0 #3330
[end-of-instance]
[mk-app] #3332 = #3329 #36
[mk-app] #3333 = #2646 #3332
[mk-proof] #3334 monotonicity #3331 #3333
[attach-meaning] #176 arith (- 1)
[mk-app] #3335 * #176 #851
[mk-app] #3336 + #33 #3335
[mk-app] #3337 = #3336 #36
[inst-discovered] theory-solving 0x0 arith# ; #3332
[mk-app] #3338 = #3332 #3337
[mk-proof] #3339 rewrite #3338
[instance] 0x0 #3338
[end-of-instance]
[mk-app] #3340 = #2646 #3337
[mk-proof] #3341 trans #3334 #3339 #3340
[mk-app] #3342 + #2368 #853
[inst-discovered] theory-solving 0x0 arith# ; #2649
[mk-app] #3343 = #2649 #3342
[mk-proof] #3344 rewrite #3343
[instance] 0x0 #3343
[end-of-instance]
[mk-app] #3345 = #3342 #36
[mk-app] #3346 = #2650 #3345
[mk-proof] #3347 monotonicity #3344 #3346
[attach-meaning] #176 arith (- 1)
[mk-app] #3348 * #176 #853
[mk-app] #3349 + #280 #3348
[mk-app] #3350 = #3349 #36
[inst-discovered] theory-solving 0x0 arith# ; #3345
[mk-app] #3351 = #3345 #3350
[mk-proof] #3352 rewrite #3351
[instance] 0x0 #3351
[end-of-instance]
[mk-app] #3353 = #2650 #3350
[mk-proof] #3354 trans #3347 #3352 #3353
[mk-app] #3355 and #3337 #3350
[mk-app] #3356 = #2653 #3355
[mk-proof] #3357 monotonicity #3341 #3354 #3356
[mk-app] #3358 or #874 #3355
[mk-app] #3359 = #2656 #3358
[mk-proof] #3360 monotonicity #3328 #3357 #3359
[mk-quant] #3361 k!270 3 #857 #3358
[attach-var-names] #3361 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3362 null 3 #3360
[mk-proof] #3363 proof-bind #3362
[mk-app] #3364 = #2659 #3361
[mk-proof] #3365 quant-intro #3363 #3364
[mk-proof] #3366 mp #2664 #3365 #3361
[mk-app] #3367 = #915 #915
[mk-proof] #3368 refl #3367
[mk-app] #3367 = #2676 #948
[mk-proof] #3368 monotonicity #3013 #3367
[mk-app] #3369 = #2679 #956
[mk-proof] #3370 monotonicity #3368 #3369
[mk-app] #3371 and #3026 #927
[mk-app] #3372 = #2682 #3371
[mk-proof] #3373 monotonicity #3030 #3372
[mk-app] #3374 or #956 #3371
[mk-app] #3375 = #2685 #3374
[mk-proof] #3376 monotonicity #3370 #3373 #3375
[mk-quant] #3377 k!286 3 #893 #3374
[attach-var-names] #3377 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #3378 null 3 #3376
[mk-proof] #3379 proof-bind #3378
[mk-app] #3380 = #2688 #3377
[mk-proof] #3381 quant-intro #3379 #3380
[mk-proof] #3382 mp #2693 #3381 #3377
[mk-app] #3383 = #984 #984
[mk-proof] #3384 refl #3383
[mk-app] #3383 and #3026 #992
[mk-app] #3384 = #2705 #3383
[mk-proof] #3385 monotonicity #3030 #3384
[mk-app] #3386 or #1003 #3383
[mk-app] #3387 = #2708 #3386
[mk-proof] #3388 monotonicity #3385 #3387
[mk-quant] #3389 k!300 3 #973 #3386
[attach-var-names] #3389 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #3390 null 3 #3388
[mk-proof] #3391 proof-bind #3390
[mk-app] #3392 = #2711 #3389
[mk-proof] #3393 quant-intro #3391 #3392
[mk-proof] #3394 mp #2716 #3393 #3389
[mk-proof] #3395 refl #2239
[mk-proof] #3395 refl #2242
[mk-app] #3395 = #1058 #1058
[mk-proof] #3396 refl #3395
[mk-app] #3395 = #1076 #1076
[mk-proof] #3396 refl #3395
[mk-app] #3395 + #249 #1086
[inst-discovered] theory-solving 0x0 arith# ; #2733
[mk-app] #3396 = #2733 #3395
[mk-proof] #3397 rewrite #3396
[instance] 0x0 #3396
[end-of-instance]
[mk-app] #3398 = #3395 #36
[mk-app] #3399 = #2734 #3398
[mk-proof] #3400 monotonicity #3397 #3399
[attach-meaning] #176 arith (- 1)
[mk-app] #3401 * #176 #1086
[mk-app] #3402 + #33 #3401
[mk-app] #3403 = #3402 #36
[inst-discovered] theory-solving 0x0 arith# ; #3398
[mk-app] #3404 = #3398 #3403
[mk-proof] #3405 rewrite #3404
[instance] 0x0 #3404
[end-of-instance]
[mk-app] #3406 = #2734 #3403
[mk-proof] #3407 trans #3400 #3405 #3406
[mk-app] #3408 and #1095 #1106 #3403
[mk-app] #3409 = #2737 #3408
[mk-proof] #3410 monotonicity #3407 #3409
[mk-app] #3411 or #1125 #3408
[mk-app] #3412 = #2740 #3411
[mk-proof] #3413 monotonicity #3410 #3412
[mk-quant] #3414 k!326 2 #1091 #3411
[attach-var-names] #3414 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3415 null 2 #3413
[mk-proof] #3416 proof-bind #3415
[mk-app] #3417 = #2743 #3414
[mk-proof] #3418 quant-intro #3416 #3417
[mk-proof] #3419 mp #2748 #3418 #3414
[mk-app] #3420 + #795 #280
[inst-discovered] theory-solving 0x0 arith# ; #2749
[mk-app] #3421 = #2749 #3420
[mk-proof] #3422 rewrite #3421
[instance] 0x0 #3421
[end-of-instance]
[mk-app] #3423 = #3420 #36
[mk-app] #3424 = #2750 #3423
[mk-proof] #3425 monotonicity #3422 #3424
[attach-meaning] #176 arith (- 1)
[mk-app] #3426 + #32 #2368
[mk-app] #3427 = #3426 #36
[inst-discovered] theory-solving 0x0 arith# ; #3423
[mk-app] #3428 = #3423 #3427
[mk-proof] #3429 rewrite #3428
[instance] 0x0 #3428
[end-of-instance]
[mk-app] #3430 = #2750 #3427
[mk-proof] #3431 trans #3425 #3429 #3430
[mk-app] #3432 and #287 #299 #3427
[mk-app] #3433 = #2753 #3432
[mk-proof] #3434 monotonicity #2988 #3431 #3433
[mk-app] #3435 not #3432
[mk-app] #3436 = #2756 #3435
[mk-proof] #3437 monotonicity #3434 #3436
[mk-app] #3438 or #3435 #1140
[mk-app] #3439 = #2759 #3438
[mk-proof] #3440 monotonicity #3437 #3439
[mk-quant] #3441 k!332 3 #1142 #3438
[attach-var-names] #3441 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #3442 null 3 #3440
[mk-proof] #3443 proof-bind #3442
[mk-app] #3444 = #2762 #3441
[mk-proof] #3445 quant-intro #3443 #3444
[mk-proof] #3446 mp #2767 #3445 #3441
[mk-app] #3447 = #2768 #429
[mk-proof] #3448 monotonicity #3051 #3447
[mk-app] #3449 = #2771 #1179
[mk-proof] #3450 monotonicity #3448 #3449
[mk-app] #3451 = #2774 #1180
[mk-proof] #3452 monotonicity #3450 #3451
[mk-lambda] #3453 null 2 #3452
[mk-proof] #3454 proof-bind #3453
[mk-app] #3455 = #2777 #1185
[mk-proof] #3456 quant-intro #3454 #3455
[mk-proof] #3457 mp #2782 #3456 #1185
[mk-app] #3458 + #2295 #163
[inst-discovered] theory-solving 0x0 arith# ; #2783
[mk-app] #3459 = #2783 #3458
[mk-proof] #3460 rewrite #3459
[instance] 0x0 #3459
[end-of-instance]
[mk-app] #3461 = #3458 #36
[mk-app] #3462 = #2784 #3461
[mk-proof] #3463 monotonicity #3460 #3462
[attach-meaning] #176 arith (- 1)
[mk-app] #3464 + #116 #420
[mk-app] #3465 = #3464 #36
[inst-discovered] theory-solving 0x0 arith# ; #3461
[mk-app] #3466 = #3461 #3465
[mk-proof] #3467 rewrite #3466
[instance] 0x0 #3466
[end-of-instance]
[mk-app] #3468 = #2784 #3465
[mk-proof] #3469 trans #3463 #3467 #3468
[mk-app] #3470 not #3465
[mk-app] #3471 = #2787 #3470
[mk-proof] #3472 monotonicity #3469 #3471
[mk-app] #3473 and #1194 #1195 #3470
[mk-app] #3474 = #2790 #3473
[mk-proof] #3475 monotonicity #3472 #3474
[mk-app] #3476 and #1194 #1195 #3465 #2795 #1224 #1235 #2803
[mk-app] #3477 = #2806 #3476
[mk-proof] #3478 monotonicity #3469 #3477
[mk-app] #3479 or #1193 #3473 #3476
[mk-app] #3480 = #2809 #3479
[mk-proof] #3481 monotonicity #3475 #3478 #3480
[mk-quant] #3482 k!363 2 #1217 #3479
[attach-var-names] #3482 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #3483 null 2 #3481
[mk-proof] #3484 proof-bind #3483
[mk-app] #3485 = #2812 #3482
[mk-proof] #3486 quant-intro #3484 #3485
[mk-proof] #3487 mp #2817 #3486 #3482
[mk-proof] #3488 refl #2263
[mk-app] #3488 = #2824 #2824
[mk-proof] #3489 refl #3488
[inst-discovered] theory-solving 0x0 arith# ; #1343
[instance] 0x0 #1347
[end-of-instance]
[mk-app] #3488 <= #1346 #36
[mk-app] #3489 = #2830 #3488
[mk-proof] #3490 monotonicity #1348 #3489
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3488
[mk-app] #3491 = #3488 #1335
[mk-proof] #3492 rewrite #3491
[instance] 0x0 #3491
[end-of-instance]
[mk-app] #3493 = #2830 #1335
[mk-proof] #3494 trans #3490 #3492 #3493
[inst-discovered] theory-solving 0x0 arith# ; #2833
[mk-app] #3495 = #2833 #1354
[mk-proof] #3496 rewrite #3495
[instance] 0x0 #3495
[end-of-instance]
[mk-app] #3497 = #2834 #1355
[mk-proof] #3498 monotonicity #3496 #3497
[mk-app] #3499 = #2837 #1363
[mk-proof] #3500 monotonicity #3494 #3498 #3499
[mk-app] #3501 = #2840 #1338
[mk-proof] #3502 monotonicity #3494 #3501
[mk-app] #3503 = #2843 #1371
[mk-proof] #3504 monotonicity #3502 #3503
[mk-app] #3505 = #2846 #1376
[mk-proof] #3506 monotonicity #3500 #3504 #3505
[mk-lambda] #3507 null 2 #3506
[mk-proof] #3508 proof-bind #3507
[mk-app] #3509 = #2849 #1379
[mk-proof] #3510 quant-intro #3508 #3509
[mk-proof] #3511 mp #2854 #3510 #1379
[inst-discovered] theory-solving 0x0 arith# ; #2855
[mk-app] #3512 = #2855 #1409
[mk-proof] #3513 rewrite #3512
[instance] 0x0 #3512
[end-of-instance]
[mk-app] #3514 = #2856 #1410
[mk-proof] #3515 monotonicity #3513 #3514
[mk-app] #3516 = #2859 #1413
[mk-proof] #3517 monotonicity #3515 #3516
[mk-app] #3518 = #2862 #1418
[mk-proof] #3519 monotonicity #3517 #3518
[mk-app] #3520 = #2865 #1437
[mk-proof] #3521 monotonicity #3519 #3520
[mk-app] #3522 + #249 #1396 #1389
[inst-discovered] theory-solving 0x0 arith# ; #2868
[mk-app] #3523 = #2868 #3522
[mk-proof] #3524 rewrite #3523
[instance] 0x0 #3523
[end-of-instance]
[mk-app] #3525 = #3522 #36
[mk-app] #3526 = #2869 #3525
[mk-proof] #3527 monotonicity #3524 #3526
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3525
[mk-app] #3528 = #3525 #1427
[mk-proof] #3529 rewrite #3528
[instance] 0x0 #3528
[end-of-instance]
[mk-app] #3530 = #2869 #1427
[mk-proof] #3531 trans #3527 #3529 #3530
[mk-app] #3532 = #2872 #1438
[mk-proof] #3533 monotonicity #3521 #3531 #3532
[mk-lambda] #3534 null 3 #3533
[mk-proof] #3535 proof-bind #3534
[mk-app] #3536 = #2875 #1443
[mk-proof] #3537 quant-intro #3535 #3536
[mk-proof] #3538 mp #2880 #3537 #1443
[mk-app] #3539 <= #3132 #36
[mk-app] #3540 = #2881 #3539
[mk-proof] #3541 monotonicity #3134 #3540
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3539
[mk-app] #3542 = #3539 #1456
[mk-proof] #3543 rewrite #3542
[instance] 0x0 #3542
[end-of-instance]
[mk-app] #3544 = #2881 #1456
[mk-proof] #3545 trans #3541 #3543 #3544
[mk-app] #3546 = #2884 #1460
[mk-proof] #3547 monotonicity #3545 #3546
[mk-app] #3548 = #2887 #1463
[mk-proof] #3549 monotonicity #3547 #3548
[mk-lambda] #3550 null 3 #3549
[mk-proof] #3551 proof-bind #3550
[mk-app] #3552 = #2890 #1466
[mk-proof] #3553 quant-intro #3551 #3552
[mk-proof] #3554 mp #2895 #3553 #1466
[mk-app] #3555 + #249 #1474
[inst-discovered] theory-solving 0x0 arith# ; #2896
[mk-app] #3556 = #2896 #3555
[mk-proof] #3557 rewrite #3556
[instance] 0x0 #3556
[end-of-instance]
[mk-app] #3558 = #3555 #36
[mk-app] #3559 = #2897 #3558
[mk-proof] #3560 monotonicity #3557 #3559
[attach-meaning] #176 arith (- 1)
[mk-app] #3561 * #176 #1474
[mk-app] #3562 + #33 #3561
[mk-app] #3563 = #3562 #36
[inst-discovered] theory-solving 0x0 arith# ; #3558
[mk-app] #3564 = #3558 #3563
[mk-proof] #3565 rewrite #3564
[instance] 0x0 #3564
[end-of-instance]
[mk-app] #3566 = #2897 #3563
[mk-proof] #3567 trans #3560 #3565 #3566
[mk-quant] #3568 prog.inj 2 #1476 #3563
[attach-var-names] #3568 (|i| ; |Int|) (|a| ; |$Ref|)
[mk-lambda] #3569 null 2 #3567
[mk-proof] #3570 proof-bind #3569
[mk-app] #3571 = #2900 #3568
[mk-proof] #3572 quant-intro #3570 #3571
[mk-proof] #3573 mp #2905 #3572 #3568
[mk-proof] #3574 refl #2281
[mk-app] #3574 = #1522 #1522
[mk-proof] #3575 refl #3574
[begin-check] 0
[mk-app] #3574 = #2326 #2326
[mk-proof] #3575 refl #3574
[mk-app] #3574 = #2326 #1
[mk-proof] #3575 iff-true #2331 #3574
[mk-proof] #3576 refl #2137
[mk-app] #3576 = #50 #1
[mk-proof] #3577 iff-true #2139 #3576
[mk-proof] #3578 refl #2140
[mk-app] #3578 = #57 #1
[mk-proof] #3579 iff-true #2142 #3578
[mk-proof] #3580 refl #2143
[mk-app] #3580 = #63 #1
[mk-proof] #3581 iff-true #2145 #3580
[mk-proof] #3582 refl #2146
[mk-app] #3582 = #70 #1
[mk-proof] #3583 iff-true #2148 #3582
[mk-proof] #3584 refl #2149
[mk-app] #3584 = #76 #1
[mk-proof] #3585 iff-true #2151 #3584
[mk-app] #3586 = #2334 #2334
[mk-proof] #3587 refl #3586
[mk-app] #3586 = #2334 #1
[mk-proof] #3587 iff-true #2293 #3586
[mk-proof] #3588 refl #2155
[mk-app] #3588 = #88 #1
[mk-proof] #3589 iff-true #2157 #3588
[mk-proof] #3590 refl #2158
[mk-app] #3590 = #95 #1
[mk-proof] #3591 iff-true #2160 #3590
[mk-proof] #3592 refl #2161
[mk-app] #3592 = #101 #1
[mk-proof] #3593 iff-true #2163 #3592
[mk-proof] #3594 refl #2164
[mk-app] #3594 = #108 #1
[mk-proof] #3595 iff-true #2166 #3594
[mk-proof] #3596 refl #2167
[mk-app] #3596 = #114 #1
[mk-proof] #3597 iff-true #2169 #3596
[mk-app] #3598 = #124 #124
[mk-proof] #3599 refl #3598
[mk-app] #3598 = #124 #1
[mk-proof] #3599 iff-true #2294 #3598
[mk-proof] #3600 refl #2173
[mk-proof] #3600 refl #2176
[mk-app] #3600 = #143 #1
[mk-proof] #3601 iff-true #2178 #3600
[mk-proof] #3602 refl #2179
[mk-app] #3602 = #154 #1
[mk-proof] #3603 iff-true #2181 #3602
[mk-app] #3604 = #193 #193
[mk-proof] #3605 refl #3604
[mk-app] #3604 = #193 #1
[mk-proof] #3605 iff-true #2927 #3604
[mk-proof] #3606 refl #2185
[mk-app] #3606 = #216 #1
[mk-proof] #3607 iff-true #2187 #3606
[mk-app] #3608 = #2941 #2941
[mk-proof] #3609 refl #3608
[mk-app] #3608 = #2941 #1
[mk-proof] #3609 iff-true #2946 #3608
[mk-app] #3610 = #237 #237
[mk-proof] #3611 refl #3610
[mk-app] #3610 = #237 #1
[mk-proof] #3611 iff-true #2961 #3610
[mk-app] #3612 = #263 #263
[mk-proof] #3613 refl #3612
[mk-app] #3612 = #263 #1
[mk-proof] #3613 iff-true #2976 #3612
[mk-app] #3614 = #2996 #2996
[mk-proof] #3615 refl #3614
[mk-app] #3614 = #2996 #1
[mk-proof] #3615 iff-true #3001 #3614
[mk-app] #3616 = #3037 #3037
[mk-proof] #3617 refl #3616
[mk-app] #3616 = #3037 #1
[mk-proof] #3617 iff-true #3042 #3616
[mk-app] #3618 = #3075 #3075
[mk-proof] #3619 refl #3618
[mk-app] #3618 = #3075 #1
[mk-proof] #3619 iff-true #3080 #3618
[mk-app] #3620 = #3110 #3110
[mk-proof] #3621 refl #3620
[mk-app] #3620 = #3110 #1
[mk-proof] #3621 iff-true #3115 #3620
[mk-app] #3622 = #3171 #3171
[mk-proof] #3623 refl #3622
[mk-app] #3622 = #3171 #1
[mk-proof] #3623 iff-true #3176 #3622
[mk-app] #3624 = #3217 #3217
[mk-proof] #3625 refl #3624
[mk-app] #3624 = #3217 #1
[mk-proof] #3625 iff-true #3222 #3624
[mk-app] #3626 = #3243 #3243
[mk-proof] #3627 refl #3626
[mk-app] #3626 = #3243 #1
[mk-proof] #3627 iff-true #3248 #3626
[inst-discovered] theory-solving 0x0 basic# ; #741
[instance] 0x0 #2580
[end-of-instance]
[mk-app] #3628 = #746 #746
[mk-proof] #3629 monotonicity #2581 #3628
[mk-app] #3630 = #752 #752
[mk-proof] #3631 monotonicity #3629 #3630
[mk-app] #3632 = #3275 #3275
[mk-proof] #3633 monotonicity #3631 #3632
[mk-app] #3634 = #3278 #3278
[mk-proof] #3635 refl #3634
[mk-app] #3634 = #3278 #1
[mk-proof] #3635 iff-true #3283 #3634
[mk-app] #3636 = #3319 #3319
[mk-proof] #3637 refl #3636
[mk-app] #3636 = #3319 #1
[mk-proof] #3637 iff-true #3324 #3636
[mk-app] #3638 = #3361 #3361
[mk-proof] #3639 refl #3638
[mk-app] #3638 = #3361 #1
[mk-proof] #3639 iff-true #3366 #3638
[mk-app] #3640 = #915 #915
[mk-proof] #3641 refl #3640
[mk-app] #3640 = #915 #1
[mk-proof] #3641 iff-true #2675 #3640
[mk-app] #3642 = #3377 #3377
[mk-proof] #3643 refl #3642
[mk-app] #3642 = #3377 #1
[mk-proof] #3643 iff-true #3382 #3642
[mk-app] #3644 = #984 #984
[mk-proof] #3645 refl #3644
[mk-app] #3644 = #984 #1
[mk-proof] #3645 iff-true #2700 #3644
[mk-app] #3646 = #3389 #3389
[mk-proof] #3647 refl #3646
[mk-app] #3646 = #3389 #1
[mk-proof] #3647 iff-true #3394 #3646
[mk-proof] #3648 refl #2239
[mk-app] #3648 = #1023 #1
[mk-proof] #3649 iff-true #2241 #3648
[mk-proof] #3650 refl #2242
[mk-app] #3650 = #1037 #1
[mk-proof] #3651 iff-true #2244 #3650
[mk-app] #3652 = #1058 #1058
[mk-proof] #3653 refl #3652
[mk-app] #3652 = #1058 #1
[mk-proof] #3653 iff-true #2725 #3652
[mk-app] #3654 = #1076 #1076
[mk-proof] #3655 refl #3654
[mk-app] #3654 = #1076 #1
[mk-proof] #3655 iff-true #2732 #3654
[mk-app] #3656 = #3414 #3414
[mk-proof] #3657 refl #3656
[mk-app] #3656 = #3414 #1
[mk-proof] #3657 iff-true #3419 #3656
[mk-app] #3658 = #3441 #3441
[mk-proof] #3659 refl #3658
[mk-app] #3658 = #3441 #1
[mk-proof] #3659 iff-true #3446 #3658
[mk-app] #3660 = #1185 #1185
[mk-proof] #3661 refl #3660
[mk-app] #3660 = #1185 #1
[mk-proof] #3661 iff-true #3457 #3660
[mk-app] #3662 = #3482 #3482
[mk-proof] #3663 refl #3662
[mk-app] #3662 = #3482 #1
[mk-proof] #3663 iff-true #3487 #3662
[mk-proof] #3664 refl #2263
[mk-app] #3664 = #1306 #1
[mk-proof] #3665 iff-true #2265 #3664
[mk-app] #3666 = #2824 #2824
[mk-proof] #3667 refl #3666
[mk-app] #3666 = #2824 #1
[mk-proof] #3667 iff-true #2829 #3666
[mk-app] #3668 = #1379 #1379
[mk-proof] #3669 refl #3668
[mk-app] #3668 = #1379 #1
[mk-proof] #3669 iff-true #3511 #3668
[mk-app] #3670 = #1443 #1443
[mk-proof] #3671 refl #3670
[mk-app] #3670 = #1443 #1
[mk-proof] #3671 iff-true #3538 #3670
[mk-app] #3672 = #1466 #1466
[mk-proof] #3673 refl #3672
[mk-app] #3672 = #1466 #1
[mk-proof] #3673 iff-true #3554 #3672
[mk-app] #3674 = #3568 #3568
[mk-proof] #3675 refl #3674
[mk-app] #3674 = #3568 #1
[mk-proof] #3675 iff-true #3573 #3674
[mk-proof] #3676 refl #2281
[mk-app] #3676 = #1495 #1
[mk-proof] #3677 iff-true #2283 #3676
[mk-app] #3678 = #1522 #1522
[mk-proof] #3679 refl #3678
[mk-app] #3678 = #1522 #1
[mk-proof] #3679 iff-true #2910 #3678
[mk-app] #3678 = #1522 #1522
[mk-proof] #3679 refl #3678
[mk-app] #3678 = #1522 #1
[mk-proof] #3679 iff-true #2910 #3678
[mk-proof] #3676 refl #2281
[mk-app] #3676 = #1495 #1
[mk-proof] #3677 iff-true #2283 #3676
[mk-app] #3674 = #3568 #3568
[mk-proof] #3675 refl #3674
[mk-app] #3674 = #3568 #1
[mk-proof] #3675 iff-true #3573 #3674
[mk-app] #3672 = #1466 #1466
[mk-proof] #3673 refl #3672
[mk-app] #3672 = #1466 #1
[mk-proof] #3673 iff-true #3554 #3672
[mk-app] #3670 = #1443 #1443
[mk-proof] #3671 refl #3670
[mk-app] #3670 = #1443 #1
[mk-proof] #3671 iff-true #3538 #3670
[mk-app] #3668 = #1379 #1379
[mk-proof] #3669 refl #3668
[mk-app] #3668 = #1379 #1
[mk-proof] #3669 iff-true #3511 #3668
[mk-app] #3666 = #2824 #2824
[mk-proof] #3667 refl #3666
[mk-app] #3666 = #2824 #1
[mk-proof] #3667 iff-true #2829 #3666
[mk-proof] #3664 refl #2263
[mk-app] #3664 = #1306 #1
[mk-proof] #3665 iff-true #2265 #3664
[mk-app] #3662 = #3482 #3482
[mk-proof] #3663 refl #3662
[mk-app] #3662 = #3482 #1
[mk-proof] #3663 iff-true #3487 #3662
[mk-app] #3660 = #1185 #1185
[mk-proof] #3661 refl #3660
[mk-app] #3660 = #1185 #1
[mk-proof] #3661 iff-true #3457 #3660
[mk-app] #3658 = #3441 #3441
[mk-proof] #3659 refl #3658
[mk-app] #3658 = #3441 #1
[mk-proof] #3659 iff-true #3446 #3658
[mk-app] #3656 = #3414 #3414
[mk-proof] #3657 refl #3656
[mk-app] #3656 = #3414 #1
[mk-proof] #3657 iff-true #3419 #3656
[mk-app] #3654 = #1076 #1076
[mk-proof] #3655 refl #3654
[mk-app] #3654 = #1076 #1
[mk-proof] #3655 iff-true #2732 #3654
[mk-app] #3652 = #1058 #1058
[mk-proof] #3653 refl #3652
[mk-app] #3652 = #1058 #1
[mk-proof] #3653 iff-true #2725 #3652
[mk-proof] #3650 refl #2242
[mk-app] #3650 = #1037 #1
[mk-proof] #3651 iff-true #2244 #3650
[mk-proof] #3648 refl #2239
[mk-app] #3648 = #1023 #1
[mk-proof] #3649 iff-true #2241 #3648
[mk-app] #3646 = #3389 #3389
[mk-proof] #3647 refl #3646
[mk-app] #3646 = #3389 #1
[mk-proof] #3647 iff-true #3394 #3646
[mk-app] #3644 = #984 #984
[mk-proof] #3645 refl #3644
[mk-app] #3644 = #984 #1
[mk-proof] #3645 iff-true #2700 #3644
[mk-app] #3642 = #3377 #3377
[mk-proof] #3643 refl #3642
[mk-app] #3642 = #3377 #1
[mk-proof] #3643 iff-true #3382 #3642
[mk-app] #3640 = #915 #915
[mk-proof] #3641 refl #3640
[mk-app] #3640 = #915 #1
[mk-proof] #3641 iff-true #2675 #3640
[mk-app] #3638 = #3361 #3361
[mk-proof] #3639 refl #3638
[mk-app] #3638 = #3361 #1
[mk-proof] #3639 iff-true #3366 #3638
[mk-app] #3636 = #3319 #3319
[mk-proof] #3637 refl #3636
[mk-app] #3636 = #3319 #1
[mk-proof] #3637 iff-true #3324 #3636
[inst-discovered] theory-solving 0x0 basic# ; #741
[instance] 0x0 #2580
[end-of-instance]
[mk-app] #3634 = #746 #746
[mk-proof] #3635 monotonicity #2581 #3634
[mk-app] #3626 = #752 #752
[mk-proof] #3627 monotonicity #3635 #3626
[mk-app] #3624 = #3275 #3275
[mk-proof] #3625 monotonicity #3627 #3624
[mk-app] #3622 = #3278 #3278
[mk-proof] #3623 refl #3622
[mk-app] #3622 = #3278 #1
[mk-proof] #3623 iff-true #3283 #3622
[mk-app] #3620 = #3243 #3243
[mk-proof] #3621 refl #3620
[mk-app] #3620 = #3243 #1
[mk-proof] #3621 iff-true #3248 #3620
[mk-app] #3618 = #3217 #3217
[mk-proof] #3619 refl #3618
[mk-app] #3618 = #3217 #1
[mk-proof] #3619 iff-true #3222 #3618
[mk-app] #3616 = #3171 #3171
[mk-proof] #3617 refl #3616
[mk-app] #3616 = #3171 #1
[mk-proof] #3617 iff-true #3176 #3616
[mk-app] #3614 = #3110 #3110
[mk-proof] #3615 refl #3614
[mk-app] #3614 = #3110 #1
[mk-proof] #3615 iff-true #3115 #3614
[mk-app] #3612 = #3075 #3075
[mk-proof] #3613 refl #3612
[mk-app] #3612 = #3075 #1
[mk-proof] #3613 iff-true #3080 #3612
[mk-app] #3610 = #3037 #3037
[mk-proof] #3611 refl #3610
[mk-app] #3610 = #3037 #1
[mk-proof] #3611 iff-true #3042 #3610
[mk-app] #3608 = #2996 #2996
[mk-proof] #3609 refl #3608
[mk-app] #3608 = #2996 #1
[mk-proof] #3609 iff-true #3001 #3608
[mk-app] #3606 = #263 #263
[mk-proof] #3607 refl #3606
[mk-app] #3606 = #263 #1
[mk-proof] #3607 iff-true #2976 #3606
[mk-app] #3604 = #237 #237
[mk-proof] #3605 refl #3604
[mk-app] #3604 = #237 #1
[mk-proof] #3605 iff-true #2961 #3604
[mk-app] #3602 = #2941 #2941
[mk-proof] #3603 refl #3602
[mk-app] #3602 = #2941 #1
[mk-proof] #3603 iff-true #2946 #3602
[mk-proof] #3600 refl #2185
[mk-app] #3600 = #216 #1
[mk-proof] #3601 iff-true #2187 #3600
[mk-app] #3598 = #193 #193
[mk-proof] #3599 refl #3598
[mk-app] #3598 = #193 #1
[mk-proof] #3599 iff-true #2927 #3598
[mk-proof] #3596 refl #2179
[mk-app] #3596 = #154 #1
[mk-proof] #3597 iff-true #2181 #3596
[mk-proof] #3594 refl #2176
[mk-app] #3594 = #143 #1
[mk-proof] #3595 iff-true #2178 #3594
[mk-proof] #3592 refl #2173
[mk-app] #3592 = #124 #124
[mk-proof] #3593 refl #3592
[mk-app] #3592 = #124 #1
[mk-proof] #3593 iff-true #2294 #3592
[mk-proof] #3590 refl #2167
[mk-app] #3590 = #114 #1
[mk-proof] #3591 iff-true #2169 #3590
[mk-proof] #3588 refl #2164
[mk-app] #3588 = #108 #1
[mk-proof] #3589 iff-true #2166 #3588
[mk-proof] #3586 refl #2161
[mk-app] #3586 = #101 #1
[mk-proof] #3587 iff-true #2163 #3586
[mk-proof] #3584 refl #2158
[mk-app] #3584 = #95 #1
[mk-proof] #3585 iff-true #2160 #3584
[mk-proof] #3582 refl #2155
[mk-app] #3582 = #88 #1
[mk-proof] #3583 iff-true #2157 #3582
[mk-app] #3580 = #2334 #2334
[mk-proof] #3581 refl #3580
[mk-app] #3580 = #2334 #1
[mk-proof] #3581 iff-true #2293 #3580
[mk-proof] #3578 refl #2149
[mk-app] #3578 = #76 #1
[mk-proof] #3579 iff-true #2151 #3578
[mk-proof] #3576 refl #2146
[mk-app] #3576 = #70 #1
[mk-proof] #3577 iff-true #2148 #3576
[mk-proof] #3574 refl #2143
[mk-app] #3574 = #63 #1
[mk-proof] #3575 iff-true #2145 #3574
[mk-proof] #3628 refl #2140
[mk-app] #3628 = #57 #1
[mk-proof] #3629 iff-true #2142 #3628
[mk-proof] #3630 refl #2137
[mk-app] #3630 = #50 #1
[mk-proof] #3631 iff-true #2139 #3630
[mk-app] #3632 = #2326 #2326
[mk-proof] #3633 refl #3632
[mk-app] #3632 = #2326 #1
[mk-proof] #3633 iff-true #2331 #3632
[mk-app] #3634 ~ #2351 #2351
[mk-proof] #3635 refl #3634
[mk-lambda] #3626 null 1 #3635
[mk-proof] #3627 proof-bind #3626
[mk-app] #3624 ~ #2326 #2326
[mk-proof] #3625 nnf-pos #3627 #3624
[mk-proof] #3632 mp~ #2331 #3625 #2326
[mk-app] #3633 = #2326 #2326
[mk-proof] #3630 refl #3633
[mk-app] #3633 ~ #48 #48
[mk-proof] #3630 refl #3633
[mk-lambda] #3631 null 1 #3630
[mk-proof] #3628 proof-bind #3631
[mk-app] #3629 ~ #50 #50
[mk-proof] #3574 nnf-pos #3628 #3629
[mk-proof] #3575 mp~ #2139 #3574 #50
[mk-proof] #3576 refl #2137
[mk-app] #3576 ~ #55 #55
[mk-proof] #3577 refl #3576
[mk-lambda] #3578 null 1 #3577
[mk-proof] #3579 proof-bind #3578
[mk-app] #3580 ~ #57 #57
[mk-proof] #3581 nnf-pos #3579 #3580
[mk-proof] #3582 mp~ #2142 #3581 #57
[mk-proof] #3583 refl #2140
[mk-app] #3583 ~ #61 #61
[mk-proof] #3584 refl #3583
[mk-lambda] #3585 null 1 #3584
[mk-proof] #3586 proof-bind #3585
[mk-app] #3587 ~ #63 #63
[mk-proof] #3588 nnf-pos #3586 #3587
[mk-proof] #3589 mp~ #2145 #3588 #63
[mk-proof] #3590 refl #2143
[mk-app] #3590 ~ #68 #68
[mk-proof] #3591 refl #3590
[mk-lambda] #3592 null 1 #3591
[mk-proof] #3593 proof-bind #3592
[mk-app] #3594 ~ #70 #70
[mk-proof] #3595 nnf-pos #3593 #3594
[mk-proof] #3596 mp~ #2148 #3595 #70
[mk-proof] #3597 refl #2146
[mk-app] #3597 ~ #74 #74
[mk-proof] #3598 refl #3597
[mk-lambda] #3599 null 1 #3598
[mk-proof] #3600 proof-bind #3599
[mk-app] #3601 ~ #76 #76
[mk-proof] #3602 nnf-pos #3600 #3601
[mk-proof] #3603 mp~ #2151 #3602 #76
[mk-proof] #3604 refl #2149
[mk-app] #3604 ~ #2313 #2313
[mk-proof] #3605 refl #3604
[mk-lambda] #3606 null 1 #3605
[mk-proof] #3607 proof-bind #3606
[mk-app] #3608 ~ #2334 #2334
[mk-proof] #3609 nnf-pos #3607 #3608
[mk-proof] #3610 mp~ #2293 #3609 #2334
[mk-app] #3611 = #2334 #2334
[mk-proof] #3612 refl #3611
[mk-app] #3611 ~ #86 #86
[mk-proof] #3612 refl #3611
[mk-lambda] #3613 null 1 #3612
[mk-proof] #3614 proof-bind #3613
[mk-app] #3615 ~ #88 #88
[mk-proof] #3616 nnf-pos #3614 #3615
[mk-proof] #3617 mp~ #2157 #3616 #88
[mk-proof] #3618 refl #2155
[mk-app] #3618 ~ #93 #93
[mk-proof] #3619 refl #3618
[mk-lambda] #3620 null 1 #3619
[mk-proof] #3621 proof-bind #3620
[mk-app] #3622 ~ #95 #95
[mk-proof] #3623 nnf-pos #3621 #3622
[mk-proof] #3636 mp~ #2160 #3623 #95
[mk-proof] #3637 refl #2158
[mk-app] #3637 ~ #99 #99
[mk-proof] #3638 refl #3637
[mk-lambda] #3639 null 1 #3638
[mk-proof] #3640 proof-bind #3639
[mk-app] #3641 ~ #101 #101
[mk-proof] #3642 nnf-pos #3640 #3641
[mk-proof] #3643 mp~ #2163 #3642 #101
[mk-proof] #3644 refl #2161
[mk-app] #3644 ~ #106 #106
[mk-proof] #3645 refl #3644
[mk-lambda] #3646 null 1 #3645
[mk-proof] #3647 proof-bind #3646
[mk-app] #3648 ~ #108 #108
[mk-proof] #3649 nnf-pos #3647 #3648
[mk-proof] #3650 mp~ #2166 #3649 #108
[mk-proof] #3651 refl #2164
[mk-app] #3651 ~ #112 #112
[mk-proof] #3652 refl #3651
[mk-lambda] #3653 null 1 #3652
[mk-proof] #3654 proof-bind #3653
[mk-app] #3655 ~ #114 #114
[mk-proof] #3656 nnf-pos #3654 #3655
[mk-proof] #3657 mp~ #2169 #3656 #114
[mk-proof] #3658 refl #2167
[mk-app] #3658 ~ #123 #123
[mk-proof] #3659 refl #3658
[mk-lambda] #3660 null 1 #3659
[mk-proof] #3661 proof-bind #3660
[mk-app] #3662 ~ #124 #124
[mk-proof] #3663 nnf-pos #3661 #3662
[mk-proof] #3664 mp~ #2294 #3663 #124
[mk-app] #3665 = #124 #124
[mk-proof] #3666 refl #3665
[mk-app] #3665 ~ #132 #132
[mk-proof] #3666 refl #3665
[mk-proof] #3665 refl #2173
[mk-app] #3665 ~ #140 #140
[mk-proof] #3666 refl #3665
[mk-lambda] #3667 null 1 #3666
[mk-proof] #3668 proof-bind #3667
[mk-app] #3669 ~ #143 #143
[mk-proof] #3670 nnf-pos #3668 #3669
[mk-proof] #3671 mp~ #2178 #3670 #143
[mk-proof] #3672 refl #2176
[mk-app] #3672 ~ #152 #152
[mk-proof] #3673 refl #3672
[mk-lambda] #3674 null 1 #3673
[mk-proof] #3675 proof-bind #3674
[mk-app] #3676 ~ #154 #154
[mk-proof] #3677 nnf-pos #3675 #3676
[mk-proof] #3678 mp~ #2181 #3677 #154
[mk-proof] #3679 refl #2179
[mk-app] #3679 ~ #188 #188
[mk-proof] #3680 refl #3679
[mk-lambda] #3681 null 2 #3680
[mk-proof] #3682 proof-bind #3681
[mk-app] #3683 ~ #193 #193
[mk-proof] #3684 nnf-pos #3682 #3683
[mk-proof] #3685 mp~ #2927 #3684 #193
[mk-app] #3686 = #193 #193
[mk-proof] #3687 refl #3686
[mk-app] #3686 ~ #213 #213
[mk-proof] #3687 refl #3686
[mk-lambda] #3688 null 2 #3687
[mk-proof] #3689 proof-bind #3688
[mk-app] #3690 ~ #216 #216
[mk-proof] #3691 nnf-pos #3689 #3690
[mk-proof] #3692 mp~ #2187 #3691 #216
[mk-proof] #3693 refl #2185
[mk-app] #3693 ~ #2936 #2936
[mk-proof] #3694 refl #3693
[mk-lambda] #3695 null 1 #3694
[mk-proof] #3696 proof-bind #3695
[mk-app] #3697 ~ #2941 #2941
[mk-proof] #3698 nnf-pos #3696 #3697
[mk-proof] #3699 mp~ #2946 #3698 #2941
[mk-app] #3700 = #2941 #2941
[mk-proof] #3701 refl #3700
[mk-app] #3700 ~ #232 #232
[mk-proof] #3701 refl #3700
[mk-lambda] #3702 null 2 #3701
[mk-proof] #3703 proof-bind #3702
[mk-app] #3704 ~ #237 #237
[mk-proof] #3705 nnf-pos #3703 #3704
[mk-proof] #3706 mp~ #2961 #3705 #237
[mk-app] #3707 = #237 #237
[mk-proof] #3708 refl #3707
[mk-app] #3707 ~ #256 #256
[mk-proof] #3708 refl #3707
[mk-lambda] #3709 null 2 #3708
[mk-proof] #3710 proof-bind #3709
[mk-app] #3711 ~ #263 #263
[mk-proof] #3712 nnf-pos #3710 #3711
[mk-proof] #3713 mp~ #2976 #3712 #263
[mk-app] #3714 = #263 #263
[mk-proof] #3715 refl #3714
[mk-app] #3714 ~ #2993 #2993
[mk-proof] #3715 refl #3714
[mk-lambda] #3716 null 3 #3715
[mk-proof] #3717 proof-bind #3716
[mk-app] #3718 ~ #2996 #2996
[mk-proof] #3719 nnf-pos #3717 #3718
[mk-proof] #3720 mp~ #3001 #3719 #2996
[mk-app] #3721 = #2996 #2996
[mk-proof] #3722 refl #3721
[mk-app] #3721 ~ #3034 #3034
[mk-proof] #3722 refl #3721
[mk-lambda] #3723 null 3 #3722
[mk-proof] #3724 proof-bind #3723
[mk-app] #3725 ~ #3037 #3037
[mk-proof] #3726 nnf-pos #3724 #3725
[mk-proof] #3727 mp~ #3042 #3726 #3037
[mk-app] #3728 = #3037 #3037
[mk-proof] #3729 refl #3728
[mk-app] #3728 ~ #3072 #3072
[mk-proof] #3729 refl #3728
[mk-lambda] #3730 null 3 #3729
[mk-proof] #3731 proof-bind #3730
[mk-app] #3732 ~ #3075 #3075
[mk-proof] #3733 nnf-pos #3731 #3732
[mk-proof] #3734 mp~ #3080 #3733 #3075
[mk-app] #3735 = #3075 #3075
[mk-proof] #3736 refl #3735
[mk-app] #3735 ~ #3107 #3107
[mk-proof] #3736 refl #3735
[mk-lambda] #3737 null 3 #3736
[mk-proof] #3738 proof-bind #3737
[mk-app] #3739 ~ #3110 #3110
[mk-proof] #3740 nnf-pos #3738 #3739
[mk-proof] #3741 mp~ #3115 #3740 #3110
[mk-app] #3742 = #3110 #3110
[mk-proof] #3743 refl #3742
[mk-app] #3742 ~ #3168 #3168
[mk-proof] #3743 refl #3742
[mk-lambda] #3744 null 4 #3743
[mk-proof] #3745 proof-bind #3744
[mk-app] #3746 ~ #3171 #3171
[mk-proof] #3747 nnf-pos #3745 #3746
[mk-proof] #3748 mp~ #3176 #3747 #3171
[mk-app] #3749 = #3171 #3171
[mk-proof] #3750 refl #3749
[mk-app] #3749 ~ #3214 #3214
[mk-proof] #3750 refl #3749
[mk-lambda] #3751 null 2 #3750
[mk-proof] #3752 proof-bind #3751
[mk-app] #3753 ~ #3217 #3217
[mk-proof] #3754 nnf-pos #3752 #3753
[mk-proof] #3755 mp~ #3222 #3754 #3217
[mk-app] #3756 = #3217 #3217
[mk-proof] #3757 refl #3756
[mk-app] #3756 ~ #3240 #3240
[mk-proof] #3757 refl #3756
[mk-lambda] #3758 null 3 #3757
[mk-proof] #3759 proof-bind #3758
[mk-app] #3760 ~ #3243 #3243
[mk-proof] #3761 nnf-pos #3759 #3760
[mk-proof] #3762 mp~ #3248 #3761 #3243
[mk-app] #3763 = #3243 #3243
[mk-proof] #3764 refl #3763
[mk-app] #3763 ~ #3275 #3275
[mk-proof] #3764 refl #3763
[mk-lambda] #3765 null 2 #3764
[mk-proof] #3766 proof-bind #3765
[mk-app] #3767 ~ #3278 #3278
[mk-proof] #3768 nnf-pos #3766 #3767
[mk-proof] #3769 mp~ #3283 #3768 #3278
[inst-discovered] theory-solving 0x0 basic# ; #741
[instance] 0x0 #2580
[end-of-instance]
[mk-app] #3770 = #746 #746
[mk-proof] #3771 monotonicity #2581 #3770
[mk-app] #3772 = #752 #752
[mk-proof] #3773 monotonicity #3771 #3772
[mk-app] #3774 = #3275 #3275
[mk-proof] #3775 monotonicity #3773 #3774
[mk-app] #3776 = #3278 #3278
[mk-proof] #3777 refl #3776
[mk-app] #3776 ~ #3316 #3316
[mk-proof] #3777 refl #3776
[mk-lambda] #3778 null 3 #3777
[mk-proof] #3779 proof-bind #3778
[mk-app] #3780 ~ #3319 #3319
[mk-proof] #3781 nnf-pos #3779 #3780
[mk-proof] #3782 mp~ #3324 #3781 #3319
[mk-app] #3783 = #3319 #3319
[mk-proof] #3784 refl #3783
[mk-app] #3783 ~ #3358 #3358
[mk-proof] #3784 refl #3783
[mk-lambda] #3785 null 3 #3784
[mk-proof] #3786 proof-bind #3785
[mk-app] #3787 ~ #3361 #3361
[mk-proof] #3788 nnf-pos #3786 #3787
[mk-proof] #3789 mp~ #3366 #3788 #3361
[mk-app] #3790 = #3361 #3361
[mk-proof] #3791 refl #3790
[mk-app] #3790 ~ #910 #910
[mk-proof] #3791 refl #3790
[mk-lambda] #3792 null 3 #3791
[mk-proof] #3793 proof-bind #3792
[mk-app] #3794 ~ #915 #915
[mk-proof] #3795 nnf-pos #3793 #3794
[mk-proof] #3796 mp~ #2675 #3795 #915
[mk-app] #3797 = #915 #915
[mk-proof] #3798 refl #3797
[mk-app] #3797 ~ #3374 #3374
[mk-proof] #3798 refl #3797
[mk-lambda] #3799 null 3 #3798
[mk-proof] #3800 proof-bind #3799
[mk-app] #3801 ~ #3377 #3377
[mk-proof] #3802 nnf-pos #3800 #3801
[mk-proof] #3803 mp~ #3382 #3802 #3377
[mk-app] #3804 = #3377 #3377
[mk-proof] #3805 refl #3804
[mk-app] #3804 ~ #979 #979
[mk-proof] #3805 refl #3804
[mk-lambda] #3806 null 3 #3805
[mk-proof] #3807 proof-bind #3806
[mk-app] #3808 ~ #984 #984
[mk-proof] #3809 nnf-pos #3807 #3808
[mk-proof] #3810 mp~ #2700 #3809 #984
[mk-app] #3811 = #984 #984
[mk-proof] #3812 refl #3811
[mk-app] #3811 ~ #3386 #3386
[mk-proof] #3812 refl #3811
[mk-lambda] #3813 null 3 #3812
[mk-proof] #3814 proof-bind #3813
[mk-app] #3815 ~ #3389 #3389
[mk-proof] #3816 nnf-pos #3814 #3815
[mk-proof] #3817 mp~ #3394 #3816 #3389
[mk-app] #3818 = #3389 #3389
[mk-proof] #3819 refl #3818
[mk-app] #3818 ~ #1020 #1020
[mk-proof] #3819 refl #3818
[mk-lambda] #3820 null 2 #3819
[mk-proof] #3821 proof-bind #3820
[mk-app] #3822 ~ #1023 #1023
[mk-proof] #3823 nnf-pos #3821 #3822
[mk-proof] #3824 mp~ #2241 #3823 #1023
[mk-proof] #3825 refl #2239
[mk-app] #3825 ~ #1034 #1034
[mk-proof] #3826 refl #3825
[mk-lambda] #3827 null 2 #3826
[mk-proof] #3828 proof-bind #3827
[mk-app] #3829 ~ #1037 #1037
[mk-proof] #3830 nnf-pos #3828 #3829
[mk-proof] #3831 mp~ #2244 #3830 #1037
[mk-proof] #3832 refl #2242
[mk-app] #3832 ~ #1053 #1053
[mk-proof] #3833 refl #3832
[mk-lambda] #3834 null 2 #3833
[mk-proof] #3835 proof-bind #3834
[mk-app] #3836 ~ #1058 #1058
[mk-proof] #3837 nnf-pos #3835 #3836
[mk-proof] #3838 mp~ #2725 #3837 #1058
[mk-app] #3839 = #1058 #1058
[mk-proof] #3840 refl #3839
[mk-app] #3839 ~ #1071 #1071
[mk-proof] #3840 refl #3839
[mk-lambda] #3841 null 2 #3840
[mk-proof] #3842 proof-bind #3841
[mk-app] #3843 ~ #1076 #1076
[mk-proof] #3844 nnf-pos #3842 #3843
[mk-proof] #3845 mp~ #2732 #3844 #1076
[mk-app] #3846 = #1076 #1076
[mk-proof] #3847 refl #3846
[mk-app] #3846 ~ #3411 #3411
[mk-proof] #3847 refl #3846
[mk-lambda] #3848 null 2 #3847
[mk-proof] #3849 proof-bind #3848
[mk-app] #3850 ~ #3414 #3414
[mk-proof] #3851 nnf-pos #3849 #3850
[mk-proof] #3852 mp~ #3419 #3851 #3414
[mk-app] #3853 = #3414 #3414
[mk-proof] #3854 refl #3853
[mk-app] #3853 ~ #3438 #3438
[mk-proof] #3854 refl #3853
[mk-lambda] #3855 null 3 #3854
[mk-proof] #3856 proof-bind #3855
[mk-app] #3857 ~ #3441 #3441
[mk-proof] #3858 nnf-pos #3856 #3857
[mk-proof] #3859 mp~ #3446 #3858 #3441
[mk-app] #3860 = #3441 #3441
[mk-proof] #3861 refl #3860
[mk-app] #3860 ~ #1180 #1180
[mk-proof] #3861 refl #3860
[mk-lambda] #3862 null 2 #3861
[mk-proof] #3863 proof-bind #3862
[mk-app] #3864 ~ #1185 #1185
[mk-proof] #3865 nnf-pos #3863 #3864
[mk-proof] #3866 mp~ #3457 #3865 #1185
[mk-app] #3867 = #1185 #1185
[mk-proof] #3868 refl #3867
[mk-app] #3867 ~ #3479 #3479
[mk-proof] #3868 refl #3867
[mk-lambda] #3869 null 2 #3868
[mk-proof] #3870 proof-bind #3869
[mk-app] #3871 ~ #3482 #3482
[mk-proof] #3872 nnf-pos #3870 #3871
[mk-proof] #3873 mp~ #3487 #3872 #3482
[mk-app] #3874 = #3482 #3482
[mk-proof] #3875 refl #3874
[mk-app] #3874 ~ #1303 #1303
[mk-proof] #3875 refl #3874
[mk-lambda] #3876 null 2 #3875
[mk-proof] #3877 proof-bind #3876
[mk-app] #3878 ~ #1306 #1306
[mk-proof] #3879 nnf-pos #3877 #3878
[mk-proof] #3880 mp~ #2265 #3879 #1306
[mk-proof] #3881 refl #2263
[mk-app] #3881 ~ #2821 #2821
[mk-proof] #3882 refl #3881
[mk-lambda] #3883 null 2 #3882
[mk-proof] #3884 proof-bind #3883
[mk-app] #3885 ~ #2824 #2824
[mk-proof] #3886 nnf-pos #3884 #3885
[mk-proof] #3887 mp~ #2829 #3886 #2824
[mk-app] #3888 = #2824 #2824
[mk-proof] #3889 refl #3888
[mk-app] #3888 ~ #1376 #1376
[mk-proof] #3889 refl #3888
[mk-lambda] #3890 null 2 #3889
[mk-proof] #3891 proof-bind #3890
[mk-app] #3892 ~ #1379 #1379
[mk-proof] #3893 nnf-pos #3891 #3892
[mk-proof] #3894 mp~ #3511 #3893 #1379
[mk-app] #3895 = #1379 #1379
[mk-proof] #3896 refl #3895
[mk-app] #3895 ~ #1438 #1438
[mk-proof] #3896 refl #3895
[mk-lambda] #3897 null 3 #3896
[mk-proof] #3898 proof-bind #3897
[mk-app] #3899 ~ #1443 #1443
[mk-proof] #3900 nnf-pos #3898 #3899
[mk-proof] #3901 mp~ #3538 #3900 #1443
[mk-app] #3902 = #1443 #1443
[mk-proof] #3903 refl #3902
[mk-app] #3902 ~ #1463 #1463
[mk-proof] #3903 refl #3902
[mk-lambda] #3904 null 3 #3903
[mk-proof] #3905 proof-bind #3904
[mk-app] #3906 ~ #1466 #1466
[mk-proof] #3907 nnf-pos #3905 #3906
[mk-proof] #3908 mp~ #3554 #3907 #1466
[mk-app] #3909 = #1466 #1466
[mk-proof] #3910 refl #3909
[mk-app] #3909 ~ #3563 #3563
[mk-proof] #3910 refl #3909
[mk-lambda] #3911 null 2 #3910
[mk-proof] #3912 proof-bind #3911
[mk-app] #3913 ~ #3568 #3568
[mk-proof] #3914 nnf-pos #3912 #3913
[mk-proof] #3915 mp~ #3573 #3914 #3568
[mk-app] #3916 = #3568 #3568
[mk-proof] #3917 refl #3916
[mk-app] #3916 ~ #1492 #1492
[mk-proof] #3917 refl #3916
[mk-lambda] #3918 null 2 #3917
[mk-proof] #3919 proof-bind #3918
[mk-app] #3920 ~ #1495 #1495
[mk-proof] #3921 nnf-pos #3919 #3920
[mk-proof] #3922 mp~ #2283 #3921 #1495
[mk-proof] #3923 refl #2281
[mk-app] #3923 ~ #1517 #1517
[mk-proof] #3924 refl #3923
[mk-lambda] #3925 null 2 #3924
[mk-proof] #3926 proof-bind #3925
[mk-app] #3927 ~ #1522 #1522
[mk-proof] #3928 nnf-pos #3926 #3927
[mk-proof] #3929 mp~ #2910 #3928 #1522
[mk-app] #3930 = #1522 #1522
[mk-proof] #3931 refl #3930
[mk-app] #3770 = #2326 #2326
[mk-proof] #3771 refl #3770
[mk-proof] #3770 refl #2137
[mk-proof] #3770 refl #2140
[mk-proof] #3770 refl #2143
[mk-proof] #3770 refl #2146
[mk-proof] #3770 refl #2149
[mk-app] #3770 = #2334 #2334
[mk-proof] #3771 refl #3770
[mk-proof] #3770 refl #2155
[mk-proof] #3770 refl #2158
[mk-proof] #3770 refl #2161
[mk-proof] #3770 refl #2164
[mk-proof] #3770 refl #2167
[mk-app] #3770 = #124 #124
[mk-proof] #3771 refl #3770
[mk-proof] #3770 refl #2173
[mk-proof] #3770 refl #2176
[mk-proof] #3770 refl #2179
[mk-app] #3770 or #135 #157
[mk-app] #3771 not #3770
[inst-discovered] theory-solving 0x0 basic# ; #160
[mk-app] #3772 = #160 #3771
[mk-proof] #3773 rewrite #3772
[instance] 0x0 #3772
[end-of-instance]
[mk-app] #3774 not #3771
[mk-app] #3775 = #187 #3774
[mk-proof] #3930 monotonicity #3773 #3775
[inst-discovered] theory-solving 0x0 basic# ; #3774
[mk-app] #3931 = #3774 #3770
[mk-proof] #3932 rewrite #3931
[instance] 0x0 #3931
[end-of-instance]
[mk-app] #3933 = #187 #3770
[mk-proof] #3934 trans #3930 #3932 #3933
[mk-app] #3935 or #3770 #177
[mk-app] #3936 = #188 #3935
[mk-proof] #3937 monotonicity #3934 #3936
[mk-app] #3938 or #135 #157 #177
[inst-discovered] theory-solving 0x0 basic# ; #3935
[mk-app] #3939 = #3935 #3938
[mk-proof] #3940 rewrite #3939
[instance] 0x0 #3939
[end-of-instance]
[mk-app] #3941 = #188 #3938
[mk-proof] #3942 trans #3937 #3940 #3941
[mk-quant] #3943 k!150 2 #167 #3938
[attach-var-names] #3943 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #3944 null 2 #3942
[mk-proof] #3945 proof-bind #3944
[mk-app] #3946 = #193 #3943
[mk-proof] #3947 quant-intro #3945 #3946
[mk-proof] #3948 mp #3685 #3947 #3943
[mk-app] #3949 not #207
[mk-app] #3950 not #210
[mk-app] #3951 or #3949 #3950
[mk-app] #3952 not #3951
[inst-discovered] theory-solving 0x0 basic# ; #213
[mk-app] #3953 = #213 #3952
[mk-proof] #3954 rewrite #3953
[instance] 0x0 #3953
[end-of-instance]
[mk-quant] #3955 k!156 2 #204 #3952
[attach-var-names] #3955 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #3956 null 2 #3954
[mk-proof] #3957 proof-bind #3956
[mk-app] #3958 = #216 #3955
[mk-proof] #3959 quant-intro #3957 #3958
[mk-proof] #3960 mp #3692 #3959 #3955
[mk-app] #3961 = #2941 #2941
[mk-proof] #3962 refl #3961
[mk-app] #3961 = #237 #237
[mk-proof] #3962 refl #3961
[mk-app] #3961 = #263 #263
[mk-proof] #3962 refl #3961
[mk-app] #3961 or #157 #270 #294 #619
[mk-app] #3962 not #3961
[inst-discovered] theory-solving 0x0 basic# ; #318
[mk-app] #3963 = #318 #3962
[mk-proof] #3964 rewrite #3963
[instance] 0x0 #3963
[end-of-instance]
[mk-app] #3965 not #3962
[mk-app] #3966 = #326 #3965
[mk-proof] #3967 monotonicity #3964 #3966
[inst-discovered] theory-solving 0x0 basic# ; #3965
[mk-app] #3968 = #3965 #3961
[mk-proof] #3969 rewrite #3968
[instance] 0x0 #3968
[end-of-instance]
[mk-app] #3970 = #326 #3961
[mk-proof] #3971 trans #3967 #3969 #3970
[mk-app] #3972 or #3961 #2370
[mk-app] #3973 = #2993 #3972
[mk-proof] #3974 monotonicity #3971 #3973
[mk-app] #3975 or #157 #270 #294 #619 #2370
[inst-discovered] theory-solving 0x0 basic# ; #3972
[mk-app] #3976 = #3972 #3975
[mk-proof] #3977 rewrite #3976
[instance] 0x0 #3976
[end-of-instance]
[mk-app] #3978 = #2993 #3975
[mk-proof] #3979 trans #3974 #3977 #3978
[mk-quant] #3980 k!179 3 #283 #284 #3975
[attach-var-names] #3980 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #3981 null 3 #3979
[mk-proof] #3982 proof-bind #3981
[mk-app] #3983 = #2996 #3980
[mk-proof] #3984 quant-intro #3982 #3983
[mk-proof] #3985 mp #3720 #3984 #3980
[mk-app] #3986 or #157 #270 #299 #356
[mk-app] #3987 not #3986
[inst-discovered] theory-solving 0x0 basic# ; #380
[mk-app] #3988 = #380 #3987
[mk-proof] #3989 rewrite #3988
[instance] 0x0 #3988
[end-of-instance]
[mk-app] #3990 not #3987
[mk-app] #3991 = #388 #3990
[mk-proof] #3992 monotonicity #3989 #3991
[inst-discovered] theory-solving 0x0 basic# ; #3990
[mk-app] #3993 = #3990 #3986
[mk-proof] #3994 rewrite #3993
[instance] 0x0 #3993
[end-of-instance]
[mk-app] #3995 = #388 #3986
[mk-proof] #3996 trans #3992 #3994 #3995
[mk-app] #3997 not #3026
[mk-app] #3998 not #2401
[mk-app] #3999 or #3997 #3998
[mk-app] #4000 not #3999
[inst-discovered] theory-solving 0x0 basic# ; #3031
[mk-app] #4001 = #3031 #4000
[mk-proof] #4002 rewrite #4001
[instance] 0x0 #4001
[end-of-instance]
[mk-app] #4003 or #3986 #4000
[mk-app] #4004 = #3034 #4003
[mk-proof] #4005 monotonicity #3996 #4002 #4004
[mk-app] #4006 or #157 #270 #299 #356 #4000
[inst-discovered] theory-solving 0x0 basic# ; #4003
[mk-app] #4007 = #4003 #4006
[mk-proof] #4008 rewrite #4007
[instance] 0x0 #4007
[end-of-instance]
[mk-app] #4009 = #3034 #4006
[mk-proof] #4010 trans #4005 #4008 #4009
[mk-quant] #4011 k!193 3 #283 #4006
[attach-var-names] #4011 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #4012 null 3 #4010
[mk-proof] #4013 proof-bind #4012
[mk-app] #4014 = #3037 #4011
[mk-proof] #4015 quant-intro #4013 #4014
[mk-proof] #4016 mp #3727 #4015 #4011
[mk-app] #4017 or #157 #270 #419 #619
[mk-app] #4018 not #4017
[inst-discovered] theory-solving 0x0 basic# ; #443
[mk-app] #4019 = #443 #4018
[mk-proof] #4020 rewrite #4019
[instance] 0x0 #4019
[end-of-instance]
[mk-app] #4021 not #4018
[mk-app] #4022 = #451 #4021
[mk-proof] #4023 monotonicity #4020 #4022
[inst-discovered] theory-solving 0x0 basic# ; #4021
[mk-app] #4024 = #4021 #4017
[mk-proof] #4025 rewrite #4024
[instance] 0x0 #4024
[end-of-instance]
[mk-app] #4026 = #451 #4017
[mk-proof] #4027 trans #4023 #4025 #4026
[mk-app] #4028 not #3064
[mk-app] #4029 not #2434
[mk-app] #4030 or #4028 #4029
[mk-app] #4031 not #4030
[inst-discovered] theory-solving 0x0 basic# ; #3069
[mk-app] #4032 = #3069 #4031
[mk-proof] #4033 rewrite #4032
[instance] 0x0 #4032
[end-of-instance]
[mk-app] #4034 or #4017 #4031
[mk-app] #4035 = #3072 #4034
[mk-proof] #4036 monotonicity #4027 #4033 #4035
[mk-app] #4037 or #157 #270 #419 #619 #4031
[inst-discovered] theory-solving 0x0 basic# ; #4034
[mk-app] #4038 = #4034 #4037
[mk-proof] #4039 rewrite #4038
[instance] 0x0 #4038
[end-of-instance]
[mk-app] #4040 = #3072 #4037
[mk-proof] #4041 trans #4036 #4039 #4040
[mk-quant] #4042 k!207 3 #412 #4037
[attach-var-names] #4042 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #4043 null 3 #4041
[mk-proof] #4044 proof-bind #4043
[mk-app] #4045 = #3075 #4042
[mk-proof] #4046 quant-intro #4044 #4045
[mk-proof] #4047 mp #3734 #4046 #4042
[mk-app] #4048 not #475
[mk-app] #4049 or #4048 #481
[mk-app] #4050 not #4049
[inst-discovered] theory-solving 0x0 basic# ; #490
[mk-app] #4051 = #490 #4050
[mk-proof] #4052 rewrite #4051
[instance] 0x0 #4051
[end-of-instance]
[mk-app] #4053 not #4050
[mk-app] #4054 = #496 #4053
[mk-proof] #4055 monotonicity #4052 #4054
[inst-discovered] theory-solving 0x0 basic# ; #4053
[mk-app] #4056 = #4053 #4049
[mk-proof] #4057 rewrite #4056
[instance] 0x0 #4056
[end-of-instance]
[mk-app] #4058 = #496 #4049
[mk-proof] #4059 trans #4055 #4057 #4058
[mk-app] #4060 or #4049 #3102
[mk-app] #4061 = #3107 #4060
[mk-proof] #4062 monotonicity #4059 #4061
[mk-app] #4063 or #481 #3102 #4048
[inst-discovered] theory-solving 0x0 basic# ; #4060
[mk-app] #4064 = #4060 #4063
[mk-proof] #4065 rewrite #4064
[instance] 0x0 #4064
[end-of-instance]
[mk-app] #4066 = #3107 #4063
[mk-proof] #4067 trans #4062 #4065 #4066
[mk-quant] #4068 k!214 3 #470 #471 #4063
[attach-var-names] #4068 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4069 null 3 #4067
[mk-proof] #4070 proof-bind #4069
[mk-app] #4071 = #3110 #4068
[mk-proof] #4072 quant-intro #4070 #4071
[mk-proof] #4073 mp #3741 #4072 #4068
[mk-app] #4074 or #619 #532
[mk-app] #4075 not #4074
[inst-discovered] theory-solving 0x0 basic# ; #542
[mk-app] #4076 = #542 #4075
[mk-proof] #4077 rewrite #4076
[instance] 0x0 #4076
[end-of-instance]
[mk-app] #4078 not #4075
[mk-app] #4079 = #557 #4078
[mk-proof] #4080 monotonicity #4077 #4079
[inst-discovered] theory-solving 0x0 basic# ; #4078
[mk-app] #4081 = #4078 #4074
[mk-proof] #4082 rewrite #4081
[instance] 0x0 #4081
[end-of-instance]
[mk-app] #4083 = #557 #4074
[mk-proof] #4084 trans #4080 #4082 #4083
[mk-app] #4085 not #3159
[mk-app] #4086 not #3162
[mk-app] #4087 or #4085 #4086
[mk-app] #4088 not #4087
[inst-discovered] theory-solving 0x0 basic# ; #3165
[mk-app] #4089 = #3165 #4088
[mk-proof] #4090 rewrite #4089
[instance] 0x0 #4089
[end-of-instance]
[mk-app] #4091 or #4074 #4088
[mk-app] #4092 = #3168 #4091
[mk-proof] #4093 monotonicity #4084 #4090 #4092
[mk-app] #4094 or #532 #619 #4088
[inst-discovered] theory-solving 0x0 basic# ; #4091
[mk-app] #4095 = #4091 #4094
[mk-proof] #4096 rewrite #4095
[instance] 0x0 #4095
[end-of-instance]
[mk-app] #4097 = #3168 #4094
[mk-proof] #4098 trans #4093 #4096 #4097
[mk-quant] #4099 k!223 4 #524 #525 #4094
[attach-var-names] #4099 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4100 null 4 #4098
[mk-proof] #4101 proof-bind #4100
[mk-app] #4102 = #3171 #4099
[mk-proof] #4103 quant-intro #4101 #4102
[mk-proof] #4104 mp #3748 #4103 #4099
[mk-app] #4105 not #3190
[mk-app] #4106 not #3205
[mk-app] #4107 or #4105 #4106
[mk-app] #4108 not #4107
[inst-discovered] theory-solving 0x0 basic# ; #3208
[mk-app] #4109 = #3208 #4108
[mk-proof] #4110 rewrite #4109
[instance] 0x0 #4109
[end-of-instance]
[mk-app] #4111 or #619 #4108
[mk-app] #4112 = #3211 #4111
[mk-proof] #4113 monotonicity #4110 #4112
[mk-app] #4114 and #4111 #635
[mk-app] #4115 = #3214 #4114
[mk-proof] #4116 monotonicity #4113 #4115
[mk-app] #4117 not #4111
[mk-app] #4118 not #635
[mk-app] #4119 or #4117 #4118
[mk-app] #4120 not #4119
[inst-discovered] theory-solving 0x0 basic# ; #4114
[mk-app] #4121 = #4114 #4120
[mk-proof] #4122 rewrite #4121
[instance] 0x0 #4121
[end-of-instance]
[mk-app] #4123 = #3214 #4120
[mk-proof] #4124 trans #4116 #4122 #4123
[mk-quant] #4125 k!234 2 #582 #583 #4120
[attach-var-names] #4125 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4126 null 2 #4124
[mk-proof] #4127 proof-bind #4126
[mk-app] #4128 = #3217 #4125
[mk-proof] #4129 quant-intro #4127 #4128
[mk-proof] #4130 mp #3755 #4129 #4125
[mk-app] #4131 or #619 #663 #294
[mk-app] #4132 not #4131
[inst-discovered] theory-solving 0x0 basic# ; #677
[mk-app] #4133 = #677 #4132
[mk-proof] #4134 rewrite #4133
[instance] 0x0 #4133
[end-of-instance]
[mk-app] #4135 not #4132
[mk-app] #4136 = #685 #4135
[mk-proof] #4137 monotonicity #4134 #4136
[inst-discovered] theory-solving 0x0 basic# ; #4135
[mk-app] #4138 = #4135 #4131
[mk-proof] #4139 rewrite #4138
[instance] 0x0 #4138
[end-of-instance]
[mk-app] #4140 = #685 #4131
[mk-proof] #4141 trans #4137 #4139 #4140
[mk-app] #4142 or #4131 #3235
[mk-app] #4143 = #3240 #4142
[mk-proof] #4144 monotonicity #4141 #4143
[mk-app] #4145 or #294 #619 #663 #3235
[inst-discovered] theory-solving 0x0 basic# ; #4142
[mk-app] #4146 = #4142 #4145
[mk-proof] #4147 rewrite #4146
[instance] 0x0 #4146
[end-of-instance]
[mk-app] #4148 = #3240 #4145
[mk-proof] #4149 trans #4144 #4147 #4148
[mk-quant] #4150 k!241 3 #656 #657 #4145
[attach-var-names] #4150 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4151 null 3 #4149
[mk-proof] #4152 proof-bind #4151
[mk-app] #4153 = #3243 #4150
[mk-proof] #4154 quant-intro #4152 #4153
[mk-proof] #4155 mp #3762 #4154 #4150
[inst-discovered] theory-solving 0x0 basic# ; #741
[instance] 0x0 #2580
[end-of-instance]
[mk-app] #4156 = #746 #746
[mk-proof] #4157 monotonicity #2581 #4156
[mk-app] #4158 not #733
[mk-app] #4159 not #741
[mk-app] #4160 or #4158 #4159
[mk-app] #4161 not #4160
[inst-discovered] theory-solving 0x0 basic# ; #746
[mk-app] #4162 = #746 #4161
[mk-proof] #4163 rewrite #4162
[instance] 0x0 #4162
[end-of-instance]
[mk-proof] #4164 trans #4157 #4163 #4162
[mk-app] #4165 or #619 #4161
[mk-app] #4166 = #752 #4165
[mk-proof] #4167 monotonicity #4164 #4166
[mk-app] #4168 and #4165 #3272
[mk-app] #4169 = #3275 #4168
[mk-proof] #4170 monotonicity #4167 #4169
[mk-app] #4171 not #4165
[mk-app] #4172 not #3272
[mk-app] #4173 or #4171 #4172
[mk-app] #4174 not #4173
[inst-discovered] theory-solving 0x0 basic# ; #4168
[mk-app] #4175 = #4168 #4174
[mk-proof] #4176 rewrite #4175
[instance] 0x0 #4175
[end-of-instance]
[mk-app] #4177 = #3275 #4174
[mk-proof] #4178 trans #4170 #4176 #4177
[mk-quant] #4179 k!254 2 #709 #710 #4174
[attach-var-names] #4179 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4180 null 2 #4178
[mk-proof] #4181 proof-bind #4180
[mk-app] #4182 = #3278 #4179
[mk-proof] #4183 quant-intro #4181 #4182
[mk-proof] #4184 mp #3769 #4183 #4179
[mk-app] #4185 or #619 #791 #813
[mk-app] #4186 not #4185
[inst-discovered] theory-solving 0x0 basic# ; #828
[mk-app] #4187 = #828 #4186
[mk-proof] #4188 rewrite #4187
[instance] 0x0 #4187
[end-of-instance]
[mk-app] #4189 not #4186
[mk-app] #4190 = #836 #4189
[mk-proof] #4191 monotonicity #4188 #4190
[inst-discovered] theory-solving 0x0 basic# ; #4189
[mk-app] #4192 = #4189 #4185
[mk-proof] #4193 rewrite #4192
[instance] 0x0 #4192
[end-of-instance]
[mk-app] #4194 = #836 #4185
[mk-proof] #4195 trans #4191 #4193 #4194
[mk-app] #4196 not #3308
[mk-app] #4197 not #2624
[mk-app] #4198 or #4196 #4197
[mk-app] #4199 not #4198
[inst-discovered] theory-solving 0x0 basic# ; #3313
[mk-app] #4200 = #3313 #4199
[mk-proof] #4201 rewrite #4200
[instance] 0x0 #4200
[end-of-instance]
[mk-app] #4202 or #4185 #4199
[mk-app] #4203 = #3316 #4202
[mk-proof] #4204 monotonicity #4195 #4201 #4203
[mk-app] #4205 or #619 #791 #813 #4199
[inst-discovered] theory-solving 0x0 basic# ; #4202
[mk-app] #4206 = #4202 #4205
[mk-proof] #4207 rewrite #4206
[instance] 0x0 #4206
[end-of-instance]
[mk-app] #4208 = #3316 #4205
[mk-proof] #4209 trans #4204 #4207 #4208
[mk-quant] #4210 k!262 3 #788 #4205
[attach-var-names] #4210 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4211 null 3 #4209
[mk-proof] #4212 proof-bind #4211
[mk-app] #4213 = #3319 #4210
[mk-proof] #4214 quant-intro #4212 #4213
[mk-proof] #4215 mp #3782 #4214 #4210
[mk-app] #4216 or #294 #666 #791
[mk-app] #4217 not #4216
[inst-discovered] theory-solving 0x0 basic# ; #866
[mk-app] #4218 = #866 #4217
[mk-proof] #4219 rewrite #4218
[instance] 0x0 #4218
[end-of-instance]
[mk-app] #4220 not #4217
[mk-app] #4221 = #874 #4220
[mk-proof] #4222 monotonicity #4219 #4221
[inst-discovered] theory-solving 0x0 basic# ; #4220
[mk-app] #4223 = #4220 #4216
[mk-proof] #4224 rewrite #4223
[instance] 0x0 #4223
[end-of-instance]
[mk-app] #4225 = #874 #4216
[mk-proof] #4226 trans #4222 #4224 #4225
[mk-app] #4227 not #3337
[mk-app] #4228 not #3350
[mk-app] #4229 or #4227 #4228
[mk-app] #4230 not #4229
[inst-discovered] theory-solving 0x0 basic# ; #3355
[mk-app] #4231 = #3355 #4230
[mk-proof] #4232 rewrite #4231
[instance] 0x0 #4231
[end-of-instance]
[mk-app] #4233 or #4216 #4230
[mk-app] #4234 = #3358 #4233
[mk-proof] #4235 monotonicity #4226 #4232 #4234
[mk-app] #4236 or #294 #666 #791 #4230
[inst-discovered] theory-solving 0x0 basic# ; #4233
[mk-app] #4237 = #4233 #4236
[mk-proof] #4238 rewrite #4237
[instance] 0x0 #4237
[end-of-instance]
[mk-app] #4239 = #3358 #4236
[mk-proof] #4240 trans #4235 #4238 #4239
[mk-quant] #4241 k!270 3 #857 #4236
[attach-var-names] #4241 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4242 null 3 #4240
[mk-proof] #4243 proof-bind #4242
[mk-app] #4244 = #3361 #4241
[mk-proof] #4245 quant-intro #4243 #4244
[mk-proof] #4246 mp #3789 #4245 #4241
[mk-app] #4247 or #896 #937
[mk-app] #4248 not #4247
[inst-discovered] theory-solving 0x0 basic# ; #903
[mk-app] #4249 = #903 #4248
[mk-proof] #4250 rewrite #4249
[instance] 0x0 #4249
[end-of-instance]
[mk-app] #4251 not #4248
[mk-app] #4252 = #909 #4251
[mk-proof] #4253 monotonicity #4250 #4252
[inst-discovered] theory-solving 0x0 basic# ; #4251
[mk-app] #4254 = #4251 #4247
[mk-proof] #4255 rewrite #4254
[instance] 0x0 #4254
[end-of-instance]
[mk-app] #4256 = #909 #4247
[mk-proof] #4257 trans #4253 #4255 #4256
[mk-app] #4258 or #4247 #891
[mk-app] #4259 = #910 #4258
[mk-proof] #4260 monotonicity #4257 #4259
[mk-app] #4261 or #891 #896 #937
[inst-discovered] theory-solving 0x0 basic# ; #4258
[mk-app] #4262 = #4258 #4261
[mk-proof] #4263 rewrite #4262
[instance] 0x0 #4262
[end-of-instance]
[mk-app] #4264 = #910 #4261
[mk-proof] #4265 trans #4260 #4263 #4264
[mk-quant] #4266 k!276 3 #893 #4261
[attach-var-names] #4266 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #4267 null 3 #4265
[mk-proof] #4268 proof-bind #4267
[mk-app] #4269 = #915 #4266
[mk-proof] #4270 quant-intro #4268 #4269
[mk-proof] #4271 mp #3796 #4270 #4266
[mk-app] #4272 or #896 #900 #356
[mk-app] #4273 not #4272
[inst-discovered] theory-solving 0x0 basic# ; #948
[mk-app] #4274 = #948 #4273
[mk-proof] #4275 rewrite #4274
[instance] 0x0 #4274
[end-of-instance]
[mk-app] #4276 not #4273
[mk-app] #4277 = #956 #4276
[mk-proof] #4278 monotonicity #4275 #4277
[inst-discovered] theory-solving 0x0 basic# ; #4276
[mk-app] #4279 = #4276 #4272
[mk-proof] #4280 rewrite #4279
[instance] 0x0 #4279
[end-of-instance]
[mk-app] #4281 = #956 #4272
[mk-proof] #4282 trans #4278 #4280 #4281
[mk-app] #4283 not #927
[mk-app] #4284 or #3997 #4283
[mk-app] #4285 not #4284
[inst-discovered] theory-solving 0x0 basic# ; #3371
[mk-app] #4286 = #3371 #4285
[mk-proof] #4287 rewrite #4286
[instance] 0x0 #4286
[end-of-instance]
[mk-app] #4288 or #4272 #4285
[mk-app] #4289 = #3374 #4288
[mk-proof] #4290 monotonicity #4282 #4287 #4289
[mk-app] #4291 or #356 #896 #900 #4285
[inst-discovered] theory-solving 0x0 basic# ; #4288
[mk-app] #4292 = #4288 #4291
[mk-proof] #4293 rewrite #4292
[instance] 0x0 #4292
[end-of-instance]
[mk-app] #4294 = #3374 #4291
[mk-proof] #4295 trans #4290 #4293 #4294
[mk-quant] #4296 k!286 3 #893 #4291
[attach-var-names] #4296 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #4297 null 3 #4295
[mk-proof] #4298 proof-bind #4297
[mk-app] #4299 = #3377 #4296
[mk-proof] #4300 quant-intro #4298 #4299
[mk-proof] #4301 mp #3803 #4300 #4296
[mk-app] #4302 or #4247 #971
[mk-app] #4303 = #979 #4302
[mk-proof] #4304 monotonicity #4257 #4303
[mk-app] #4305 or #896 #937 #971
[inst-discovered] theory-solving 0x0 basic# ; #4302
[mk-app] #4306 = #4302 #4305
[mk-proof] #4307 rewrite #4306
[instance] 0x0 #4306
[end-of-instance]
[mk-app] #4308 = #979 #4305
[mk-proof] #4309 trans #4304 #4307 #4308
[mk-quant] #4310 k!292 3 #973 #4305
[attach-var-names] #4310 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #4311 null 3 #4309
[mk-proof] #4312 proof-bind #4311
[mk-app] #4313 = #984 #4310
[mk-proof] #4314 quant-intro #4312 #4313
[mk-proof] #4315 mp #3810 #4314 #4310
[mk-app] #4316 or #896 #900
[mk-app] #4317 not #4316
[inst-discovered] theory-solving 0x0 basic# ; #997
[mk-app] #4318 = #997 #4317
[mk-proof] #4319 rewrite #4318
[instance] 0x0 #4318
[end-of-instance]
[mk-app] #4320 not #4317
[mk-app] #4321 = #1003 #4320
[mk-proof] #4322 monotonicity #4319 #4321
[inst-discovered] theory-solving 0x0 basic# ; #4320
[mk-app] #4323 = #4320 #4316
[mk-proof] #4324 rewrite #4323
[instance] 0x0 #4323
[end-of-instance]
[mk-app] #4325 = #1003 #4316
[mk-proof] #4326 trans #4322 #4324 #4325
[mk-app] #4327 not #992
[mk-app] #4328 or #3997 #4327
[mk-app] #4329 not #4328
[inst-discovered] theory-solving 0x0 basic# ; #3383
[mk-app] #4330 = #3383 #4329
[mk-proof] #4331 rewrite #4330
[instance] 0x0 #4330
[end-of-instance]
[mk-app] #4332 or #4316 #4329
[mk-app] #4333 = #3386 #4332
[mk-proof] #4334 monotonicity #4326 #4331 #4333
[mk-app] #4335 or #896 #900 #4329
[inst-discovered] theory-solving 0x0 basic# ; #4332
[mk-app] #4336 = #4332 #4335
[mk-proof] #4337 rewrite #4336
[instance] 0x0 #4336
[end-of-instance]
[mk-app] #4338 = #3386 #4335
[mk-proof] #4339 trans #4334 #4337 #4338
[mk-quant] #4340 k!300 3 #973 #4335
[attach-var-names] #4340 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #4341 null 3 #4339
[mk-proof] #4342 proof-bind #4341
[mk-app] #4343 = #3389 #4340
[mk-proof] #4344 quant-intro #4342 #4343
[mk-proof] #4345 mp #3817 #4344 #4340
[mk-proof] #4346 refl #2239
[mk-proof] #4346 refl #2242
[mk-app] #4346 = #1058 #1058
[mk-proof] #4347 refl #4346
[mk-app] #4346 = #1076 #1076
[mk-proof] #4347 refl #4346
[mk-app] #4346 not #1095
[mk-app] #4347 not #3403
[mk-app] #4348 or #1103 #4346 #4347
[mk-app] #4349 not #4348
[inst-discovered] theory-solving 0x0 basic# ; #3408
[mk-app] #4350 = #3408 #4349
[mk-proof] #4351 rewrite #4350
[instance] 0x0 #4350
[end-of-instance]
[mk-app] #4352 or #1125 #4349
[mk-app] #4353 = #3411 #4352
[mk-proof] #4354 monotonicity #4351 #4353
[mk-quant] #4355 k!326 2 #1091 #4352
[attach-var-names] #4355 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4356 null 2 #4354
[mk-proof] #4357 proof-bind #4356
[mk-app] #4358 = #3414 #4355
[mk-proof] #4359 quant-intro #4357 #4358
[mk-proof] #4360 mp #3852 #4359 #4355
[mk-app] #4361 not #3427
[mk-app] #4362 or #294 #619 #4361
[mk-app] #4363 not #4362
[inst-discovered] theory-solving 0x0 basic# ; #3432
[mk-app] #4364 = #3432 #4363
[mk-proof] #4365 rewrite #4364
[instance] 0x0 #4364
[end-of-instance]
[mk-app] #4366 not #4363
[mk-app] #4367 = #3435 #4366
[mk-proof] #4368 monotonicity #4365 #4367
[inst-discovered] theory-solving 0x0 basic# ; #4366
[mk-app] #4369 = #4366 #4362
[mk-proof] #4370 rewrite #4369
[instance] 0x0 #4369
[end-of-instance]
[mk-app] #4371 = #3435 #4362
[mk-proof] #4372 trans #4368 #4370 #4371
[mk-app] #4373 or #4362 #1140
[mk-app] #4374 = #3438 #4373
[mk-proof] #4375 monotonicity #4372 #4374
[mk-app] #4376 or #294 #619 #1140 #4361
[inst-discovered] theory-solving 0x0 basic# ; #4373
[mk-app] #4377 = #4373 #4376
[mk-proof] #4378 rewrite #4377
[instance] 0x0 #4377
[end-of-instance]
[mk-app] #4379 = #3438 #4376
[mk-proof] #4380 trans #4375 #4378 #4379
[mk-quant] #4381 k!332 3 #1142 #4376
[attach-var-names] #4381 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4382 null 3 #4380
[mk-proof] #4383 proof-bind #4382
[mk-app] #4384 = #3441 #4381
[mk-proof] #4385 quant-intro #4383 #4384
[mk-proof] #4386 mp #3859 #4385 #4381
[mk-app] #4387 or #619 #419
[mk-app] #4388 not #4387
[inst-discovered] theory-solving 0x0 basic# ; #429
[mk-app] #4389 = #429 #4388
[mk-proof] #4390 rewrite #4389
[instance] 0x0 #4389
[end-of-instance]
[mk-app] #4391 not #4388
[mk-app] #4392 = #1179 #4391
[mk-proof] #4393 monotonicity #4390 #4392
[inst-discovered] theory-solving 0x0 basic# ; #4391
[mk-app] #4394 = #4391 #4387
[mk-proof] #4395 rewrite #4394
[instance] 0x0 #4394
[end-of-instance]
[mk-app] #4396 = #1179 #4387
[mk-proof] #4397 trans #4393 #4395 #4396
[mk-app] #4398 or #4387 #1171
[mk-app] #4399 = #1180 #4398
[mk-proof] #4400 monotonicity #4397 #4399
[mk-app] #4401 or #419 #619 #1171
[inst-discovered] theory-solving 0x0 basic# ; #4398
[mk-app] #4402 = #4398 #4401
[mk-proof] #4403 rewrite #4402
[instance] 0x0 #4402
[end-of-instance]
[mk-app] #4404 = #1180 #4401
[mk-proof] #4405 trans #4400 #4403 #4404
[mk-quant] #4406 k!338 2 #1173 #4401
[attach-var-names] #4406 (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #4407 null 2 #4405
[mk-proof] #4408 proof-bind #4407
[mk-app] #4409 = #1185 #4406
[mk-proof] #4410 quant-intro #4408 #4409
[mk-proof] #4411 mp #3866 #4410 #4406
[mk-app] #4412 or #1194 #1195
[mk-app] #4413 not #4412
[inst-discovered] theory-solving 0x0 basic# ; #1193
[mk-app] #4414 = #1193 #4413
[mk-proof] #4415 rewrite #4414
[instance] 0x0 #4414
[end-of-instance]
[mk-app] #4416 or #1191 #1192 #3465
[mk-app] #4417 not #4416
[inst-discovered] theory-solving 0x0 basic# ; #3473
[mk-app] #4418 = #3473 #4417
[mk-proof] #4419 rewrite #4418
[instance] 0x0 #4418
[end-of-instance]
[mk-app] #4420 not #2795
[mk-app] #4421 not #1224
[mk-app] #4422 or #1191 #1192 #1232 #2800 #3470 #4420 #4421
[mk-app] #4423 not #4422
[inst-discovered] theory-solving 0x0 basic# ; #3476
[mk-app] #4424 = #3476 #4423
[mk-proof] #4425 rewrite #4424
[instance] 0x0 #4424
[end-of-instance]
[mk-app] #4426 or #4413 #4417 #4423
[mk-app] #4427 = #3479 #4426
[mk-proof] #4428 monotonicity #4415 #4419 #4425 #4427
[mk-quant] #4429 k!363 2 #1217 #4426
[attach-var-names] #4429 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #4430 null 2 #4428
[mk-proof] #4431 proof-bind #4430
[mk-app] #4432 = #3482 #4429
[mk-proof] #4433 quant-intro #4431 #4432
[mk-proof] #4434 mp #3873 #4433 #4429
[mk-proof] #4435 refl #2263
[mk-app] #4435 = #2824 #2824
[mk-proof] #4436 refl #4435
[mk-app] #4435 not #1363
[mk-app] #4436 not #1371
[mk-app] #4437 or #4435 #4436
[mk-app] #4438 not #4437
[inst-discovered] theory-solving 0x0 basic# ; #1376
[mk-app] #4439 = #1376 #4438
[mk-proof] #4440 rewrite #4439
[instance] 0x0 #4439
[end-of-instance]
[mk-quant] #4441 $Seq[Int]_prog.ranged_seq_length 2 #1329 #4438
[attach-var-names] #4441 (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #4442 null 2 #4440
[mk-proof] #4443 proof-bind #4442
[mk-app] #4444 = #1379 #4441
[mk-proof] #4445 quant-intro #4443 #4444
[mk-proof] #4446 mp #3894 #4445 #4441
[mk-app] #4447 or #619 #1410
[mk-app] #4448 not #4447
[inst-discovered] theory-solving 0x0 basic# ; #1418
[mk-app] #4449 = #1418 #4448
[mk-proof] #4450 rewrite #4449
[instance] 0x0 #4449
[end-of-instance]
[mk-app] #4451 not #4448
[mk-app] #4452 = #1437 #4451
[mk-proof] #4453 monotonicity #4450 #4452
[inst-discovered] theory-solving 0x0 basic# ; #4451
[mk-app] #4454 = #4451 #4447
[mk-proof] #4455 rewrite #4454
[instance] 0x0 #4454
[end-of-instance]
[mk-app] #4456 = #1437 #4447
[mk-proof] #4457 trans #4453 #4455 #4456
[mk-app] #4458 or #4447 #1427
[mk-app] #4459 = #1438 #4458
[mk-proof] #4460 monotonicity #4457 #4459
[mk-app] #4461 or #619 #1410 #1427
[inst-discovered] theory-solving 0x0 basic# ; #4458
[mk-app] #4462 = #4458 #4461
[mk-proof] #4463 rewrite #4462
[instance] 0x0 #4462
[end-of-instance]
[mk-app] #4464 = #1438 #4461
[mk-proof] #4465 trans #4460 #4463 #4464
[mk-quant] #4466 $Seq[Int]_prog.ranged_seq_index 3 #1393 #4461
[attach-var-names] #4466 (|j| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #4467 null 3 #4465
[mk-proof] #4468 proof-bind #4467
[mk-app] #4469 = #1443 #4466
[mk-proof] #4470 quant-intro #4468 #4469
[mk-proof] #4471 mp #3901 #4470 #4466
[mk-app] #4472 not #1456
[mk-app] #4473 or #4472 #663
[mk-app] #4474 not #4473
[inst-discovered] theory-solving 0x0 basic# ; #1460
[mk-app] #4475 = #1460 #4474
[mk-proof] #4476 rewrite #4475
[instance] 0x0 #4475
[end-of-instance]
[mk-app] #4477 = #1449 #4474
[mk-app] #4478 = #1463 #4477
[mk-proof] #4479 monotonicity #4476 #4478
[mk-quant] #4480 $Seq[Int]_prog.ranged_seq_contains 3 #1453 #4477
[attach-var-names] #4480 (|v| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #4481 null 3 #4479
[mk-proof] #4482 proof-bind #4481
[mk-app] #4483 = #1466 #4480
[mk-proof] #4484 quant-intro #4482 #4483
[mk-proof] #4485 mp #3908 #4484 #4480
[mk-app] #4486 = #3568 #3568
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2281
[mk-app] #4486 = #1522 #1522
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #2326 #2326
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3632 #4487 #2326
[mk-proof] #4486 mp #3575 #2138 #50
[mk-proof] #4486 mp #3582 #2141 #57
[mk-proof] #4486 mp #3589 #2144 #63
[mk-proof] #4486 mp #3596 #2147 #70
[mk-proof] #4486 mp #3603 #2150 #76
[mk-app] #4486 = #2334 #2334
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3610 #4487 #2334
[mk-proof] #4486 mp #3617 #2156 #88
[mk-proof] #4486 mp #3636 #2159 #95
[mk-proof] #4486 mp #3643 #2162 #101
[mk-proof] #4486 mp #3650 #2165 #108
[mk-proof] #4486 mp #3657 #2168 #114
[mk-app] #4486 = #124 #124
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3664 #4487 #124
[mk-proof] #4486 mp #2175 #2174 #132
[mk-proof] #4486 mp #3671 #2177 #143
[mk-proof] #4486 mp #3678 #2180 #154
[mk-app] #4486 = #3943 #3943
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3948 #4487 #3943
[mk-app] #4486 = #3955 #3955
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3960 #4487 #3955
[mk-app] #4486 = #2941 #2941
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3699 #4487 #2941
[mk-app] #4486 = #237 #237
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3706 #4487 #237
[mk-app] #4486 = #263 #263
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3713 #4487 #263
[mk-app] #4486 = #3980 #3980
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3985 #4487 #3980
[mk-app] #4486 = #4011 #4011
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4016 #4487 #4011
[mk-app] #4486 = #4042 #4042
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4047 #4487 #4042
[mk-app] #4486 = #4068 #4068
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4073 #4487 #4068
[mk-app] #4486 = #4099 #4099
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4104 #4487 #4099
[mk-app] #4486 = #4125 #4125
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4130 #4487 #4125
[mk-app] #4486 = #4150 #4150
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4155 #4487 #4150
[mk-app] #4486 = #4179 #4179
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4184 #4487 #4179
[mk-app] #4486 = #4210 #4210
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4215 #4487 #4210
[mk-app] #4486 = #4241 #4241
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4246 #4487 #4241
[mk-app] #4486 = #4266 #4266
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4271 #4487 #4266
[mk-app] #4486 = #4296 #4296
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4301 #4487 #4296
[mk-app] #4486 = #4310 #4310
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4315 #4487 #4310
[mk-app] #4486 = #4340 #4340
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4345 #4487 #4340
[mk-proof] #4486 mp #3824 #2240 #1023
[mk-proof] #4486 mp #3831 #2243 #1037
[mk-app] #4486 = #1058 #1058
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3838 #4487 #1058
[mk-app] #4486 = #1076 #1076
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3845 #4487 #1076
[mk-app] #4486 = #4355 #4355
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4360 #4487 #4355
[mk-app] #4486 = #4381 #4381
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4386 #4487 #4381
[mk-app] #4486 = #4406 #4406
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4411 #4487 #4406
[mk-app] #4486 = #4429 #4429
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4434 #4487 #4429
[mk-proof] #4486 mp #3880 #2264 #1306
[mk-app] #4486 = #2824 #2824
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3887 #4487 #2824
[mk-app] #4486 = #4441 #4441
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4446 #4487 #4441
[mk-app] #4486 = #4466 #4466
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4471 #4487 #4466
[mk-app] #4486 = #4480 #4480
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #4485 #4487 #4480
[mk-app] #4486 = #3568 #3568
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3915 #4487 #3568
[mk-proof] #4486 mp #3922 #2282 #1495
[mk-app] #4486 = #1522 #1522
[mk-proof] #4487 rewrite #4486
[mk-proof] #4488 mp #3929 #4487 #1522
[mk-app] #4486 = #2326 #2326
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2137
[mk-proof] #4486 refl #2140
[mk-proof] #4486 refl #2143
[mk-proof] #4486 refl #2146
[mk-proof] #4486 refl #2149
[mk-app] #4486 = #2334 #2334
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2155
[mk-proof] #4486 refl #2158
[mk-proof] #4486 refl #2161
[mk-proof] #4486 refl #2164
[mk-proof] #4486 refl #2167
[mk-app] #4486 = #124 #124
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2173
[mk-proof] #4486 refl #2176
[mk-proof] #4486 refl #2179
[mk-app] #4486 = #3943 #3943
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #3955 #3955
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #2941 #2941
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #237 #237
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #263 #263
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #3980 #3980
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4011 #4011
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4042 #4042
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4068 #4068
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4099 #4099
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4125 #4125
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4150 #4150
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4179 #4179
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4210 #4210
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4241 #4241
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4266 #4266
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4296 #4296
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4310 #4310
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4340 #4340
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2239
[mk-proof] #4486 refl #2242
[mk-app] #4486 = #1058 #1058
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #1076 #1076
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4355 #4355
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4381 #4381
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4406 #4406
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4429 #4429
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2263
[mk-app] #4486 = #2824 #2824
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4441 #4441
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4466 #4466
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4480 #4480
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #3568 #3568
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2281
[mk-app] #4486 = #1522 #1522
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #2326 #2326
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2137
[mk-proof] #4486 refl #2140
[mk-proof] #4486 refl #2143
[mk-proof] #4486 refl #2146
[mk-proof] #4486 refl #2149
[mk-app] #4486 = #2334 #2334
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2155
[mk-proof] #4486 refl #2158
[mk-proof] #4486 refl #2161
[mk-proof] #4486 refl #2164
[mk-proof] #4486 refl #2167
[mk-app] #4486 = #124 #124
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2173
[mk-proof] #4486 refl #2176
[mk-proof] #4486 refl #2179
[mk-app] #4486 = #3943 #3943
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #3955 #3955
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #2941 #2941
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #237 #237
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #263 #263
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #3980 #3980
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4011 #4011
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4042 #4042
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4068 #4068
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4099 #4099
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4125 #4125
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4150 #4150
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4179 #4179
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4210 #4210
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4241 #4241
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4266 #4266
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4296 #4296
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4310 #4310
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4340 #4340
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2239
[mk-proof] #4486 refl #2242
[mk-app] #4486 = #1058 #1058
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #1076 #1076
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4355 #4355
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4381 #4381
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4406 #4406
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4429 #4429
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2263
[mk-app] #4486 = #2824 #2824
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4441 #4441
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4466 #4466
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #4480 #4480
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #3568 #3568
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2281
[mk-app] #4486 = #1522 #1522
[mk-proof] #4487 refl #4486
[mk-app] #4486 = #2326 #2326
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2137
[mk-proof] #4486 refl #2140
[mk-proof] #4486 refl #2143
[mk-proof] #4486 refl #2146
[mk-proof] #4486 refl #2149
[mk-app] #4486 = #2334 #2334
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2155
[mk-proof] #4486 refl #2158
[mk-proof] #4486 refl #2161
[mk-proof] #4486 refl #2164
[mk-proof] #4486 refl #2167
[mk-app] #4486 = #124 #124
[mk-proof] #4487 refl #4486
[mk-proof] #4486 refl #2173
[mk-proof] #4486 refl #2176
[mk-proof] #4486 refl #2179
[mk-app] #4486 = #3943 #3943
[mk-proof] #4487 refl #4486
[inst-discovered] theory-solving 0x0 basic# ; #3951
[mk-app] #4486 = #3951 #3951
[mk-proof] #4487 rewrite #4486
[instance] 0x0 #4486
[end-of-instance]
[mk-app] #4488 = #3952 #3952
[mk-proof] #4489 monotonicity #4487 #4488
[mk-app] #4490 = #3955 #3955
[mk-proof] #4491 refl #4490
[mk-app] #4490 = #2941 #2941
[mk-proof] #4491 refl #4490
[mk-app] #4490 = #237 #237
[mk-proof] #4491 refl #4490
[mk-app] #4490 = #263 #263
[mk-proof] #4491 refl #4490
[inst-discovered] theory-solving 0x0 basic# ; #3975
[mk-app] #4490 = #3975 #3975
[mk-proof] #4491 rewrite #4490
[instance] 0x0 #4490
[end-of-instance]
[mk-app] #4492 = #3980 #3980
[mk-proof] #4493 refl #4492
[inst-discovered] theory-solving 0x0 basic# ; #3999
[mk-app] #4492 = #3999 #3999
[mk-proof] #4493 rewrite #4492
[instance] 0x0 #4492
[end-of-instance]
[mk-app] #4494 = #4000 #4000
[mk-proof] #4495 monotonicity #4493 #4494
[mk-app] #4496 = #4006 #4006
[mk-proof] #4497 monotonicity #4495 #4496
[inst-discovered] theory-solving 0x0 basic# ; #4006
[mk-proof] #4498 rewrite #4496
[instance] 0x0 #4496
[end-of-instance]
[mk-proof] #4499 trans #4497 #4498 #4496
[mk-app] #4500 = #4011 #4011
[mk-proof] #4501 refl #4500
[inst-discovered] theory-solving 0x0 basic# ; #4030
[mk-app] #4500 = #4030 #4030
[mk-proof] #4501 rewrite #4500
[instance] 0x0 #4500
[end-of-instance]
[mk-app] #4502 = #4031 #4031
[mk-proof] #4503 monotonicity #4501 #4502
[mk-app] #4504 = #4037 #4037
[mk-proof] #4505 monotonicity #4503 #4504
[inst-discovered] theory-solving 0x0 basic# ; #4037
[mk-proof] #4506 rewrite #4504
[instance] 0x0 #4504
[end-of-instance]
[mk-proof] #4507 trans #4505 #4506 #4504
[mk-app] #4508 = #4042 #4042
[mk-proof] #4509 refl #4508
[inst-discovered] theory-solving 0x0 basic# ; #4063
[mk-app] #4508 = #4063 #4063
[mk-proof] #4509 rewrite #4508
[instance] 0x0 #4508
[end-of-instance]
[mk-app] #4510 = #4068 #4068
[mk-proof] #4511 refl #4510
[inst-discovered] theory-solving 0x0 basic# ; #4087
[mk-app] #4510 = #4087 #4087
[mk-proof] #4511 rewrite #4510
[instance] 0x0 #4510
[end-of-instance]
[mk-app] #4512 = #4088 #4088
[mk-proof] #4513 monotonicity #4511 #4512
[mk-app] #4514 = #4094 #4094
[mk-proof] #4515 monotonicity #4513 #4514
[inst-discovered] theory-solving 0x0 basic# ; #4094
[mk-proof] #4516 rewrite #4514
[instance] 0x0 #4514
[end-of-instance]
[mk-proof] #4517 trans #4515 #4516 #4514
[mk-app] #4518 = #4099 #4099
[mk-proof] #4519 refl #4518
[inst-discovered] theory-solving 0x0 basic# ; #4119
[mk-app] #4518 = #4119 #4119
[mk-proof] #4519 rewrite #4518
[instance] 0x0 #4518
[end-of-instance]
[mk-app] #4520 = #4120 #4120
[mk-proof] #4521 monotonicity #4519 #4520
[mk-app] #4522 = #4125 #4125
[mk-proof] #4523 refl #4522
[inst-discovered] theory-solving 0x0 basic# ; #4145
[mk-app] #4522 = #4145 #4145
[mk-proof] #4523 rewrite #4522
[instance] 0x0 #4522
[end-of-instance]
[mk-app] #4524 = #4150 #4150
[mk-proof] #4525 refl #4524
[mk-app] #4524 = #4159 #4159
[mk-proof] #4525 monotonicity #2581 #4524
[mk-app] #4526 = #4160 #4160
[mk-proof] #4527 monotonicity #4525 #4526
[inst-discovered] theory-solving 0x0 basic# ; #4160
[mk-proof] #4528 rewrite #4526
[instance] 0x0 #4526
[end-of-instance]
[mk-proof] #4529 trans #4527 #4528 #4526
[mk-app] #4530 = #4161 #4161
[mk-proof] #4531 monotonicity #4529 #4530
[mk-app] #4532 = #4165 #4165
[mk-proof] #4533 monotonicity #4531 #4532
[mk-app] #4534 = #4171 #4171
[mk-proof] #4535 monotonicity #4533 #4534
[mk-app] #4536 = #4173 #4173
[mk-proof] #4537 monotonicity #4535 #4536
[inst-discovered] theory-solving 0x0 basic# ; #4173
[mk-proof] #4538 rewrite #4536
[instance] 0x0 #4536
[end-of-instance]
[mk-proof] #4539 trans #4537 #4538 #4536
[mk-app] #4540 = #4174 #4174
[mk-proof] #4541 monotonicity #4539 #4540
[mk-app] #4542 = #4179 #4179
[mk-proof] #4543 refl #4542
[inst-discovered] theory-solving 0x0 basic# ; #4198
[mk-app] #4542 = #4198 #4198
[mk-proof] #4543 rewrite #4542
[instance] 0x0 #4542
[end-of-instance]
[mk-app] #4544 = #4199 #4199
[mk-proof] #4545 monotonicity #4543 #4544
[mk-app] #4546 = #4205 #4205
[mk-proof] #4547 monotonicity #4545 #4546
[inst-discovered] theory-solving 0x0 basic# ; #4205
[mk-proof] #4548 rewrite #4546
[instance] 0x0 #4546
[end-of-instance]
[mk-proof] #4549 trans #4547 #4548 #4546
[mk-app] #4550 = #4210 #4210
[mk-proof] #4551 refl #4550
[inst-discovered] theory-solving 0x0 basic# ; #4229
[mk-app] #4550 = #4229 #4229
[mk-proof] #4551 rewrite #4550
[instance] 0x0 #4550
[end-of-instance]
[mk-app] #4552 = #4230 #4230
[mk-proof] #4553 monotonicity #4551 #4552
[mk-app] #4554 = #4236 #4236
[mk-proof] #4555 monotonicity #4553 #4554
[inst-discovered] theory-solving 0x0 basic# ; #4236
[mk-proof] #4556 rewrite #4554
[instance] 0x0 #4554
[end-of-instance]
[mk-proof] #4557 trans #4555 #4556 #4554
[mk-app] #4558 = #4241 #4241
[mk-proof] #4559 refl #4558
[inst-discovered] theory-solving 0x0 basic# ; #4261
[mk-app] #4558 = #4261 #4261
[mk-proof] #4559 rewrite #4558
[instance] 0x0 #4558
[end-of-instance]
[mk-app] #4560 = #4266 #4266
[mk-proof] #4561 refl #4560
[inst-discovered] theory-solving 0x0 basic# ; #4284
[mk-app] #4560 = #4284 #4284
[mk-proof] #4561 rewrite #4560
[instance] 0x0 #4560
[end-of-instance]
[mk-app] #4562 = #4285 #4285
[mk-proof] #4563 monotonicity #4561 #4562
[mk-app] #4564 = #4291 #4291
[mk-proof] #4565 monotonicity #4563 #4564
[inst-discovered] theory-solving 0x0 basic# ; #4291
[mk-proof] #4566 rewrite #4564
[instance] 0x0 #4564
[end-of-instance]
[mk-proof] #4567 trans #4565 #4566 #4564
[mk-app] #4568 = #4296 #4296
[mk-proof] #4569 refl #4568
[inst-discovered] theory-solving 0x0 basic# ; #4305
[mk-app] #4568 = #4305 #4305
[mk-proof] #4569 rewrite #4568
[instance] 0x0 #4568
[end-of-instance]
[mk-app] #4570 = #4310 #4310
[mk-proof] #4571 refl #4570
[inst-discovered] theory-solving 0x0 basic# ; #4328
[mk-app] #4570 = #4328 #4328
[mk-proof] #4571 rewrite #4570
[instance] 0x0 #4570
[end-of-instance]
[mk-app] #4572 = #4329 #4329
[mk-proof] #4573 monotonicity #4571 #4572
[mk-app] #4574 = #4335 #4335
[mk-proof] #4575 monotonicity #4573 #4574
[inst-discovered] theory-solving 0x0 basic# ; #4335
[mk-proof] #4576 rewrite #4574
[instance] 0x0 #4574
[end-of-instance]
[mk-proof] #4577 trans #4575 #4576 #4574
[mk-app] #4578 = #4340 #4340
[mk-proof] #4579 refl #4578
[mk-proof] #4578 refl #2239
[mk-proof] #4578 refl #2242
[mk-app] #4578 = #1058 #1058
[mk-proof] #4579 refl #4578
[mk-app] #4578 = #1076 #1076
[mk-proof] #4579 refl #4578
[inst-discovered] theory-solving 0x0 basic# ; #4348
[mk-app] #4578 = #4348 #4348
[mk-proof] #4579 rewrite #4578
[instance] 0x0 #4578
[end-of-instance]
[mk-app] #4580 = #4349 #4349
[mk-proof] #4581 monotonicity #4579 #4580
[mk-app] #4582 = #4352 #4352
[mk-proof] #4583 monotonicity #4581 #4582
[mk-app] #4584 = #4355 #4355
[mk-proof] #4585 refl #4584
[inst-discovered] theory-solving 0x0 basic# ; #4376
[mk-app] #4584 = #4376 #4376
[mk-proof] #4585 rewrite #4584
[instance] 0x0 #4584
[end-of-instance]
[mk-app] #4586 = #4381 #4381
[mk-proof] #4587 refl #4586
[inst-discovered] theory-solving 0x0 basic# ; #4401
[mk-app] #4586 = #4401 #4401
[mk-proof] #4587 rewrite #4586
[instance] 0x0 #4586
[end-of-instance]
[mk-app] #4588 = #4406 #4406
[mk-proof] #4589 refl #4588
[inst-discovered] theory-solving 0x0 basic# ; #4422
[mk-app] #4588 = #4422 #4422
[mk-proof] #4589 rewrite #4588
[instance] 0x0 #4588
[end-of-instance]
[mk-app] #4590 = #4423 #4423
[mk-proof] #4591 monotonicity #4589 #4590
[mk-app] #4592 = #4426 #4426
[mk-proof] #4593 monotonicity #4591 #4592
[mk-app] #4594 = #4429 #4429
[mk-proof] #4595 refl #4594
[mk-proof] #4594 refl #2263
[mk-app] #4594 = #2824 #2824
[mk-proof] #4595 refl #4594
[inst-discovered] theory-solving 0x0 basic# ; #4437
[mk-app] #4594 = #4437 #4437
[mk-proof] #4595 rewrite #4594
[instance] 0x0 #4594
[end-of-instance]
[mk-app] #4596 = #4438 #4438
[mk-proof] #4597 monotonicity #4595 #4596
[mk-app] #4598 = #4441 #4441
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4466 #4466
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4480 #4480
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #3568 #3568
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2281
[mk-app] #4598 = #1522 #1522
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #2326 #2326
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2137
[mk-proof] #4598 refl #2140
[mk-proof] #4598 refl #2143
[mk-proof] #4598 refl #2146
[mk-proof] #4598 refl #2149
[mk-app] #4598 = #2334 #2334
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2155
[mk-proof] #4598 refl #2158
[mk-proof] #4598 refl #2161
[mk-proof] #4598 refl #2164
[mk-proof] #4598 refl #2167
[mk-app] #4598 = #124 #124
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2173
[mk-proof] #4598 refl #2176
[mk-proof] #4598 refl #2179
[mk-app] #4598 = #3943 #3943
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #3955 #3955
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #2941 #2941
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #237 #237
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #263 #263
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #3980 #3980
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4011 #4011
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4042 #4042
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4068 #4068
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4099 #4099
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4125 #4125
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4150 #4150
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4179 #4179
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4210 #4210
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4241 #4241
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4266 #4266
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4296 #4296
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4310 #4310
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4340 #4340
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2239
[mk-proof] #4598 refl #2242
[mk-app] #4598 = #1058 #1058
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #1076 #1076
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4355 #4355
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4381 #4381
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4406 #4406
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4429 #4429
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2263
[mk-app] #4598 = #2824 #2824
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4441 #4441
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4466 #4466
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #4480 #4480
[mk-proof] #4599 refl #4598
[mk-app] #4598 = #3568 #3568
[mk-proof] #4599 refl #4598
[mk-proof] #4598 refl #2281
[mk-app] #4598 = #1522 #1522
[mk-proof] #4599 refl #4598
[assign] #2326 justification -1: 
[assign] #50 justification -1: 
[assign] #57 justification -1: 
[assign] #63 justification -1: 
[assign] #70 justification -1: 
[assign] #76 justification -1: 
[assign] #2334 justification -1: 
[assign] #88 justification -1: 
[assign] #95 justification -1: 
[assign] #101 justification -1: 
[assign] #108 justification -1: 
[assign] #114 justification -1: 
[assign] #124 justification -1: 
[attach-enode] #130 0
[attach-enode] #131 0
[attach-enode] #36 0
[attach-enode] #132 0
[assign] #132 justification -1: 
[assign] #143 justification -1: 
[assign] #154 justification -1: 
[assign] #3943 justification -1: 
[assign] #3955 justification -1: 
[assign] #2941 justification -1: 
[assign] #237 justification -1: 
[assign] #263 justification -1: 
[assign] #3980 justification -1: 
[assign] #4011 justification -1: 
[assign] #4042 justification -1: 
[assign] #4068 justification -1: 
[assign] #4099 justification -1: 
[assign] #4125 justification -1: 
[assign] #4150 justification -1: 
[assign] #4179 justification -1: 
[assign] #4210 justification -1: 
[assign] #4241 justification -1: 
[assign] #4266 justification -1: 
[assign] #4296 justification -1: 
[assign] #4310 justification -1: 
[assign] #4340 justification -1: 
[assign] #1023 justification -1: 
[assign] #1037 justification -1: 
[assign] #1058 justification -1: 
[assign] #1076 justification -1: 
[assign] #4355 justification -1: 
[assign] #4381 justification -1: 
[assign] #4406 justification -1: 
[assign] #4429 justification -1: 
[assign] #1306 justification -1: 
[assign] #2824 justification -1: 
[assign] #4441 justification -1: 
[assign] #4466 justification -1: 
[assign] #4480 justification -1: 
[assign] #3568 justification -1: 
[assign] #1495 justification -1: 
[assign] #1522 justification -1: 
[mk-app] #4524 = #2326 #1
[mk-proof] #4525 iff-true #3632 #4524
[mk-app] #4526 = #50 #1
[mk-proof] #4527 iff-true #3575 #4526
[mk-app] #4528 = #57 #1
[mk-proof] #4529 iff-true #3582 #4528
[mk-app] #4530 = #63 #1
[mk-proof] #4531 iff-true #3589 #4530
[mk-app] #4532 = #70 #1
[mk-proof] #4533 iff-true #3596 #4532
[mk-app] #4534 = #76 #1
[mk-proof] #4535 iff-true #3603 #4534
[mk-app] #4536 = #2334 #1
[mk-proof] #4537 iff-true #3610 #4536
[mk-app] #4538 = #88 #1
[mk-proof] #4539 iff-true #3617 #4538
[mk-app] #4540 = #95 #1
[mk-proof] #4541 iff-true #3636 #4540
[mk-app] #4500 = #101 #1
[mk-proof] #4501 iff-true #3643 #4500
[mk-app] #4502 = #108 #1
[mk-proof] #4503 iff-true #3650 #4502
[mk-app] #4504 = #114 #1
[mk-proof] #4505 iff-true #3657 #4504
[mk-app] #4506 = #124 #1
[mk-proof] #4507 iff-true #3664 #4506
[mk-app] #4492 = #143 #1
[mk-proof] #4493 iff-true #3671 #4492
[mk-app] #4494 = #154 #1
[mk-proof] #4495 iff-true #3678 #4494
[mk-app] #4560 = #3943 #1
[mk-proof] #4561 iff-true #3948 #4560
[mk-app] #4562 = #3955 #1
[mk-proof] #4563 iff-true #3960 #4562
[mk-app] #4564 = #2941 #1
[mk-proof] #4565 iff-true #3699 #4564
[mk-app] #4566 = #237 #1
[mk-proof] #4567 iff-true #3706 #4566
[mk-app] #4518 = #263 #1
[mk-proof] #4519 iff-true #3713 #4518
[mk-app] #4520 = #3980 #1
[mk-proof] #4521 iff-true #3985 #4520
[mk-app] #4496 = #4011 #1
[mk-proof] #4497 iff-true #4016 #4496
[mk-app] #4498 = #4042 #1
[mk-proof] #4499 iff-true #4047 #4498
[mk-app] #4510 = #4068 #1
[mk-proof] #4511 iff-true #4073 #4510
[mk-app] #4512 = #4099 #1
[mk-proof] #4513 iff-true #4104 #4512
[mk-app] #4514 = #4125 #1
[mk-proof] #4515 iff-true #4130 #4514
[mk-app] #4516 = #4150 #1
[mk-proof] #4517 iff-true #4155 #4516
[mk-app] #4588 = #4179 #1
[mk-proof] #4589 iff-true #4184 #4588
[mk-app] #4590 = #4210 #1
[mk-proof] #4591 iff-true #4215 #4590
[mk-app] #4592 = #4241 #1
[mk-proof] #4593 iff-true #4246 #4592
[mk-app] #4550 = #4266 #1
[mk-proof] #4551 iff-true #4271 #4550
[mk-app] #4552 = #4296 #1
[mk-proof] #4553 iff-true #4301 #4552
[mk-app] #4554 = #4310 #1
[mk-proof] #4555 iff-true #4315 #4554
[mk-app] #4556 = #4340 #1
[mk-proof] #4557 iff-true #4345 #4556
[mk-app] #4570 = #1023 #1
[mk-proof] #4571 iff-true #3824 #4570
[mk-app] #4572 = #1037 #1
[mk-proof] #4573 iff-true #3831 #4572
[mk-app] #4508 = #1058 #1
[mk-proof] #4509 iff-true #3838 #4508
[mk-app] #4568 = #1076 #1
[mk-proof] #4569 iff-true #3845 #4568
[mk-app] #4578 = #4355 #1
[mk-proof] #4579 iff-true #4360 #4578
[mk-app] #4580 = #4381 #1
[mk-proof] #4581 iff-true #4386 #4580
[mk-app] #4582 = #4406 #1
[mk-proof] #4583 iff-true #4411 #4582
[mk-app] #4574 = #4429 #1
[mk-proof] #4575 iff-true #4434 #4574
[mk-app] #4576 = #1306 #1
[mk-proof] #4577 iff-true #3880 #4576
[mk-app] #4542 = #2824 #1
[mk-proof] #4543 iff-true #3887 #4542
[mk-app] #4544 = #4441 #1
[mk-proof] #4545 iff-true #4446 #4544
[mk-app] #4546 = #4466 #1
[mk-proof] #4547 iff-true #4471 #4546
[mk-app] #4548 = #4480 #1
[mk-proof] #4549 iff-true #4485 #4548
[mk-app] #4558 = #3568 #1
[mk-proof] #4559 iff-true #3915 #4558
[mk-app] #4522 = #1495 #1
[mk-proof] #4523 iff-true #3922 #4522
[mk-app] #4594 = #1522 #1
[mk-proof] #4595 iff-true #3929 #4594
[eq-expl] #130 root
[new-match] 0x1280abde0 #124 #118 #130 ; #131
[new-match] 0x1280abe10 #143 #118 #130 ; #131
[mk-app] #4596 >= #131 #36
[mk-app] #4597 = #4596 #4596
[mk-proof] #4490 refl #4597
[mk-app] #4491 not #124
[mk-app] #4586 or #4491 #4596
[mk-proof] #4587 quant-inst #4586
[instance] 0x1280abde0 #4587 ; 1
[assign] #4596 justification -1: p13
[end-of-instance]
[mk-app] #4597 <= #131 #36
[assign] #4597 justification -1: p14
[mk-app] #4490 Seq<Int>!val!0
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #5 bv #b1
[attach-meaning] #6 bv #b0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[attach-meaning] #6 bv #b0
[attach-enode] #1 0
[attach-enode] #2 0
[mk-app] #2129 = #43 #43
[mk-proof] #2130 refl #2129
[mk-app] #2129 = #43 #1
[mk-proof] #2130 iff-true #44 #2129
[mk-app] #2128 = #50 #50
[mk-proof] #2131 refl #2128
[mk-app] #2128 = #50 #1
[mk-proof] #2131 iff-true #51 #2128
[mk-app] #2132 = #57 #57
[mk-proof] #2133 refl #2132
[mk-app] #2132 = #57 #1
[mk-proof] #2133 iff-true #58 #2132
[mk-app] #2284 = #63 #63
[mk-proof] #2285 refl #2284
[mk-app] #2284 = #63 #1
[mk-proof] #2285 iff-true #64 #2284
[mk-app] #2286 = #70 #70
[mk-proof] #2906 refl #2286
[mk-app] #2286 = #70 #1
[mk-proof] #2906 iff-true #71 #2286
[mk-app] #2907 = #76 #76
[mk-proof] #2908 refl #2907
[mk-app] #2907 = #76 #1
[mk-proof] #2908 iff-true #77 #2907
[mk-app] #2909 = #82 #82
[mk-proof] #2910 refl #2909
[mk-app] #2909 = #82 #1
[mk-proof] #2910 iff-true #83 #2909
[mk-app] #2281 = #88 #88
[mk-proof] #2282 refl #2281
[mk-app] #2281 = #88 #1
[mk-proof] #2282 iff-true #89 #2281
[mk-app] #2283 = #95 #95
[mk-proof] #2278 refl #2283
[mk-app] #2283 = #95 #1
[mk-proof] #2278 iff-true #96 #2283
[mk-app] #2279 = #101 #101
[mk-proof] #2280 refl #2279
[mk-app] #2279 = #101 #1
[mk-proof] #2280 iff-true #102 #2279
[mk-app] #2898 = #108 #108
[mk-proof] #2899 refl #2898
[mk-app] #2898 = #108 #1
[mk-proof] #2899 iff-true #109 #2898
[mk-app] #2901 = #114 #114
[mk-proof] #2902 refl #2901
[mk-app] #2901 = #114 #1
[mk-proof] #2902 iff-true #115 #2901
[mk-app] #2903 = #124 #124
[mk-proof] #2904 refl #2903
[mk-app] #2903 = #124 #1
[mk-proof] #2904 iff-true #129 #2903
[mk-app] #2905 = #132 #132
[mk-proof] #2116 refl #2905
[mk-app] #2905 = #143 #143
[mk-proof] #2116 refl #2905
[mk-app] #2905 = #143 #1
[mk-proof] #2116 iff-true #148 #2905
[mk-app] #2117 = #154 #154
[mk-proof] #2118 refl #2117
[mk-app] #2117 = #154 #1
[mk-proof] #2118 iff-true #155 #2117
[mk-app] #2119 = #193 #193
[mk-proof] #2120 refl #2119
[mk-app] #2119 = #193 #1
[mk-proof] #2120 iff-true #198 #2119
[mk-app] #2121 = #216 #216
[mk-proof] #2123 refl #2121
[mk-app] #2121 = #216 #1
[mk-proof] #2123 iff-true #221 #2121
[mk-app] #2124 = #224 #224
[mk-proof] #2122 refl #2124
[mk-app] #2124 = #224 #1
[mk-proof] #2122 iff-true #225 #2124
[mk-app] #2125 = #237 #237
[mk-proof] #2126 refl #2125
[mk-app] #2125 = #237 #1
[mk-proof] #2126 iff-true #242 #2125
[mk-app] #2127 = #263 #263
[mk-proof] #2275 refl #2127
[mk-app] #2127 = #263 #1
[mk-proof] #2275 iff-true #268 #2127
[mk-app] #2276 = #332 #332
[mk-proof] #2277 refl #2276
[mk-app] #2276 = #332 #1
[mk-proof] #2277 iff-true #337 #2276
[mk-app] #2882 = #394 #394
[mk-proof] #2883 refl #2882
[mk-app] #2882 = #394 #1
[mk-proof] #2883 iff-true #399 #2882
[mk-app] #2885 = #457 #457
[mk-proof] #2886 refl #2885
[mk-app] #2885 = #457 #1
[mk-proof] #2886 iff-true #462 #2885
[mk-app] #2888 = #502 #502
[mk-proof] #2889 refl #2888
[mk-app] #2888 = #502 #1
[mk-proof] #2889 iff-true #507 #2888
[mk-app] #2891 = #563 #563
[mk-proof] #2892 refl #2891
[mk-app] #2891 = #563 #1
[mk-proof] #2892 iff-true #568 #2891
[mk-app] #2893 = #643 #643
[mk-proof] #2894 refl #2893
[mk-app] #2893 = #643 #1
[mk-proof] #2894 iff-true #648 #2893
[mk-app] #2895 = #691 #691
[mk-proof] #2098 refl #2895
[mk-app] #2895 = #691 #1
[mk-proof] #2098 iff-true #696 #2895
[inst-discovered] theory-solving 0x0 basic# ; #741
[mk-app] #2099 = #741 #741
[mk-proof] #2100 rewrite #2099
[instance] 0x0 #2099
[end-of-instance]
[mk-app] #2101 = #746 #746
[mk-proof] #2102 monotonicity #2100 #2101
[mk-app] #2103 = #752 #752
[mk-proof] #2104 monotonicity #2102 #2103
[mk-app] #2105 = #765 #765
[mk-proof] #2106 monotonicity #2104 #2105
[mk-app] #2107 = #768 #768
[mk-proof] #2108 refl #2107
[mk-app] #2107 = #768 #1
[mk-proof] #2108 iff-true #773 #2107
[mk-app] #2109 = #842 #842
[mk-proof] #2111 refl #2109
[mk-app] #2109 = #842 #1
[mk-proof] #2111 iff-true #847 #2109
[mk-app] #2112 = #880 #880
[mk-proof] #2110 refl #2112
[mk-app] #2112 = #880 #1
[mk-proof] #2110 iff-true #885 #2112
[mk-app] #2113 = #915 #915
[mk-proof] #2114 refl #2113
[mk-app] #2113 = #915 #1
[mk-proof] #2114 iff-true #920 #2113
[mk-app] #2115 = #962 #962
[mk-proof] #2272 refl #2115
[mk-app] #2115 = #962 #1
[mk-proof] #2272 iff-true #967 #2115
[mk-app] #2273 = #984 #984
[mk-proof] #2274 refl #2273
[mk-app] #2273 = #984 #1
[mk-proof] #2274 iff-true #989 #2273
[mk-app] #2857 = #1009 #1009
[mk-proof] #2858 refl #2857
[mk-app] #2857 = #1009 #1
[mk-proof] #2858 iff-true #1014 #2857
[mk-app] #2860 = #1023 #1023
[mk-proof] #2861 refl #2860
[mk-app] #2860 = #1023 #1
[mk-proof] #2861 iff-true #1028 #2860
[mk-app] #2863 = #1037 #1037
[mk-proof] #2864 refl #2863
[mk-app] #2863 = #1037 #1
[mk-proof] #2864 iff-true #1042 #2863
[mk-app] #2866 = #1058 #1058
[mk-proof] #2867 refl #2866
[mk-app] #2866 = #1058 #1
[mk-proof] #2867 iff-true #1063 #2866
[mk-app] #2870 = #1076 #1076
[mk-proof] #2871 refl #2870
[mk-app] #2870 = #1076 #1
[mk-proof] #2871 iff-true #1081 #2870
[mk-app] #2873 = #1131 #1131
[mk-proof] #2874 refl #2873
[mk-app] #2873 = #1131 #1
[mk-proof] #2874 iff-true #1136 #2873
[mk-app] #2876 = #1165 #1165
[mk-proof] #2877 refl #2876
[mk-app] #2876 = #1165 #1
[mk-proof] #2877 iff-true #1170 #2876
[mk-app] #2878 = #1185 #1185
[mk-proof] #2879 refl #2878
[mk-app] #2878 = #1185 #1
[mk-proof] #2879 iff-true #1190 #2878
[mk-app] #2880 = #1294 #1294
[mk-proof] #2075 refl #2880
[mk-app] #2880 = #1294 #1
[mk-proof] #2075 iff-true #1299 #2880
[mk-app] #2076 = #1306 #1306
[mk-proof] #2077 refl #2076
[mk-app] #2076 = #1306 #1
[mk-proof] #2077 iff-true #1311 #2076
[mk-app] #2078 = #1317 #1317
[mk-proof] #2079 refl #2078
[mk-app] #2078 = #1317 #1
[mk-proof] #2079 iff-true #1318 #2078
[mk-app] #2080 = #1379 #1379
[mk-proof] #2081 refl #2080
[mk-app] #2080 = #1379 #1
[mk-proof] #2081 iff-true #1384 #2080
[mk-app] #2082 = #1443 #1443
[mk-proof] #2083 refl #2082
[mk-app] #2082 = #1443 #1
[mk-proof] #2083 iff-true #1448 #2082
[mk-app] #2084 = #1466 #1466
[mk-proof] #2085 refl #2084
[mk-app] #2084 = #1466 #1
[mk-proof] #2085 iff-true #1471 #2084
[mk-app] #2086 = #1477 #1477
[mk-proof] #2087 refl #2086
[mk-app] #2086 = #1477 #1
[mk-proof] #2087 iff-true #1478 #2086
[mk-app] #2088 = #1495 #1495
[mk-proof] #2089 refl #2088
[mk-app] #2088 = #1495 #1
[mk-proof] #2089 iff-true #1500 #2088
[mk-app] #2090 = #1522 #1522
[mk-proof] #2091 refl #2090
[mk-app] #2090 = #1522 #1
[mk-proof] #2091 iff-true #1527 #2090
[mk-app] #2090 = #1522 #1522
[mk-proof] #2091 refl #2090
[mk-app] #2090 = #1522 #1
[mk-proof] #2091 iff-true #1527 #2090
[mk-app] #2088 = #1495 #1495
[mk-proof] #2089 refl #2088
[mk-app] #2088 = #1495 #1
[mk-proof] #2089 iff-true #1500 #2088
[mk-app] #2086 = #1477 #1477
[mk-proof] #2087 refl #2086
[mk-app] #2086 = #1477 #1
[mk-proof] #2087 iff-true #1478 #2086
[mk-app] #2084 = #1466 #1466
[mk-proof] #2085 refl #2084
[mk-app] #2084 = #1466 #1
[mk-proof] #2085 iff-true #1471 #2084
[mk-app] #2082 = #1443 #1443
[mk-proof] #2083 refl #2082
[mk-app] #2082 = #1443 #1
[mk-proof] #2083 iff-true #1448 #2082
[mk-app] #2080 = #1379 #1379
[mk-proof] #2081 refl #2080
[mk-app] #2080 = #1379 #1
[mk-proof] #2081 iff-true #1384 #2080
[mk-app] #2078 = #1317 #1317
[mk-proof] #2079 refl #2078
[mk-app] #2078 = #1317 #1
[mk-proof] #2079 iff-true #1318 #2078
[mk-app] #2076 = #1306 #1306
[mk-proof] #2077 refl #2076
[mk-app] #2076 = #1306 #1
[mk-proof] #2077 iff-true #1311 #2076
[mk-app] #2880 = #1294 #1294
[mk-proof] #2075 refl #2880
[mk-app] #2880 = #1294 #1
[mk-proof] #2075 iff-true #1299 #2880
[mk-app] #2878 = #1185 #1185
[mk-proof] #2879 refl #2878
[mk-app] #2878 = #1185 #1
[mk-proof] #2879 iff-true #1190 #2878
[mk-app] #2876 = #1165 #1165
[mk-proof] #2877 refl #2876
[mk-app] #2876 = #1165 #1
[mk-proof] #2877 iff-true #1170 #2876
[mk-app] #2873 = #1131 #1131
[mk-proof] #2874 refl #2873
[mk-app] #2873 = #1131 #1
[mk-proof] #2874 iff-true #1136 #2873
[mk-app] #2870 = #1076 #1076
[mk-proof] #2871 refl #2870
[mk-app] #2870 = #1076 #1
[mk-proof] #2871 iff-true #1081 #2870
[mk-app] #2866 = #1058 #1058
[mk-proof] #2867 refl #2866
[mk-app] #2866 = #1058 #1
[mk-proof] #2867 iff-true #1063 #2866
[mk-app] #2863 = #1037 #1037
[mk-proof] #2864 refl #2863
[mk-app] #2863 = #1037 #1
[mk-proof] #2864 iff-true #1042 #2863
[mk-app] #2860 = #1023 #1023
[mk-proof] #2861 refl #2860
[mk-app] #2860 = #1023 #1
[mk-proof] #2861 iff-true #1028 #2860
[mk-app] #2857 = #1009 #1009
[mk-proof] #2858 refl #2857
[mk-app] #2857 = #1009 #1
[mk-proof] #2858 iff-true #1014 #2857
[mk-app] #2273 = #984 #984
[mk-proof] #2274 refl #2273
[mk-app] #2273 = #984 #1
[mk-proof] #2274 iff-true #989 #2273
[mk-app] #2115 = #962 #962
[mk-proof] #2272 refl #2115
[mk-app] #2115 = #962 #1
[mk-proof] #2272 iff-true #967 #2115
[mk-app] #2113 = #915 #915
[mk-proof] #2114 refl #2113
[mk-app] #2113 = #915 #1
[mk-proof] #2114 iff-true #920 #2113
[mk-app] #2112 = #880 #880
[mk-proof] #2110 refl #2112
[mk-app] #2112 = #880 #1
[mk-proof] #2110 iff-true #885 #2112
[mk-app] #2109 = #842 #842
[mk-proof] #2111 refl #2109
[mk-app] #2109 = #842 #1
[mk-proof] #2111 iff-true #847 #2109
[inst-discovered] theory-solving 0x0 basic# ; #741
[mk-app] #2107 = #741 #741
[mk-proof] #2108 rewrite #2107
[instance] 0x0 #2107
[end-of-instance]
[mk-app] #2895 = #746 #746
[mk-proof] #2098 monotonicity #2108 #2895
[mk-app] #2893 = #752 #752
[mk-proof] #2894 monotonicity #2098 #2893
[mk-app] #2891 = #765 #765
[mk-proof] #2892 monotonicity #2894 #2891
[mk-app] #2888 = #768 #768
[mk-proof] #2889 refl #2888
[mk-app] #2888 = #768 #1
[mk-proof] #2889 iff-true #773 #2888
[mk-app] #2885 = #691 #691
[mk-proof] #2886 refl #2885
[mk-app] #2885 = #691 #1
[mk-proof] #2886 iff-true #696 #2885
[mk-app] #2882 = #643 #643
[mk-proof] #2883 refl #2882
[mk-app] #2882 = #643 #1
[mk-proof] #2883 iff-true #648 #2882
[mk-app] #2276 = #563 #563
[mk-proof] #2277 refl #2276
[mk-app] #2276 = #563 #1
[mk-proof] #2277 iff-true #568 #2276
[mk-app] #2127 = #502 #502
[mk-proof] #2275 refl #2127
[mk-app] #2127 = #502 #1
[mk-proof] #2275 iff-true #507 #2127
[mk-app] #2125 = #457 #457
[mk-proof] #2126 refl #2125
[mk-app] #2125 = #457 #1
[mk-proof] #2126 iff-true #462 #2125
[mk-app] #2124 = #394 #394
[mk-proof] #2122 refl #2124
[mk-app] #2124 = #394 #1
[mk-proof] #2122 iff-true #399 #2124
[mk-app] #2121 = #332 #332
[mk-proof] #2123 refl #2121
[mk-app] #2121 = #332 #1
[mk-proof] #2123 iff-true #337 #2121
[mk-app] #2119 = #263 #263
[mk-proof] #2120 refl #2119
[mk-app] #2119 = #263 #1
[mk-proof] #2120 iff-true #268 #2119
[mk-app] #2117 = #237 #237
[mk-proof] #2118 refl #2117
[mk-app] #2117 = #237 #1
[mk-proof] #2118 iff-true #242 #2117
[mk-app] #2905 = #224 #224
[mk-proof] #2116 refl #2905
[mk-app] #2905 = #224 #1
[mk-proof] #2116 iff-true #225 #2905
[mk-app] #2903 = #216 #216
[mk-proof] #2904 refl #2903
[mk-app] #2903 = #216 #1
[mk-proof] #2904 iff-true #221 #2903
[mk-app] #2901 = #193 #193
[mk-proof] #2902 refl #2901
[mk-app] #2901 = #193 #1
[mk-proof] #2902 iff-true #198 #2901
[mk-app] #2898 = #154 #154
[mk-proof] #2899 refl #2898
[mk-app] #2898 = #154 #1
[mk-proof] #2899 iff-true #155 #2898
[mk-app] #2279 = #143 #143
[mk-proof] #2280 refl #2279
[mk-app] #2279 = #143 #1
[mk-proof] #2280 iff-true #148 #2279
[mk-app] #2283 = #132 #132
[mk-proof] #2278 refl #2283
[mk-app] #2283 = #124 #124
[mk-proof] #2278 refl #2283
[mk-app] #2283 = #124 #1
[mk-proof] #2278 iff-true #129 #2283
[mk-app] #2281 = #114 #114
[mk-proof] #2282 refl #2281
[mk-app] #2281 = #114 #1
[mk-proof] #2282 iff-true #115 #2281
[mk-app] #2909 = #108 #108
[mk-proof] #2910 refl #2909
[mk-app] #2909 = #108 #1
[mk-proof] #2910 iff-true #109 #2909
[mk-app] #2907 = #101 #101
[mk-proof] #2908 refl #2907
[mk-app] #2907 = #101 #1
[mk-proof] #2908 iff-true #102 #2907
[mk-app] #2286 = #95 #95
[mk-proof] #2906 refl #2286
[mk-app] #2286 = #95 #1
[mk-proof] #2906 iff-true #96 #2286
[mk-app] #2284 = #88 #88
[mk-proof] #2285 refl #2284
[mk-app] #2284 = #88 #1
[mk-proof] #2285 iff-true #89 #2284
[mk-app] #2132 = #82 #82
[mk-proof] #2133 refl #2132
[mk-app] #2132 = #82 #1
[mk-proof] #2133 iff-true #83 #2132
[mk-app] #2128 = #76 #76
[mk-proof] #2131 refl #2128
[mk-app] #2128 = #76 #1
[mk-proof] #2131 iff-true #77 #2128
[mk-app] #2129 = #70 #70
[mk-proof] #2130 refl #2129
[mk-app] #2129 = #70 #1
[mk-proof] #2130 iff-true #71 #2129
[mk-app] #2099 = #63 #63
[mk-proof] #2100 refl #2099
[mk-app] #2099 = #63 #1
[mk-proof] #2100 iff-true #64 #2099
[mk-app] #2101 = #57 #57
[mk-proof] #2102 refl #2101
[mk-app] #2101 = #57 #1
[mk-proof] #2102 iff-true #58 #2101
[mk-app] #2103 = #50 #50
[mk-proof] #2104 refl #2103
[mk-app] #2103 = #50 #1
[mk-proof] #2104 iff-true #51 #2103
[mk-app] #2105 = #43 #43
[mk-proof] #2106 refl #2105
[mk-app] #2105 = #43 #1
[mk-proof] #2106 iff-true #44 #2105
[mk-app] #2107 ~ #41 #41
[mk-proof] #2108 refl #2107
[mk-lambda] #2895 null 1 #2108
[mk-proof] #2098 proof-bind #2895
[mk-app] #2893 ~ #43 #43
[mk-proof] #2894 nnf-pos #2098 #2893
[mk-proof] #2891 mp~ #44 #2894 #43
[mk-app] #2892 = #43 #43
[mk-proof] #2105 refl #2892
[mk-app] #2892 ~ #48 #48
[mk-proof] #2105 refl #2892
[mk-lambda] #2106 null 1 #2105
[mk-proof] #2103 proof-bind #2106
[mk-app] #2104 ~ #50 #50
[mk-proof] #2101 nnf-pos #2103 #2104
[mk-proof] #2102 mp~ #51 #2101 #50
[mk-app] #2099 = #50 #50
[mk-proof] #2100 refl #2099
[mk-app] #2099 ~ #55 #55
[mk-proof] #2100 refl #2099
[mk-lambda] #2129 null 1 #2100
[mk-proof] #2130 proof-bind #2129
[mk-app] #2128 ~ #57 #57
[mk-proof] #2131 nnf-pos #2130 #2128
[mk-proof] #2132 mp~ #58 #2131 #57
[mk-app] #2133 = #57 #57
[mk-proof] #2284 refl #2133
[mk-app] #2133 ~ #61 #61
[mk-proof] #2284 refl #2133
[mk-lambda] #2285 null 1 #2284
[mk-proof] #2286 proof-bind #2285
[mk-app] #2906 ~ #63 #63
[mk-proof] #2907 nnf-pos #2286 #2906
[mk-proof] #2908 mp~ #64 #2907 #63
[mk-app] #2909 = #63 #63
[mk-proof] #2910 refl #2909
[mk-app] #2909 ~ #68 #68
[mk-proof] #2910 refl #2909
[mk-lambda] #2281 null 1 #2910
[mk-proof] #2282 proof-bind #2281
[mk-app] #2283 ~ #70 #70
[mk-proof] #2278 nnf-pos #2282 #2283
[mk-proof] #2279 mp~ #71 #2278 #70
[mk-app] #2280 = #70 #70
[mk-proof] #2898 refl #2280
[mk-app] #2280 ~ #74 #74
[mk-proof] #2898 refl #2280
[mk-lambda] #2899 null 1 #2898
[mk-proof] #2901 proof-bind #2899
[mk-app] #2902 ~ #76 #76
[mk-proof] #2903 nnf-pos #2901 #2902
[mk-proof] #2904 mp~ #77 #2903 #76
[mk-app] #2905 = #76 #76
[mk-proof] #2116 refl #2905
[mk-app] #2905 ~ #80 #80
[mk-proof] #2116 refl #2905
[mk-lambda] #2117 null 1 #2116
[mk-proof] #2118 proof-bind #2117
[mk-app] #2119 ~ #82 #82
[mk-proof] #2120 nnf-pos #2118 #2119
[mk-proof] #2121 mp~ #83 #2120 #82
[mk-app] #2123 = #82 #82
[mk-proof] #2124 refl #2123
[mk-app] #2123 ~ #86 #86
[mk-proof] #2124 refl #2123
[mk-lambda] #2122 null 1 #2124
[mk-proof] #2125 proof-bind #2122
[mk-app] #2126 ~ #88 #88
[mk-proof] #2127 nnf-pos #2125 #2126
[mk-proof] #2275 mp~ #89 #2127 #88
[mk-app] #2276 = #88 #88
[mk-proof] #2277 refl #2276
[mk-app] #2276 ~ #93 #93
[mk-proof] #2277 refl #2276
[mk-lambda] #2882 null 1 #2277
[mk-proof] #2883 proof-bind #2882
[mk-app] #2885 ~ #95 #95
[mk-proof] #2886 nnf-pos #2883 #2885
[mk-proof] #2888 mp~ #96 #2886 #95
[mk-app] #2889 = #95 #95
[mk-proof] #2109 refl #2889
[mk-app] #2889 ~ #99 #99
[mk-proof] #2109 refl #2889
[mk-lambda] #2111 null 1 #2109
[mk-proof] #2112 proof-bind #2111
[mk-app] #2110 ~ #101 #101
[mk-proof] #2113 nnf-pos #2112 #2110
[mk-proof] #2114 mp~ #102 #2113 #101
[mk-app] #2115 = #101 #101
[mk-proof] #2272 refl #2115
[mk-app] #2115 ~ #106 #106
[mk-proof] #2272 refl #2115
[mk-lambda] #2273 null 1 #2272
[mk-proof] #2274 proof-bind #2273
[mk-app] #2857 ~ #108 #108
[mk-proof] #2858 nnf-pos #2274 #2857
[mk-proof] #2860 mp~ #109 #2858 #108
[mk-app] #2861 = #108 #108
[mk-proof] #2863 refl #2861
[mk-app] #2861 ~ #112 #112
[mk-proof] #2863 refl #2861
[mk-lambda] #2864 null 1 #2863
[mk-proof] #2866 proof-bind #2864
[mk-app] #2867 ~ #114 #114
[mk-proof] #2870 nnf-pos #2866 #2867
[mk-proof] #2871 mp~ #115 #2870 #114
[mk-app] #2873 = #114 #114
[mk-proof] #2874 refl #2873
[mk-app] #2873 ~ #123 #123
[mk-proof] #2874 refl #2873
[mk-lambda] #2876 null 1 #2874
[mk-proof] #2877 proof-bind #2876
[mk-app] #2878 ~ #124 #124
[mk-proof] #2879 nnf-pos #2877 #2878
[mk-proof] #2880 mp~ #129 #2879 #124
[mk-app] #2075 = #124 #124
[mk-proof] #2076 refl #2075
[mk-app] #2075 ~ #132 #132
[mk-proof] #2076 refl #2075
[mk-app] #2075 = #132 #132
[mk-proof] #2076 refl #2075
[mk-app] #2075 ~ #140 #140
[mk-proof] #2076 refl #2075
[mk-lambda] #2077 null 1 #2076
[mk-proof] #2078 proof-bind #2077
[mk-app] #2079 ~ #143 #143
[mk-proof] #2080 nnf-pos #2078 #2079
[mk-proof] #2081 mp~ #148 #2080 #143
[mk-app] #2082 = #143 #143
[mk-proof] #2083 refl #2082
[mk-app] #2082 ~ #152 #152
[mk-proof] #2083 refl #2082
[mk-lambda] #2084 null 1 #2083
[mk-proof] #2085 proof-bind #2084
[mk-app] #2086 ~ #154 #154
[mk-proof] #2087 nnf-pos #2085 #2086
[mk-proof] #2088 mp~ #155 #2087 #154
[mk-app] #2089 = #154 #154
[mk-proof] #2090 refl #2089
[mk-app] #2089 ~ #188 #188
[mk-proof] #2090 refl #2089
[mk-lambda] #2091 null 2 #2090
[mk-proof] #2093 proof-bind #2091
[mk-app] #2094 ~ #193 #193
[mk-proof] #2092 nnf-pos #2093 #2094
[mk-proof] #2095 mp~ #198 #2092 #193
[mk-app] #2096 = #193 #193
[mk-proof] #2097 refl #2096
[mk-app] #2096 ~ #213 #213
[mk-proof] #2097 refl #2096
[mk-lambda] #2269 null 2 #2097
[mk-proof] #2270 proof-bind #2269
[mk-app] #2271 ~ #216 #216
[mk-proof] #2831 nnf-pos #2270 #2271
[mk-proof] #2832 mp~ #221 #2831 #216
[mk-app] #2835 = #216 #216
[mk-proof] #2836 refl #2835
[mk-app] #2835 ~ #223 #223
[mk-proof] #2836 refl #2835
[mk-lambda] #2838 null 1 #2836
[mk-proof] #2839 proof-bind #2838
[mk-app] #2841 ~ #224 #224
[mk-proof] #2842 nnf-pos #2839 #2841
[mk-proof] #2844 mp~ #225 #2842 #224
[mk-app] #2845 = #224 #224
[mk-proof] #2847 refl #2845
[mk-app] #2845 ~ #232 #232
[mk-proof] #2847 refl #2845
[mk-lambda] #2848 null 2 #2847
[mk-proof] #2850 proof-bind #2848
[mk-app] #2851 ~ #237 #237
[mk-proof] #2852 nnf-pos #2850 #2851
[mk-proof] #2853 mp~ #242 #2852 #237
[mk-app] #2854 = #237 #237
[mk-proof] #2266 refl #2854
[mk-app] #2854 ~ #256 #256
[mk-proof] #2266 refl #2854
[mk-lambda] #2267 null 2 #2266
[mk-proof] #2268 proof-bind #2267
[mk-app] #2819 ~ #263 #263
[mk-proof] #2820 nnf-pos #2268 #2819
[mk-proof] #2822 mp~ #268 #2820 #263
[mk-app] #2823 = #263 #263
[mk-proof] #2825 refl #2823
[mk-app] #2823 ~ #327 #327
[mk-proof] #2825 refl #2823
[mk-lambda] #2826 null 3 #2825
[mk-proof] #2827 proof-bind #2826
[mk-app] #2828 ~ #332 #332
[mk-proof] #2829 nnf-pos #2827 #2828
[mk-proof] #2263 mp~ #337 #2829 #332
[mk-app] #2264 = #332 #332
[mk-proof] #2265 refl #2264
[mk-app] #2264 ~ #389 #389
[mk-proof] #2265 refl #2264
[mk-lambda] #2015 null 3 #2265
[mk-proof] #2016 proof-bind #2015
[mk-app] #2017 ~ #394 #394
[mk-proof] #2018 nnf-pos #2016 #2017
[mk-proof] #2019 mp~ #399 #2018 #394
[mk-app] #2020 = #394 #394
[mk-proof] #2021 refl #2020
[mk-app] #2020 ~ #452 #452
[mk-proof] #2021 refl #2020
[mk-lambda] #2022 null 3 #2021
[mk-proof] #2023 proof-bind #2022
[mk-app] #2024 ~ #457 #457
[mk-proof] #2025 nnf-pos #2023 #2024
[mk-proof] #2026 mp~ #462 #2025 #457
[mk-app] #2027 = #457 #457
[mk-proof] #2028 refl #2027
[mk-app] #2027 ~ #497 #497
[mk-proof] #2028 refl #2027
[mk-lambda] #2029 null 3 #2028
[mk-proof] #2030 proof-bind #2029
[mk-app] #2031 ~ #502 #502
[mk-proof] #2032 nnf-pos #2030 #2031
[mk-proof] #2033 mp~ #507 #2032 #502
[mk-app] #2034 = #502 #502
[mk-proof] #2035 refl #2034
[mk-app] #2034 ~ #558 #558
[mk-proof] #2035 refl #2034
[mk-lambda] #2036 null 4 #2035
[mk-proof] #2037 proof-bind #2036
[mk-app] #2038 ~ #563 #563
[mk-proof] #2039 nnf-pos #2037 #2038
[mk-proof] #2040 mp~ #568 #2039 #563
[mk-app] #2041 = #563 #563
[mk-proof] #2042 refl #2041
[mk-app] #2041 ~ #640 #640
[mk-proof] #2042 refl #2041
[mk-lambda] #2043 null 2 #2042
[mk-proof] #2044 proof-bind #2043
[mk-app] #2045 ~ #643 #643
[mk-proof] #2046 nnf-pos #2044 #2045
[mk-proof] #2047 mp~ #648 #2046 #643
[mk-app] #2048 = #643 #643
[mk-proof] #2049 refl #2048
[mk-app] #2048 ~ #686 #686
[mk-proof] #2049 refl #2048
[mk-lambda] #2050 null 3 #2049
[mk-proof] #2051 proof-bind #2050
[mk-app] #2052 ~ #691 #691
[mk-proof] #2053 nnf-pos #2051 #2052
[mk-proof] #2054 mp~ #696 #2053 #691
[mk-app] #2055 = #691 #691
[mk-proof] #2056 refl #2055
[mk-app] #2055 ~ #765 #765
[mk-proof] #2056 refl #2055
[mk-lambda] #2057 null 2 #2056
[mk-proof] #2058 proof-bind #2057
[mk-app] #2059 ~ #768 #768
[mk-proof] #2060 nnf-pos #2058 #2059
[mk-proof] #2061 mp~ #773 #2060 #768
[inst-discovered] theory-solving 0x0 basic# ; #741
[mk-app] #2062 = #741 #741
[mk-proof] #2063 rewrite #2062
[instance] 0x0 #2062
[end-of-instance]
[mk-app] #2064 = #746 #746
[mk-proof] #2065 monotonicity #2063 #2064
[mk-app] #2066 = #752 #752
[mk-proof] #2067 monotonicity #2065 #2066
[mk-app] #2068 = #765 #765
[mk-proof] #2070 monotonicity #2067 #2068
[mk-app] #2071 = #768 #768
[mk-proof] #2069 refl #2071
[mk-app] #2071 ~ #837 #837
[mk-proof] #2069 refl #2071
[mk-lambda] #2072 null 3 #2069
[mk-proof] #2073 proof-bind #2072
[mk-app] #2074 ~ #842 #842
[mk-proof] #2260 nnf-pos #2073 #2074
[mk-proof] #2261 mp~ #847 #2260 #842
[mk-app] #2262 = #842 #842
[mk-proof] #2785 refl #2262
[mk-app] #2262 ~ #875 #875
[mk-proof] #2785 refl #2262
[mk-lambda] #2786 null 3 #2785
[mk-proof] #2788 proof-bind #2786
[mk-app] #2789 ~ #880 #880
[mk-proof] #2791 nnf-pos #2788 #2789
[mk-proof] #2792 mp~ #885 #2791 #880
[mk-app] #2796 = #880 #880
[mk-proof] #2797 refl #2796
[mk-app] #2796 ~ #910 #910
[mk-proof] #2797 refl #2796
[mk-lambda] #2801 null 3 #2797
[mk-proof] #2802 proof-bind #2801
[mk-app] #2804 ~ #915 #915
[mk-proof] #2805 nnf-pos #2802 #2804
[mk-proof] #2807 mp~ #920 #2805 #915
[mk-app] #2808 = #915 #915
[mk-proof] #2810 refl #2808
[mk-app] #2808 ~ #957 #957
[mk-proof] #2810 refl #2808
[mk-lambda] #2811 null 3 #2810
[mk-proof] #2813 proof-bind #2811
[mk-app] #2814 ~ #962 #962
[mk-proof] #2815 nnf-pos #2813 #2814
[mk-proof] #2816 mp~ #967 #2815 #962
[mk-app] #2817 = #962 #962
[mk-proof] #1611 refl #2817
[mk-app] #2817 ~ #979 #979
[mk-proof] #1611 refl #2817
[mk-lambda] #1612 null 3 #1611
[mk-proof] #1613 proof-bind #1612
[mk-app] #2000 ~ #984 #984
[mk-proof] #2001 nnf-pos #1613 #2000
[mk-proof] #2002 mp~ #989 #2001 #984
[mk-app] #2003 = #984 #984
[mk-proof] #2004 refl #2003
[mk-app] #2003 ~ #1004 #1004
[mk-proof] #2004 refl #2003
[mk-lambda] #2005 null 3 #2004
[mk-proof] #2006 proof-bind #2005
[mk-app] #2007 ~ #1009 #1009
[mk-proof] #2008 nnf-pos #2006 #2007
[mk-proof] #2010 mp~ #1014 #2008 #1009
[mk-app] #2011 = #1009 #1009
[mk-proof] #2009 refl #2011
[mk-app] #2011 ~ #1020 #1020
[mk-proof] #2009 refl #2011
[mk-lambda] #2012 null 2 #2009
[mk-proof] #2013 proof-bind #2012
[mk-app] #2014 ~ #1023 #1023
[mk-proof] #2257 nnf-pos #2013 #2014
[mk-proof] #2258 mp~ #1028 #2257 #1023
[mk-app] #2259 = #1023 #1023
[mk-proof] #2417 refl #2259
[mk-app] #2259 ~ #1034 #1034
[mk-proof] #2417 refl #2259
[mk-lambda] #2418 null 2 #2417
[mk-proof] #2420 proof-bind #2418
[mk-app] #2421 ~ #1037 #1037
[mk-proof] #2769 nnf-pos #2420 #2421
[mk-proof] #2770 mp~ #1042 #2769 #1037
[mk-app] #2772 = #1037 #1037
[mk-proof] #2773 refl #2772
[mk-app] #2772 ~ #1053 #1053
[mk-proof] #2773 refl #2772
[mk-lambda] #2775 null 2 #2773
[mk-proof] #2776 proof-bind #2775
[mk-app] #2778 ~ #1058 #1058
[mk-proof] #2779 nnf-pos #2776 #2778
[mk-proof] #2780 mp~ #1063 #2779 #1058
[mk-app] #2781 = #1058 #1058
[mk-proof] #2782 refl #2781
[mk-app] #2781 ~ #1071 #1071
[mk-proof] #2782 refl #2781
[mk-lambda] #1974 null 2 #2782
[mk-proof] #1975 proof-bind #1974
[mk-app] #1976 ~ #1076 #1076
[mk-proof] #1977 nnf-pos #1975 #1976
[mk-proof] #1978 mp~ #1081 #1977 #1076
[mk-app] #1979 = #1076 #1076
[mk-proof] #1980 refl #1979
[mk-app] #1979 ~ #1126 #1126
[mk-proof] #1980 refl #1979
[mk-lambda] #1981 null 2 #1980
[mk-proof] #1982 proof-bind #1981
[mk-app] #1983 ~ #1131 #1131
[mk-proof] #1984 nnf-pos #1982 #1983
[mk-proof] #1985 mp~ #1136 #1984 #1131
[mk-app] #1986 = #1131 #1131
[mk-proof] #1987 refl #1986
[mk-app] #1986 ~ #1160 #1160
[mk-proof] #1987 refl #1986
[mk-lambda] #1988 null 3 #1987
[mk-proof] #1989 proof-bind #1988
[mk-app] #1990 ~ #1165 #1165
[mk-proof] #1991 nnf-pos #1989 #1990
[mk-proof] #1992 mp~ #1170 #1991 #1165
[mk-app] #1993 = #1165 #1165
[mk-proof] #1995 refl #1993
[mk-app] #1993 ~ #1180 #1180
[mk-proof] #1995 refl #1993
[mk-lambda] #1996 null 2 #1995
[mk-proof] #1994 proof-bind #1996
[mk-app] #1997 ~ #1185 #1185
[mk-proof] #1998 nnf-pos #1994 #1997
[mk-proof] #1999 mp~ #1190 #1998 #1185
[mk-app] #2254 = #1185 #1185
[mk-proof] #2255 refl #2254
[mk-app] #2254 ~ #1289 #1289
[mk-proof] #2255 refl #2254
[mk-lambda] #2256 null 2 #2255
[mk-proof] #2357 proof-bind #2256
[mk-app] #2358 ~ #1294 #1294
[mk-proof] #2360 nnf-pos #2357 #2358
[mk-proof] #2361 mp~ #1299 #2360 #1294
[mk-app] #2751 = #1294 #1294
[mk-proof] #2752 refl #2751
[mk-app] #2751 ~ #1303 #1303
[mk-proof] #2752 refl #2751
[mk-lambda] #2754 null 2 #2752
[mk-proof] #2755 proof-bind #2754
[mk-app] #2757 ~ #1306 #1306
[mk-proof] #2758 nnf-pos #2755 #2757
[mk-proof] #2760 mp~ #1311 #2758 #1306
[mk-app] #2761 = #1306 #1306
[mk-proof] #2763 refl #2761
[mk-app] #2761 ~ #1315 #1315
[mk-proof] #2763 refl #2761
[mk-lambda] #2764 null 2 #2763
[mk-proof] #2765 proof-bind #2764
[mk-app] #2766 ~ #1317 #1317
[mk-proof] #2767 nnf-pos #2765 #2766
[mk-proof] #1949 mp~ #1318 #2767 #1317
[mk-app] #1950 = #1317 #1317
[mk-proof] #1951 refl #1950
[mk-app] #1950 ~ #1376 #1376
[mk-proof] #1951 refl #1950
[mk-lambda] #1952 null 2 #1951
[mk-proof] #1953 proof-bind #1952
[mk-app] #1954 ~ #1379 #1379
[mk-proof] #1955 nnf-pos #1953 #1954
[mk-proof] #1956 mp~ #1384 #1955 #1379
[mk-app] #1957 = #1379 #1379
[mk-proof] #1958 refl #1957
[mk-app] #1957 ~ #1438 #1438
[mk-proof] #1958 refl #1957
[mk-lambda] #1959 null 3 #1958
[mk-proof] #1960 proof-bind #1959
[mk-app] #1961 ~ #1443 #1443
[mk-proof] #1962 nnf-pos #1960 #1961
[mk-proof] #1963 mp~ #1448 #1962 #1443
[mk-app] #1964 = #1443 #1443
[mk-proof] #1965 refl #1964
[mk-app] #1964 ~ #1463 #1463
[mk-proof] #1965 refl #1964
[mk-lambda] #1966 null 3 #1965
[mk-proof] #1967 proof-bind #1966
[mk-app] #1969 ~ #1466 #1466
[mk-proof] #1970 nnf-pos #1967 #1969
[mk-proof] #1968 mp~ #1471 #1970 #1466
[mk-app] #1971 = #1466 #1466
[mk-proof] #1972 refl #1971
[mk-app] #1971 ~ #1475 #1475
[mk-proof] #1972 refl #1971
[mk-lambda] #1973 null 2 #1972
[mk-proof] #2251 proof-bind #1973
[mk-app] #2252 ~ #1477 #1477
[mk-proof] #2253 nnf-pos #2251 #2252
[mk-proof] #2735 mp~ #1478 #2253 #1477
[mk-app] #2736 = #1477 #1477
[mk-proof] #2738 refl #2736
[mk-app] #2736 ~ #1492 #1492
[mk-proof] #2738 refl #2736
[mk-lambda] #2739 null 2 #2738
[mk-proof] #2741 proof-bind #2739
[mk-app] #2742 ~ #1495 #1495
[mk-proof] #2744 nnf-pos #2741 #2742
[mk-proof] #2745 mp~ #1500 #2744 #1495
[mk-app] #2746 = #1495 #1495
[mk-proof] #2747 refl #2746
[mk-app] #2746 ~ #1517 #1517
[mk-proof] #2747 refl #2746
[mk-lambda] #2748 null 2 #2747
[mk-proof] #1930 proof-bind #2748
[mk-app] #1940 ~ #1522 #1522
[mk-proof] #1941 nnf-pos #1930 #1940
[mk-proof] #1942 mp~ #1527 #1941 #1522
[mk-app] #1944 = #1522 #1522
[mk-proof] #1945 refl #1944
[mk-app] #2062 = #43 #43
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #50 #50
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #57 #57
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #63 #63
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #70 #70
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #76 #76
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #82 #82
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #88 #88
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #95 #95
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #101 #101
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #108 #108
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #114 #114
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #124 #124
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #132 #132
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #143 #143
[mk-proof] #2063 refl #2062
[mk-app] #2062 = #154 #154
[mk-proof] #2063 refl #2062
[mk-app] #2062 or #135 #157
[mk-app] #2063 not #2062
[inst-discovered] theory-solving 0x0 basic# ; #160
[mk-app] #2064 = #160 #2063
[mk-proof] #2065 rewrite #2064
[instance] 0x0 #2064
[end-of-instance]
[mk-app] #2066 not #2063
[mk-app] #2067 = #187 #2066
[mk-proof] #2068 monotonicity #2065 #2067
[inst-discovered] theory-solving 0x0 basic# ; #2066
[mk-app] #2070 = #2066 #2062
[mk-proof] #1944 rewrite #2070
[instance] 0x0 #2070
[end-of-instance]
[mk-app] #1945 = #187 #2062
[mk-proof] #1943 trans #2068 #1944 #1945
[mk-app] #1946 or #2062 #177
[mk-app] #1947 = #188 #1946
[mk-proof] #1948 monotonicity #1943 #1947
[mk-app] #2248 or #135 #157 #177
[inst-discovered] theory-solving 0x0 basic# ; #1946
[mk-app] #2249 = #1946 #2248
[mk-proof] #2250 rewrite #2249
[instance] 0x0 #2249
[end-of-instance]
[mk-app] #2717 = #188 #2248
[mk-proof] #2718 trans #1948 #2250 #2717
[mk-quant] #2726 k!150 2 #167 #2248
[attach-var-names] #2726 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2727 null 2 #2718
[mk-proof] #2728 proof-bind #2727
[mk-app] #2729 = #193 #2726
[mk-proof] #2730 quant-intro #2728 #2729
[mk-proof] #2731 mp #2095 #2730 #2726
[mk-app] #2732 not #207
[mk-app] #1931 not #210
[mk-app] #1932 or #1931 #2732
[mk-app] #1933 not #1932
[inst-discovered] theory-solving 0x0 basic# ; #213
[mk-app] #1935 = #213 #1933
[mk-proof] #1936 rewrite #1935
[instance] 0x0 #1935
[end-of-instance]
[mk-quant] #1934 k!156 2 #204 #1933
[attach-var-names] #1934 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1937 null 2 #1936
[mk-proof] #1938 proof-bind #1937
[mk-app] #1939 = #216 #1934
[mk-proof] #2245 quant-intro #1938 #1939
[mk-proof] #2246 mp #2832 #2245 #1934
[mk-app] #2247 = #224 #224
[mk-proof] #2719 refl #2247
[mk-app] #2247 = #237 #237
[mk-proof] #2719 refl #2247
[mk-app] #2247 = #263 #263
[mk-proof] #2719 refl #2247
[mk-app] #2247 or #157 #270 #294 #619
[mk-app] #2719 not #2247
[inst-discovered] theory-solving 0x0 basic# ; #318
[mk-app] #2720 = #318 #2719
[mk-proof] #2721 rewrite #2720
[instance] 0x0 #2720
[end-of-instance]
[mk-app] #2722 not #2719
[mk-app] #2723 = #326 #2722
[mk-proof] #2724 monotonicity #2721 #2723
[inst-discovered] theory-solving 0x0 basic# ; #2722
[mk-app] #2725 = #2722 #2247
[mk-proof] #2242 rewrite #2725
[instance] 0x0 #2725
[end-of-instance]
[mk-app] #2243 = #326 #2247
[mk-proof] #2244 trans #2724 #2242 #2243
[mk-app] #2239 or #2247 #281
[mk-app] #2240 = #327 #2239
[mk-proof] #2241 monotonicity #2244 #2240
[mk-app] #1912 or #157 #270 #281 #294 #619
[inst-discovered] theory-solving 0x0 basic# ; #2239
[mk-app] #1913 = #2239 #1912
[mk-proof] #1914 rewrite #1913
[instance] 0x0 #1913
[end-of-instance]
[mk-app] #1915 = #327 #1912
[mk-proof] #1916 trans #2241 #1914 #1915
[mk-quant] #1917 k!179 3 #283 #284 #1912
[attach-var-names] #1917 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1918 null 3 #1916
[mk-proof] #1919 proof-bind #1918
[mk-app] #1920 = #332 #1917
[mk-proof] #1921 quant-intro #1919 #1920
[mk-proof] #1922 mp #2263 #1921 #1917
[mk-app] #1923 or #157 #270 #299 #356
[mk-app] #1925 not #1923
[inst-discovered] theory-solving 0x0 basic# ; #380
[mk-app] #1926 = #380 #1925
[mk-proof] #1924 rewrite #1926
[instance] 0x0 #1926
[end-of-instance]
[mk-app] #1927 not #1925
[mk-app] #1928 = #388 #1927
[mk-proof] #1929 monotonicity #1924 #1928
[inst-discovered] theory-solving 0x0 basic# ; #1927
[mk-app] #2236 = #1927 #1923
[mk-proof] #2237 rewrite #2236
[instance] 0x0 #2236
[end-of-instance]
[mk-app] #2238 = #388 #1923
[mk-proof] #2701 trans #1929 #2237 #2238
[mk-app] #2702 not #345
[mk-app] #2703 not #347
[mk-app] #2704 or #2702 #2703
[mk-app] #2397 not #2704
[inst-discovered] theory-solving 0x0 basic# ; #348
[mk-app] #2398 = #348 #2397
[mk-proof] #2706 rewrite #2398
[instance] 0x0 #2398
[end-of-instance]
[mk-app] #2707 or #1923 #2397
[mk-app] #2709 = #389 #2707
[mk-proof] #2710 monotonicity #2701 #2706 #2709
[mk-app] #2712 or #157 #270 #299 #356 #2397
[inst-discovered] theory-solving 0x0 basic# ; #2707
[mk-app] #2713 = #2707 #2712
[mk-proof] #2714 rewrite #2713
[instance] 0x0 #2713
[end-of-instance]
[mk-app] #2715 = #389 #2712
[mk-proof] #2716 trans #2710 #2714 #2715
[mk-quant] #1854 k!193 3 #283 #2712
[attach-var-names] #1854 (|n| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1855 null 3 #2716
[mk-proof] #1856 proof-bind #1855
[mk-app] #1898 = #394 #1854
[mk-proof] #1899 quant-intro #1856 #1898
[mk-proof] #1900 mp #2019 #1899 #1854
[mk-app] #1860 or #157 #270 #419 #619
[mk-app] #1901 not #1860
[inst-discovered] theory-solving 0x0 basic# ; #443
[mk-app] #1902 = #443 #1901
[mk-proof] #1903 rewrite #1902
[instance] 0x0 #1902
[end-of-instance]
[mk-app] #1904 not #1901
[mk-app] #1905 = #451 #1904
[mk-proof] #1907 monotonicity #1903 #1905
[inst-discovered] theory-solving 0x0 basic# ; #1904
[mk-app] #1908 = #1904 #1860
[mk-proof] #1906 rewrite #1908
[instance] 0x0 #1908
[end-of-instance]
[mk-app] #1909 = #451 #1860
[mk-proof] #1910 trans #1907 #1906 #1909
[mk-app] #1911 not #406
[mk-app] #2233 not #409
[mk-app] #2234 or #1911 #2233
[mk-app] #2235 not #2234
[inst-discovered] theory-solving 0x0 basic# ; #410
[mk-app] #2665 = #410 #2235
[mk-proof] #2666 rewrite #2665
[instance] 0x0 #2665
[end-of-instance]
[mk-app] #2667 or #1860 #2235
[mk-app] #2668 = #452 #2667
[mk-proof] #2694 monotonicity #1910 #2666 #2668
[mk-app] #2695 or #157 #270 #419 #619 #2235
[inst-discovered] theory-solving 0x0 basic# ; #2667
[mk-app] #2696 = #2667 #2695
[mk-proof] #2697 rewrite #2696
[instance] 0x0 #2696
[end-of-instance]
[mk-app] #2698 = #452 #2695
[mk-proof] #2699 trans #2694 #2697 #2698
[mk-quant] #2700 k!207 3 #412 #2695
[attach-var-names] #2700 (|m| ; |Int|) (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #1872 null 3 #2699
[mk-proof] #1873 proof-bind #1872
[mk-app] #1874 = #457 #2700
[mk-proof] #1875 quant-intro #1873 #1874
[mk-proof] #1876 mp #2026 #1875 #2700
[mk-app] #1877 not #475
[mk-app] #1878 or #1877 #481
[mk-app] #1879 not #1878
[inst-discovered] theory-solving 0x0 basic# ; #490
[mk-app] #1880 = #490 #1879
[mk-proof] #1881 rewrite #1880
[instance] 0x0 #1880
[end-of-instance]
[mk-app] #1882 not #1879
[mk-app] #1883 = #496 #1882
[mk-proof] #1884 monotonicity #1881 #1883
[inst-discovered] theory-solving 0x0 basic# ; #1882
[mk-app] #1885 = #1882 #1878
[mk-proof] #1886 rewrite #1885
[instance] 0x0 #1885
[end-of-instance]
[mk-app] #1887 = #496 #1878
[mk-proof] #1888 trans #1884 #1886 #1887
[mk-app] #1889 or #1878 #468
[mk-app] #1890 = #497 #1889
[mk-proof] #1891 monotonicity #1888 #1890
[mk-app] #1893 or #468 #481 #1877
[inst-discovered] theory-solving 0x0 basic# ; #1889
[mk-app] #1894 = #1889 #1893
[mk-proof] #1892 rewrite #1894
[instance] 0x0 #1894
[end-of-instance]
[mk-app] #1895 = #497 #1893
[mk-proof] #1896 trans #1891 #1892 #1895
[mk-quant] #1897 k!214 3 #470 #471 #1893
[attach-var-names] #1897 (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2230 null 3 #1896
[mk-proof] #2231 proof-bind #2230
[mk-app] #2232 = #502 #1897
[mk-proof] #2384 quant-intro #2231 #2232
[mk-proof] #2385 mp #2033 #2384 #1897
[mk-app] #2387 or #619 #532
[mk-app] #2388 not #2387
[inst-discovered] theory-solving 0x0 basic# ; #542
[mk-app] #2677 = #542 #2388
[mk-proof] #2678 rewrite #2677
[instance] 0x0 #2677
[end-of-instance]
[mk-app] #2680 not #2388
[mk-app] #2681 = #557 #2680
[mk-proof] #2683 monotonicity #2678 #2681
[inst-discovered] theory-solving 0x0 basic# ; #2680
[mk-app] #2684 = #2680 #2387
[mk-proof] #2686 rewrite #2684
[instance] 0x0 #2684
[end-of-instance]
[mk-app] #2687 = #557 #2387
[mk-proof] #2689 trans #2683 #2686 #2687
[mk-app] #2690 not #545
[mk-app] #2691 not #548
[mk-app] #2692 or #2690 #2691
[mk-app] #2693 not #2692
[inst-discovered] theory-solving 0x0 basic# ; #551
[mk-app] #1857 = #551 #2693
[mk-proof] #1858 rewrite #1857
[instance] 0x0 #1857
[end-of-instance]
[mk-app] #1859 or #2387 #2693
[mk-app] #1861 = #558 #1859
[mk-proof] #1862 monotonicity #2689 #1858 #1861
[mk-app] #1863 or #532 #619 #2693
[inst-discovered] theory-solving 0x0 basic# ; #1859
[mk-app] #1864 = #1859 #1863
[mk-proof] #1865 rewrite #1864
[instance] 0x0 #1864
[end-of-instance]
[mk-app] #1867 = #558 #1863
[mk-proof] #1868 trans #1862 #1865 #1867
[mk-quant] #1866 k!223 4 #524 #525 #1863
[attach-var-names] #1866 (|n| ; |Int|) (|v| ; |Int|) (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1869 null 4 #1868
[mk-proof] #1870 proof-bind #1869
[mk-app] #1871 = #563 #1866
[mk-proof] #2227 quant-intro #1870 #1871
[mk-proof] #2228 mp #2040 #2227 #1866
[mk-app] #2229 not #593
[mk-app] #2669 not #608
[mk-app] #2670 or #2229 #2669
[mk-app] #2671 not #2670
[inst-discovered] theory-solving 0x0 basic# ; #613
[mk-app] #2672 = #613 #2671
[mk-proof] #2673 rewrite #2672
[instance] 0x0 #2672
[end-of-instance]
[mk-app] #2674 or #619 #2671
[mk-app] #2675 = #620 #2674
[mk-proof] #1828 monotonicity #2673 #2675
[mk-app] #1829 and #2674 #635
[mk-app] #1830 = #640 #1829
[mk-proof] #1831 monotonicity #1828 #1830
[mk-app] #1832 not #2674
[mk-app] #1833 not #635
[mk-app] #1834 or #1832 #1833
[mk-app] #1835 not #1834
[inst-discovered] theory-solving 0x0 basic# ; #1829
[mk-app] #1836 = #1829 #1835
[mk-proof] #1837 rewrite #1836
[instance] 0x0 #1836
[end-of-instance]
[mk-app] #1838 = #640 #1835
[mk-proof] #1839 trans #1831 #1837 #1838
[mk-quant] #1840 k!234 2 #582 #583 #1835
[attach-var-names] #1840 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1841 null 2 #1839
[mk-proof] #1842 proof-bind #1841
[mk-app] #1843 = #643 #1840
[mk-proof] #1844 quant-intro #1842 #1843
[mk-proof] #1845 mp #2047 #1844 #1840
[mk-app] #1846 or #619 #663 #294
[mk-app] #1847 not #1846
[inst-discovered] theory-solving 0x0 basic# ; #677
[mk-app] #1849 = #677 #1847
[mk-proof] #1850 rewrite #1849
[instance] 0x0 #1849
[end-of-instance]
[mk-app] #1848 not #1847
[mk-app] #1851 = #685 #1848
[mk-proof] #1852 monotonicity #1850 #1851
[inst-discovered] theory-solving 0x0 basic# ; #1848
[mk-app] #1853 = #1848 #1846
[mk-proof] #2224 rewrite #1853
[instance] 0x0 #1853
[end-of-instance]
[mk-app] #2225 = #685 #1846
[mk-proof] #2226 trans #1852 #2224 #2225
[mk-app] #2640 or #1846 #654
[mk-app] #2641 = #686 #2640
[mk-proof] #2643 monotonicity #2226 #2641
[mk-app] #2644 or #294 #619 #654 #663
[inst-discovered] theory-solving 0x0 basic# ; #2640
[mk-app] #2647 = #2640 #2644
[mk-proof] #2648 rewrite #2647
[instance] 0x0 #2647
[end-of-instance]
[mk-app] #2651 = #686 #2644
[mk-proof] #2652 trans #2643 #2648 #2651
[mk-quant] #2654 k!241 3 #656 #657 #2644
[attach-var-names] #2654 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2655 null 3 #2652
[mk-proof] #2657 proof-bind #2655
[mk-app] #2658 = #691 #2654
[mk-proof] #2660 quant-intro #2657 #2658
[mk-proof] #2661 mp #2054 #2660 #2654
[inst-discovered] theory-solving 0x0 basic# ; #741
[mk-app] #2662 = #741 #741
[mk-proof] #2663 rewrite #2662
[instance] 0x0 #2662
[end-of-instance]
[mk-app] #2664 = #746 #746
[mk-proof] #1793 monotonicity #2663 #2664
[mk-app] #1794 not #733
[mk-app] #1795 not #741
[mk-app] #1796 or #1794 #1795
[mk-app] #1797 not #1796
[inst-discovered] theory-solving 0x0 basic# ; #746
[mk-app] #1798 = #746 #1797
[mk-proof] #1799 rewrite #1798
[instance] 0x0 #1798
[end-of-instance]
[mk-proof] #1800 trans #1793 #1799 #1798
[mk-app] #1801 or #619 #1797
[mk-app] #1802 = #752 #1801
[mk-proof] #1803 monotonicity #1800 #1802
[mk-app] #1804 and #1801 #760
[mk-app] #1805 = #765 #1804
[mk-proof] #1806 monotonicity #1803 #1805
[mk-app] #1807 not #1801
[mk-app] #1808 not #760
[mk-app] #1809 or #1807 #1808
[mk-app] #1810 not #1809
[inst-discovered] theory-solving 0x0 basic# ; #1804
[mk-app] #1811 = #1804 #1810
[mk-proof] #1812 rewrite #1811
[instance] 0x0 #1811
[end-of-instance]
[mk-app] #1813 = #765 #1810
[mk-proof] #1814 trans #1806 #1812 #1813
[mk-quant] #1815 k!254 2 #709 #710 #1810
[attach-var-names] #1815 (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1816 null 2 #1814
[mk-proof] #1817 proof-bind #1816
[mk-app] #1818 = #768 #1815
[mk-proof] #1819 quant-intro #1817 #1818
[mk-proof] #1820 mp #2061 #1819 #1815
[mk-app] #1821 or #619 #791 #813
[mk-app] #1823 not #1821
[inst-discovered] theory-solving 0x0 basic# ; #828
[mk-app] #1824 = #828 #1823
[mk-proof] #1822 rewrite #1824
[instance] 0x0 #1824
[end-of-instance]
[mk-app] #1825 not #1823
[mk-app] #1826 = #836 #1825
[mk-proof] #1827 monotonicity #1822 #1826
[inst-discovered] theory-solving 0x0 basic# ; #1825
[mk-app] #2221 = #1825 #1821
[mk-proof] #2222 rewrite #2221
[instance] 0x0 #2221
[end-of-instance]
[mk-app] #2223 = #836 #1821
[mk-proof] #2607 trans #1827 #2222 #2223
[mk-app] #2608 not #781
[mk-app] #2610 not #785
[mk-app] #2611 or #2608 #2610
[mk-app] #2613 not #2611
[inst-discovered] theory-solving 0x0 basic# ; #786
[mk-app] #2614 = #786 #2613
[mk-proof] #2616 rewrite #2614
[instance] 0x0 #2614
[end-of-instance]
[mk-app] #2617 or #1821 #2613
[mk-app] #2620 = #837 #2617
[mk-proof] #2621 monotonicity #2607 #2616 #2620
[mk-app] #2625 or #619 #791 #813 #2613
[inst-discovered] theory-solving 0x0 basic# ; #2617
[mk-app] #2626 = #2617 #2625
[mk-proof] #2628 rewrite #2626
[instance] 0x0 #2626
[end-of-instance]
[mk-app] #2629 = #837 #2625
[mk-proof] #2631 trans #2621 #2628 #2629
[mk-quant] #2632 k!262 3 #788 #2625
[attach-var-names] #2632 (|j| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2634 null 3 #2631
[mk-proof] #2635 proof-bind #2634
[mk-app] #2636 = #842 #2632
[mk-proof] #2637 quant-intro #2635 #2636
[mk-proof] #2638 mp #2261 #2637 #2632
[mk-app] #1746 or #294 #666 #791
[mk-app] #1747 not #1746
[inst-discovered] theory-solving 0x0 basic# ; #866
[mk-app] #1748 = #866 #1747
[mk-proof] #1749 rewrite #1748
[instance] 0x0 #1748
[end-of-instance]
[mk-app] #1750 not #1747
[mk-app] #1751 = #874 #1750
[mk-proof] #1752 monotonicity #1749 #1751
[inst-discovered] theory-solving 0x0 basic# ; #1750
[mk-app] #1753 = #1750 #1746
[mk-proof] #1754 rewrite #1753
[instance] 0x0 #1753
[end-of-instance]
[mk-app] #1755 = #874 #1746
[mk-proof] #1756 trans #1752 #1754 #1755
[mk-app] #1757 not #852
[mk-app] #1758 not #854
[mk-app] #1759 or #1757 #1758
[mk-app] #1760 not #1759
[inst-discovered] theory-solving 0x0 basic# ; #855
[mk-app] #1761 = #855 #1760
[mk-proof] #1762 rewrite #1761
[instance] 0x0 #1761
[end-of-instance]
[mk-app] #1763 or #1746 #1760
[mk-app] #1764 = #875 #1763
[mk-proof] #1765 monotonicity #1756 #1762 #1764
[mk-app] #1766 or #294 #666 #791 #1760
[inst-discovered] theory-solving 0x0 basic# ; #1763
[mk-app] #1767 = #1763 #1766
[mk-proof] #1768 rewrite #1767
[instance] 0x0 #1767
[end-of-instance]
[mk-app] #1769 = #875 #1766
[mk-proof] #1770 trans #1765 #1768 #1769
[mk-quant] #1771 k!270 3 #857 #1766
[attach-var-names] #1771 (|i| ; |Int|) (|n| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1772 null 3 #1770
[mk-proof] #1773 proof-bind #1772
[mk-app] #1774 = #880 #1771
[mk-proof] #1775 quant-intro #1773 #1774
[mk-proof] #1776 mp #2792 #1775 #1771
[mk-app] #1777 or #896 #937
[mk-app] #1778 not #1777
[inst-discovered] theory-solving 0x0 basic# ; #903
[mk-app] #1779 = #903 #1778
[mk-proof] #1780 rewrite #1779
[instance] 0x0 #1779
[end-of-instance]
[mk-app] #1781 not #1778
[mk-app] #1782 = #909 #1781
[mk-proof] #1783 monotonicity #1780 #1782
[inst-discovered] theory-solving 0x0 basic# ; #1781
[mk-app] #1784 = #1781 #1777
[mk-proof] #1785 rewrite #1784
[instance] 0x0 #1784
[end-of-instance]
[mk-app] #1786 = #909 #1777
[mk-proof] #1788 trans #1783 #1785 #1786
[mk-app] #1789 or #1777 #891
[mk-app] #1787 = #910 #1789
[mk-proof] #1790 monotonicity #1788 #1787
[mk-app] #1791 or #891 #896 #937
[inst-discovered] theory-solving 0x0 basic# ; #1789
[mk-app] #1792 = #1789 #1791
[mk-proof] #2218 rewrite #1792
[instance] 0x0 #1792
[end-of-instance]
[mk-app] #2219 = #910 #1791
[mk-proof] #2220 trans #1790 #2218 #2219
[mk-quant] #2573 k!276 3 #893 #1791
[attach-var-names] #2573 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #2574 null 3 #2220
[mk-proof] #2576 proof-bind #2574
[mk-app] #2577 = #915 #2573
[mk-proof] #2578 quant-intro #2576 #2577
[mk-proof] #2579 mp #2807 #2578 #2573
[mk-app] #2580 or #896 #900 #356
[mk-app] #2581 not #2580
[inst-discovered] theory-solving 0x0 basic# ; #948
[mk-app] #2582 = #948 #2581
[mk-proof] #2584 rewrite #2582
[instance] 0x0 #2582
[end-of-instance]
[mk-app] #2585 not #2581
[mk-app] #2587 = #956 #2585
[mk-proof] #2588 monotonicity #2584 #2587
[inst-discovered] theory-solving 0x0 basic# ; #2585
[mk-app] #2591 = #2585 #2580
[mk-proof] #2592 rewrite #2591
[instance] 0x0 #2591
[end-of-instance]
[mk-app] #2594 = #956 #2580
[mk-proof] #2595 trans #2588 #2592 #2594
[mk-app] #2597 not #927
[mk-app] #2598 or #2702 #2597
[mk-app] #2600 not #2598
[inst-discovered] theory-solving 0x0 basic# ; #928
[mk-app] #2601 = #928 #2600
[mk-proof] #2602 rewrite #2601
[instance] 0x0 #2601
[end-of-instance]
[mk-app] #2603 or #2580 #2600
[mk-app] #2604 = #957 #2603
[mk-proof] #1720 monotonicity #2595 #2602 #2604
[mk-app] #1721 or #356 #896 #900 #2600
[inst-discovered] theory-solving 0x0 basic# ; #2603
[mk-app] #1722 = #2603 #1721
[mk-proof] #1723 rewrite #1722
[instance] 0x0 #1722
[end-of-instance]
[mk-app] #1724 = #957 #1721
[mk-proof] #1725 trans #1720 #1723 #1724
[mk-quant] #1726 k!286 3 #893 #1721
[attach-var-names] #1726 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1727 null 3 #1725
[mk-proof] #1728 proof-bind #1727
[mk-app] #1729 = #962 #1726
[mk-proof] #1730 quant-intro #1728 #1729
[mk-proof] #1731 mp #2816 #1730 #1726
[mk-app] #1732 or #1777 #971
[mk-app] #1733 = #979 #1732
[mk-proof] #1734 monotonicity #1788 #1733
[mk-app] #1735 or #896 #937 #971
[inst-discovered] theory-solving 0x0 basic# ; #1732
[mk-app] #1736 = #1732 #1735
[mk-proof] #1737 rewrite #1736
[instance] 0x0 #1736
[end-of-instance]
[mk-app] #1738 = #979 #1735
[mk-proof] #1739 trans #1734 #1737 #1738
[mk-quant] #1741 k!292 3 #973 #1735
[attach-var-names] #1741 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1742 null 3 #1739
[mk-proof] #1740 proof-bind #1742
[mk-app] #1743 = #984 #1741
[mk-proof] #1744 quant-intro #1740 #1743
[mk-proof] #1745 mp #2002 #1744 #1741
[mk-app] #2215 or #896 #900
[mk-app] #2216 not #2215
[inst-discovered] theory-solving 0x0 basic# ; #997
[mk-app] #2217 = #997 #2216
[mk-proof] #2553 rewrite #2217
[instance] 0x0 #2217
[end-of-instance]
[mk-app] #2554 not #2216
[mk-app] #2556 = #1003 #2554
[mk-proof] #2557 monotonicity #2553 #2556
[inst-discovered] theory-solving 0x0 basic# ; #2554
[mk-app] #2560 = #2554 #2215
[mk-proof] #2561 rewrite #2560
[instance] 0x0 #2560
[end-of-instance]
[mk-app] #2563 = #1003 #2215
[mk-proof] #2564 trans #2557 #2561 #2563
[mk-app] #2566 not #992
[mk-app] #2567 or #2702 #2566
[mk-app] #2568 not #2567
[inst-discovered] theory-solving 0x0 basic# ; #993
[mk-app] #2569 = #993 #2568
[mk-proof] #2570 rewrite #2569
[instance] 0x0 #2569
[end-of-instance]
[mk-app] #1681 or #2215 #2568
[mk-app] #1682 = #1004 #1681
[mk-proof] #1683 monotonicity #2564 #2570 #1682
[mk-app] #1684 or #896 #900 #2568
[inst-discovered] theory-solving 0x0 basic# ; #1681
[mk-app] #1685 = #1681 #1684
[mk-proof] #1686 rewrite #1685
[instance] 0x0 #1685
[end-of-instance]
[mk-app] #1687 = #1004 #1684
[mk-proof] #1688 trans #1683 #1686 #1687
[mk-quant] #1689 k!300 3 #973 #1684
[attach-var-names] #1689 (|n| ; |Int|) (|t| ; |Seq<Int>|) (|s| ; |Seq<Int>|)
[mk-lambda] #1690 null 3 #1688
[mk-proof] #1691 proof-bind #1690
[mk-app] #1692 = #1009 #1689
[mk-proof] #1693 quant-intro #1691 #1692
[mk-proof] #1694 mp #2010 #1693 #1689
[mk-app] #1695 = #1023 #1023
[mk-proof] #1696 refl #1695
[mk-app] #1695 = #1037 #1037
[mk-proof] #1696 refl #1695
[mk-app] #1695 = #1058 #1058
[mk-proof] #1696 refl #1695
[mk-app] #1695 = #1076 #1076
[mk-proof] #1696 refl #1695
[mk-app] #1695 not #1095
[mk-app] #1696 not #1087
[mk-app] #1697 or #1103 #1695 #1696
[mk-app] #1698 not #1697
[inst-discovered] theory-solving 0x0 basic# ; #1117
[mk-app] #1699 = #1117 #1698
[mk-proof] #1700 rewrite #1699
[instance] 0x0 #1699
[end-of-instance]
[mk-app] #1701 or #1125 #1698
[mk-app] #1702 = #1126 #1701
[mk-proof] #1703 monotonicity #1700 #1702
[mk-quant] #1704 k!326 2 #1091 #1701
[attach-var-names] #1704 (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1705 null 2 #1703
[mk-proof] #1706 proof-bind #1705
[mk-app] #1707 = #1131 #1704
[mk-proof] #1708 quant-intro #1706 #1707
[mk-proof] #1709 mp #1985 #1708 #1704
[mk-app] #1710 not #1137
[mk-app] #1711 or #294 #619 #1710
[mk-app] #1712 not #1711
[inst-discovered] theory-solving 0x0 basic# ; #1151
[mk-app] #1713 = #1151 #1712
[mk-proof] #1715 rewrite #1713
[instance] 0x0 #1713
[end-of-instance]
[mk-app] #1716 not #1712
[mk-app] #1714 = #1159 #1716
[mk-proof] #1717 monotonicity #1715 #1714
[inst-discovered] theory-solving 0x0 basic# ; #1716
[mk-app] #1718 = #1716 #1711
[mk-proof] #1719 rewrite #1718
[instance] 0x0 #1718
[end-of-instance]
[mk-app] #2212 = #1159 #1711
[mk-proof] #2213 trans #1717 #1719 #2212
[mk-app] #2214 or #1711 #1140
[mk-app] #2523 = #1160 #2214
[mk-proof] #2524 monotonicity #2213 #2523
[mk-app] #2526 or #294 #619 #1140 #1710
[inst-discovered] theory-solving 0x0 basic# ; #2214
[mk-app] #2527 = #2214 #2526
[mk-proof] #2530 rewrite #2527
[instance] 0x0 #2527
[end-of-instance]
[mk-app] #2531 = #1160 #2526
[mk-proof] #2533 trans #2524 #2530 #2531
[mk-quant] #2534 k!332 3 #1142 #2526
[attach-var-names] #2534 (|i| ; |Int|) (|x| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #2536 null 3 #2533
[mk-proof] #2537 proof-bind #2536
[mk-app] #2539 = #1165 #2534
[mk-proof] #2540 quant-intro #2537 #2539
[mk-proof] #2541 mp #1992 #2540 #2534
[mk-app] #2542 or #619 #419
[mk-app] #2544 not #2542
[inst-discovered] theory-solving 0x0 basic# ; #429
[mk-app] #2545 = #429 #2544
[mk-proof] #2547 rewrite #2545
[instance] 0x0 #2545
[end-of-instance]
[mk-app] #2548 not #2544
[mk-app] #2549 = #1179 #2548
[mk-proof] #2550 monotonicity #2547 #2549
[inst-discovered] theory-solving 0x0 basic# ; #2548
[mk-app] #2551 = #2548 #2542
[mk-proof] #1663 rewrite #2551
[instance] 0x0 #2551
[end-of-instance]
[mk-app] #1664 = #1179 #2542
[mk-proof] #1665 trans #2550 #1663 #1664
[mk-app] #1666 or #2542 #1171
[mk-app] #1667 = #1180 #1666
[mk-proof] #1668 monotonicity #1665 #1667
[mk-app] #1669 or #419 #619 #1171
[inst-discovered] theory-solving 0x0 basic# ; #1666
[mk-app] #1670 = #1666 #1669
[mk-proof] #1671 rewrite #1670
[instance] 0x0 #1670
[end-of-instance]
[mk-app] #1672 = #1180 #1669
[mk-proof] #1673 trans #1668 #1671 #1672
[mk-quant] #1674 k!338 2 #1173 #1669
[attach-var-names] #1674 (|i| ; |Int|) (|s| ; |Seq<Int>|)
[mk-lambda] #1676 null 2 #1673
[mk-proof] #1677 proof-bind #1676
[mk-app] #1675 = #1185 #1674
[mk-proof] #1678 quant-intro #1677 #1675
[mk-proof] #1679 mp #1999 #1678 #1674
[mk-app] #1680 or #1194 #1195
[mk-app] #2209 not #1680
[inst-discovered] theory-solving 0x0 basic# ; #1193
[mk-app] #2210 = #1193 #2209
[mk-proof] #2211 rewrite #2210
[instance] 0x0 #2210
[end-of-instance]
[mk-app] #2476 or #1191 #1192 #1196
[mk-app] #2477 not #2476
[inst-discovered] theory-solving 0x0 basic# ; #1220
[mk-app] #2479 = #1220 #2477
[mk-proof] #2480 rewrite #2479
[instance] 0x0 #2479
[end-of-instance]
[mk-app] #2482 not #1202
[mk-app] #2483 not #1224
[mk-app] #2485 or #1191 #1192 #1197 #1207 #1232 #2482 #2483
[mk-app] #2486 not #2485
[inst-discovered] theory-solving 0x0 basic# ; #1278
[mk-app] #2489 = #1278 #2486
[mk-proof] #2490 rewrite #2489
[instance] 0x0 #2489
[end-of-instance]
[mk-app] #2492 or #2209 #2477 #2486
[mk-app] #2493 = #1289 #2492
[mk-proof] #2496 monotonicity #2211 #2480 #2490 #2493
[mk-quant] #2497 k!363 2 #1217 #2492
[attach-var-names] #2497 (|s1| ; |Seq<Int>|) (|s0| ; |Seq<Int>|)
[mk-lambda] #2499 null 2 #2496
[mk-proof] #2500 proof-bind #2499
[mk-app] #2504 = #1294 #2497
[mk-proof] #2505 quant-intro #2500 #2504
[mk-proof] #2507 mp #2361 #2505 #2497
[mk-app] #2508 = #1306 #1306
[mk-proof] #2510 refl #2508
[mk-app] #2508 = #1317 #1317
[mk-proof] #2510 refl #2508
[mk-app] #2508 not #1363
[mk-app] #2510 not #1371
[mk-app] #2511 or #2508 #2510
[mk-app] #2513 not #2511
[inst-discovered] theory-solving 0x0 basic# ; #1376
[mk-app] #2514 = #1376 #2513
[mk-proof] #2516 rewrite #2514
[instance] 0x0 #2514
[end-of-instance]
[mk-quant] #2517 $Seq[Int]_prog.ranged_seq_length 2 #1329 #2513
[attach-var-names] #2517 (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2518 null 2 #2516
[mk-proof] #2519 proof-bind #2518
[mk-app] #2520 = #1379 #2517
[mk-proof] #1645 quant-intro #2519 #2520
[mk-proof] #1646 mp #1956 #1645 #2517
[mk-app] #1647 or #619 #1410
[mk-app] #1648 not #1647
[inst-discovered] theory-solving 0x0 basic# ; #1418
[mk-app] #1649 = #1418 #1648
[mk-proof] #1650 rewrite #1649
[instance] 0x0 #1649
[end-of-instance]
[mk-app] #1651 not #1648
[mk-app] #1652 = #1437 #1651
[mk-proof] #1653 monotonicity #1650 #1652
[inst-discovered] theory-solving 0x0 basic# ; #1651
[mk-app] #1654 = #1651 #1647
[mk-proof] #1655 rewrite #1654
[instance] 0x0 #1654
[end-of-instance]
[mk-app] #1656 = #1437 #1647
[mk-proof] #1658 trans #1653 #1655 #1656
[mk-app] #1659 or #1647 #1427
[mk-app] #1657 = #1438 #1659
[mk-proof] #1660 monotonicity #1658 #1657
[mk-app] #1661 or #619 #1410 #1427
[inst-discovered] theory-solving 0x0 basic# ; #1659
[mk-app] #1662 = #1659 #1661
[mk-proof] #2206 rewrite #1662
[instance] 0x0 #1662
[end-of-instance]
[mk-app] #2207 = #1438 #1661
[mk-proof] #2208 trans #1660 #2206 #2207
[mk-quant] #2450 $Seq[Int]_prog.ranged_seq_index 3 #1393 #1661
[attach-var-names] #2450 (|j| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2451 null 3 #2208
[mk-proof] #2453 proof-bind #2451
[mk-app] #2454 = #1443 #2450
[mk-proof] #2456 quant-intro #2453 #2454
[mk-proof] #2457 mp #1963 #2456 #2450
[mk-app] #2459 not #1456
[mk-app] #2460 or #2459 #663
[mk-app] #2463 not #2460
[inst-discovered] theory-solving 0x0 basic# ; #1460
[mk-app] #2464 = #1460 #2463
[mk-proof] #2466 rewrite #2464
[instance] 0x0 #2464
[end-of-instance]
[mk-app] #2467 = #1449 #2463
[mk-app] #2469 = #1463 #2467
[mk-proof] #2470 monotonicity #2466 #2469
[mk-quant] #2471 $Seq[Int]_prog.ranged_seq_contains 3 #1453 #2467
[attach-var-names] #2471 (|v| ; |Int|) (|max| ; |Int|) (|min_| ; |Int|)
[mk-lambda] #2472 null 3 #2470
[mk-proof] #2473 proof-bind #2472
[mk-app] #1614 = #1466 #2471
[mk-proof] #1615 quant-intro #2473 #1614
[mk-proof] #1616 mp #1968 #1615 #2471
[mk-app] #1617 = #1477 #1477
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1495 #1495
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1522 #1522
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #43 #43
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2891 #1618 #43
[mk-app] #1617 = #50 #50
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2102 #1618 #50
[mk-app] #1617 = #57 #57
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2132 #1618 #57
[mk-app] #1617 = #63 #63
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2908 #1618 #63
[mk-app] #1617 = #70 #70
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2279 #1618 #70
[mk-app] #1617 = #76 #76
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2904 #1618 #76
[mk-app] #1617 = #82 #82
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2121 #1618 #82
[mk-app] #1617 = #88 #88
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2275 #1618 #88
[mk-app] #1617 = #95 #95
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2888 #1618 #95
[mk-app] #1617 = #101 #101
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2114 #1618 #101
[mk-app] #1617 = #108 #108
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2860 #1618 #108
[mk-app] #1617 = #114 #114
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2871 #1618 #114
[mk-app] #1617 = #124 #124
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2880 #1618 #124
[mk-app] #1617 = #132 #132
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #133 #1618 #132
[mk-app] #1617 = #143 #143
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2081 #1618 #143
[mk-app] #1617 = #154 #154
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2088 #1618 #154
[mk-app] #1617 = #2726 #2726
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2731 #1618 #2726
[mk-app] #1617 = #1934 #1934
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2246 #1618 #1934
[mk-app] #1617 = #224 #224
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2844 #1618 #224
[mk-app] #1617 = #237 #237
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2853 #1618 #237
[mk-app] #1617 = #263 #263
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2822 #1618 #263
[mk-app] #1617 = #1917 #1917
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1922 #1618 #1917
[mk-app] #1617 = #1854 #1854
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1900 #1618 #1854
[mk-app] #1617 = #2700 #2700
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1876 #1618 #2700
[mk-app] #1617 = #1897 #1897
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2385 #1618 #1897
[mk-app] #1617 = #1866 #1866
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2228 #1618 #1866
[mk-app] #1617 = #1840 #1840
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1845 #1618 #1840
[mk-app] #1617 = #2654 #2654
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2661 #1618 #2654
[mk-app] #1617 = #1815 #1815
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1820 #1618 #1815
[mk-app] #1617 = #2632 #2632
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2638 #1618 #2632
[mk-app] #1617 = #1771 #1771
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1776 #1618 #1771
[mk-app] #1617 = #2573 #2573
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2579 #1618 #2573
[mk-app] #1617 = #1726 #1726
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1731 #1618 #1726
[mk-app] #1617 = #1741 #1741
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1745 #1618 #1741
[mk-app] #1617 = #1689 #1689
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1694 #1618 #1689
[mk-app] #1617 = #1023 #1023
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2258 #1618 #1023
[mk-app] #1617 = #1037 #1037
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2770 #1618 #1037
[mk-app] #1617 = #1058 #1058
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2780 #1618 #1058
[mk-app] #1617 = #1076 #1076
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1978 #1618 #1076
[mk-app] #1617 = #1704 #1704
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1709 #1618 #1704
[mk-app] #1617 = #2534 #2534
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2541 #1618 #2534
[mk-app] #1617 = #1674 #1674
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1679 #1618 #1674
[mk-app] #1617 = #2497 #2497
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2507 #1618 #2497
[mk-app] #1617 = #1306 #1306
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2760 #1618 #1306
[mk-app] #1617 = #1317 #1317
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1949 #1618 #1317
[mk-app] #1617 = #2517 #2517
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1646 #1618 #2517
[mk-app] #1617 = #2450 #2450
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2457 #1618 #2450
[mk-app] #1617 = #2471 #2471
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1616 #1618 #2471
[mk-app] #1617 = #1477 #1477
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2735 #1618 #1477
[mk-app] #1617 = #1495 #1495
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #2745 #1618 #1495
[mk-app] #1617 = #1522 #1522
[mk-proof] #1618 rewrite #1617
[mk-proof] #1619 mp #1942 #1618 #1522
[mk-app] #1617 = #43 #43
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #50 #50
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #57 #57
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #63 #63
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #70 #70
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #76 #76
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #82 #82
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #88 #88
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #95 #95
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #101 #101
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #108 #108
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #114 #114
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #124 #124
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #132 #132
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #143 #143
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #154 #154
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2726 #2726
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1934 #1934
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #224 #224
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #237 #237
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #263 #263
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1917 #1917
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1854 #1854
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2700 #2700
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1897 #1897
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1866 #1866
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1840 #1840
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2654 #2654
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1815 #1815
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2632 #2632
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1771 #1771
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2573 #2573
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1726 #1726
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1741 #1741
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1689 #1689
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1023 #1023
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1037 #1037
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1058 #1058
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1076 #1076
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1704 #1704
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2534 #2534
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1674 #1674
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2497 #2497
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1306 #1306
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1317 #1317
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2517 #2517
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2450 #2450
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2471 #2471
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1477 #1477
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1495 #1495
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1522 #1522
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #43 #43
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #50 #50
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #57 #57
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #63 #63
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #70 #70
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #76 #76
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #82 #82
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #88 #88
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #95 #95
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #101 #101
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #108 #108
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #114 #114
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #124 #124
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #132 #132
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #143 #143
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #154 #154
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2726 #2726
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1934 #1934
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #224 #224
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #237 #237
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #263 #263
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1917 #1917
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1854 #1854
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2700 #2700
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1897 #1897
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1866 #1866
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1840 #1840
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2654 #2654
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1815 #1815
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2632 #2632
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1771 #1771
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2573 #2573
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1726 #1726
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1741 #1741
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1689 #1689
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1023 #1023
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1037 #1037
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1058 #1058
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1076 #1076
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1704 #1704
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2534 #2534
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1674 #1674
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2497 #2497
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1306 #1306
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1317 #1317
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2517 #2517
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2450 #2450
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2471 #2471
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1477 #1477
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1495 #1495
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1522 #1522
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #43 #43
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #50 #50
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #57 #57
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #63 #63
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #70 #70
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #76 #76
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #82 #82
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #88 #88
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #95 #95
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #101 #101
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #108 #108
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #114 #114
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #124 #124
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #132 #132
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #143 #143
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #154 #154
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #2726 #2726
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #1934 #1934
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #224 #224
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #237 #237
[mk-proof] #1618 refl #1617
[mk-app] #1617 = #263 #263
[mk-proof] #1618 refl #1617
[inst-discovered] theory-solving 0x0 basic# ; #1912
[mk-app] #1617 = #1912 #1912
[mk-proof] #1618 rewrite #1617
[instance] 0x0 #1617
[end-of-instance]
[mk-app] #1619 = #1917 #1917
[mk-proof] #1620 refl #1619
[inst-discovered] theory-solving 0x0 basic# ; #2704
[mk-app] #1619 = #2704 #2704
[mk-proof] #1620 rewrite #1619
[instance] 0x0 #1619
[end-of-instance]
[mk-app] #1621 = #2397 #2397
[mk-proof] #1622 monotonicity #1620 #1621
[mk-app] #1623 = #2712 #2712
[mk-proof] #1624 monotonicity #1622 #1623
[inst-discovered] theory-solving 0x0 basic# ; #2712
[mk-proof] #1625 rewrite #1623
[instance] 0x0 #1623
[end-of-instance]
[mk-proof] #1626 trans #1624 #1625 #1623
[mk-app] #1627 = #1854 #1854
[mk-proof] #1628 refl #1627
[inst-discovered] theory-solving 0x0 basic# ; #2234
[mk-app] #1627 = #2234 #2234
[mk-proof] #1628 rewrite #1627
[instance] 0x0 #1627
[end-of-instance]
[mk-app] #1629 = #2235 #2235
[mk-proof] #1630 monotonicity #1628 #1629
[mk-app] #1631 = #2695 #2695
[mk-proof] #1632 monotonicity #1630 #1631
[inst-discovered] theory-solving 0x0 basic# ; #2695
[mk-proof] #1633 rewrite #1631
[instance] 0x0 #1631
[end-of-instance]
[mk-proof] #1634 trans #1632 #1633 #1631
[mk-app] #1635 = #2700 #2700
[mk-proof] #1636 refl #1635
[inst-discovered] theory-solving 0x0 basic# ; #1893
[mk-app] #1635 = #1893 #1893
[mk-proof] #1636 rewrite #1635
[instance] 0x0 #1635
[end-of-instance]
[mk-app] #1637 = #1897 #1897
[mk-proof] #1638 refl #1637
[inst-discovered] theory-solving 0x0 basic# ; #1863
[mk-app] #1637 = #1863 #1863
[mk-proof] #1638 rewrite #1637
[instance] 0x0 #1637
[end-of-instance]
[mk-app] #1640 = #1866 #1866
[mk-proof] #1641 refl #1640
[inst-discovered] theory-solving 0x0 basic# ; #2670
[mk-app] #1640 = #2670 #2670
[mk-proof] #1641 rewrite #1640
[instance] 0x0 #1640
[end-of-instance]
[mk-app] #1639 = #2671 #2671
[mk-proof] #1642 monotonicity #1641 #1639
[mk-app] #1643 = #2674 #2674
[mk-proof] #1644 monotonicity #1642 #1643
[mk-app] #2203 = #1832 #1832
[mk-proof] #2204 monotonicity #1644 #2203
[mk-app] #2205 = #1834 #1834
[mk-proof] #2423 monotonicity #2204 #2205
[inst-discovered] theory-solving 0x0 basic# ; #1834
[mk-proof] #2424 rewrite #2205
[instance] 0x0 #2205
[end-of-instance]
[mk-proof] #2426 trans #2423 #2424 #2205
[mk-app] #2427 = #1835 #1835
[mk-proof] #2430 monotonicity #2426 #2427
[mk-app] #2431 = #1840 #1840
[mk-proof] #2435 refl #2431
[inst-discovered] theory-solving 0x0 basic# ; #2644
[mk-app] #2431 = #2644 #2644
[mk-proof] #2435 rewrite #2431
[instance] 0x0 #2431
[end-of-instance]
[mk-app] #2436 = #2654 #2654
[mk-proof] #2438 refl #2436
[mk-app] #2436 = #1795 #1795
[mk-proof] #2438 monotonicity #2663 #2436
[mk-app] #2439 = #1796 #1796
[mk-proof] #2441 monotonicity #2438 #2439
[inst-discovered] theory-solving 0x0 basic# ; #1796
[mk-proof] #2442 rewrite #2439
[instance] 0x0 #2439
[end-of-instance]
[mk-proof] #2444 trans #2441 #2442 #2439
[mk-app] #2445 = #1797 #1797
[mk-proof] #2446 monotonicity #2444 #2445
[mk-app] #2447 = #1801 #1801
[mk-proof] #2448 monotonicity #2446 #2447
[mk-app] #1577 = #1807 #1807
[mk-proof] #1578 monotonicity #2448 #1577
[mk-app] #1579 = #1809 #1809
[mk-proof] #1580 monotonicity #1578 #1579
[inst-discovered] theory-solving 0x0 basic# ; #1809
[mk-proof] #1581 rewrite #1579
[instance] 0x0 #1579
[end-of-instance]
[mk-proof] #1582 trans #1580 #1581 #1579
[mk-app] #1583 = #1810 #1810
[mk-proof] #1584 monotonicity #1582 #1583
[mk-app] #1585 = #1815 #1815
[mk-proof] #1586 refl #1585
[inst-discovered] theory-solving 0x0 basic# ; #2611
[mk-app] #1585 = #2611 #2611
[mk-proof] #1586 rewrite #1585
[instance] 0x0 #1585
[end-of-instance]
[mk-app] #1587 = #2613 #2613
[mk-proof] #1588 monotonicity #1586 #1587
[mk-app] #1589 = #2625 #2625
[mk-proof] #1590 monotonicity #1588 #1589
[inst-discovered] theory-solving 0x0 basic# ; #2625
[mk-proof] #1591 rewrite #1589
[instance] 0x0 #1589
[end-of-instance]
[mk-proof] #1592 trans #1590 #1591 #1589
[mk-app] #1593 = #2632 #2632
[mk-proof] #1594 refl #1593
[inst-discovered] theory-solving 0x0 basic# ; #1766
[mk-app] #1593 = #1766 #1766
[mk-proof] #1594 rewrite #1593
[instance] 0x0 #1593
[end-of-instance]
[mk-app] #1595 = #1771 #1771
[mk-proof] #1596 refl #1595
[inst-discovered] theory-solving 0x0 basic# ; #1791
[mk-app] #1595 = #1791 #1791
[mk-proof] #1596 rewrite #1595
[instance] 0x0 #1595
[end-of-instance]
[mk-app] #1597 = #2573 #2573
[mk-proof] #1598 refl #1597
[inst-discovered] theory-solving 0x0 basic# ; #1721
[mk-app] #1597 = #1721 #1721
[mk-proof] #1598 rewrite #1597
[instance] 0x0 #1597
[end-of-instance]
[mk-app] #1599 = #1726 #1726
[mk-proof] #1600 refl #1599
[inst-discovered] theory-solving 0x0 basic# ; #1735
[mk-app] #1599 = #1735 #1735
[mk-proof] #1600 rewrite #1599
[instance] 0x0 #1599
[end-of-instance]
[mk-app] #1601 = #1741 #1741
[mk-proof] #1602 refl #1601
[inst-discovered] theory-solving 0x0 basic# ; #1684
[mk-app] #1601 = #1684 #1684
[mk-proof] #1602 rewrite #1601
[instance] 0x0 #1601
[end-of-instance]
[mk-app] #1603 = #1689 #1689
[mk-proof] #1604 refl #1603
[mk-app] #1603 = #1023 #1023
[mk-proof] #1604 refl #1603
[mk-app] #1603 = #1037 #1037
[mk-proof] #1604 refl #1603
[mk-app] #1603 = #1058 #1058
[mk-proof] #1604 refl #1603
[mk-app] #1603 = #1076 #1076
[mk-proof] #1604 refl #1603
[inst-discovered] theory-solving 0x0 basic# ; #1697
[mk-app] #1603 = #1697 #1697
[mk-proof] #1604 rewrite #1603
[instance] 0x0 #1603
[end-of-instance]
[mk-app] #1606 = #1698 #1698
[mk-proof] #1607 monotonicity #1604 #1606
[mk-app] #1605 = #1701 #1701
[mk-proof] #1608 monotonicity #1607 #1605
[mk-app] #1609 = #1704 #1704
[mk-proof] #1610 refl #1609
[inst-discovered] theory-solving 0x0 basic# ; #2526
[mk-app] #1609 = #2526 #2526
[mk-proof] #1610 rewrite #1609
[instance] 0x0 #1609
[end-of-instance]
[mk-app] #2200 = #2534 #2534
[mk-proof] #2201 refl #2200
[inst-discovered] theory-solving 0x0 basic# ; #1669
[mk-app] #2200 = #1669 #1669
[mk-proof] #2201 rewrite #2200
[instance] 0x0 #2200
[end-of-instance]
[mk-app] #2202 = #1674 #1674
[mk-proof] #2390 refl #2202
[inst-discovered] theory-solving 0x0 basic# ; #2485
[mk-app] #2202 = #2485 #2485
[mk-proof] #2390 rewrite #2202
[instance] 0x0 #2202
[end-of-instance]
[mk-app] #2391 = #2486 #2486
[mk-proof] #2393 monotonicity #2390 #2391
[mk-app] #2394 = #2492 #2492
[mk-proof] #2402 monotonicity #2393 #2394
[mk-app] #2403 = #2497 #2497
[mk-proof] #2405 refl #2403
[mk-app] #2403 = #1306 #1306
[mk-proof] #2405 refl #2403
[mk-app] #2403 = #1317 #1317
[mk-proof] #2405 refl #2403
[inst-discovered] theory-solving 0x0 basic# ; #2511
[mk-app] #2403 = #2511 #2511
[mk-proof] #2405 rewrite #2403
[instance] 0x0 #2403
[end-of-instance]
[mk-app] #2406 = #2513 #2513
[mk-proof] #2408 monotonicity #2405 #2406
[mk-app] #2409 = #2517 #2517
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2450 #2450
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2471 #2471
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1477 #1477
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1495 #1495
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1522 #1522
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #43 #43
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #50 #50
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #57 #57
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #63 #63
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #70 #70
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #76 #76
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #82 #82
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #88 #88
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #95 #95
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #101 #101
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #108 #108
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #114 #114
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #124 #124
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #132 #132
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #143 #143
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #154 #154
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2726 #2726
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1934 #1934
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #224 #224
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #237 #237
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #263 #263
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1917 #1917
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1854 #1854
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2700 #2700
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1897 #1897
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1866 #1866
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1840 #1840
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2654 #2654
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1815 #1815
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2632 #2632
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1771 #1771
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2573 #2573
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1726 #1726
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1741 #1741
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1689 #1689
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1023 #1023
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1037 #1037
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1058 #1058
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1076 #1076
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1704 #1704
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2534 #2534
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1674 #1674
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2497 #2497
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1306 #1306
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1317 #1317
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2517 #2517
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2450 #2450
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #2471 #2471
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1477 #1477
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1495 #1495
[mk-proof] #2411 refl #2409
[mk-app] #2409 = #1522 #1522
[mk-proof] #2411 refl #2409
[assign] #43 justification -1: 
[assign] #50 justification -1: 
[assign] #57 justification -1: 
[assign] #63 justification -1: 
[assign] #70 justification -1: 
[assign] #76 justification -1: 
[assign] #82 justification -1: 
[assign] #88 justification -1: 
[assign] #95 justification -1: 
[assign] #101 justification -1: 
[assign] #108 justification -1: 
[assign] #114 justification -1: 
[assign] #124 justification -1: 
[attach-enode] #130 0
[attach-enode] #131 0
[attach-enode] #36 0
[attach-enode] #132 0
[assign] #132 justification -1: 
[assign] #143 justification -1: 
[assign] #154 justification -1: 
[assign] #2726 justification -1: 
[assign] #1934 justification -1: 
[assign] #224 justification -1: 
[assign] #237 justification -1: 
[assign] #263 justification -1: 
[assign] #1917 justification -1: 
[assign] #1854 justification -1: 
[assign] #2700 justification -1: 
[assign] #1897 justification -1: 
[assign] #1866 justification -1: 
[assign] #1840 justification -1: 
[assign] #2654 justification -1: 
[assign] #1815 justification -1: 
[assign] #2632 justification -1: 
[assign] #1771 justification -1: 
[assign] #2573 justification -1: 
[assign] #1726 justification -1: 
[assign] #1741 justification -1: 
[assign] #1689 justification -1: 
[assign] #1023 justification -1: 
[assign] #1037 justification -1: 
[assign] #1058 justification -1: 
[assign] #1076 justification -1: 
[assign] #1704 justification -1: 
[assign] #2534 justification -1: 
[assign] #1674 justification -1: 
[assign] #2497 justification -1: 
[assign] #1306 justification -1: 
[assign] #1317 justification -1: 
[assign] #2517 justification -1: 
[assign] #2450 justification -1: 
[assign] #2471 justification -1: 
[assign] #1477 justification -1: 
[assign] #1495 justification -1: 
[assign] #1522 justification -1: 
[mk-app] #2436 = #43 #1
[mk-proof] #2438 iff-true #2891 #2436
[mk-app] #2439 = #50 #1
[mk-proof] #2441 iff-true #2102 #2439
[mk-app] #2442 = #57 #1
[mk-proof] #2444 iff-true #2132 #2442
[mk-app] #2445 = #63 #1
[mk-proof] #2446 iff-true #2908 #2445
[mk-app] #2447 = #70 #1
[mk-proof] #2448 iff-true #2279 #2447
[mk-app] #1577 = #76 #1
[mk-proof] #1578 iff-true #2904 #1577
[mk-app] #1579 = #82 #1
[mk-proof] #1580 iff-true #2121 #1579
[mk-app] #1581 = #88 #1
[mk-proof] #1582 iff-true #2275 #1581
[mk-app] #1583 = #95 #1
[mk-proof] #1584 iff-true #2888 #1583
[mk-app] #2202 = #101 #1
[mk-proof] #2390 iff-true #2114 #2202
[mk-app] #2391 = #108 #1
[mk-proof] #2393 iff-true #2860 #2391
[mk-app] #2394 = #114 #1
[mk-proof] #2402 iff-true #2871 #2394
[mk-app] #1603 = #124 #1
[mk-proof] #1604 iff-true #2880 #1603
[mk-app] #1606 = #143 #1
[mk-proof] #1607 iff-true #2081 #1606
[mk-app] #1640 = #154 #1
[mk-proof] #1641 iff-true #2088 #1640
[mk-app] #1639 = #2726 #1
[mk-proof] #1642 iff-true #2731 #1639
[mk-app] #1643 = #1934 #1
[mk-proof] #1644 iff-true #2246 #1643
[mk-app] #2203 = #224 #1
[mk-proof] #2204 iff-true #2844 #2203
[mk-app] #2205 = #237 #1
[mk-proof] #2423 iff-true #2853 #2205
[mk-app] #2424 = #263 #1
[mk-proof] #2426 iff-true #2822 #2424
[mk-app] #2427 = #1917 #1
[mk-proof] #2430 iff-true #1922 #2427
[mk-app] #1593 = #1854 #1
[mk-proof] #1594 iff-true #1900 #1593
[mk-app] #1619 = #2700 #1
[mk-proof] #1620 iff-true #1876 #1619
[mk-app] #1621 = #1897 #1
[mk-proof] #1622 iff-true #2385 #1621
[mk-app] #1597 = #1866 #1
[mk-proof] #1598 iff-true #2228 #1597
[mk-app] #1627 = #1840 #1
[mk-proof] #1628 iff-true #1845 #1627
[mk-app] #1629 = #2654 #1
[mk-proof] #1630 iff-true #2661 #1629
[mk-app] #1631 = #1815 #1
[mk-proof] #1632 iff-true #1820 #1631
[mk-app] #1633 = #2632 #1
[mk-proof] #1634 iff-true #2638 #1633
[mk-app] #1585 = #1771 #1
[mk-proof] #1586 iff-true #1776 #1585
[mk-app] #1587 = #2573 #1
[mk-proof] #1588 iff-true #2579 #1587
[mk-app] #1617 = #1726 #1
[mk-proof] #1618 iff-true #1731 #1617
[mk-app] #1623 = #1741 #1
[mk-proof] #1624 iff-true #1745 #1623
[mk-app] #1625 = #1689 #1
[mk-proof] #1626 iff-true #1694 #1625
[mk-app] #2431 = #1023 #1
[mk-proof] #2435 iff-true #2258 #2431
[mk-app] #1599 = #1037 #1
[mk-proof] #1600 iff-true #2770 #1599
[mk-app] #1609 = #1058 #1
[mk-proof] #1610 iff-true #2780 #1609
[mk-app] #1595 = #1076 #1
[mk-proof] #1596 iff-true #1978 #1595
[mk-app] #2403 = #1704 #1
[mk-proof] #2405 iff-true #1709 #2403
[mk-app] #2406 = #2534 #1
[mk-proof] #2408 iff-true #2541 #2406
[mk-app] #1635 = #1674 #1
[mk-proof] #1636 iff-true #1679 #1635
[mk-app] #1605 = #2497 #1
[mk-proof] #1608 iff-true #2507 #1605
[mk-app] #1637 = #1306 #1
[mk-proof] #1638 iff-true #2760 #1637
[mk-app] #2200 = #1317 #1
[mk-proof] #2201 iff-true #1949 #2200
[mk-app] #1601 = #2517 #1
[mk-proof] #1602 iff-true #1646 #1601
[mk-app] #1589 = #2450 #1
[mk-proof] #1590 iff-true #2457 #1589
[mk-app] #1591 = #2471 #1
[mk-proof] #1592 iff-true #1616 #1591
[mk-app] #2409 = #1477 #1
[mk-proof] #2411 iff-true #2735 #2409
[mk-app] #2412 = #1495 #1
[mk-proof] #2413 iff-true #2745 #2412
[mk-app] #2414 = #1522 #1
[mk-proof] #2415 iff-true #1942 #2414
[eq-expl] #130 root
[new-match] 0x11e1235e0 #124 #118 #130 ; #131
[new-match] 0x11e123610 #143 #118 #130 ; #131
[mk-app] #1543 >= #131 #36
[mk-app] #1544 = #1543 #1543
[mk-proof] #1545 refl #1544
[mk-app] #1546 not #124
[mk-app] #1547 or #1546 #1543
[mk-proof] #1548 quant-inst #1547
[instance] 0x11e1235e0 #1548 ; 1
[assign] #1543 justification -1: p13
[end-of-instance]
[mk-app] #1544 <= #131 #36
[assign] #1544 justification -1: p14
[push] 0
[mk-app] #1545 x@1@01
[mk-app] #1549 $Ref.null
[mk-app] #1550 = #1545 #1549
[mk-app] #1551 not #1550
[mk-proof] #1552 asserted #1551
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[begin-check] 1
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1550 #2
[mk-proof] #1554 iff-false #1552 #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1550 #2
[mk-proof] #1554 iff-false #1552 #1553
[mk-app] #1553 ~ #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 rewrite #1553
[mk-proof] #1555 mp #1552 #1554 #1551
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[mk-app] #1553 = #1551 #1551
[mk-proof] #1554 refl #1553
[attach-enode] #1545 0
[attach-enode] #1549 0
[attach-enode] #1550 0
[assign] (not #1550) justification -1: 
[mk-app] #1553 = #1550 #2
[mk-proof] #1554 iff-false #1552 #1553
[mk-app] #1555 Seq<Int>!val!0
[mk-app] #1556 $Ref!val!0
[mk-app] #1557 $Ref!val!1
[push] 1
[mk-app] #1558 $t@3@01
[mk-app] #1559 $Snap.first #1558
[mk-app] #1560 $Snap.second #1558
[mk-app] #1561 $Snap.combine #1559 #1560
[mk-app] #1562 = #1558 #1561
[mk-proof] #1563 asserted #1562
[mk-app] #1564 = #1562 #1562
[mk-proof] #1565 refl #1564
[mk-app] #1564 $Snap.unit
[mk-app] #1565 = #1560 #1564
[mk-proof] #1566 asserted #1565
[mk-app] #1567 = #1565 #1565
[mk-proof] #1568 refl #1567
[mk-app] #1567 $SortWrappers.$SnapToSeq<Int> #1559
[mk-app] #1568 Seq_length #1567
[mk-app] #1569 $t@2@01
[mk-app] #1570 Seq_length #1569
[mk-app] #1572 + #1570 #151
[mk-app] #1573 = #1568 #1572
[mk-proof] #1571 asserted #1573
[mk-app] #1574 + #151 #1570
[inst-discovered] theory-solving 0x0 arith# ; #1572
[mk-app] #1575 = #1572 #1574
[mk-proof] #1576 rewrite #1575
[instance] 0x0 #1575
[end-of-instance]
[mk-app] #2197 = #1568 #1574
[mk-app] #2198 = #1573 #2197
[mk-proof] #2199 monotonicity #1576 #2198
[attach-meaning] #176 arith (- 1)
[mk-app] #2363 * #176 #1570
[mk-app] #2364 + #1568 #2363
[mk-app] #2366 = #2364 #151
[inst-discovered] theory-solving 0x0 arith# ; #2197
[mk-app] #2367 = #2197 #2366
[mk-proof] #2371 rewrite #2367
[instance] 0x0 #2367
[end-of-instance]
[mk-app] #2372 = #1573 #2366
[mk-proof] #2374 trans #2199 #2371 #2372
[mk-proof] #2375 mp #1571 #2374 #2366
[pop] 1 2
[push] 1
[mk-app] #1558 idx_zero@6@01
[mk-app] #1559 offset<Ptr32> #1545 #36
[mk-app] #1567 = #1558 #1559
[mk-proof] #1568 asserted #1567
[mk-app] #1569 = #1567 #1567
[mk-proof] #1570 refl #1569
[mk-app] #1569 idx_one@7@01
[mk-app] #1570 next<Ptr32> #1558
[mk-app] #1572 = #1569 #1570
[mk-proof] #1573 asserted #1572
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1559 #1558
[mk-proof] #1564 symm #1568 #1560
[mk-app] #1565 = #1572 #1572
[mk-proof] #1561 refl #1565
[mk-app] #1565 = #1570 #1569
[mk-proof] #1561 symm #1573 #1565
[mk-app] #1565 = #1572 #1572
[mk-proof] #1561 refl #1565
[mk-app] #1565 = #1570 #1569
[mk-proof] #1561 symm #1573 #1565
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1559 #1558
[mk-proof] #1564 symm #1568 #1560
[mk-app] #1560 ~ #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 ~ #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 rewrite #1560
[mk-proof] #1565 mp #1568 #1564 #1567
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 rewrite #1560
[mk-proof] #1565 mp #1573 #1564 #1572
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1567 #1567
[mk-proof] #1564 refl #1560
[mk-app] #1560 = #1572 #1572
[mk-proof] #1564 refl #1560
[attach-enode] #1558 0
[attach-enode] #1559 0
[attach-enode] #1567 0
[assign] #1567 justification -1: 
[attach-enode] #1569 0
[attach-enode] #1570 0
[attach-enode] #1572 0
[assign] #1572 justification -1: 
[mk-app] #1560 = #1559 #1558
[mk-proof] #1564 symm #1568 #1560
[mk-app] #1565 = #1570 #1569
[mk-proof] #1561 symm #1573 #1565
[eq-expl] #1545 root
[eq-expl] #36 root
[new-match] 0x11e123d60 #1477 #1476 #36 #1545 ; #1559
[eq-expl] #1558 lit #1567 ; #1559
[eq-expl] #1559 root
[new-match] 0x11e123d98 #1495 #1483 #36 #1545 ; #1570 (#1558 #1559)
[mk-app] #1562 offset_inj<Int> #1559 #1545
[mk-app] #1571 = #1562 #36
[mk-app] #1574 = #1571 #1571
[mk-proof] #1575 refl #1574
[mk-app] #1576 not #1477
[mk-app] #2197 or #1576 #1571
[mk-proof] #2198 quant-inst #2197
[instance] 0x11e123d60 #2198 ; 1
[attach-enode] #1562 1
[attach-enode] #1571 1
[assign] #1571 justification -1: p49
[end-of-instance]
[mk-app] #1574 next<Ptr32> #1559
[mk-app] #1575 + #151 #36
[mk-app] #2199 offset<Ptr32> #1545 #1575
[mk-app] #2363 = #1574 #2199
[inst-discovered] theory-solving 0x0 arith# ; #1575
[mk-app] #2364 = #1575 #151
[mk-proof] #2366 rewrite #2364
[instance] 0x0 #2364
[end-of-instance]
[mk-app] #2367 offset<Ptr32> #1545 #151
[mk-app] #2371 = #2199 #2367
[mk-proof] #2372 monotonicity #2366 #2371
[mk-app] #2374 = #1574 #2367
[mk-app] #2375 = #2363 #2374
[mk-proof] #1566 monotonicity #2372 #2375
[mk-app] #1563 not #1495
[mk-app] #2377 or #1563 #2374
[mk-app] #2378 or #1563 #2363
[mk-proof] #2379 quant-inst #2378
[mk-app] #2380 = #2378 #2377
[mk-proof] #2381 monotonicity #1566 #2380
[mk-app] #1538 = #2377 #2377
[mk-proof] #1539 rewrite #1538
[mk-proof] #1537 trans #2381 #1539 #2380
[mk-proof] #1540 mp #2379 #1537 #2377
[instance] 0x11e123d98 #2379 ; 1
[attach-enode] #1574 1
[attach-enode] #151 1
[attach-enode] #2367 1
[attach-enode] #2374 1
[assign] #2374 justification -1: p50
[end-of-instance]
[eq-expl] #151 root
[new-match] 0x11e124210 #1477 #1476 #151 #1545 ; #2367
[mk-app] #1541 offset_inj<Int> #2367 #1545
[mk-app] #1542 = #1541 #151
[mk-app] #2194 = #1542 #1542
[mk-proof] #2195 refl #2194
[mk-app] #2196 or #1576 #1542
[mk-proof] #2289 quant-inst #2196
[instance] 0x11e124210 #2289 ; 2
[attach-enode] #1541 2
[attach-enode] #1542 2
[assign] #1542 justification -1: p49
[end-of-instance]
[push] 2
[mk-app] #2194 = #1558 #1569
[mk-app] #2195 not #2194
[mk-app] #2290 not #2195
[mk-proof] #2300 asserted #2290
[inst-discovered] theory-solving 0x0 basic# ; #2290
[mk-app] #2291 = #2290 #2194
[mk-proof] #2292 rewrite #2291
[instance] 0x0 #2291
[end-of-instance]
[mk-proof] #2321 mp #2300 #2292 #2194
[begin-check] 3
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #1569 #1558
[mk-proof] #2191 symm #2321 #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #1569 #1558
[mk-proof] #2191 symm #2321 #2322
[mk-app] #2322 ~ #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 rewrite #2322
[mk-proof] #2192 mp #2321 #2191 #2194
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[mk-app] #2322 = #2194 #2194
[mk-proof] #2191 refl #2322
[attach-enode] #2194 0
[assign] #2194 justification -1: 
[mk-app] #2322 = #1569 #1558
[mk-proof] #2191 symm #2321 #2322
[mk-proof] #2192 unit-resolution #2289 #2735 #1542
[mk-proof] #2193 unit-resolution #1540 #2745 #2374
[mk-app] #2347 = #2367 #1574
[mk-proof] #2348 symm #2193 #2347
[mk-app] #2288 = #1574 #1570
[mk-proof] #2315 monotonicity #1564 #2288
[mk-app] #2316 = #1570 #1574
[mk-proof] #2317 symm #2315 #2316
[mk-app] #2318 = #1559 #2367
[mk-proof] #2188 trans* #1564 #2321 #1573 #2317 #2193 #2318
[mk-proof] #2189 unit-resolution #2198 #2735 #1571
[mk-app] #2190 = #36 #1562
[mk-proof] #2343 symm #2189 #2190
[mk-app] #2344 = #1562 #1541
[mk-proof] #2356 monotonicity #2188 #2344
[mk-app] #2339 = #36 #151
[mk-proof] #2340 trans* #2343 #2356 #2192 #2339
[mk-app] #2341 = #2339 #2
[mk-proof] #2342 rewrite #2341
[mk-proof] #2185 mp #2340 #2342 #2
[pop] 1 3
[mk-proof] #2322 asserted #2195
[mk-app] #2191 = #2195 #2195
[mk-proof] #2347 refl #2191
[mk-app] #2191 Seq_singleton #36
[mk-app] #2347 Seq_length #2191
[mk-app] #2348 = #2347 #151
[mk-proof] #2186 asserted #2348
[mk-app] #2187 = #2348 #2348
[mk-proof] #1528 refl #2187
[mk-app] #2187 seq@8@01
[mk-app] #1528 $t@2@01
[mk-app] #1529 Seq_append #1528 #2191
[mk-app] #1530 = #2187 #1529
[mk-proof] #1532 asserted #1530
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2194 #2
[mk-proof] #1531 iff-false #2322 #1533
[mk-app] #1534 = #2348 #2348
[mk-proof] #1535 refl #1534
[mk-app] #1534 = #1530 #1530
[mk-proof] #1535 refl #1534
[mk-app] #1534 = #1529 #2187
[mk-proof] #1535 symm #1532 #1534
[mk-app] #1534 = #1530 #1530
[mk-proof] #1535 refl #1534
[mk-app] #1534 = #1529 #2187
[mk-proof] #1535 symm #1532 #1534
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2194 #2
[mk-proof] #1531 iff-false #2322 #1533
[mk-app] #1533 ~ #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 ~ #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 ~ #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 rewrite #1533
[mk-proof] #1534 mp #2322 #1531 #2195
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 rewrite #1533
[mk-proof] #1534 mp #2186 #1531 #2348
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 rewrite #1533
[mk-proof] #1534 mp #1532 #1531 #1530
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2195 #2195
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #2348 #2348
[mk-proof] #1531 refl #1533
[mk-app] #1533 = #1530 #1530
[mk-proof] #1531 refl #1533
[attach-enode] #2194 0
[assign] (not #2194) justification -1: 
[attach-enode] #2191 0
[attach-enode] #2347 0
[attach-enode] #2348 0
[assign] #2348 justification -1: 
[attach-enode] #2187 0
[attach-enode] #1528 0
[attach-enode] #1529 0
[attach-enode] #1530 0
[assign] #1530 justification -1: 
[mk-app] #1533 = #2194 #2
[mk-proof] #1531 iff-false #2322 #1533
[mk-app] #1534 = #1529 #2187
[mk-proof] #1535 symm #1532 #1534
[eq-expl] #2191 root
[new-match] 0x106808480 #124 #118 #2191 ; #2347
[new-match] 0x1068084b0 #143 #118 #2191 ; #2347
[new-match] 0x1068084e0 #154 #153 #36 ; #2191
[new-match] 0x106808510 #224 #153 #36 ; #2191
[eq-expl] #1528 root
[new-match] 0x106808540 #1934 #204 #2191 #1528 ; #1529
[mk-app] #1536 >= #2347 #36
[mk-app] #2182 = #1536 #1536
[mk-proof] #2183 refl #2182
[mk-app] #2184 or #1546 #1536
[mk-proof] #2298 quant-inst #2184
[instance] 0x106808480 #2298 ; 1
[assign] #1536 justification -1: p13
[end-of-instance]
[mk-app] #2182 = #2347 #36
[mk-app] #2183 not #2182
[mk-app] #2353 = #2191 #130
[mk-app] #2303 or #2183 #2353
[mk-app] #2304 = #2303 #2303
[mk-proof] #2306 refl #2304
[mk-app] #2307 not #143
[mk-app] #2308 or #2307 #2183 #2353
[mk-app] #2309 or #2307 #2303
[mk-proof] #2310 quant-inst #2309
[mk-app] #2179 = #2309 #2308
[mk-proof] #2180 rewrite #2179
[mk-proof] #2181 mp #2310 #2180 #2308
[instance] 0x1068084b0 #2310 ; 1
[attach-enode] #2182 1
[mk-app] #2176 <= #2347 #36
[attach-enode] #2353 1
[end-of-instance]
[mk-app] #2304 Seq_index #2191 #36
[mk-app] #2306 = #2304 #36
[mk-app] #2177 = #2306 #2306
[mk-proof] #2178 refl #2177
[mk-app] #2173 not #224
[mk-app] #2174 or #2173 #2306
[mk-proof] #2175 quant-inst #2174
[instance] 0x106808510 #2175 ; 1
[attach-enode] #2304 1
[attach-enode] #2306 1
[assign] #2306 justification -1: p19
[end-of-instance]
[mk-app] #2177 not #2353
[mk-app] #2178 = #1529 #1528
[mk-app] #2170 or #2177 #2178
[mk-app] #2171 not #2170
[mk-app] #2172 = #1528 #130
[mk-app] #2294 not #2172
[mk-app] #2167 = #1529 #2191
[mk-app] #2168 or #2294 #2167
[mk-app] #2169 not #2168
[mk-app] #2164 or #2171 #2169
[mk-app] #2165 not #2164
[mk-app] #2166 or #2169 #2171
[inst-discovered] theory-solving 0x0 basic# ; #2164
[mk-app] #2161 = #2164 #2166
[mk-proof] #2162 rewrite #2161
[instance] 0x0 #2161
[end-of-instance]
[mk-app] #2163 not #2166
[mk-app] #2158 = #2165 #2163
[mk-proof] #2159 monotonicity #2162 #2158
[mk-app] #2160 not #1934
[mk-app] #2155 or #2160 #2163
[mk-app] #2156 or #2160 #2165
[mk-proof] #2157 quant-inst #2156
[mk-app] #2152 = #2156 #2155
[mk-proof] #2153 monotonicity #2159 #2152
[mk-app] #2154 = #2155 #2155
[mk-proof] #2314 rewrite #2154
[mk-proof] #2333 trans #2153 #2314 #2152
[mk-proof] #2335 mp #2157 #2333 #2155
[instance] 0x106808540 #2157 ; 1
[attach-enode] #2172 1
[attach-enode] #2167 1
[mk-app] #2336 or #2168 #2172
[mk-proof] #2337 def-axiom #2336
[mk-app] #2338 not #2167
[mk-app] #2293 or #2168 #2338
[mk-proof] #2149 def-axiom #2293
[mk-app] #2150 or #2169 #2294 #2167
[mk-proof] #2151 def-axiom #2150
[attach-enode] #2178 1
[mk-app] #2146 or #2170 #2353
[mk-proof] #2147 def-axiom #2146
[mk-app] #2148 not #2178
[mk-app] #2143 or #2170 #2148
[mk-proof] #2144 def-axiom #2143
[mk-app] #2145 or #2171 #2177 #2178
[mk-proof] #2140 def-axiom #2145
[mk-app] #2141 or #2166 #2168
[mk-proof] #2142 def-axiom #2141
[mk-app] #2137 or #2166 #2170
[mk-proof] #2138 def-axiom #2137
[mk-app] #2139 or #2163 #2169 #2171
[mk-proof] #2134 def-axiom #2139
[assign] (not #2166) justification -1: p18
[end-of-instance]
[assign] #2168 clause p70 p73
  (or (not (= $t@2@01 Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int))) 
  (or (not (or (not (= $t@2@01 Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int)))) (not (or (not (= (Seq_singleton 0::Int) Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01)))) 

[assign] #2170 clause p72 p73
  (or (not (= (Seq_singleton 0::Int) Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01)) 
  (or (not (or (not (= $t@2@01 Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int)))) (not (or (not (= (Seq_singleton 0::Int) Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01)))) 

[mk-app] #2135 <= #2347 #151
[mk-app] #2136 >= #2347 #151
[assign] #2135 justification -1: p61
[assign] #2136 justification -1: p61
[assign] (not #2176) justification -1: p75
[new-match] 0x106809030 #1674 #1173 #36 #2191 ; #2304
[new-match] 0x106809068 #2700 #412 #36 #2191 #1528 ; #2304 #1529 (#2191 #2191) (#2191 #2191)
[mk-app] #2352 * #176 #2347
[mk-app] #2325 + #36 #2352
[mk-app] #2327 >= #2325 #36
[mk-app] #2328 >= #36 #36
[mk-app] #2329 not #2328
[mk-app] #2330 Seq_contains_trigger #2191 #2304
[mk-app] #2331 or #2327 #2329 #2330
[inst-discovered] theory-solving 0x0 arith# ; #2325
[mk-app] #3561 = #2325 #2352
[mk-proof] #3562 rewrite #3561
[instance] 0x0 #3561
[end-of-instance]
[mk-app] #3563 >= #2352 #36
[mk-app] #3568 = #2327 #3563
[mk-proof] #4472 monotonicity #3562 #3568
[inst-discovered] theory-solving 0x0 arith# ; #3563
[mk-app] #4473 = #3563 #2176
[mk-proof] #4474 rewrite #4473
[instance] 0x0 #4473
[end-of-instance]
[mk-app] #4477 = #2327 #2176
[mk-proof] #4480 trans #4472 #4474 #4477
[inst-discovered] theory-solving 0x0 arith# ; #2328
[mk-app] #4461 = #2328 #1
[mk-proof] #4466 rewrite #4461
[instance] 0x0 #4461
[end-of-instance]
[mk-app] #4435 not #1
[mk-app] #4436 = #2329 #4435
[mk-proof] #4437 monotonicity #4466 #4436
[inst-discovered] theory-solving 0x0 basic# ; #4435
[mk-app] #4438 = #4435 #2
[mk-proof] #4441 rewrite #4438
[instance] 0x0 #4438
[end-of-instance]
[mk-app] #4412 = #2329 #2
[mk-proof] #4413 trans #4437 #4441 #4412
[mk-app] #3464 or #2176 #2 #2330
[mk-app] #3465 = #2331 #3464
[mk-proof] #4416 monotonicity #4480 #4413 #3465
[mk-app] #4417 or #2176 #2330
[inst-discovered] theory-solving 0x0 basic# ; #3464
[mk-app] #3470 = #3464 #4417
[mk-proof] #4420 rewrite #3470
[instance] 0x0 #3470
[end-of-instance]
[mk-app] #4421 = #2331 #4417
[mk-proof] #4422 trans #4416 #4420 #4421
[mk-app] #4423 not #1674
[mk-app] #4426 or #4423 #2176 #2330
[mk-app] #4429 or #4423 #2331
[mk-proof] #4401 quant-inst #4429
[mk-app] #4406 or #4423 #4417
[mk-app] #3426 = #4429 #4406
[mk-proof] #3427 monotonicity #4422 #3426
[mk-app] #4361 = #4406 #4426
[mk-proof] #4376 rewrite #4361
[mk-app] #4381 = #4429 #4426
[mk-proof] #4346 trans #3427 #4376 #4381
[mk-proof] #3401 mp #4401 #4346 #4426
[instance] 0x106809030 #4401 ; 2
[attach-enode] #2330 2
[assign] #2330 justification -1: p42 (not p65)
[end-of-instance]
[mk-app] #3402 Seq_length #1528
[mk-app] #3403 Seq_add #36 #3402
[mk-app] #4347 Seq_sub #3403 #3402
[mk-app] #4348 = #4347 #36
[mk-app] #4349 not #4348
[mk-app] #4352 Seq_index #1529 #3403
[mk-app] #4355 = #4352 #2304
[mk-app] #3024 not #4355
[mk-app] #3025 or #4349 #3024
[mk-app] #3026 not #3025
[mk-app] #3997 or #2353 #2172 #2327 #2329 #3026
[mk-app] #4327 or #3024 #4349
[inst-discovered] theory-solving 0x0 basic# ; #3025
[mk-app] #4328 = #3025 #4327
[mk-proof] #4329 rewrite #4328
[instance] 0x0 #4328
[end-of-instance]
[mk-app] #4335 not #4327
[mk-app] #4340 = #3026 #4335
[mk-proof] #4305 monotonicity #4329 #4340
[mk-app] #4310 or #2353 #2172 #2176 #2 #4335
[mk-app] #4283 = #3997 #4310
[mk-proof] #4284 monotonicity #4480 #4413 #4305 #4283
[mk-app] #4285 or #2172 #2176 #2353 #4335
[inst-discovered] theory-solving 0x0 basic# ; #4310
[mk-app] #4291 = #4310 #4285
[mk-proof] #4296 rewrite #4291
[instance] 0x0 #4291
[end-of-instance]
[mk-app] #4261 = #3997 #4285
[mk-proof] #4266 trans #4284 #4296 #4261
[mk-app] #3335 not #2700
[mk-app] #3336 or #3335 #2172 #2176 #2353 #4335
[mk-app] #3337 or #3335 #3997
[mk-proof] #4227 quant-inst #3337
[mk-app] #3348 or #3335 #4285
[mk-app] #3349 = #3337 #3348
[mk-proof] #3350 monotonicity #4266 #3349
[mk-app] #4228 = #3348 #3336
[mk-proof] #4229 rewrite #4228
[mk-app] #4230 = #3337 #3336
[mk-proof] #4236 trans #3350 #4229 #4230
[mk-proof] #4241 mp #4227 #4236 #3336
[instance] 0x106809068 #4227 ; 2
[attach-enode] #3402 2
[attach-enode] #3403 2
[attach-enode] #4352 2
[attach-enode] #4355 2
[attach-enode] #4347 2
[attach-enode] #4348 2
[mk-app] #3306 or #4327 #4355
[mk-proof] #3307 def-axiom #3306
[mk-app] #3308 or #4327 #4348
[mk-proof] #4196 def-axiom #3308
[mk-app] #4197 or #4335 #3024 #4349
[mk-proof] #4198 def-axiom #4197
[end-of-instance]
[assign] (not #2182) clause (not p64) p65
  (not (= (Seq_length (Seq_singleton 0::Int)) 0::Int)) 
  (<= (Seq_length (Seq_singleton 0::Int)) 0::Int) 

[push] 2
[mk-app] #4199 address<Int> #1558
[mk-app] #4205 mod #4199 #1503
[mk-app] #4210 = #4205 #36
[mk-app] #4158 not #4210
[mk-app] #4159 not #4158
[mk-proof] #4160 asserted #4159
[inst-discovered] theory-solving 0x0 basic# ; #4159
[mk-app] #4161 = #4159 #4210
[mk-proof] #4165 rewrite #4161
[instance] 0x0 #4161
[end-of-instance]
[mk-proof] #4171 mp #4160 #4165 #4210
[begin-check] 3
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 ~ #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 rewrite #3265
[mk-proof] #3267 mp #4171 #3266 #4210
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[mk-app] #3265 = #4210 #4210
[mk-proof] #3266 refl #3265
[attach-enode] #4199 0
[attach-enode] #1503 0
[attach-enode] #4205 0
[attach-enode] #4210 0
[mk-app] #3265 <= #4205 #36
[mk-app] #3266 >= #4205 #36
[assign] #4210 justification -1: 
[mk-app] #3267 div #4199 #1503
[mk-app] #3272 < #1503 #36
[mk-app] #4172 - #36 #1503
[mk-app] #4173 if #3272 #4172 #1503
[mk-app] #4174 - #4173 #151
[mk-app] #4179 <= #36 #1503
[mk-app] #3233 not #4179
[inst-discovered] theory-solving 0x0 arith# ; #3272
[mk-app] #3234 = #3272 #3233
[mk-proof] #3235 rewrite #3234
[instance] 0x0 #3234
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #4179
[mk-app] #4145 = #4179 #1
[mk-proof] #4150 rewrite #4145
[instance] 0x0 #4145
[end-of-instance]
[mk-app] #3183 = #3233 #4435
[mk-proof] #3184 monotonicity #4150 #3183
[inst-discovered] theory-solving 0x0 basic# ; #4435
[instance] 0x0 #4438
[end-of-instance]
[mk-app] #3185 = #3233 #2
[mk-proof] #3190 trans #3184 #4441 #3185
[mk-app] #4105 = #3272 #2
[mk-proof] #3199 trans #3235 #3190 #4105
[attach-meaning] #176 arith (- 1)
[mk-app] #3200 * #176 #1503
[mk-app] #3205 + #36 #3200
[inst-discovered] theory-solving 0x0 arith# ; #4172
[mk-app] #4106 = #4172 #3205
[mk-proof] #4107 rewrite #4106
[instance] 0x0 #4106
[end-of-instance]
[mk-app] #4108 Int
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3200
[mk-app] #4111 = #3200 #4108
[mk-proof] #4117 rewrite #4111
[instance] 0x0 #4111
[end-of-instance]
[mk-app] #4118 + #36 #4108
[mk-app] #4119 = #3205 #4118
[mk-proof] #4120 monotonicity #4117 #4119
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4118
[mk-app] #4125 = #4118 #4108
[mk-proof] #3138 rewrite #4125
[instance] 0x0 #4125
[end-of-instance]
[mk-app] #3143 = #3205 #4108
[mk-proof] #3152 trans #4120 #3138 #3143
[mk-app] #3153 = #4172 #4108
[mk-proof] #3154 trans #4107 #3152 #3153
[mk-app] #3159 if #2 #4108 #1503
[mk-app] #4085 = #4173 #3159
[mk-proof] #3162 monotonicity #3199 #3154 #4085
[inst-discovered] theory-solving 0x0 arith# ; #3159
[mk-app] #4086 = #3159 #1503
[mk-proof] #4087 rewrite #4086
[instance] 0x0 #4086
[end-of-instance]
[mk-app] #4088 = #4173 #1503
[mk-proof] #4094 trans #3162 #4087 #4088
[mk-app] #4099 - #1503 #151
[mk-app] #3100 = #4174 #4099
[mk-proof] #3101 monotonicity #4094 #3100
[attach-meaning] #176 arith (- 1)
[mk-app] #3102 * #176 #151
[mk-app] #4048 + #1503 #3102
[inst-discovered] theory-solving 0x0 arith# ; #4099
[mk-app] #4063 = #4099 #4048
[mk-proof] #4068 rewrite #4063
[instance] 0x0 #4063
[end-of-instance]
[mk-app] #3062 = #4174 #4048
[mk-proof] #3063 trans #3101 #4068 #3062
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3102
[mk-app] #3064 = #3102 #176
[mk-proof] #4028 rewrite #3064
[instance] 0x0 #3064
[end-of-instance]
[mk-app] #4029 + #1503 #176
[mk-app] #4030 = #4048 #4029
[mk-proof] #4031 monotonicity #4028 #4030
[mk-app] #4037 Int
[attach-meaning] #4037 arith 3
[inst-discovered] theory-solving 0x0 arith# ; #4029
[mk-app] #4042 = #4029 #4037
[mk-proof] #3998 rewrite #4042
[instance] 0x0 #4042
[end-of-instance]
[mk-app] #3999 = #4048 #4037
[mk-proof] #4000 trans #4031 #3998 #3999
[mk-app] #4006 = #4174 #4037
[mk-proof] #4011 trans #3063 #4000 #4006
[mk-app] #3975 = #1503 #36
[mk-app] #3980 * #1503 #3267
[mk-app] #2934 + #3980 #4205
[mk-app] #2935 = #2934 #4199
[mk-app] #2936 <= #4205 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3975
[mk-app] #3272 = #3975 #2
[mk-proof] #3234 rewrite #3272
[instance] 0x0 #3272
[end-of-instance]
[attach-enode] #3267 0
[attach-enode] #3980 0
[attach-enode] #2934 0
[attach-enode] #2935 0
[mk-app] #3235 or #3975 #2935
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #3235
[assign] #2935 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3975
[mk-app] #3272 = #3975 #2
[mk-proof] #3234 rewrite #3272
[instance] 0x0 #3272
[end-of-instance]
[attach-enode] #3266 0
[mk-app] #3235 or #3975 #3266
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #3235
[assign] #3266 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3975
[mk-app] #3272 = #3975 #2
[mk-proof] #3234 rewrite #3272
[instance] 0x0 #3272
[end-of-instance]
[attach-enode] #2936 0
[mk-app] #3235 or #3975 #2936
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #3235
[assign] #2936 justification -1: true
[end-of-instance]
[assign] #3265 clause p81 (not p80)
  (<= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int) 
  (not (= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 

[eq-expl] #1558 lit #1567 ; #1559
[eq-expl] #1559 root
[new-match] 0x106809ed0 #1522 #1506 #36 #1545 ; #4199 (#1558 #1559)
[mk-app] #3235 address<Int> #1574
[mk-app] #4105 address<Int> #1559
[mk-app] #3199 * #176 #4105
[mk-app] #4172 + #3235 #3199
[mk-app] #4106 = #4172 #1503
[mk-app] #3975 = #4106 #4106
[mk-proof] #3272 refl #3975
[mk-app] #3234 not #1522
[mk-app] #4107 or #3234 #4106
[mk-proof] #3153 quant-inst #4107
[instance] 0x106809ed0 #3153 ; 1
[attach-enode] #3235 1
[attach-enode] #4105 1
[attach-enode] #176 1
[attach-enode] #3199 1
[attach-enode] #4172 1
[attach-enode] #4106 1
[mk-app] #3154 <= #4172 #1503
[mk-app] #4173 >= #4172 #1503
[assign] #4106 justification -1: p51
[end-of-instance]
[assign] #3154 clause p86 (not p85)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[assign] #4173 clause p87 (not p85)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[mk-app] #3975 = #2934 #4105
[attach-meaning] #176 arith (- 1)
[mk-app] #3272 + #2934 #3199
[mk-app] #3159 <= #3272 #36
[mk-app] #4085 >= #3272 #36
[assign] #3975 justification -1: p83 p55
[attach-enode] #3975 0
[attach-enode] #3272 0
[assign] #3159 justification -1: p88
[assign] #4085 justification -1: p88
[eq-expl] #1574 cg (#1559 #1558) ; #1570
[eq-expl] #1570 root
[eq-expl] #2367 lit #2374 ; #1574
[new-match] 0x106817118 #1522 #1506 #151 #1545 ; #3235 (#1574 #2367)
[mk-app] #3162 next<Ptr32> #2367
[mk-app] #4086 address<Int> #3162
[mk-app] #4087 address<Int> #2367
[mk-app] #4088 * #176 #4087
[mk-app] #4094 + #4086 #4088
[mk-app] #4174 = #4094 #1503
[mk-app] #4099 = #4174 #4174
[mk-proof] #3100 refl #4099
[mk-app] #3101 or #3234 #4174
[mk-proof] #4063 quant-inst #3101
[instance] 0x106817118 #4063 ; 2
[attach-enode] #3162 2
[attach-enode] #4086 2
[attach-enode] #4087 2
[attach-enode] #4088 2
[attach-enode] #4094 2
[attach-enode] #4174 2
[mk-app] #4068 <= #4094 #1503
[mk-app] #3062 >= #4094 #1503
[assign] #4174 justification -1: p51
[end-of-instance]
[assign] #4068 clause p92 (not p91)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[assign] #3062 clause p93 (not p91)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[mk-app] #4099 = #3235 #4087
[attach-meaning] #176 arith (- 1)
[mk-app] #3100 + #3235 #4088
[mk-app] #3063 <= #3100 #36
[mk-app] #4006 >= #3100 #36
[assign] #4099 justification -1: p58
[attach-enode] #4099 0
[attach-enode] #3100 0
[assign] #3063 justification -1: p94
[assign] #4006 justification -1: p94
[new-match] 0x106817980 #1495 #1483 #151 #1545 ; #3162 (#2367 #2367)
[mk-app] #4011 + #151 #151
[mk-app] #2941 offset<Ptr32> #1545 #4011
[mk-app] #3949 = #3162 #2941
[mk-app] #3950 Int
[attach-meaning] #3950 arith 2
[inst-discovered] theory-solving 0x0 arith# ; #4011
[mk-app] #3951 = #4011 #3950
[mk-proof] #3952 rewrite #3951
[instance] 0x0 #3951
[end-of-instance]
[mk-app] #3955 offset<Ptr32> #1545 #3950
[mk-app] #3938 = #2941 #3955
[mk-proof] #3943 monotonicity #3952 #3938
[mk-app] #4490 = #3162 #3955
[mk-app] #3018 = #3949 #4490
[mk-proof] #3019 monotonicity #3943 #3018
[mk-app] #3020 or #1563 #4490
[mk-app] #3021 or #1563 #3949
[mk-proof] #3022 quant-inst #3021
[mk-app] #3023 = #3021 #3020
[mk-proof] #3027 monotonicity #3019 #3023
[mk-app] #3028 = #3020 #3020
[mk-proof] #3029 rewrite #3028
[mk-proof] #3030 trans #3027 #3029 #3023
[mk-proof] #3383 mp #3022 #3030 #3020
[instance] 0x106817980 #3022 ; 3
[attach-enode] #3950 3
[attach-enode] #3955 3
[attach-enode] #4490 3
[assign] #4490 justification -1: p50
[end-of-instance]
[eq-expl] #3950 root
[new-match] 0x106817c40 #1477 #1476 #3950 #1545 ; #3955
[eq-expl] #3162 lit #4490 ; #3955
[eq-expl] #3955 root
[new-match] 0x106817c78 #1522 #1506 #3950 #1545 ; #4086 (#3162 #3955)
[mk-app] #3384 offset_inj<Int> #3955 #1545
[mk-app] #3385 = #3384 #3950
[mk-app] #3386 = #3385 #3385
[mk-proof] #3387 refl #3386
[mk-app] #3388 or #1576 #3385
[mk-proof] #3390 quant-inst #3388
[instance] 0x106817c40 #3390 ; 4
[attach-enode] #3384 4
[attach-enode] #3385 4
[assign] #3385 justification -1: p49
[end-of-instance]
[mk-app] #3386 next<Ptr32> #3955
[mk-app] #3387 address<Int> #3386
[mk-app] #3391 address<Int> #3955
[mk-app] #3389 * #176 #3391
[mk-app] #3392 + #3387 #3389
[mk-app] #3393 = #3392 #1503
[mk-app] #3394 = #3393 #3393
[mk-proof] #3811 refl #3394
[mk-app] #3812 or #3234 #3393
[mk-proof] #3813 quant-inst #3812
[instance] 0x106817c78 #3813 ; 4
[attach-enode] #3386 4
[attach-enode] #3387 4
[attach-enode] #3391 4
[attach-enode] #3389 4
[attach-enode] #3392 4
[attach-enode] #3393 4
[mk-app] #3814 <= #3392 #1503
[mk-app] #3815 >= #3392 #1503
[assign] #3393 justification -1: p51
[end-of-instance]
[assign] #3814 clause p100 (not p99)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[assign] #3815 clause p101 (not p99)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[mk-app] #3394 = #3391 #4086
[attach-meaning] #176 arith (- 1)
[mk-app] #3811 * #176 #4086
[mk-app] #3816 + #3391 #3811
[mk-app] #3817 <= #3816 #36
[mk-app] #4316 >= #3816 #36
[assign] #3394 justification -1: p97
[attach-enode] #3394 0
[attach-enode] #3811 0
[attach-enode] #3816 0
[assign] #3817 justification -1: p102
[assign] #4316 justification -1: p102
[new-match] 0x1068186c0 #1495 #1483 #3950 #1545 ; #3386 (#3955 #3955)
[mk-app] #4317 + #151 #3950
[mk-app] #4318 offset<Ptr32> #1545 #4317
[mk-app] #4319 = #3386 #4318
[inst-discovered] theory-solving 0x0 arith# ; #4317
[mk-app] #4320 = #4317 #4037
[mk-proof] #4321 rewrite #4320
[instance] 0x0 #4320
[end-of-instance]
[mk-app] #4322 offset<Ptr32> #1545 #4037
[mk-app] #4323 = #4318 #4322
[mk-proof] #4324 monotonicity #4321 #4323
[mk-app] #4325 = #3386 #4322
[mk-app] #4326 = #4319 #4325
[mk-proof] #4330 monotonicity #4324 #4326
[mk-app] #4331 or #1563 #4325
[mk-app] #4332 or #1563 #4319
[mk-proof] #4333 quant-inst #4332
[mk-app] #4334 = #4332 #4331
[mk-proof] #4336 monotonicity #4330 #4334
[mk-app] #4337 = #4331 #4331
[mk-proof] #4338 rewrite #4337
[mk-proof] #4339 trans #4336 #4338 #4334
[mk-proof] #4341 mp #4333 #4339 #4331
[instance] 0x1068186c0 #4333 ; 5
[attach-enode] #4037 5
[attach-enode] #4322 5
[attach-enode] #4325 5
[assign] #4325 justification -1: p50
[end-of-instance]
[eq-expl] #4037 root
[new-match] 0x106818960 #1477 #1476 #4037 #1545 ; #4322
[eq-expl] #3386 lit #4325 ; #4322
[eq-expl] #4322 root
[new-match] 0x106818998 #1522 #1506 #4037 #1545 ; #3387 (#3386 #4322)
[mk-app] #4342 offset_inj<Int> #4322 #1545
[mk-app] #4343 = #4342 #4037
[mk-app] #4344 = #4343 #4343
[mk-proof] #4345 refl #4344
[mk-app] #4556 or #1576 #4343
[mk-proof] #4557 quant-inst #4556
[instance] 0x106818960 #4557 ; 6
[attach-enode] #4342 6
[attach-enode] #4343 6
[assign] #4343 justification -1: p49
[end-of-instance]
[mk-app] #4344 next<Ptr32> #4322
[mk-app] #4345 address<Int> #4344
[mk-app] #3488 address<Int> #4322
[mk-app] #3489 * #176 #3488
[mk-app] #3490 + #4345 #3489
[mk-app] #3491 = #3490 #1503
[mk-app] #3492 + #3489 #4345
[inst-discovered] theory-solving 0x0 arith# ; #3490
[mk-app] #3493 = #3490 #3492
[mk-proof] #3494 rewrite #3493
[instance] 0x0 #3493
[end-of-instance]
[mk-app] #3495 = #3492 #1503
[mk-app] #3496 = #3491 #3495
[mk-proof] #3497 monotonicity #3494 #3496
[attach-meaning] #176 arith (- 1)
[mk-app] #3498 * #176 #4345
[mk-app] #3499 + #3488 #3498
[attach-meaning] #4108 arith (- 4)
[mk-app] #3500 = #3499 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3495
[mk-app] #3501 = #3495 #3500
[mk-proof] #3502 rewrite #3501
[instance] 0x0 #3501
[end-of-instance]
[mk-app] #3503 = #3491 #3500
[mk-proof] #3504 trans #3497 #3502 #3503
[mk-app] #3505 or #3234 #3500
[mk-app] #3506 or #3234 #3491
[mk-proof] #3507 quant-inst #3506
[mk-app] #3508 = #3506 #3505
[mk-proof] #3509 monotonicity #3504 #3508
[mk-app] #3510 = #3505 #3505
[mk-proof] #3511 rewrite #3510
[mk-proof] #3888 trans #3509 #3511 #3508
[mk-proof] #3889 mp #3507 #3888 #3505
[instance] 0x106818998 #3507 ; 6
[attach-enode] #3488 6
[attach-enode] #4344 6
[attach-enode] #4345 6
[attach-enode] #3498 6
[attach-enode] #3499 6
[attach-enode] #4108 6
[attach-enode] #3500 6
[mk-app] #3890 <= #3499 #4108
[mk-app] #3891 >= #3499 #4108
[assign] #3500 justification -1: p51
[end-of-instance]
[assign] #3890 clause p108 (not p107)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[assign] #3891 clause p109 (not p107)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[mk-app] #3892 = #3387 #3488
[attach-meaning] #176 arith (- 1)
[mk-app] #3893 + #3387 #3489
[mk-app] #3894 <= #3893 #36
[mk-app] #4439 >= #3893 #36
[assign] #3892 justification -1: p105
[attach-enode] #3892 0
[attach-enode] #3489 0
[attach-enode] #3893 0
[assign] #3894 justification -1: p110
[assign] #4439 justification -1: p110
[new-match] 0x10681c4c0 #1495 #1483 #4037 #1545 ; #4344 (#4322 #4322)
[mk-app] #4440 + #151 #4037
[mk-app] #4442 offset<Ptr32> #1545 #4440
[mk-app] #4443 = #4344 #4442
[inst-discovered] theory-solving 0x0 arith# ; #4440
[mk-app] #4444 = #4440 #1503
[mk-proof] #4445 rewrite #4444
[instance] 0x0 #4444
[end-of-instance]
[mk-app] #4446 offset<Ptr32> #1545 #1503
[mk-app] #4544 = #4442 #4446
[mk-proof] #4545 monotonicity #4445 #4544
[mk-app] #2962 = #4344 #4446
[mk-app] #2963 = #4443 #2962
[mk-proof] #2964 monotonicity #4545 #2963
[mk-app] #2965 or #1563 #2962
[mk-app] #2966 or #1563 #4443
[mk-proof] #2967 quant-inst #2966
[mk-app] #2968 = #2966 #2965
[mk-proof] #2969 monotonicity #2964 #2968
[mk-app] #2970 = #2965 #2965
[mk-proof] #2971 rewrite #2970
[mk-proof] #2972 trans #2969 #2971 #2968
[mk-proof] #2973 mp #2967 #2972 #2965
[instance] 0x10681c4c0 #2967 ; 7
[attach-enode] #4446 7
[attach-enode] #2962 7
[assign] #2962 justification -1: p50
[end-of-instance]
[eq-expl] #1503 root
[new-match] 0x10681c6d0 #1477 #1476 #1503 #1545 ; #4446
[eq-expl] #4344 lit #2962 ; #4446
[eq-expl] #4446 root
[new-match] 0x10681c708 #1522 #1506 #1503 #1545 ; #4345 (#4344 #4446)
[mk-app] #2974 offset_inj<Int> #4446 #1545
[mk-app] #2975 = #2974 #1503
[mk-app] #2976 = #2975 #2975
[mk-proof] #3707 refl #2976
[mk-app] #3708 or #1576 #2975
[mk-proof] #3709 quant-inst #3708
[instance] 0x10681c6d0 #3709 ; 8
[attach-enode] #2974 8
[attach-enode] #2975 8
[assign] #2975 justification -1: p49
[end-of-instance]
[mk-app] #2976 next<Ptr32> #4446
[mk-app] #3707 address<Int> #2976
[mk-app] #3710 address<Int> #4446
[mk-app] #3711 * #176 #3710
[mk-app] #3712 + #3707 #3711
[mk-app] #3713 = #3712 #1503
[mk-app] #4518 = #3713 #3713
[mk-proof] #4519 refl #4518
[mk-app] #3644 or #3234 #3713
[mk-proof] #3645 quant-inst #3644
[instance] 0x10681c708 #3645 ; 8
[attach-enode] #2976 8
[attach-enode] #3707 8
[attach-enode] #3710 8
[attach-enode] #3711 8
[attach-enode] #3712 8
[attach-enode] #3713 8
[mk-app] #3646 <= #3712 #1503
[mk-app] #3647 >= #3712 #1503
[assign] #3713 justification -1: p51
[end-of-instance]
[assign] #3646 clause p116 (not p115)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[assign] #3647 clause p117 (not p115)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[mk-app] #4518 = #3710 #4345
[attach-meaning] #176 arith (- 1)
[mk-app] #4519 + #3710 #3498
[mk-app] #3648 <= #4519 #36
[mk-app] #3649 >= #4519 #36
[assign] #4518 justification -1: p113
[attach-enode] #4518 0
[attach-enode] #4519 0
[assign] #3648 justification -1: p118
[assign] #3649 justification -1: p118
[new-match] 0x10681d0c8 #1495 #1483 #1503 #1545 ; #2976 (#4446 #4446)
[mk-app] #3650 + #151 #1503
[mk-app] #4502 offset<Ptr32> #1545 #3650
[mk-app] #4503 = #2976 #4502
[mk-app] #3395 Int
[attach-meaning] #3395 arith 5
[inst-discovered] theory-solving 0x0 arith# ; #3650
[mk-app] #3396 = #3650 #3395
[mk-proof] #3397 rewrite #3396
[instance] 0x0 #3396
[end-of-instance]
[mk-app] #3398 offset<Ptr32> #1545 #3395
[mk-app] #3399 = #4502 #3398
[mk-proof] #3400 monotonicity #3397 #3399
[mk-app] #3404 = #2976 #3398
[mk-app] #3405 = #4503 #3404
[mk-proof] #3406 monotonicity #3400 #3405
[mk-app] #3407 or #1563 #3404
[mk-app] #3408 or #1563 #4503
[mk-proof] #3409 quant-inst #3408
[mk-app] #3410 = #3408 #3407
[mk-proof] #3411 monotonicity #3406 #3410
[mk-app] #3412 = #3407 #3407
[mk-proof] #3413 rewrite #3412
[mk-proof] #3415 trans #3411 #3413 #3410
[mk-proof] #3416 mp #3409 #3415 #3407
[instance] 0x10681d0c8 #3409 ; 9
[attach-enode] #3395 9
[attach-enode] #3398 9
[attach-enode] #3404 9
[assign] #3404 justification -1: p50
[end-of-instance]
[eq-expl] #3395 root
[new-match] 0x10681d368 #1477 #1476 #3395 #1545 ; #3398
[eq-expl] #2976 lit #3404 ; #3398
[eq-expl] #3398 root
[new-match] 0x10681d3a0 #1522 #1506 #3395 #1545 ; #3707 (#2976 #3398)
[mk-app] #3414 offset_inj<Int> #3398 #1545
[mk-app] #3417 = #3414 #3395
[mk-app] #3418 = #3417 #3417
[mk-proof] #3419 refl #3418
[mk-app] #3846 or #1576 #3417
[mk-proof] #3847 quant-inst #3846
[instance] 0x10681d368 #3847 ; 10
[attach-enode] #3414 10
[attach-enode] #3417 10
[assign] #3417 justification -1: p49
[end-of-instance]
[mk-app] #3418 next<Ptr32> #3398
[mk-app] #3419 address<Int> #3418
[mk-app] #3848 address<Int> #3398
[mk-app] #3849 * #176 #3848
[mk-app] #3850 + #3419 #3849
[mk-app] #3851 = #3850 #1503
[mk-app] #3852 = #3851 #3851
[mk-proof] #4350 refl #3852
[mk-app] #4351 or #3234 #3851
[mk-proof] #4353 quant-inst #4351
[instance] 0x10681d3a0 #4353 ; 10
[attach-enode] #3418 10
[attach-enode] #3419 10
[attach-enode] #3848 10
[attach-enode] #3849 10
[attach-enode] #3850 10
[attach-enode] #3851 10
[mk-app] #4354 <= #3850 #1503
[mk-app] #4356 >= #3850 #1503
[assign] #3851 justification -1: p51
[end-of-instance]
[assign] #4354 clause p124 (not p123)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[assign] #4356 clause p125 (not p123)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[mk-app] #3852 = #3707 #3848
[attach-meaning] #176 arith (- 1)
[mk-app] #4350 + #3707 #3849
[mk-app] #4357 <= #4350 #36
[mk-app] #4358 >= #4350 #36
[assign] #3852 justification -1: p121
[attach-enode] #3852 0
[attach-enode] #4350 0
[assign] #4357 justification -1: p126
[assign] #4358 justification -1: p126
[new-match] 0x106822980 #1495 #1483 #3395 #1545 ; #3418 (#3398 #3398)
[mk-app] #4359 + #151 #3395
[mk-app] #4360 offset<Ptr32> #1545 #4359
[mk-app] #4578 = #3418 #4360
[mk-app] #4579 Int
[attach-meaning] #4579 arith 6
[inst-discovered] theory-solving 0x0 arith# ; #4359
[mk-app] #2977 = #4359 #4579
[mk-proof] #2978 rewrite #2977
[instance] 0x0 #2977
[end-of-instance]
[mk-app] #2979 offset<Ptr32> #1545 #4579
[mk-app] #2980 = #4360 #2979
[mk-proof] #2981 monotonicity #2978 #2980
[mk-app] #2982 = #3418 #2979
[mk-app] #2983 = #4578 #2982
[mk-proof] #2984 monotonicity #2981 #2983
[mk-app] #2985 or #1563 #2982
[mk-app] #2986 or #1563 #4578
[mk-proof] #2987 quant-inst #2986
[mk-app] #2988 = #2986 #2985
[mk-proof] #3223 monotonicity #2984 #2988
[mk-app] #3224 = #2985 #2985
[mk-proof] #3225 rewrite #3224
[mk-proof] #3226 trans #3223 #3225 #2988
[mk-proof] #3227 mp #2987 #3226 #2985
[instance] 0x106822980 #2987 ; 11
[attach-enode] #4579 11
[attach-enode] #2979 11
[attach-enode] #2982 11
[assign] #2982 justification -1: p50
[end-of-instance]
[eq-expl] #4579 root
[new-match] 0x106822c20 #1477 #1476 #4579 #1545 ; #2979
[eq-expl] #3418 lit #2982 ; #2979
[eq-expl] #2979 root
[new-match] 0x106822c58 #1522 #1506 #4579 #1545 ; #3419 (#3418 #2979)
[mk-app] #3228 offset_inj<Int> #2979 #1545
[mk-app] #3229 = #3228 #4579
[mk-app] #3230 = #3229 #3229
[mk-proof] #3231 refl #3230
[mk-app] #3232 or #1576 #3229
[mk-proof] #3236 quant-inst #3232
[instance] 0x106822c20 #3236 ; 12
[attach-enode] #3228 12
[attach-enode] #3229 12
[assign] #3229 justification -1: p49
[end-of-instance]
[mk-app] #3230 next<Ptr32> #2979
[mk-app] #3231 address<Int> #3230
[mk-app] #3237 address<Int> #2979
[mk-app] #3238 * #176 #3237
[mk-app] #3239 + #3231 #3238
[mk-app] #3240 = #3239 #1503
[mk-app] #3241 = #3240 #3240
[mk-proof] #3242 refl #3241
[mk-app] #3244 or #3234 #3240
[mk-proof] #3245 quant-inst #3244
[instance] 0x106822c58 #3245 ; 12
[attach-enode] #3230 12
[attach-enode] #3231 12
[attach-enode] #3237 12
[attach-enode] #3238 12
[attach-enode] #3239 12
[attach-enode] #3240 12
[mk-app] #3243 <= #3239 #1503
[mk-app] #3246 >= #3239 #1503
[assign] #3240 justification -1: p51
[end-of-instance]
[assign] #3243 clause p132 (not p131)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[assign] #3246 clause p133 (not p131)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[mk-app] #3241 = #3237 #3419
[attach-meaning] #176 arith (- 1)
[mk-app] #3242 * #176 #3419
[mk-app] #3247 + #3237 #3242
[mk-app] #3248 <= #3247 #36
[mk-app] #3756 >= #3247 #36
[assign] #3241 justification -1: p129
[attach-enode] #3241 0
[attach-enode] #3242 0
[attach-enode] #3247 0
[assign] #3248 justification -1: p134
[assign] #3756 justification -1: p134
[new-match] 0x1068236a0 #1495 #1483 #4579 #1545 ; #3230 (#2979 #2979)
[mk-app] #3757 + #151 #4579
[mk-app] #3758 offset<Ptr32> #1545 #3757
[mk-app] #3759 = #3230 #3758
[mk-app] #3760 Int
[attach-meaning] #3760 arith 7
[inst-discovered] theory-solving 0x0 arith# ; #3757
[mk-app] #3761 = #3757 #3760
[mk-proof] #3762 rewrite #3761
[instance] 0x0 #3761
[end-of-instance]
[mk-app] #4131 offset<Ptr32> #1545 #3760
[mk-app] #4132 = #3758 #4131
[mk-proof] #4133 monotonicity #3762 #4132
[mk-app] #4134 = #3230 #4131
[mk-app] #4135 = #3759 #4134
[mk-proof] #4136 monotonicity #4133 #4135
[mk-app] #4137 or #1563 #4134
[mk-app] #4138 or #1563 #3759
[mk-proof] #4139 quant-inst #4138
[mk-app] #4140 = #4138 #4137
[mk-proof] #4141 monotonicity #4136 #4140
[mk-app] #4142 = #4137 #4137
[mk-proof] #4143 rewrite #4142
[mk-proof] #4144 trans #4141 #4143 #4140
[mk-proof] #4146 mp #4139 #4144 #4137
[instance] 0x1068236a0 #4139 ; 13
[attach-enode] #3760 13
[attach-enode] #4131 13
[attach-enode] #4134 13
[assign] #4134 justification -1: p50
[end-of-instance]
[eq-expl] #3760 root
[new-match] 0x106823940 #1477 #1476 #3760 #1545 ; #4131
[eq-expl] #3230 lit #4134 ; #4131
[eq-expl] #4131 root
[new-match] 0x106823978 #1522 #1506 #3760 #1545 ; #3231 (#3230 #4131)
[mk-app] #4147 offset_inj<Int> #4131 #1545
[mk-app] #4148 = #4147 #3760
[mk-app] #4149 = #4148 #4148
[mk-proof] #4151 refl #4149
[mk-app] #4152 or #1576 #4148
[mk-proof] #4153 quant-inst #4152
[instance] 0x106823940 #4153 ; 14
[attach-enode] #4147 14
[attach-enode] #4148 14
[assign] #4148 justification -1: p49
[end-of-instance]
[mk-app] #4149 next<Ptr32> #4131
[mk-app] #4151 address<Int> #4149
[mk-app] #4154 address<Int> #4131
[mk-app] #4155 * #176 #4154
[mk-app] #4516 + #4151 #4155
[mk-app] #4517 = #4516 #1503
[mk-app] #3686 = #4517 #4517
[mk-proof] #3687 refl #3686
[mk-app] #3688 or #3234 #4517
[mk-proof] #3689 quant-inst #3688
[instance] 0x106823978 #3689 ; 14
[attach-enode] #4149 14
[attach-enode] #4151 14
[attach-enode] #4154 14
[attach-enode] #4155 14
[attach-enode] #4516 14
[attach-enode] #4517 14
[mk-app] #3690 <= #4516 #1503
[mk-app] #3691 >= #4516 #1503
[assign] #4517 justification -1: p51
[end-of-instance]
[assign] #3690 clause p140 (not p139)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[assign] #3691 clause p141 (not p139)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[mk-app] #3686 = #3231 #4154
[attach-meaning] #176 arith (- 1)
[mk-app] #3687 + #3231 #4155
[mk-app] #3692 <= #3687 #36
[mk-app] #3953 >= #3687 #36
[assign] #3686 justification -1: p137
[attach-enode] #3686 0
[attach-enode] #3687 0
[assign] #3692 justification -1: p142
[assign] #3953 justification -1: p142
[new-match] 0x106824338 #1495 #1483 #3760 #1545 ; #4149 (#4131 #4131)
[mk-app] #3954 + #151 #3760
[mk-app] #3956 offset<Ptr32> #1545 #3954
[mk-app] #3957 = #4149 #3956
[mk-app] #3958 Int
[attach-meaning] #3958 arith 8
[inst-discovered] theory-solving 0x0 arith# ; #3954
[mk-app] #3959 = #3954 #3958
[mk-proof] #3960 rewrite #3959
[instance] 0x0 #3959
[end-of-instance]
[mk-app] #4562 offset<Ptr32> #1545 #3958
[mk-app] #4563 = #3956 #4562
[mk-proof] #3249 monotonicity #3960 #4563
[mk-app] #3250 = #4149 #4562
[mk-app] #3251 = #3957 #3250
[mk-proof] #3252 monotonicity #3249 #3251
[mk-app] #3253 or #1563 #3250
[mk-app] #3254 or #1563 #3957
[mk-proof] #3255 quant-inst #3254
[mk-app] #3256 = #3254 #3253
[mk-proof] #3257 monotonicity #3252 #3256
[mk-app] #3258 = #3253 #3253
[mk-proof] #3259 rewrite #3258
[mk-proof] #3260 trans #3257 #3259 #3256
[mk-proof] #3261 mp #3255 #3260 #3253
[instance] 0x106824338 #3255 ; 15
[attach-enode] #3958 15
[attach-enode] #4562 15
[attach-enode] #3250 15
[assign] #3250 justification -1: p50
[end-of-instance]
[eq-expl] #3958 root
[new-match] 0x1068245d8 #1477 #1476 #3958 #1545 ; #4562
[eq-expl] #4149 lit #3250 ; #4562
[eq-expl] #4562 root
[new-match] 0x106824610 #1522 #1506 #3958 #1545 ; #4151 (#4149 #4562)
[mk-app] #3262 offset_inj<Int> #4562 #1545
[mk-app] #3263 = #3262 #3958
[mk-app] #3264 = #3263 #3263
[mk-proof] #3268 refl #3264
[mk-app] #3269 or #1576 #3263
[mk-proof] #3270 quant-inst #3269
[instance] 0x1068245d8 #3270 ; 16
[attach-enode] #3262 16
[attach-enode] #3263 16
[assign] #3263 justification -1: p49
[end-of-instance]
[mk-app] #3264 next<Ptr32> #4562
[mk-app] #3268 address<Int> #3264
[mk-app] #3271 address<Int> #4562
[mk-app] #3273 * #176 #3271
[mk-app] #3274 + #3268 #3273
[mk-app] #3275 = #3274 #1503
[mk-app] #3276 = #3275 #3275
[mk-proof] #3277 refl #3276
[mk-app] #3279 or #3234 #3275
[mk-proof] #3280 quant-inst #3279
[instance] 0x106824610 #3280 ; 16
[attach-enode] #3264 16
[attach-enode] #3268 16
[attach-enode] #3271 16
[attach-enode] #3273 16
[attach-enode] #3274 16
[attach-enode] #3275 16
[mk-app] #3278 <= #3274 #1503
[mk-app] #3281 >= #3274 #1503
[assign] #3275 justification -1: p51
[end-of-instance]
[assign] #3278 clause p148 (not p147)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[assign] #3281 clause p149 (not p147)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[mk-app] #3276 = #3271 #4151
[attach-meaning] #176 arith (- 1)
[mk-app] #3277 * #176 #4151
[mk-app] #3282 + #3271 #3277
[mk-app] #3283 <= #3282 #36
[mk-app] #3763 >= #3282 #36
[assign] #3276 justification -1: p145
[attach-enode] #3276 0
[attach-enode] #3277 0
[attach-enode] #3282 0
[assign] #3283 justification -1: p150
[assign] #3763 justification -1: p150
[new-match] 0x10682c6b8 #1495 #1483 #3958 #1545 ; #3264 (#4562 #4562)
[mk-app] #3764 + #151 #3958
[mk-app] #3765 offset<Ptr32> #1545 #3764
[mk-app] #3766 = #3264 #3765
[mk-app] #3767 Int
[attach-meaning] #3767 arith 9
[inst-discovered] theory-solving 0x0 arith# ; #3764
[mk-app] #3768 = #3764 #3767
[mk-proof] #3769 rewrite #3768
[instance] 0x0 #3768
[end-of-instance]
[mk-app] #4156 offset<Ptr32> #1545 #3767
[mk-app] #4157 = #3765 #4156
[mk-proof] #4162 monotonicity #3769 #4157
[mk-app] #4163 = #3264 #4156
[mk-app] #4164 = #3766 #4163
[mk-proof] #4166 monotonicity #4162 #4164
[mk-app] #4167 or #1563 #4163
[mk-app] #4168 or #1563 #3766
[mk-proof] #4169 quant-inst #4168
[mk-app] #4170 = #4168 #4167
[mk-proof] #4175 monotonicity #4166 #4170
[mk-app] #4176 = #4167 #4167
[mk-proof] #4177 rewrite #4176
[mk-proof] #4178 trans #4175 #4177 #4170
[mk-proof] #4180 mp #4169 #4178 #4167
[instance] 0x10682c6b8 #4169 ; 17
[attach-enode] #3767 17
[attach-enode] #4156 17
[attach-enode] #4163 17
[assign] #4163 justification -1: p50
[end-of-instance]
[eq-expl] #3767 root
[new-match] 0x10682c958 #1477 #1476 #3767 #1545 ; #4156
[eq-expl] #3264 lit #4163 ; #4156
[eq-expl] #4156 root
[new-match] 0x10682c990 #1522 #1506 #3767 #1545 ; #3268 (#3264 #4156)
[mk-app] #4181 offset_inj<Int> #4156 #1545
[mk-app] #4182 = #4181 #3767
[mk-app] #4183 = #4182 #4182
[mk-proof] #4184 refl #4183
[mk-app] #4588 or #1576 #4182
[mk-proof] #4589 quant-inst #4588
[instance] 0x10682c958 #4589 ; 18
[attach-enode] #4181 18
[attach-enode] #4182 18
[assign] #4182 justification -1: p49
[end-of-instance]
[mk-app] #4183 next<Ptr32> #4156
[mk-app] #4184 address<Int> #4183
[mk-app] #3618 address<Int> #4156
[mk-app] #3619 * #176 #3618
[mk-app] #3620 + #4184 #3619
[mk-app] #3621 = #3620 #1503
[mk-app] #3622 + #3619 #4184
[inst-discovered] theory-solving 0x0 arith# ; #3620
[mk-app] #3623 = #3620 #3622
[mk-proof] #3636 rewrite #3623
[instance] 0x0 #3623
[end-of-instance]
[mk-app] #4540 = #3622 #1503
[mk-app] #4541 = #3621 #4540
[mk-proof] #3832 monotonicity #3636 #4541
[attach-meaning] #176 arith (- 1)
[mk-app] #3833 * #176 #4184
[mk-app] #3834 + #3618 #3833
[attach-meaning] #4108 arith (- 4)
[mk-app] #3835 = #3834 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4540
[mk-app] #3836 = #4540 #3835
[mk-proof] #3837 rewrite #3836
[instance] 0x0 #3836
[end-of-instance]
[mk-app] #3838 = #3621 #3835
[mk-proof] #4508 trans #3832 #3837 #3838
[mk-app] #4509 or #3234 #3835
[mk-app] #2928 or #3234 #3621
[mk-proof] #2929 quant-inst #2928
[mk-app] #2930 = #2928 #4509
[mk-proof] #2931 monotonicity #4508 #2930
[mk-app] #2932 = #4509 #4509
[mk-proof] #2933 rewrite #2932
[mk-proof] #2937 trans #2931 #2933 #2930
[mk-proof] #2938 mp #2929 #2937 #4509
[instance] 0x10682c990 #2929 ; 18
[attach-enode] #3618 18
[attach-enode] #4183 18
[attach-enode] #4184 18
[attach-enode] #3833 18
[attach-enode] #3834 18
[attach-enode] #3835 18
[mk-app] #2939 <= #3834 #4108
[mk-app] #2940 >= #3834 #4108
[assign] #3835 justification -1: p51
[end-of-instance]
[assign] #2939 clause p156 (not p155)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[assign] #2940 clause p157 (not p155)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[mk-app] #2942 = #3268 #3618
[attach-meaning] #176 arith (- 1)
[mk-app] #2943 + #3268 #3619
[mk-app] #2944 <= #2943 #36
[mk-app] #2945 >= #2943 #36
[assign] #2942 justification -1: p153
[attach-enode] #2942 0
[attach-enode] #3619 0
[attach-enode] #2943 0
[assign] #2944 justification -1: p158
[assign] #2945 justification -1: p158
[new-match] 0x10682d3d8 #1495 #1483 #3767 #1545 ; #4183 (#4156 #4156)
[mk-app] #2946 + #151 #3767
[mk-app] #3693 offset<Ptr32> #1545 #2946
[mk-app] #3694 = #4183 #3693
[mk-app] #3695 Int
[attach-meaning] #3695 arith 10
[inst-discovered] theory-solving 0x0 arith# ; #2946
[mk-app] #3696 = #2946 #3695
[mk-proof] #3697 rewrite #3696
[instance] 0x0 #3696
[end-of-instance]
[mk-app] #3698 offset<Ptr32> #1545 #3695
[mk-app] #3699 = #3693 #3698
[mk-proof] #4564 monotonicity #3697 #3699
[mk-app] #4565 = #4183 #3698
[mk-app] #3611 = #3694 #4565
[mk-proof] #3612 monotonicity #4564 #3611
[mk-app] #3613 or #1563 #4565
[mk-app] #3614 or #1563 #3694
[mk-proof] #3615 quant-inst #3614
[mk-app] #3616 = #3614 #3613
[mk-proof] #3617 monotonicity #3612 #3616
[mk-app] #4538 = #3613 #3613
[mk-proof] #4539 rewrite #4538
[mk-proof] #3081 trans #3617 #4539 #3616
[mk-proof] #3082 mp #3615 #3081 #3613
[instance] 0x10682d3d8 #3615 ; 19
[attach-enode] #3695 19
[attach-enode] #3698 19
[attach-enode] #4565 19
[assign] #4565 justification -1: p50
[end-of-instance]
[eq-expl] #3695 root
[new-match] 0x10682d678 #1477 #1476 #3695 #1545 ; #3698
[eq-expl] #4183 lit #4565 ; #3698
[eq-expl] #3698 root
[new-match] 0x10682d6b0 #1522 #1506 #3695 #1545 ; #4184 (#4183 #3698)
[mk-app] #3083 offset_inj<Int> #3698 #1545
[mk-app] #3084 = #3083 #3695
[mk-app] #3085 = #3084 #3084
[mk-proof] #3086 refl #3085
[mk-app] #3087 or #1576 #3084
[mk-proof] #3088 quant-inst #3087
[instance] 0x10682d678 #3088 ; 20
[attach-enode] #3083 20
[attach-enode] #3084 20
[assign] #3084 justification -1: p49
[end-of-instance]
[mk-app] #3085 next<Ptr32> #3698
[mk-app] #3086 address<Int> #3085
[mk-app] #3089 address<Int> #3698
[mk-app] #3090 * #176 #3089
[mk-app] #3091 + #3086 #3090
[mk-app] #3092 = #3091 #1503
[mk-app] #3093 = #3092 #3092
[mk-proof] #3094 refl #3093
[mk-app] #3095 or #3234 #3092
[mk-proof] #3096 quant-inst #3095
[instance] 0x10682d6b0 #3096 ; 20
[attach-enode] #3085 20
[attach-enode] #3086 20
[attach-enode] #3089 20
[attach-enode] #3090 20
[attach-enode] #3091 20
[attach-enode] #3092 20
[mk-app] #3097 <= #3091 #1503
[mk-app] #3098 >= #3091 #1503
[assign] #3092 justification -1: p51
[end-of-instance]
[assign] #3097 clause p164 (not p163)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[assign] #3098 clause p165 (not p163)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[mk-app] #3093 = #3089 #4184
[attach-meaning] #176 arith (- 1)
[mk-app] #3094 + #3089 #3833
[mk-app] #3099 <= #3094 #36
[mk-app] #3103 >= #3094 #36
[assign] #3093 justification -1: p161
[attach-enode] #3093 0
[attach-enode] #3094 0
[assign] #3099 justification -1: p166
[assign] #3103 justification -1: p166
[new-match] 0x1068320b0 #1495 #1483 #3695 #1545 ; #3085 (#3698 #3698)
[mk-app] #3104 + #151 #3695
[mk-app] #3105 offset<Ptr32> #1545 #3104
[mk-app] #3106 = #3085 #3105
[mk-app] #3107 Int
[attach-meaning] #3107 arith 11
[inst-discovered] theory-solving 0x0 arith# ; #3104
[mk-app] #3108 = #3104 #3107
[mk-proof] #3109 rewrite #3108
[instance] 0x0 #3108
[end-of-instance]
[mk-app] #3111 offset<Ptr32> #1545 #3107
[mk-app] #3112 = #3105 #3111
[mk-proof] #3110 monotonicity #3109 #3112
[mk-app] #3113 = #3085 #3111
[mk-app] #3114 = #3106 #3113
[mk-proof] #3115 monotonicity #3110 #3114
[mk-app] #3735 or #1563 #3113
[mk-app] #3736 or #1563 #3106
[mk-proof] #3737 quant-inst #3736
[mk-app] #3738 = #3736 #3735
[mk-proof] #3739 monotonicity #3115 #3738
[mk-app] #3740 = #3735 #3735
[mk-proof] #3741 rewrite #3740
[mk-proof] #4049 trans #3739 #3741 #3738
[mk-proof] #4050 mp #3737 #4049 #3735
[instance] 0x1068320b0 #3737 ; 21
[attach-enode] #3107 21
[attach-enode] #3111 21
[attach-enode] #3113 21
[assign] #3113 justification -1: p50
[end-of-instance]
[eq-expl] #3107 root
[new-match] 0x106832350 #1477 #1476 #3107 #1545 ; #3111
[eq-expl] #3085 lit #3113 ; #3111
[eq-expl] #3111 root
[new-match] 0x106832388 #1522 #1506 #3107 #1545 ; #3086 (#3085 #3111)
[mk-app] #4051 offset_inj<Int> #3111 #1545
[mk-app] #4052 = #4051 #3107
[mk-app] #4053 = #4052 #4052
[mk-proof] #4054 refl #4053
[mk-app] #4055 or #1576 #4052
[mk-proof] #4056 quant-inst #4055
[instance] 0x106832350 #4056 ; 22
[attach-enode] #4051 22
[attach-enode] #4052 22
[assign] #4052 justification -1: p49
[end-of-instance]
[mk-app] #4053 next<Ptr32> #3111
[mk-app] #4054 address<Int> #4053
[mk-app] #4057 address<Int> #3111
[mk-app] #4058 * #176 #4057
[mk-app] #4059 + #4054 #4058
[mk-app] #4060 = #4059 #1503
[mk-app] #4061 = #4060 #4060
[mk-proof] #4062 refl #4061
[mk-app] #4064 or #3234 #4060
[mk-proof] #4065 quant-inst #4064
[instance] 0x106832388 #4065 ; 22
[attach-enode] #4053 22
[attach-enode] #4054 22
[attach-enode] #4057 22
[attach-enode] #4058 22
[attach-enode] #4059 22
[attach-enode] #4060 22
[mk-app] #4066 <= #4059 #1503
[mk-app] #4067 >= #4059 #1503
[assign] #4060 justification -1: p51
[end-of-instance]
[assign] #4066 clause p172 (not p171)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[assign] #4067 clause p173 (not p171)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[mk-app] #4061 = #3086 #4057
[attach-meaning] #176 arith (- 1)
[mk-app] #4062 + #3086 #4058
[mk-app] #4069 <= #4062 #36
[mk-app] #4070 >= #4062 #36
[assign] #4061 justification -1: p169
[attach-enode] #4061 0
[attach-enode] #4062 0
[assign] #4069 justification -1: p174
[assign] #4070 justification -1: p174
[new-match] 0x106832d48 #1495 #1483 #3107 #1545 ; #4053 (#3111 #3111)
[mk-app] #4071 + #151 #3107
[mk-app] #4072 offset<Ptr32> #1545 #4071
[mk-app] #4073 = #4053 #4072
[mk-app] #4510 Int
[attach-meaning] #4510 arith 12
[inst-discovered] theory-solving 0x0 arith# ; #4071
[mk-app] #4511 = #4071 #4510
[mk-proof] #3325 rewrite #4511
[instance] 0x0 #4511
[end-of-instance]
[mk-app] #3326 offset<Ptr32> #1545 #4510
[mk-app] #3327 = #4072 #3326
[mk-proof] #3328 monotonicity #3325 #3327
[mk-app] #3329 = #4053 #3326
[mk-app] #3330 = #4073 #3329
[mk-proof] #3331 monotonicity #3328 #3330
[mk-app] #3332 or #1563 #3329
[mk-app] #3333 or #1563 #4073
[mk-proof] #3334 quant-inst #3333
[mk-app] #3338 = #3333 #3332
[mk-proof] #3339 monotonicity #3331 #3338
[mk-app] #3340 = #3332 #3332
[mk-proof] #3341 rewrite #3340
[mk-proof] #3342 trans #3339 #3341 #3338
[mk-proof] #3343 mp #3334 #3342 #3332
[instance] 0x106832d48 #3334 ; 23
[attach-enode] #4510 23
[attach-enode] #3326 23
[attach-enode] #3329 23
[assign] #3329 justification -1: p50
[end-of-instance]
[eq-expl] #4510 root
[new-match] 0x106832fe8 #1477 #1476 #4510 #1545 ; #3326
[eq-expl] #4053 lit #3329 ; #3326
[eq-expl] #3326 root
[new-match] 0x106833020 #1522 #1506 #4510 #1545 ; #4054 (#4053 #3326)
[mk-app] #3344 offset_inj<Int> #3326 #1545
[mk-app] #3345 = #3344 #4510
[mk-app] #3346 = #3345 #3345
[mk-proof] #3347 refl #3346
[mk-app] #3351 or #1576 #3345
[mk-proof] #3352 quant-inst #3351
[instance] 0x106832fe8 #3352 ; 24
[attach-enode] #3344 24
[attach-enode] #3345 24
[assign] #3345 justification -1: p49
[end-of-instance]
[mk-app] #3346 next<Ptr32> #3326
[mk-app] #3347 address<Int> #3346
[mk-app] #3353 address<Int> #3326
[mk-app] #3354 * #176 #3353
[mk-app] #3355 + #3347 #3354
[mk-app] #3356 = #3355 #1503
[mk-app] #3357 = #3356 #3356
[mk-proof] #3358 refl #3357
[mk-app] #3359 or #3234 #3356
[mk-proof] #3360 quant-inst #3359
[instance] 0x106833020 #3360 ; 24
[attach-enode] #3346 24
[attach-enode] #3347 24
[attach-enode] #3353 24
[attach-enode] #3354 24
[attach-enode] #3355 24
[attach-enode] #3356 24
[mk-app] #3362 <= #3355 #1503
[mk-app] #3363 >= #3355 #1503
[assign] #3356 justification -1: p51
[end-of-instance]
[assign] #3362 clause p180 (not p179)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[assign] #3363 clause p181 (not p179)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[mk-app] #3357 = #3353 #4054
[attach-meaning] #176 arith (- 1)
[mk-app] #3358 * #176 #4054
[mk-app] #3361 + #3353 #3358
[mk-app] #3364 <= #3361 #36
[mk-app] #3365 >= #3361 #36
[assign] #3357 justification -1: p177
[attach-enode] #3357 0
[attach-enode] #3358 0
[attach-enode] #3361 0
[assign] #3364 justification -1: p182
[assign] #3365 justification -1: p182
[new-match] 0x106833a68 #1495 #1483 #4510 #1545 ; #3346 (#3326 #3326)
[mk-app] #3366 + #151 #4510
[mk-app] #3783 offset<Ptr32> #1545 #3366
[mk-app] #3784 = #3346 #3783
[mk-app] #3785 Int
[attach-meaning] #3785 arith 13
[inst-discovered] theory-solving 0x0 arith# ; #3366
[mk-app] #3786 = #3366 #3785
[mk-proof] #3787 rewrite #3786
[instance] 0x0 #3786
[end-of-instance]
[mk-app] #3788 offset<Ptr32> #1545 #3785
[mk-app] #3789 = #3783 #3788
[mk-proof] #4216 monotonicity #3787 #3789
[mk-app] #4217 = #3346 #3788
[mk-app] #4218 = #3784 #4217
[mk-proof] #4219 monotonicity #4216 #4218
[mk-app] #4220 or #1563 #4217
[mk-app] #4221 or #1563 #3784
[mk-proof] #4222 quant-inst #4221
[mk-app] #4223 = #4221 #4220
[mk-proof] #4224 monotonicity #4219 #4223
[mk-app] #4225 = #4220 #4220
[mk-proof] #4226 rewrite #4225
[mk-proof] #4231 trans #4224 #4226 #4223
[mk-proof] #4232 mp #4222 #4231 #4220
[instance] 0x106833a68 #4222 ; 25
[attach-enode] #3785 25
[attach-enode] #3788 25
[attach-enode] #4217 25
[assign] #4217 justification -1: p50
[end-of-instance]
[eq-expl] #3785 root
[new-match] 0x106833d08 #1477 #1476 #3785 #1545 ; #3788
[eq-expl] #3346 lit #4217 ; #3788
[eq-expl] #3788 root
[new-match] 0x106833d40 #1522 #1506 #3785 #1545 ; #3347 (#3346 #3788)
[mk-app] #4233 offset_inj<Int> #3788 #1545
[mk-app] #4234 = #4233 #3785
[mk-app] #4235 = #4234 #4234
[mk-proof] #4237 refl #4235
[mk-app] #4238 or #1576 #4234
[mk-proof] #4239 quant-inst #4238
[instance] 0x106833d08 #4239 ; 26
[attach-enode] #4233 26
[attach-enode] #4234 26
[assign] #4234 justification -1: p49
[end-of-instance]
[mk-app] #4235 next<Ptr32> #3788
[mk-app] #4237 address<Int> #4235
[mk-app] #4240 address<Int> #3788
[mk-app] #4242 * #176 #4240
[mk-app] #4243 + #4237 #4242
[mk-app] #4244 = #4243 #1503
[mk-app] #4245 = #4244 #4244
[mk-proof] #4246 refl #4245
[mk-app] #4592 or #3234 #4244
[mk-proof] #4593 quant-inst #4592
[instance] 0x106833d40 #4593 ; 26
[attach-enode] #4235 26
[attach-enode] #4237 26
[attach-enode] #4240 26
[attach-enode] #4242 26
[attach-enode] #4243 26
[attach-enode] #4244 26
[mk-app] #2947 <= #4243 #1503
[mk-app] #2948 >= #4243 #1503
[assign] #4244 justification -1: p51
[end-of-instance]
[assign] #2947 clause p188 (not p187)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[assign] #2948 clause p189 (not p187)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[mk-app] #4245 = #3347 #4240
[attach-meaning] #176 arith (- 1)
[mk-app] #4246 + #3347 #4242
[mk-app] #2949 <= #4246 #36
[mk-app] #2950 >= #4246 #36
[assign] #4245 justification -1: p185
[attach-enode] #4245 0
[attach-enode] #4246 0
[assign] #2949 justification -1: p190
[assign] #2950 justification -1: p190
[new-match] 0x10683b310 #1495 #1483 #3785 #1545 ; #4235 (#3788 #3788)
[mk-app] #2951 + #151 #3785
[mk-app] #2952 offset<Ptr32> #1545 #2951
[mk-app] #2953 = #4235 #2952
[mk-app] #2954 Int
[attach-meaning] #2954 arith 14
[inst-discovered] theory-solving 0x0 arith# ; #2951
[mk-app] #2955 = #2951 #2954
[mk-proof] #2956 rewrite #2955
[instance] 0x0 #2955
[end-of-instance]
[mk-app] #2957 offset<Ptr32> #1545 #2954
[mk-app] #2958 = #2952 #2957
[mk-proof] #2959 monotonicity #2956 #2958
[mk-app] #2960 = #4235 #2957
[mk-app] #2961 = #2953 #2960
[mk-proof] #3700 monotonicity #2959 #2961
[mk-app] #3701 or #1563 #2960
[mk-app] #3702 or #1563 #2953
[mk-proof] #3703 quant-inst #3702
[mk-app] #3704 = #3702 #3701
[mk-proof] #3705 monotonicity #3700 #3704
[mk-app] #3706 = #3701 #3701
[mk-proof] #4566 rewrite #3706
[mk-proof] #4567 trans #3705 #4566 #3704
[mk-proof] #3637 mp #3703 #4567 #3701
[instance] 0x10683b310 #3703 ; 27
[attach-enode] #2954 27
[attach-enode] #2957 27
[attach-enode] #2960 27
[assign] #2960 justification -1: p50
[end-of-instance]
[eq-expl] #2954 root
[new-match] 0x10683b5b0 #1477 #1476 #2954 #1545 ; #2957
[eq-expl] #4235 lit #2960 ; #2957
[eq-expl] #2957 root
[new-match] 0x10683b5e8 #1522 #1506 #2954 #1545 ; #4237 (#4235 #2957)
[mk-app] #3638 offset_inj<Int> #2957 #1545
[mk-app] #3639 = #3638 #2954
[mk-app] #3640 = #3639 #3639
[mk-proof] #3641 refl #3640
[mk-app] #3642 or #1576 #3639
[mk-proof] #3643 quant-inst #3642
[instance] 0x10683b5b0 #3643 ; 28
[attach-enode] #3638 28
[attach-enode] #3639 28
[assign] #3639 justification -1: p49
[end-of-instance]
[mk-app] #3640 next<Ptr32> #2957
[mk-app] #3641 address<Int> #3640
[mk-app] #4500 address<Int> #2957
[mk-app] #4501 * #176 #4500
[mk-app] #3555 + #3641 #4501
[mk-app] #3556 = #3555 #1503
[mk-app] #3557 = #3556 #3556
[mk-proof] #3558 refl #3557
[mk-app] #3559 or #3234 #3556
[mk-proof] #3560 quant-inst #3559
[instance] 0x10683b5e8 #3560 ; 28
[attach-enode] #3640 28
[attach-enode] #3641 28
[attach-enode] #4500 28
[attach-enode] #4501 28
[attach-enode] #3555 28
[attach-enode] #3556 28
[mk-app] #3564 <= #3555 #1503
[mk-app] #3565 >= #3555 #1503
[assign] #3556 justification -1: p51
[end-of-instance]
[assign] #3564 clause p196 (not p195)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[assign] #3565 clause p197 (not p195)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[mk-app] #3557 = #4237 #4500
[attach-meaning] #176 arith (- 1)
[mk-app] #3558 + #4237 #4501
[mk-app] #3566 <= #3558 #36
[mk-app] #3567 >= #3558 #36
[assign] #3557 justification -1: p193
[attach-enode] #3557 0
[attach-enode] #3558 0
[assign] #3566 justification -1: p198
[assign] #3567 justification -1: p198
[new-match] 0x10683bfa8 #1495 #1483 #2954 #1545 ; #3640 (#2957 #2957)
[mk-app] #3569 + #151 #2954
[mk-app] #3570 offset<Ptr32> #1545 #3569
[mk-app] #3571 = #3640 #3570
[mk-app] #3572 Int
[attach-meaning] #3572 arith 15
[inst-discovered] theory-solving 0x0 arith# ; #3569
[mk-app] #3573 = #3569 #3572
[mk-proof] #3909 rewrite #3573
[instance] 0x0 #3573
[end-of-instance]
[mk-app] #3910 offset<Ptr32> #1545 #3572
[mk-app] #3911 = #3570 #3910
[mk-proof] #3912 monotonicity #3909 #3911
[mk-app] #3913 = #3640 #3910
[mk-app] #3914 = #3571 #3913
[mk-proof] #3915 monotonicity #3912 #3914
[mk-app] #4558 or #1563 #3913
[mk-app] #4559 or #1563 #3571
[mk-proof] #3002 quant-inst #4559
[mk-app] #3003 = #4559 #4558
[mk-proof] #3004 monotonicity #3915 #3003
[mk-app] #3005 = #4558 #4558
[mk-proof] #3006 rewrite #3005
[mk-proof] #3007 trans #3004 #3006 #3003
[mk-proof] #3008 mp #3002 #3007 #4558
[instance] 0x10683bfa8 #3002 ; 29
[attach-enode] #3572 29
[attach-enode] #3910 29
[attach-enode] #3913 29
[assign] #3913 justification -1: p50
[end-of-instance]
[eq-expl] #3572 root
[new-match] 0x10683c248 #1477 #1476 #3572 #1545 ; #3910
[eq-expl] #3640 lit #3913 ; #3910
[eq-expl] #3910 root
[new-match] 0x10683c280 #1522 #1506 #3572 #1545 ; #3641 (#3640 #3910)
[mk-app] #3009 offset_inj<Int> #3910 #1545
[mk-app] #3010 = #3009 #3572
[mk-app] #3011 = #3010 #3010
[mk-proof] #3012 refl #3011
[mk-app] #3013 or #1576 #3010
[mk-proof] #3014 quant-inst #3013
[instance] 0x10683c248 #3014 ; 30
[attach-enode] #3009 30
[attach-enode] #3010 30
[assign] #3010 justification -1: p49
[end-of-instance]
[mk-app] #3011 next<Ptr32> #3910
[mk-app] #3012 address<Int> #3011
[mk-app] #3015 address<Int> #3910
[mk-app] #3016 * #176 #3015
[mk-app] #3017 + #3012 #3016
[mk-app] #3031 = #3017 #1503
[mk-app] #3032 = #3031 #3031
[mk-proof] #3033 refl #3032
[mk-app] #3034 or #3234 #3031
[mk-proof] #3035 quant-inst #3034
[instance] 0x10683c280 #3035 ; 30
[attach-enode] #3011 30
[attach-enode] #3012 30
[attach-enode] #3015 30
[attach-enode] #3016 30
[attach-enode] #3017 30
[attach-enode] #3031 30
[mk-app] #3036 <= #3017 #1503
[mk-app] #3038 >= #3017 #1503
[assign] #3031 justification -1: p51
[end-of-instance]
[assign] #3036 clause p204 (not p203)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[assign] #3038 clause p205 (not p203)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[mk-app] #3032 = #3015 #3641
[attach-meaning] #176 arith (- 1)
[mk-app] #3033 * #176 #3641
[mk-app] #3039 + #3015 #3033
[mk-app] #3037 <= #3039 #36
[mk-app] #3040 >= #3039 #36
[assign] #3032 justification -1: p201
[attach-enode] #3032 0
[attach-enode] #3033 0
[attach-enode] #3039 0
[assign] #3037 justification -1: p206
[assign] #3040 justification -1: p206
[new-match] 0x106840f38 #1495 #1483 #3572 #1545 ; #3011 (#3910 #3910)
[mk-app] #3041 + #151 #3572
[mk-app] #3042 offset<Ptr32> #1545 #3041
[mk-app] #3721 = #3011 #3042
[mk-app] #3722 Int
[attach-meaning] #3722 arith 16
[inst-discovered] theory-solving 0x0 arith# ; #3041
[mk-app] #3723 = #3041 #3722
[mk-proof] #3724 rewrite #3723
[instance] 0x0 #3723
[end-of-instance]
[mk-app] #3725 offset<Ptr32> #1545 #3722
[mk-app] #3726 = #3042 #3725
[mk-proof] #3727 monotonicity #3724 #3726
[mk-app] #3986 = #3011 #3725
[mk-app] #3987 = #3721 #3986
[mk-proof] #3988 monotonicity #3727 #3987
[mk-app] #3989 or #1563 #3986
[mk-app] #3990 or #1563 #3721
[mk-proof] #3991 quant-inst #3990
[mk-app] #3992 = #3990 #3989
[mk-proof] #3993 monotonicity #3988 #3992
[mk-app] #3994 = #3989 #3989
[mk-proof] #3995 rewrite #3994
[mk-proof] #3996 trans #3993 #3995 #3992
[mk-proof] #4001 mp #3991 #3996 #3989
[instance] 0x106840f38 #3991 ; 31
[attach-enode] #3722 31
[attach-enode] #3725 31
[attach-enode] #3986 31
[assign] #3986 justification -1: p50
[end-of-instance]
[eq-expl] #3722 root
[new-match] 0x1068411d8 #1477 #1476 #3722 #1545 ; #3725
[eq-expl] #3011 lit #3986 ; #3725
[eq-expl] #3725 root
[new-match] 0x106841210 #1522 #1506 #3722 #1545 ; #3012 (#3011 #3725)
[mk-app] #4002 offset_inj<Int> #3725 #1545
[mk-app] #4003 = #4002 #3722
[mk-app] #4004 = #4003 #4003
[mk-proof] #4005 refl #4004
[mk-app] #4007 or #1576 #4003
[mk-proof] #4008 quant-inst #4007
[instance] 0x1068411d8 #4008 ; 32
[attach-enode] #4002 32
[attach-enode] #4003 32
[assign] #4003 justification -1: p49
[end-of-instance]
[mk-app] #4004 next<Ptr32> #3725
[mk-app] #4005 address<Int> #4004
[mk-app] #4009 address<Int> #3725
[mk-app] #4010 * #176 #4009
[mk-app] #4012 + #4005 #4010
[mk-app] #4013 = #4012 #1503
[mk-app] #4014 = #4013 #4013
[mk-proof] #4015 refl #4014
[mk-app] #4016 or #3234 #4013
[mk-proof] #4496 quant-inst #4016
[instance] 0x106841210 #4496 ; 32
[attach-enode] #4004 32
[attach-enode] #4005 32
[attach-enode] #4009 32
[attach-enode] #4010 32
[attach-enode] #4012 32
[attach-enode] #4013 32
[mk-app] #4497 <= #4012 #1503
[mk-app] #3634 >= #4012 #1503
[assign] #4013 justification -1: p51
[end-of-instance]
[assign] #4497 clause p212 (not p211)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[assign] #3634 clause p213 (not p211)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[mk-app] #4014 = #3012 #4009
[attach-meaning] #176 arith (- 1)
[mk-app] #4015 + #3012 #4010
[mk-app] #3635 <= #4015 #36
[mk-app] #3626 >= #4015 #36
[assign] #4014 justification -1: p209
[attach-enode] #4014 0
[attach-enode] #4015 0
[assign] #3635 justification -1: p214
[assign] #3626 justification -1: p214
[new-match] 0x106841bd0 #1495 #1483 #3722 #1545 ; #4004 (#3725 #3725)
[mk-app] #3627 + #151 #3722
[mk-app] #3624 offset<Ptr32> #1545 #3627
[mk-app] #3625 = #4004 #3624
[mk-app] #3632 Int
[attach-meaning] #3632 arith 17
[inst-discovered] theory-solving 0x0 arith# ; #3627
[mk-app] #4524 = #3627 #3632
[mk-proof] #4525 rewrite #4524
[instance] 0x0 #4524
[end-of-instance]
[mk-app] #3633 offset<Ptr32> #1545 #3632
[mk-app] #3630 = #3624 #3633
[mk-proof] #3631 monotonicity #4525 #3630
[mk-app] #3628 = #4004 #3633
[mk-app] #3629 = #3625 #3628
[mk-proof] #3574 monotonicity #3631 #3629
[mk-app] #3575 or #1563 #3628
[mk-app] #4526 or #1563 #3625
[mk-proof] #4527 quant-inst #4526
[mk-app] #3590 = #4526 #3575
[mk-proof] #3591 monotonicity #3574 #3590
[mk-app] #3592 = #3575 #3575
[mk-proof] #3593 rewrite #3592
[mk-proof] #3594 trans #3591 #3593 #3590
[mk-proof] #3595 mp #4527 #3594 #3575
[instance] 0x106841bd0 #4527 ; 33
[attach-enode] #3632 33
[attach-enode] #3633 33
[attach-enode] #3628 33
[assign] #3628 justification -1: p50
[end-of-instance]
[eq-expl] #3632 root
[new-match] 0x106841e70 #1477 #1476 #3632 #1545 ; #3633
[eq-expl] #4004 lit #3628 ; #3633
[eq-expl] #3633 root
[new-match] 0x106841ea8 #1522 #1506 #3632 #1545 ; #4005 (#4004 #3633)
[mk-app] #3596 offset_inj<Int> #3633 #1545
[mk-app] #4532 = #3596 #3632
[mk-app] #4533 = #4532 #4532
[mk-proof] #3367 refl #4533
[mk-app] #3368 or #1576 #4532
[mk-proof] #3369 quant-inst #3368
[instance] 0x106841e70 #3369 ; 34
[attach-enode] #3596 34
[attach-enode] #4532 34
[assign] #4532 justification -1: p49
[end-of-instance]
[mk-app] #4533 next<Ptr32> #3633
[mk-app] #3367 address<Int> #4533
[mk-app] #3370 address<Int> #3633
[mk-app] #3371 * #176 #3370
[mk-app] #3372 + #3367 #3371
[mk-app] #3373 = #3372 #1503
[mk-app] #3374 = #3373 #3373
[mk-proof] #3375 refl #3374
[mk-app] #3376 or #3234 #3373
[mk-proof] #3378 quant-inst #3376
[instance] 0x106841ea8 #3378 ; 34
[attach-enode] #4533 34
[attach-enode] #3367 34
[attach-enode] #3370 34
[attach-enode] #3371 34
[attach-enode] #3372 34
[attach-enode] #3373 34
[mk-app] #3379 <= #3372 #1503
[mk-app] #3377 >= #3372 #1503
[assign] #3373 justification -1: p51
[end-of-instance]
[assign] #3379 clause p220 (not p219)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[assign] #3377 clause p221 (not p219)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[mk-app] #3374 = #3370 #4005
[attach-meaning] #176 arith (- 1)
[mk-app] #3375 * #176 #4005
[mk-app] #3380 + #3370 #3375
[mk-app] #3381 <= #3380 #36
[mk-app] #3382 >= #3380 #36
[assign] #3374 justification -1: p217
[attach-enode] #3374 0
[attach-enode] #3375 0
[attach-enode] #3380 0
[assign] #3381 justification -1: p222
[assign] #3382 justification -1: p222
[new-match] 0x1068428f0 #1495 #1483 #3632 #1545 ; #4533 (#3633 #3633)
[mk-app] #3797 + #151 #3632
[mk-app] #3798 offset<Ptr32> #1545 #3797
[mk-app] #3799 = #4533 #3798
[mk-app] #3800 Int
[attach-meaning] #3800 arith 18
[inst-discovered] theory-solving 0x0 arith# ; #3797
[mk-app] #3801 = #3797 #3800
[mk-proof] #3802 rewrite #3801
[instance] 0x0 #3801
[end-of-instance]
[mk-app] #3803 offset<Ptr32> #1545 #3800
[mk-app] #4272 = #3798 #3803
[mk-proof] #4273 monotonicity #3802 #4272
[mk-app] #4274 = #4533 #3803
[mk-app] #4275 = #3799 #4274
[mk-proof] #4276 monotonicity #4273 #4275
[mk-app] #4277 or #1563 #4274
[mk-app] #4278 or #1563 #3799
[mk-proof] #4279 quant-inst #4278
[mk-app] #4280 = #4278 #4277
[mk-proof] #4281 monotonicity #4276 #4280
[mk-app] #4282 = #4277 #4277
[mk-proof] #4286 rewrite #4282
[mk-proof] #4287 trans #4281 #4286 #4280
[mk-proof] #4288 mp #4279 #4287 #4277
[instance] 0x1068428f0 #4279 ; 35
[attach-enode] #3800 35
[attach-enode] #3803 35
[attach-enode] #4274 35
[assign] #4274 justification -1: p50
[end-of-instance]
[eq-expl] #3800 root
[new-match] 0x106842b90 #1477 #1476 #3800 #1545 ; #3803
[eq-expl] #4533 lit #4274 ; #3803
[eq-expl] #3803 root
[new-match] 0x106842bc8 #1522 #1506 #3800 #1545 ; #3367 (#4533 #3803)
[mk-app] #4289 offset_inj<Int> #3803 #1545
[mk-app] #4290 = #4289 #3800
[mk-app] #4292 = #4290 #4290
[mk-proof] #4293 refl #4292
[mk-app] #4294 or #1576 #4290
[mk-proof] #4295 quant-inst #4294
[instance] 0x106842b90 #4295 ; 36
[attach-enode] #4289 36
[attach-enode] #4290 36
[assign] #4290 justification -1: p49
[end-of-instance]
[mk-app] #4292 next<Ptr32> #3803
[mk-app] #4293 address<Int> #4292
[mk-app] #4297 address<Int> #3803
[mk-app] #4298 * #176 #4297
[mk-app] #4299 + #4293 #4298
[mk-app] #4300 = #4299 #1503
[mk-app] #4301 = #4300 #4300
[mk-proof] #4552 refl #4301
[mk-app] #4553 or #3234 #4300
[mk-proof] #3825 quant-inst #4553
[instance] 0x106842bc8 #3825 ; 36
[attach-enode] #4292 36
[attach-enode] #4293 36
[attach-enode] #4297 36
[attach-enode] #4298 36
[attach-enode] #4299 36
[attach-enode] #4300 36
[mk-app] #3826 <= #4299 #1503
[mk-app] #3827 >= #4299 #1503
[assign] #4300 justification -1: p51
[end-of-instance]
[assign] #3826 clause p228 (not p227)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[assign] #3827 clause p229 (not p227)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[mk-app] #4301 = #3367 #4297
[attach-meaning] #176 arith (- 1)
[mk-app] #4552 + #3367 #4298
[mk-app] #3828 <= #4552 #36
[mk-app] #3829 >= #4552 #36
[assign] #4301 justification -1: p225
[attach-enode] #4301 0
[attach-enode] #4552 0
[assign] #3828 justification -1: p230
[assign] #3829 justification -1: p230
[new-match] 0x106828798 #1495 #1483 #3800 #1545 ; #4292 (#3803 #3803)
[mk-app] #3830 + #151 #3800
[mk-app] #3831 offset<Ptr32> #1545 #3830
[mk-app] #4572 = #4292 #3831
[mk-app] #4573 Int
[attach-meaning] #4573 arith 19
[inst-discovered] theory-solving 0x0 arith# ; #3830
[mk-app] #3116 = #3830 #4573
[mk-proof] #3117 rewrite #3116
[instance] 0x0 #3116
[end-of-instance]
[mk-app] #3118 offset<Ptr32> #1545 #4573
[mk-app] #3119 = #3831 #3118
[mk-proof] #3120 monotonicity #3117 #3119
[mk-app] #3121 = #4292 #3118
[mk-app] #3122 = #4572 #3121
[mk-proof] #3123 monotonicity #3120 #3122
[mk-app] #3124 or #1563 #3121
[mk-app] #3125 or #1563 #4572
[mk-proof] #3126 quant-inst #3125
[mk-app] #3127 = #3125 #3124
[mk-proof] #3128 monotonicity #3123 #3127
[mk-app] #3129 = #3124 #3124
[mk-proof] #3130 rewrite #3129
[mk-proof] #3131 trans #3128 #3130 #3127
[mk-proof] #3132 mp #3126 #3131 #3124
[instance] 0x106828798 #3126 ; 37
[attach-enode] #4573 37
[attach-enode] #3118 37
[attach-enode] #3121 37
[assign] #3121 justification -1: p50
[end-of-instance]
[eq-expl] #4573 root
[new-match] 0x106828a38 #1477 #1476 #4573 #1545 ; #3118
[eq-expl] #4292 lit #3121 ; #3118
[eq-expl] #3118 root
[new-match] 0x106828a70 #1522 #1506 #4573 #1545 ; #4293 (#4292 #3118)
[mk-app] #3133 offset_inj<Int> #3118 #1545
[mk-app] #3134 = #3133 #4573
[mk-app] #3135 = #3134 #3134
[mk-proof] #3136 refl #3135
[mk-app] #3137 or #1576 #3134
[mk-proof] #3139 quant-inst #3137
[instance] 0x106828a38 #3139 ; 38
[attach-enode] #3133 38
[attach-enode] #3134 38
[assign] #3134 justification -1: p49
[end-of-instance]
[mk-app] #3135 next<Ptr32> #3118
[mk-app] #3136 address<Int> #3135
[mk-app] #3140 address<Int> #3118
[mk-app] #3141 * #176 #3140
[mk-app] #3142 + #3136 #3141
[mk-app] #3144 = #3142 #1503
[mk-app] #3145 = #3144 #3144
[mk-proof] #3146 refl #3145
[mk-app] #3147 or #3234 #3144
[mk-proof] #3148 quant-inst #3147
[instance] 0x106828a70 #3148 ; 38
[attach-enode] #3135 38
[attach-enode] #3136 38
[attach-enode] #3140 38
[attach-enode] #3141 38
[attach-enode] #3142 38
[attach-enode] #3144 38
[mk-app] #3149 <= #3142 #1503
[mk-app] #3150 >= #3142 #1503
[assign] #3144 justification -1: p51
[end-of-instance]
[assign] #3149 clause p236 (not p235)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[assign] #3150 clause p237 (not p235)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[mk-app] #3145 = #3140 #4293
[attach-meaning] #176 arith (- 1)
[mk-app] #3146 * #176 #4293
[mk-app] #3151 + #3140 #3146
[mk-app] #3155 <= #3151 #36
[mk-app] #3156 >= #3151 #36
[assign] #3145 justification -1: p233
[attach-enode] #3145 0
[attach-enode] #3146 0
[attach-enode] #3151 0
[assign] #3155 justification -1: p238
[assign] #3156 justification -1: p238
[new-match] 0x1068294b8 #1495 #1483 #4573 #1545 ; #3135 (#3118 #3118)
[mk-app] #3157 + #151 #4573
[mk-app] #3158 offset<Ptr32> #1545 #3157
[mk-app] #3160 = #3135 #3158
[mk-app] #3161 Int
[attach-meaning] #3161 arith 20
[inst-discovered] theory-solving 0x0 arith# ; #3157
[mk-app] #3163 = #3157 #3161
[mk-proof] #3164 rewrite #3163
[instance] 0x0 #3163
[end-of-instance]
[mk-app] #3165 offset<Ptr32> #1545 #3161
[mk-app] #3166 = #3158 #3165
[mk-proof] #3167 monotonicity #3164 #3166
[mk-app] #3168 = #3135 #3165
[mk-app] #3169 = #3160 #3168
[mk-proof] #3170 monotonicity #3167 #3169
[mk-app] #3172 or #1563 #3168
[mk-app] #3173 or #1563 #3160
[mk-proof] #3171 quant-inst #3173
[mk-app] #3174 = #3173 #3172
[mk-proof] #3175 monotonicity #3170 #3174
[mk-app] #3176 = #3172 #3172
[mk-proof] #3742 rewrite #3176
[mk-proof] #3743 trans #3175 #3742 #3174
[mk-proof] #3744 mp #3171 #3743 #3172
[instance] 0x1068294b8 #3171 ; 39
[attach-enode] #3161 39
[attach-enode] #3165 39
[attach-enode] #3168 39
[assign] #3168 justification -1: p50
[end-of-instance]
[eq-expl] #3161 root
[new-match] 0x106829758 #1477 #1476 #3161 #1545 ; #3165
[eq-expl] #3135 lit #3168 ; #3165
[eq-expl] #3165 root
[new-match] 0x106829790 #1522 #1506 #3161 #1545 ; #3136 (#3135 #3165)
[mk-app] #3745 offset_inj<Int> #3165 #1545
[mk-app] #3746 = #3745 #3161
[mk-app] #3747 = #3746 #3746
[mk-proof] #3748 refl #3747
[mk-app] #4074 or #1576 #3746
[mk-proof] #4075 quant-inst #4074
[instance] 0x106829758 #4075 ; 40
[attach-enode] #3745 40
[attach-enode] #3746 40
[assign] #3746 justification -1: p49
[end-of-instance]
[mk-app] #3747 next<Ptr32> #3165
[mk-app] #3748 address<Int> #3747
[mk-app] #4076 address<Int> #3165
[mk-app] #4077 * #176 #4076
[mk-app] #4078 + #3748 #4077
[mk-app] #4079 = #4078 #1503
[mk-app] #4080 = #4079 #4079
[mk-proof] #4081 refl #4080
[mk-app] #4082 or #3234 #4079
[mk-proof] #4083 quant-inst #4082
[instance] 0x106829790 #4083 ; 40
[attach-enode] #3747 40
[attach-enode] #3748 40
[attach-enode] #4076 40
[attach-enode] #4077 40
[attach-enode] #4078 40
[attach-enode] #4079 40
[mk-app] #4084 <= #4078 #1503
[mk-app] #4089 >= #4078 #1503
[assign] #4079 justification -1: p51
[end-of-instance]
[assign] #4084 clause p244 (not p243)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[assign] #4089 clause p245 (not p243)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[mk-app] #4080 = #3136 #4076
[attach-meaning] #176 arith (- 1)
[mk-app] #4081 + #3136 #4077
[mk-app] #4090 <= #4081 #36
[mk-app] #4091 >= #4081 #36
[assign] #4080 justification -1: p241
[attach-enode] #4080 0
[attach-enode] #4081 0
[assign] #4090 justification -1: p246
[assign] #4091 justification -1: p246
[new-match] 0x106859b60 #1495 #1483 #3161 #1545 ; #3747 (#3165 #3165)
[mk-app] #4092 + #151 #3161
[mk-app] #4093 offset<Ptr32> #1545 #4092
[mk-app] #4095 = #3747 #4093
[mk-app] #4096 Int
[attach-meaning] #4096 arith 21
[inst-discovered] theory-solving 0x0 arith# ; #4092
[mk-app] #4097 = #4092 #4096
[mk-proof] #4098 rewrite #4097
[instance] 0x0 #4097
[end-of-instance]
[mk-app] #4100 offset<Ptr32> #1545 #4096
[mk-app] #4101 = #4093 #4100
[mk-proof] #4102 monotonicity #4098 #4101
[mk-app] #4103 = #3747 #4100
[mk-app] #4104 = #4095 #4103
[mk-proof] #4512 monotonicity #4102 #4104
[mk-app] #4513 or #1563 #4103
[mk-app] #3512 or #1563 #4095
[mk-proof] #3513 quant-inst #3512
[mk-app] #3514 = #3512 #4513
[mk-proof] #3515 monotonicity #4512 #3514
[mk-app] #3516 = #4513 #4513
[mk-proof] #3517 rewrite #3516
[mk-proof] #3518 trans #3515 #3517 #3514
[mk-proof] #3519 mp #3513 #3518 #4513
[instance] 0x106859b60 #3513 ; 41
[attach-enode] #4096 41
[attach-enode] #4100 41
[attach-enode] #4103 41
[assign] #4103 justification -1: p50
[end-of-instance]
[eq-expl] #4096 root
[new-match] 0x106859e00 #1477 #1476 #4096 #1545 ; #4100
[eq-expl] #3747 lit #4103 ; #4100
[eq-expl] #4100 root
[new-match] 0x106859e38 #1522 #1506 #4096 #1545 ; #3748 (#3747 #4100)
[mk-app] #3520 offset_inj<Int> #4100 #1545
[mk-app] #3521 = #3520 #4096
[mk-app] #3522 = #3521 #3521
[mk-proof] #3523 refl #3522
[mk-app] #3524 or #1576 #3521
[mk-proof] #3525 quant-inst #3524
[instance] 0x106859e00 #3525 ; 42
[attach-enode] #3520 42
[attach-enode] #3521 42
[assign] #3521 justification -1: p49
[end-of-instance]
[mk-app] #3522 next<Ptr32> #4100
[mk-app] #3523 address<Int> #3522
[mk-app] #3526 address<Int> #4100
[mk-app] #3527 * #176 #3526
[mk-app] #3528 + #3523 #3527
[mk-app] #3529 = #3528 #1503
[mk-app] #3530 = #3529 #3529
[mk-proof] #3531 refl #3530
[mk-app] #3532 or #3234 #3529
[mk-proof] #3533 quant-inst #3532
[instance] 0x106859e38 #3533 ; 42
[attach-enode] #3522 42
[attach-enode] #3523 42
[attach-enode] #3526 42
[attach-enode] #3527 42
[attach-enode] #3528 42
[attach-enode] #3529 42
[mk-app] #3534 <= #3528 #1503
[mk-app] #3535 >= #3528 #1503
[assign] #3529 justification -1: p51
[end-of-instance]
[assign] #3534 clause p252 (not p251)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[assign] #3535 clause p253 (not p251)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[mk-app] #3530 = #3526 #3748
[attach-meaning] #176 arith (- 1)
[mk-app] #3531 * #176 #3748
[mk-app] #3536 + #3526 #3531
[mk-app] #3537 <= #3536 #36
[mk-app] #3538 >= #3536 #36
[assign] #3530 justification -1: p249
[attach-enode] #3530 0
[attach-enode] #3531 0
[attach-enode] #3536 0
[assign] #3537 justification -1: p254
[assign] #3538 justification -1: p254
[new-match] 0x10685a880 #1495 #1483 #4096 #1545 ; #3522 (#4100 #4100)
[mk-app] #3895 + #151 #4096
[mk-app] #3896 offset<Ptr32> #1545 #3895
[mk-app] #3897 = #3522 #3896
[mk-app] #3898 Int
[attach-meaning] #3898 arith 22
[inst-discovered] theory-solving 0x0 arith# ; #3895
[mk-app] #3899 = #3895 #3898
[mk-proof] #3900 rewrite #3899
[instance] 0x0 #3899
[end-of-instance]
[mk-app] #3901 offset<Ptr32> #1545 #3898
[mk-app] #4447 = #3896 #3901
[mk-proof] #4448 monotonicity #3900 #4447
[mk-app] #4449 = #3522 #3901
[mk-app] #4450 = #3897 #4449
[mk-proof] #4451 monotonicity #4448 #4450
[mk-app] #4452 or #1563 #4449
[mk-app] #4453 or #1563 #3897
[mk-proof] #4454 quant-inst #4453
[mk-app] #4455 = #4453 #4452
[mk-proof] #4456 monotonicity #4451 #4455
[mk-app] #4457 = #4452 #4452
[mk-proof] #4458 rewrite #4457
[mk-proof] #4459 trans #4456 #4458 #4455
[mk-proof] #4460 mp #4454 #4459 #4452
[instance] 0x10685a880 #4454 ; 43
[attach-enode] #3898 43
[attach-enode] #3901 43
[attach-enode] #4449 43
[assign] #4449 justification -1: p50
[end-of-instance]
[eq-expl] #3898 root
[new-match] 0x10685ab20 #1477 #1476 #3898 #1545 ; #3901
[eq-expl] #3522 lit #4449 ; #3901
[eq-expl] #3901 root
[new-match] 0x10685ab58 #1522 #1506 #3898 #1545 ; #3523 (#3522 #3901)
[mk-app] #4462 offset_inj<Int> #3901 #1545
[mk-app] #4463 = #4462 #3898
[mk-app] #4464 = #4463 #4463
[mk-proof] #4465 refl #4464
[mk-app] #4467 or #1576 #4463
[mk-proof] #4468 quant-inst #4467
[instance] 0x10685ab20 #4468 ; 44
[attach-enode] #4462 44
[attach-enode] #4463 44
[assign] #4463 justification -1: p49
[end-of-instance]
[mk-app] #4464 next<Ptr32> #3901
[mk-app] #4465 address<Int> #4464
[mk-app] #4469 address<Int> #3901
[mk-app] #4470 * #176 #4469
[mk-app] #4471 + #4465 #4470
[mk-app] #4546 = #4471 #1503
[mk-app] #4547 = #4546 #4546
[mk-proof] #3420 refl #4547
[mk-app] #3421 or #3234 #4546
[mk-proof] #3422 quant-inst #3421
[instance] 0x10685ab58 #3422 ; 44
[attach-enode] #4464 44
[attach-enode] #4465 44
[attach-enode] #4469 44
[attach-enode] #4470 44
[attach-enode] #4471 44
[attach-enode] #4546 44
[mk-app] #3423 <= #4471 #1503
[mk-app] #3424 >= #4471 #1503
[assign] #4546 justification -1: p51
[end-of-instance]
[assign] #3423 clause p260 (not p259)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[assign] #3424 clause p261 (not p259)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[mk-app] #4547 = #3523 #4469
[attach-meaning] #176 arith (- 1)
[mk-app] #3420 + #3523 #4470
[mk-app] #3425 <= #3420 #36
[mk-app] #3428 >= #3420 #36
[assign] #4547 justification -1: p257
[attach-enode] #4547 0
[attach-enode] #3420 0
[assign] #3425 justification -1: p262
[assign] #3428 justification -1: p262
[new-match] 0x10685b518 #1495 #1483 #3898 #1545 ; #4464 (#3901 #3901)
[mk-app] #3429 + #151 #3898
[mk-app] #3430 offset<Ptr32> #1545 #3429
[mk-app] #3431 = #4464 #3430
[mk-app] #3432 Int
[attach-meaning] #3432 arith 23
[inst-discovered] theory-solving 0x0 arith# ; #3429
[mk-app] #3433 = #3429 #3432
[mk-proof] #3434 rewrite #3433
[instance] 0x0 #3433
[end-of-instance]
[mk-app] #3435 offset<Ptr32> #1545 #3432
[mk-app] #3436 = #3430 #3435
[mk-proof] #3437 monotonicity #3434 #3436
[mk-app] #3438 = #4464 #3435
[mk-app] #3439 = #3431 #3438
[mk-proof] #3440 monotonicity #3437 #3439
[mk-app] #3442 or #1563 #3438
[mk-app] #3443 or #1563 #3431
[mk-proof] #3441 quant-inst #3443
[mk-app] #3444 = #3443 #3442
[mk-proof] #3445 monotonicity #3440 #3444
[mk-app] #3446 = #3442 #3442
[mk-proof] #3853 rewrite #3446
[mk-proof] #3854 trans #3445 #3853 #3444
[mk-proof] #3855 mp #3441 #3854 #3442
[instance] 0x10685b518 #3441 ; 45
[attach-enode] #3432 45
[attach-enode] #3435 45
[attach-enode] #3438 45
[assign] #3438 justification -1: p50
[end-of-instance]
[eq-expl] #3432 root
[new-match] 0x10685b7b8 #1477 #1476 #3432 #1545 ; #3435
[eq-expl] #4464 lit #3438 ; #3435
[eq-expl] #3435 root
[new-match] 0x106862810 #1522 #1506 #3432 #1545 ; #4465 (#4464 #3435)
[mk-app] #3856 offset_inj<Int> #3435 #1545
[mk-app] #3857 = #3856 #3432
[mk-app] #3858 = #3857 #3857
[mk-proof] #3859 refl #3858
[mk-app] #4362 or #1576 #3857
[mk-proof] #4363 quant-inst #4362
[instance] 0x10685b7b8 #4363 ; 46
[attach-enode] #3856 46
[attach-enode] #3857 46
[assign] #3857 justification -1: p49
[end-of-instance]
[mk-app] #3858 next<Ptr32> #3435
[mk-app] #3859 address<Int> #3858
[mk-app] #4364 address<Int> #3435
[mk-app] #4365 * #176 #4364
[mk-app] #4366 + #3859 #4365
[mk-app] #4367 = #4366 #1503
[mk-app] #4368 = #4367 #4367
[mk-proof] #4369 refl #4368
[mk-app] #4370 or #3234 #4367
[mk-proof] #4371 quant-inst #4370
[instance] 0x106862810 #4371 ; 46
[attach-enode] #3858 46
[attach-enode] #3859 46
[attach-enode] #4364 46
[attach-enode] #4365 46
[attach-enode] #4366 46
[attach-enode] #4367 46
[mk-app] #4372 <= #4366 #1503
[mk-app] #4373 >= #4366 #1503
[assign] #4367 justification -1: p51
[end-of-instance]
[assign] #4372 clause p268 (not p267)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[assign] #4373 clause p269 (not p267)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[mk-app] #4368 = #4364 #4465
[attach-meaning] #176 arith (- 1)
[mk-app] #4369 * #176 #4465
[mk-app] #4374 + #4364 #4369
[mk-app] #4375 <= #4374 #36
[mk-app] #4377 >= #4374 #36
[assign] #4368 justification -1: p265
[attach-enode] #4368 0
[attach-enode] #4369 0
[attach-enode] #4374 0
[assign] #4375 justification -1: p270
[assign] #4377 justification -1: p270
[new-match] 0x106863258 #1495 #1483 #3432 #1545 ; #3858 (#3435 #3435)
[mk-app] #4378 + #151 #3432
[mk-app] #4379 offset<Ptr32> #1545 #4378
[mk-app] #4380 = #3858 #4379
[mk-app] #4382 Int
[attach-meaning] #4382 arith 24
[inst-discovered] theory-solving 0x0 arith# ; #4378
[mk-app] #4383 = #4378 #4382
[mk-proof] #4384 rewrite #4383
[instance] 0x0 #4383
[end-of-instance]
[mk-app] #4385 offset<Ptr32> #1545 #4382
[mk-app] #4386 = #4379 #4385
[mk-proof] #4580 monotonicity #4384 #4386
[mk-app] #4581 = #3858 #4385
[mk-app] #3539 = #4380 #4581
[mk-proof] #3540 monotonicity #4580 #3539
[mk-app] #3541 or #1563 #4581
[mk-app] #3542 or #1563 #4380
[mk-proof] #3543 quant-inst #3542
[mk-app] #3544 = #3542 #3541
[mk-proof] #3545 monotonicity #3540 #3544
[mk-app] #3546 = #3541 #3541
[mk-proof] #3547 rewrite #3546
[mk-proof] #3548 trans #3545 #3547 #3544
[mk-proof] #3549 mp #3543 #3548 #3541
[instance] 0x106863258 #3543 ; 47
[attach-enode] #4382 47
[attach-enode] #4385 47
[attach-enode] #4581 47
[assign] #4581 justification -1: p50
[end-of-instance]
[eq-expl] #4382 root
[new-match] 0x1068634f8 #1477 #1476 #4382 #1545 ; #4385
[eq-expl] #3858 lit #4581 ; #4385
[eq-expl] #4385 root
[new-match] 0x106863530 #1522 #1506 #4382 #1545 ; #3859 (#3858 #4385)
[mk-app] #3550 offset_inj<Int> #4385 #1545
[mk-app] #3551 = #3550 #4382
[mk-app] #3552 = #3551 #3551
[mk-proof] #3553 refl #3552
[mk-app] #3554 or #1576 #3551
[mk-proof] #3902 quant-inst #3554
[instance] 0x1068634f8 #3902 ; 48
[attach-enode] #3550 48
[attach-enode] #3551 48
[assign] #3551 justification -1: p49
[end-of-instance]
[mk-app] #3552 next<Ptr32> #4385
[mk-app] #3553 address<Int> #3552
[mk-app] #3903 address<Int> #4385
[mk-app] #3904 * #176 #3903
[mk-app] #3905 + #3553 #3904
[mk-app] #3906 = #3905 #1503
[mk-app] #3907 = #3906 #3906
[mk-proof] #3908 refl #3907
[mk-app] #4475 or #3234 #3906
[mk-proof] #4476 quant-inst #4475
[instance] 0x106863530 #4476 ; 48
[attach-enode] #3552 48
[attach-enode] #3553 48
[attach-enode] #3903 48
[attach-enode] #3904 48
[attach-enode] #3905 48
[attach-enode] #3906 48
[mk-app] #4478 <= #3905 #1503
[mk-app] #4479 >= #3905 #1503
[assign] #3906 justification -1: p51
[end-of-instance]
[assign] #4478 clause p276 (not p275)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[assign] #4479 clause p277 (not p275)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[mk-app] #3907 = #3859 #3903
[attach-meaning] #176 arith (- 1)
[mk-app] #3908 + #3859 #3904
[mk-app] #4481 <= #3908 #36
[mk-app] #4482 >= #3908 #36
[assign] #3907 justification -1: p273
[attach-enode] #3907 0
[attach-enode] #3908 0
[assign] #4481 justification -1: p278
[assign] #4482 justification -1: p278
[new-match] 0x106863ef0 #1495 #1483 #4382 #1545 ; #3552 (#4385 #4385)
[mk-app] #4483 + #151 #4382
[mk-app] #4484 offset<Ptr32> #1545 #4483
[mk-app] #4485 = #3552 #4484
[mk-app] #4548 Int
[attach-meaning] #4548 arith 25
[inst-discovered] theory-solving 0x0 arith# ; #4483
[mk-app] #4549 = #4483 #4548
[mk-proof] #3804 rewrite #4549
[instance] 0x0 #4549
[end-of-instance]
[mk-app] #3805 offset<Ptr32> #1545 #4548
[mk-app] #3806 = #4484 #3805
[mk-proof] #3807 monotonicity #3804 #3806
[mk-app] #3808 = #3552 #3805
[mk-app] #3809 = #4485 #3808
[mk-proof] #3810 monotonicity #3807 #3809
[mk-app] #4247 or #1563 #3808
[mk-app] #4248 or #1563 #4485
[mk-proof] #4249 quant-inst #4248
[mk-app] #4250 = #4248 #4247
[mk-proof] #4251 monotonicity #3810 #4250
[mk-app] #4252 = #4247 #4247
[mk-proof] #4253 rewrite #4252
[mk-proof] #4254 trans #4251 #4253 #4250
[mk-proof] #4255 mp #4249 #4254 #4247
[instance] 0x106863ef0 #4249 ; 49
[attach-enode] #4548 49
[attach-enode] #3805 49
[attach-enode] #3808 49
[assign] #3808 justification -1: p50
[end-of-instance]
[eq-expl] #4548 root
[new-match] 0x106864190 #1477 #1476 #4548 #1545 ; #3805
[eq-expl] #3552 lit #3808 ; #3805
[eq-expl] #3805 root
[new-match] 0x1068641c8 #1522 #1506 #4548 #1545 ; #3553 (#3552 #3805)
[mk-app] #4256 offset_inj<Int> #3805 #1545
[mk-app] #4257 = #4256 #4548
[mk-app] #4302 = #4257 #4257
[mk-proof] #4303 refl #4302
[mk-app] #4304 or #1576 #4257
[mk-proof] #4306 quant-inst #4304
[instance] 0x106864190 #4306 ; 50
[attach-enode] #4256 50
[attach-enode] #4257 50
[assign] #4257 justification -1: p49
[end-of-instance]
[mk-app] #4302 next<Ptr32> #3805
[mk-app] #4303 address<Int> #4302
[mk-app] #4307 address<Int> #3805
[mk-app] #4308 * #176 #4307
[mk-app] #4309 + #4303 #4308
[mk-app] #4311 = #4309 #1503
[mk-app] #4312 = #4311 #4311
[mk-proof] #4313 refl #4312
[mk-app] #4314 or #3234 #4311
[mk-proof] #4315 quant-inst #4314
[instance] 0x1068641c8 #4315 ; 50
[attach-enode] #4302 50
[attach-enode] #4303 50
[attach-enode] #4307 50
[attach-enode] #4308 50
[attach-enode] #4309 50
[attach-enode] #4311 50
[mk-app] #4554 <= #4309 #1503
[mk-app] #4555 >= #4309 #1503
[assign] #4311 justification -1: p51
[end-of-instance]
[assign] #4554 clause p284 (not p283)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[assign] #4555 clause p285 (not p283)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[mk-app] #4312 = #3553 #4307
[attach-meaning] #176 arith (- 1)
[mk-app] #4313 + #3553 #4308
[mk-app] #2911 <= #4313 #36
[mk-app] #2912 >= #4313 #36
[assign] #4312 justification -1: p281
[attach-enode] #4312 0
[attach-enode] #4313 0
[assign] #2911 justification -1: p286
[assign] #2912 justification -1: p286
[new-match] 0x1068675a8 #1495 #1483 #4548 #1545 ; #4302 (#3805 #3805)
[mk-app] #2913 + #151 #4548
[mk-app] #2914 offset<Ptr32> #1545 #2913
[mk-app] #2915 = #4302 #2914
[mk-app] #2916 Int
[attach-meaning] #2916 arith 26
[inst-discovered] theory-solving 0x0 arith# ; #2913
[mk-app] #2917 = #2913 #2916
[mk-proof] #2918 rewrite #2917
[instance] 0x0 #2917
[end-of-instance]
[mk-app] #2919 offset<Ptr32> #1545 #2916
[mk-app] #2920 = #2914 #2919
[mk-proof] #2921 monotonicity #2918 #2920
[mk-app] #2922 = #4302 #2919
[mk-app] #2923 = #2915 #2922
[mk-proof] #2924 monotonicity #2921 #2923
[mk-app] #2925 or #1563 #2922
[mk-app] #2926 or #1563 #2915
[mk-proof] #2927 quant-inst #2926
[mk-app] #3679 = #2926 #2925
[mk-proof] #3680 monotonicity #2924 #3679
[mk-app] #3681 = #2925 #2925
[mk-proof] #3682 rewrite #3681
[mk-proof] #3683 trans #3680 #3682 #3679
[mk-proof] #3684 mp #2927 #3683 #2925
[instance] 0x1068675a8 #2927 ; 51
[attach-enode] #2916 51
[attach-enode] #2919 51
[attach-enode] #2922 51
[assign] #2922 justification -1: p50
[end-of-instance]
[eq-expl] #2916 root
[new-match] 0x106867848 #1477 #1476 #2916 #1545 ; #2919
[eq-expl] #4302 lit #2922 ; #2919
[eq-expl] #2919 root
[new-match] 0x106867880 #1522 #1506 #2916 #1545 ; #4303 (#4302 #2919)
[mk-app] #3685 offset_inj<Int> #2919 #1545
[mk-app] #3770 = #3685 #2916
[mk-app] #3771 = #3770 #3770
[mk-proof] #3772 refl #3771
[mk-app] #3773 or #1576 #3770
[mk-proof] #3774 quant-inst #3773
[instance] 0x106867848 #3774 ; 52
[attach-enode] #3685 52
[attach-enode] #3770 52
[assign] #3770 justification -1: p49
[end-of-instance]
[mk-app] #3771 next<Ptr32> #2919
[mk-app] #3772 address<Int> #3771
[mk-app] #3775 address<Int> #2919
[mk-app] #3930 * #176 #3775
[mk-app] #3931 + #3772 #3930
[mk-app] #3932 = #3931 #1503
[mk-app] #3933 = #3932 #3932
[mk-proof] #3934 refl #3933
[mk-app] #3935 or #3234 #3932
[mk-proof] #3936 quant-inst #3935
[instance] 0x106867880 #3936 ; 52
[attach-enode] #3771 52
[attach-enode] #3772 52
[attach-enode] #3775 52
[attach-enode] #3930 52
[attach-enode] #3931 52
[attach-enode] #3932 52
[mk-app] #3937 <= #3931 #1503
[mk-app] #3939 >= #3931 #1503
[assign] #3932 justification -1: p51
[end-of-instance]
[assign] #3937 clause p292 (not p291)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[assign] #3939 clause p293 (not p291)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[mk-app] #3933 = #3775 #4303
[attach-meaning] #176 arith (- 1)
[mk-app] #3934 * #176 #4303
[mk-app] #3940 + #3775 #3934
[mk-app] #3941 <= #3940 #36
[mk-app] #3942 >= #3940 #36
[assign] #3933 justification -1: p289
[attach-enode] #3933 0
[attach-enode] #3934 0
[attach-enode] #3940 0
[assign] #3941 justification -1: p294
[assign] #3942 justification -1: p294
[new-match] 0x1068682c8 #1495 #1483 #2916 #1545 ; #3771 (#2919 #2919)
[mk-app] #3944 + #151 #2916
[mk-app] #3945 offset<Ptr32> #1545 #3944
[mk-app] #3946 = #3771 #3945
[mk-app] #3947 Int
[attach-meaning] #3947 arith 27
[inst-discovered] theory-solving 0x0 arith# ; #3944
[mk-app] #3948 = #3944 #3947
[mk-proof] #4560 rewrite #3948
[instance] 0x0 #3948
[end-of-instance]
[mk-app] #4561 offset<Ptr32> #1545 #3947
[mk-app] #3916 = #3945 #4561
[mk-proof] #3917 monotonicity #4560 #3916
[mk-app] #3918 = #3771 #4561
[mk-app] #3919 = #3946 #3918
[mk-proof] #3920 monotonicity #3917 #3919
[mk-app] #3921 or #1563 #3918
[mk-app] #3922 or #1563 #3946
[mk-proof] #4522 quant-inst #3922
[mk-app] #4523 = #3922 #3921
[mk-proof] #3576 monotonicity #3920 #4523
[mk-app] #3577 = #3921 #3921
[mk-proof] #3578 rewrite #3577
[mk-proof] #3579 trans #3576 #3578 #4523
[mk-proof] #3580 mp #4522 #3579 #3921
[instance] 0x1068682c8 #4522 ; 53
[attach-enode] #3947 53
[attach-enode] #4561 53
[attach-enode] #3918 53
[assign] #3918 justification -1: p50
[end-of-instance]
[eq-expl] #3947 root
[new-match] 0x106868568 #1477 #1476 #3947 #1545 ; #4561
[eq-expl] #3771 lit #3918 ; #4561
[eq-expl] #4561 root
[new-match] 0x1068685a0 #1522 #1506 #3947 #1545 ; #3772 (#3771 #4561)
[mk-app] #3581 offset_inj<Int> #4561 #1545
[mk-app] #3582 = #3581 #3947
[mk-app] #4528 = #3582 #3582
[mk-proof] #4529 refl #4528
[mk-app] #3583 or #1576 #3582
[mk-proof] #3584 quant-inst #3583
[instance] 0x106868568 #3584 ; 54
[attach-enode] #3581 54
[attach-enode] #3582 54
[assign] #3582 justification -1: p49
[end-of-instance]
[mk-app] #4528 next<Ptr32> #4561
[mk-app] #4529 address<Int> #4528
[mk-app] #3585 address<Int> #4561
[mk-app] #3586 * #176 #3585
[mk-app] #3587 + #4529 #3586
[mk-app] #3588 = #3587 #1503
[mk-app] #3589 + #3586 #4529
[inst-discovered] theory-solving 0x0 arith# ; #3587
[mk-app] #4530 = #3587 #3589
[mk-proof] #4531 rewrite #4530
[instance] 0x0 #4530
[end-of-instance]
[mk-app] #3043 = #3589 #1503
[mk-app] #3044 = #3588 #3043
[mk-proof] #3045 monotonicity #4531 #3044
[attach-meaning] #176 arith (- 1)
[mk-app] #3046 * #176 #4529
[mk-app] #3047 + #3585 #3046
[attach-meaning] #4108 arith (- 4)
[mk-app] #3048 = #3047 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3043
[mk-app] #3049 = #3043 #3048
[mk-proof] #3050 rewrite #3049
[instance] 0x0 #3049
[end-of-instance]
[mk-app] #3051 = #3588 #3048
[mk-proof] #3447 trans #3045 #3050 #3051
[mk-app] #3448 or #3234 #3048
[mk-app] #3449 or #3234 #3588
[mk-proof] #3450 quant-inst #3449
[mk-app] #3451 = #3449 #3448
[mk-proof] #3452 monotonicity #3447 #3451
[mk-app] #3453 = #3448 #3448
[mk-proof] #3454 rewrite #3453
[mk-proof] #3455 trans #3452 #3454 #3451
[mk-proof] #3456 mp #3450 #3455 #3448
[instance] 0x1068685a0 #3450 ; 54
[attach-enode] #3585 54
[attach-enode] #4528 54
[attach-enode] #4529 54
[attach-enode] #3046 54
[attach-enode] #3047 54
[attach-enode] #3048 54
[mk-app] #3457 <= #3047 #4108
[mk-app] #3860 >= #3047 #4108
[assign] #3048 justification -1: p51
[end-of-instance]
[assign] #3457 clause p300 (not p299)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[assign] #3860 clause p301 (not p299)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[mk-app] #3861 = #3585 #3772
[attach-meaning] #176 arith (- 1)
[mk-app] #3862 * #176 #3772
[mk-app] #3863 + #3585 #3862
[mk-app] #3864 <= #3863 #36
[mk-app] #3865 >= #3863 #36
[assign] #3861 justification -1: p297
[attach-enode] #3861 0
[attach-enode] #3862 0
[attach-enode] #3863 0
[assign] #3864 justification -1: p302
[assign] #3865 justification -1: p302
[new-match] 0x106868fe8 #1495 #1483 #3947 #1545 ; #4528 (#4561 #4561)
[mk-app] #3866 + #151 #3947
[mk-app] #4387 offset<Ptr32> #1545 #3866
[mk-app] #4388 = #4528 #4387
[mk-app] #4389 Int
[attach-meaning] #4389 arith 28
[inst-discovered] theory-solving 0x0 arith# ; #3866
[mk-app] #4390 = #3866 #4389
[mk-proof] #4391 rewrite #4390
[instance] 0x0 #4390
[end-of-instance]
[mk-app] #4392 offset<Ptr32> #1545 #4389
[mk-app] #4393 = #4387 #4392
[mk-proof] #4394 monotonicity #4391 #4393
[mk-app] #4395 = #4528 #4392
[mk-app] #4396 = #4388 #4395
[mk-proof] #4397 monotonicity #4394 #4396
[mk-app] #4398 or #1563 #4395
[mk-app] #4399 or #1563 #4388
[mk-proof] #4400 quant-inst #4399
[mk-app] #4402 = #4399 #4398
[mk-proof] #4403 monotonicity #4397 #4402
[mk-app] #4404 = #4398 #4398
[mk-proof] #4405 rewrite #4404
[mk-proof] #4407 trans #4403 #4405 #4402
[mk-proof] #4408 mp #4400 #4407 #4398
[instance] 0x106868fe8 #4400 ; 55
[attach-enode] #4389 55
[attach-enode] #4392 55
[attach-enode] #4395 55
[assign] #4395 justification -1: p50
[end-of-instance]
[eq-expl] #4389 root
[new-match] 0x106847ab8 #1477 #1476 #4389 #1545 ; #4392
[eq-expl] #4528 lit #4395 ; #4392
[eq-expl] #4392 root
[new-match] 0x106847af0 #1522 #1506 #4389 #1545 ; #4529 (#4528 #4392)
[mk-app] #4409 offset_inj<Int> #4392 #1545
[mk-app] #4410 = #4409 #4389
[mk-app] #4411 = #4410 #4410
[mk-proof] #4582 refl #4411
[mk-app] #4583 or #1576 #4410
[mk-proof] #3790 quant-inst #4583
[instance] 0x106847ab8 #3790 ; 56
[attach-enode] #4409 56
[attach-enode] #4410 56
[assign] #4410 justification -1: p49
[end-of-instance]
[mk-app] #4411 next<Ptr32> #4392
[mk-app] #4582 address<Int> #4411
[mk-app] #3791 address<Int> #4392
[mk-app] #3792 * #176 #3791
[mk-app] #3793 + #4582 #3792
[mk-app] #3794 = #3793 #1503
[mk-app] #3795 + #3792 #4582
[inst-discovered] theory-solving 0x0 arith# ; #3793
[mk-app] #3796 = #3793 #3795
[mk-proof] #4258 rewrite #3796
[instance] 0x0 #3796
[end-of-instance]
[mk-app] #4259 = #3795 #1503
[mk-app] #4260 = #3794 #4259
[mk-proof] #4262 monotonicity #4258 #4260
[attach-meaning] #176 arith (- 1)
[mk-app] #4263 * #176 #4582
[mk-app] #4264 + #3791 #4263
[attach-meaning] #4108 arith (- 4)
[mk-app] #4265 = #4264 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4259
[mk-app] #4267 = #4259 #4265
[mk-proof] #4268 rewrite #4267
[instance] 0x0 #4267
[end-of-instance]
[mk-app] #4269 = #3794 #4265
[mk-proof] #4270 trans #4262 #4268 #4269
[mk-app] #4271 or #3234 #4265
[mk-app] #4550 or #3234 #3794
[mk-proof] #4551 quant-inst #4550
[mk-app] #3839 = #4550 #4271
[mk-proof] #3840 monotonicity #4270 #3839
[mk-app] #3841 = #4271 #4271
[mk-proof] #3842 rewrite #3841
[mk-proof] #3843 trans #3840 #3842 #3839
[mk-proof] #3844 mp #4551 #3843 #4271
[instance] 0x106847af0 #4551 ; 56
[attach-enode] #3791 56
[attach-enode] #4411 56
[attach-enode] #4582 56
[attach-enode] #4263 56
[attach-enode] #4264 56
[attach-enode] #4265 56
[mk-app] #3845 <= #4264 #4108
[mk-app] #4568 >= #4264 #4108
[assign] #4265 justification -1: p51
[end-of-instance]
[assign] #3845 clause p308 (not p307)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[assign] #4568 clause p309 (not p307)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[mk-app] #4569 = #3791 #4529
[attach-meaning] #176 arith (- 1)
[mk-app] #3881 + #3791 #3046
[mk-app] #3882 <= #3881 #36
[mk-app] #3883 >= #3881 #36
[assign] #4569 justification -1: p305
[attach-enode] #4569 0
[attach-enode] #3881 0
[assign] #3882 justification -1: p310
[assign] #3883 justification -1: p310
[new-match] 0x1068484b0 #1495 #1483 #4389 #1545 ; #4411 (#4392 #4392)
[mk-app] #3884 + #151 #4389
[mk-app] #3885 offset<Ptr32> #1545 #3884
[mk-app] #3886 = #4411 #3885
[mk-app] #3887 Int
[attach-meaning] #3887 arith 29
[inst-discovered] theory-solving 0x0 arith# ; #3884
[mk-app] #4542 = #3884 #3887
[mk-proof] #4543 rewrite #4542
[instance] 0x0 #4542
[end-of-instance]
[mk-app] #3923 offset<Ptr32> #1545 #3887
[mk-app] #3924 = #3885 #3923
[mk-proof] #3925 monotonicity #4543 #3924
[mk-app] #3926 = #4411 #3923
[mk-app] #3927 = #3886 #3926
[mk-proof] #3928 monotonicity #3925 #3927
[mk-app] #3929 or #1563 #3926
[mk-app] #4594 or #1563 #3886
[mk-proof] #4595 quant-inst #4594
[mk-app] #3458 = #4594 #3929
[mk-proof] #3459 monotonicity #3928 #3458
[mk-app] #3460 = #3929 #3929
[mk-proof] #3461 rewrite #3460
[mk-proof] #3462 trans #3459 #3461 #3458
[mk-proof] #3463 mp #4595 #3462 #3929
[instance] 0x1068484b0 #4595 ; 57
[attach-enode] #3887 57
[attach-enode] #3923 57
[attach-enode] #3926 57
[assign] #3926 justification -1: p50
[end-of-instance]
[eq-expl] #3887 root
[new-match] 0x106848750 #1477 #1476 #3887 #1545 ; #3923
[eq-expl] #4411 lit #3926 ; #3923
[eq-expl] #3923 root
[new-match] 0x106848788 #1522 #1506 #3887 #1545 ; #4582 (#4411 #3923)
[mk-app] #3466 offset_inj<Int> #3923 #1545
[mk-app] #3467 = #3466 #3887
[mk-app] #3468 = #3467 #3467
[mk-proof] #3469 refl #3468
[mk-app] #3471 or #1576 #3467
[mk-proof] #3472 quant-inst #3471
[instance] 0x106848750 #3472 ; 58
[attach-enode] #3466 58
[attach-enode] #3467 58
[assign] #3467 justification -1: p49
[end-of-instance]
[mk-app] #3468 next<Ptr32> #3923
[mk-app] #3469 address<Int> #3468
[mk-app] #3473 address<Int> #3923
[mk-app] #3474 * #176 #3473
[mk-app] #3475 + #3469 #3474
[mk-app] #3476 = #3475 #1503
[mk-app] #3477 = #3476 #3476
[mk-proof] #3478 refl #3477
[mk-app] #3479 or #3234 #3476
[mk-proof] #3480 quant-inst #3479
[instance] 0x106848788 #3480 ; 58
[attach-enode] #3468 58
[attach-enode] #3469 58
[attach-enode] #3473 58
[attach-enode] #3474 58
[attach-enode] #3475 58
[attach-enode] #3476 58
[mk-app] #3481 <= #3475 #1503
[mk-app] #3483 >= #3475 #1503
[assign] #3476 justification -1: p51
[end-of-instance]
[assign] #3481 clause p316 (not p315)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[assign] #3483 clause p317 (not p315)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[mk-app] #3477 = #3473 #4582
[attach-meaning] #176 arith (- 1)
[mk-app] #3478 + #3473 #4263
[mk-app] #3484 <= #3478 #36
[mk-app] #3482 >= #3478 #36
[assign] #3477 justification -1: p313
[attach-enode] #3477 0
[attach-enode] #3478 0
[assign] #3484 justification -1: p318
[assign] #3482 justification -1: p318
[new-match] 0x106849148 #1495 #1483 #3887 #1545 ; #3468 (#3923 #3923)
[mk-app] #3485 + #151 #3887
[mk-app] #3486 offset<Ptr32> #1545 #3485
[mk-app] #3487 = #3468 #3486
[mk-app] #3867 Int
[attach-meaning] #3867 arith 30
[inst-discovered] theory-solving 0x0 arith# ; #3485
[mk-app] #3868 = #3485 #3867
[mk-proof] #3869 rewrite #3868
[instance] 0x0 #3868
[end-of-instance]
[mk-app] #3870 offset<Ptr32> #1545 #3867
[mk-app] #3871 = #3486 #3870
[mk-proof] #3872 monotonicity #3869 #3871
[mk-app] #3873 = #3468 #3870
[mk-app] #4414 = #3487 #3873
[mk-proof] #4415 monotonicity #3872 #4414
[mk-app] #4418 or #1563 #3873
[mk-app] #4419 or #1563 #3487
[mk-proof] #4424 quant-inst #4419
[mk-app] #4425 = #4419 #4418
[mk-proof] #4427 monotonicity #4415 #4425
[mk-app] #4428 = #4418 #4418
[mk-proof] #4430 rewrite #4428
[mk-proof] #4431 trans #4427 #4430 #4425
[mk-proof] #4432 mp #4424 #4431 #4418
[instance] 0x106849148 #4424 ; 59
[attach-enode] #3867 59
[attach-enode] #3870 59
[attach-enode] #3873 59
[assign] #3873 justification -1: p50
[end-of-instance]
[eq-expl] #3867 root
[new-match] 0x1068493e8 #1477 #1476 #3867 #1545 ; #3870
[eq-expl] #3468 lit #3873 ; #3870
[eq-expl] #3870 root
[new-match] 0x106849420 #1522 #1506 #3867 #1545 ; #3469 (#3468 #3870)
[mk-app] #4433 offset_inj<Int> #3870 #1545
[mk-app] #4434 = #4433 #3867
[mk-app] #4574 = #4434 #4434
[mk-proof] #4575 refl #4574
[mk-app] #3604 or #1576 #4434
[mk-proof] #3605 quant-inst #3604
[instance] 0x1068493e8 #3605 ; 60
[attach-enode] #4433 60
[attach-enode] #4434 60
[assign] #4434 justification -1: p49
[end-of-instance]
[mk-app] #4574 next<Ptr32> #3870
[mk-app] #4575 address<Int> #4574
[mk-app] #3606 address<Int> #3870
[mk-app] #3607 * #176 #3606
[mk-app] #3608 + #4575 #3607
[mk-app] #3609 = #3608 #1503
[mk-app] #3610 + #3607 #4575
[inst-discovered] theory-solving 0x0 arith# ; #3608
[mk-app] #4536 = #3608 #3610
[mk-proof] #4537 rewrite #4536
[instance] 0x0 #4536
[end-of-instance]
[mk-app] #3052 = #3610 #1503
[mk-app] #3053 = #3609 #3052
[mk-proof] #3054 monotonicity #4537 #3053
[attach-meaning] #176 arith (- 1)
[mk-app] #3055 * #176 #4575
[mk-app] #3056 + #3606 #3055
[attach-meaning] #4108 arith (- 4)
[mk-app] #3057 = #3056 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3052
[mk-app] #3058 = #3052 #3057
[mk-proof] #3059 rewrite #3058
[instance] 0x0 #3058
[end-of-instance]
[mk-app] #3060 = #3609 #3057
[mk-proof] #3061 trans #3054 #3059 #3060
[mk-app] #3065 or #3234 #3057
[mk-app] #3066 or #3234 #3609
[mk-proof] #3067 quant-inst #3066
[mk-app] #3068 = #3066 #3065
[mk-proof] #3069 monotonicity #3061 #3068
[mk-app] #3070 = #3065 #3065
[mk-proof] #3071 rewrite #3070
[mk-proof] #3072 trans #3069 #3071 #3068
[mk-proof] #3073 mp #3067 #3072 #3065
[instance] 0x106849420 #3067 ; 60
[attach-enode] #3606 60
[attach-enode] #4574 60
[attach-enode] #4575 60
[attach-enode] #3055 60
[attach-enode] #3056 60
[attach-enode] #3057 60
[mk-app] #3074 <= #3056 #4108
[mk-app] #3076 >= #3056 #4108
[assign] #3057 justification -1: p51
[end-of-instance]
[assign] #3074 clause p324 (not p323)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[assign] #3076 clause p325 (not p323)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[mk-app] #3077 = #3469 #3606
[attach-meaning] #176 arith (- 1)
[mk-app] #3075 + #3469 #3607
[mk-app] #3078 <= #3075 #36
[mk-app] #3079 >= #3075 #36
[assign] #3077 justification -1: p321
[attach-enode] #3077 0
[attach-enode] #3607 0
[attach-enode] #3075 0
[assign] #3078 justification -1: p326
[assign] #3079 justification -1: p326
[new-match] 0x106887e98 #1495 #1483 #3867 #1545 ; #4574 (#3870 #3870)
[mk-app] #3080 + #151 #3867
[mk-app] #3728 offset<Ptr32> #1545 #3080
[mk-app] #3729 = #4574 #3728
[mk-app] #3730 Int
[attach-meaning] #3730 arith 31
[inst-discovered] theory-solving 0x0 arith# ; #3080
[mk-app] #3731 = #3080 #3730
[mk-proof] #3732 rewrite #3731
[instance] 0x0 #3731
[end-of-instance]
[mk-app] #3733 offset<Ptr32> #1545 #3730
[mk-app] #3734 = #3728 #3733
[mk-proof] #4017 monotonicity #3732 #3734
[mk-app] #4018 = #4574 #3733
[mk-app] #4019 = #3729 #4018
[mk-proof] #4020 monotonicity #4017 #4019
[mk-app] #4021 or #1563 #4018
[mk-app] #4022 or #1563 #3729
[mk-proof] #4023 quant-inst #4022
[mk-app] #4024 = #4022 #4021
[mk-proof] #4025 monotonicity #4020 #4024
[mk-app] #4026 = #4021 #4021
[mk-proof] #4027 rewrite #4026
[mk-proof] #4032 trans #4025 #4027 #4024
[mk-proof] #4033 mp #4023 #4032 #4021
[instance] 0x106887e98 #4023 ; 61
[attach-enode] #3730 61
[attach-enode] #3733 61
[attach-enode] #4018 61
[assign] #4018 justification -1: p50
[end-of-instance]
[eq-expl] #3730 root
[new-match] 0x106888138 #1477 #1476 #3730 #1545 ; #3733
[eq-expl] #4574 lit #4018 ; #3733
[eq-expl] #3733 root
[new-match] 0x106888170 #1522 #1506 #3730 #1545 ; #4575 (#4574 #3733)
[mk-app] #4034 offset_inj<Int> #3733 #1545
[mk-app] #4035 = #4034 #3730
[mk-app] #4036 = #4035 #4035
[mk-proof] #4038 refl #4036
[mk-app] #4039 or #1576 #4035
[mk-proof] #4040 quant-inst #4039
[instance] 0x106888138 #4040 ; 62
[attach-enode] #4034 62
[attach-enode] #4035 62
[assign] #4035 justification -1: p49
[end-of-instance]
[mk-app] #4036 next<Ptr32> #3733
[mk-app] #4038 address<Int> #4036
[mk-app] #4041 address<Int> #3733
[mk-app] #4043 * #176 #4041
[mk-app] #4044 + #4038 #4043
[mk-app] #4045 = #4044 #1503
[mk-app] #4046 = #4045 #4045
[mk-proof] #4047 refl #4046
[mk-app] #4498 or #3234 #4045
[mk-proof] #4499 quant-inst #4498
[instance] 0x106888170 #4499 ; 62
[attach-enode] #4036 62
[attach-enode] #4038 62
[attach-enode] #4041 62
[attach-enode] #4043 62
[attach-enode] #4044 62
[attach-enode] #4045 62
[mk-app] #3284 <= #4044 #1503
[mk-app] #3285 >= #4044 #1503
[assign] #4045 justification -1: p51
[end-of-instance]
[assign] #3284 clause p332 (not p331)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[assign] #3285 clause p333 (not p331)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[mk-app] #4046 = #4041 #4575
[attach-meaning] #176 arith (- 1)
[mk-app] #4047 + #4041 #3055
[mk-app] #3286 <= #4047 #36
[mk-app] #3287 >= #4047 #36
[assign] #4046 justification -1: p329
[attach-enode] #4046 0
[attach-enode] #4047 0
[assign] #3286 justification -1: p334
[assign] #3287 justification -1: p334
[new-match] 0x106888b30 #1495 #1483 #3730 #1545 ; #4036 (#3733 #3733)
[mk-app] #3288 + #151 #3730
[mk-app] #3289 offset<Ptr32> #1545 #3288
[mk-app] #3290 = #4036 #3289
[mk-app] #3291 Int
[attach-meaning] #3291 arith 32
[inst-discovered] theory-solving 0x0 arith# ; #3288
[mk-app] #3292 = #3288 #3291
[mk-proof] #3293 rewrite #3292
[instance] 0x0 #3292
[end-of-instance]
[mk-app] #3294 offset<Ptr32> #1545 #3291
[mk-app] #3295 = #3289 #3294
[mk-proof] #3296 monotonicity #3293 #3295
[mk-app] #3297 = #4036 #3294
[mk-app] #3298 = #3290 #3297
[mk-proof] #3299 monotonicity #3296 #3298
[mk-app] #3300 or #1563 #3297
[mk-app] #3301 or #1563 #3290
[mk-proof] #3302 quant-inst #3301
[mk-app] #3303 = #3301 #3300
[mk-proof] #3304 monotonicity #3299 #3303
[mk-app] #3305 = #3300 #3300
[mk-proof] #3309 rewrite #3305
[mk-proof] #3310 trans #3304 #3309 #3303
[mk-proof] #3311 mp #3302 #3310 #3300
[instance] 0x106888b30 #3302 ; 63
[attach-enode] #3291 63
[attach-enode] #3294 63
[attach-enode] #3297 63
[assign] #3297 justification -1: p50
[end-of-instance]
[eq-expl] #3291 root
[new-match] 0x106888dd0 #1477 #1476 #3291 #1545 ; #3294
[eq-expl] #4036 lit #3297 ; #3294
[eq-expl] #3294 root
[new-match] 0x106888e08 #1522 #1506 #3291 #1545 ; #4038 (#4036 #3294)
[mk-app] #3312 offset_inj<Int> #3294 #1545
[mk-app] #3313 = #3312 #3291
[mk-app] #3314 = #3313 #3313
[mk-proof] #3315 refl #3314
[mk-app] #3316 or #1576 #3313
[mk-proof] #3317 quant-inst #3316
[instance] 0x106888dd0 #3317 ; 64
[attach-enode] #3312 64
[attach-enode] #3313 64
[assign] #3313 justification -1: p49
[end-of-instance]
[mk-app] #3314 next<Ptr32> #3294
[mk-app] #3315 address<Int> #3314
[mk-app] #3318 address<Int> #3294
[mk-app] #3320 * #176 #3318
[mk-app] #3321 + #3315 #3320
[mk-app] #3319 = #3321 #1503
[mk-app] #3322 = #3319 #3319
[mk-proof] #3323 refl #3322
[mk-app] #3324 or #3234 #3319
[mk-proof] #3776 quant-inst #3324
[instance] 0x106888e08 #3776 ; 64
[attach-enode] #3314 64
[attach-enode] #3315 64
[attach-enode] #3318 64
[attach-enode] #3320 64
[attach-enode] #3321 64
[attach-enode] #3319 64
[mk-app] #3777 <= #3321 #1503
[mk-app] #3778 >= #3321 #1503
[assign] #3319 justification -1: p51
[end-of-instance]
[assign] #3777 clause p340 (not p339)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[assign] #3778 clause p341 (not p339)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[mk-app] #3322 = #3318 #4038
[attach-meaning] #176 arith (- 1)
[mk-app] #3323 * #176 #4038
[mk-app] #3779 + #3318 #3323
[mk-app] #3780 <= #3779 #36
[mk-app] #3781 >= #3779 #36
[assign] #3322 justification -1: p337
[attach-enode] #3322 0
[attach-enode] #3323 0
[attach-enode] #3779 0
[assign] #3780 justification -1: p342
[assign] #3781 justification -1: p342
[new-match] 0x106889850 #1495 #1483 #3291 #1545 ; #3314 (#3294 #3294)
[mk-app] #3782 + #151 #3291
[mk-app] #4185 offset<Ptr32> #1545 #3782
[mk-app] #4186 = #3314 #4185
[mk-app] #4187 Int
[attach-meaning] #4187 arith 33
[inst-discovered] theory-solving 0x0 arith# ; #3782
[mk-app] #4188 = #3782 #4187
[mk-proof] #4189 rewrite #4188
[instance] 0x0 #4188
[end-of-instance]
[mk-app] #4190 offset<Ptr32> #1545 #4187
[mk-app] #4191 = #4185 #4190
[mk-proof] #4192 monotonicity #4189 #4191
[mk-app] #4193 = #3314 #4190
[mk-app] #4194 = #4186 #4193
[mk-proof] #4195 monotonicity #4192 #4194
[mk-app] #4200 or #1563 #4193
[mk-app] #4201 or #1563 #4186
[mk-proof] #4202 quant-inst #4201
[mk-app] #4203 = #4201 #4200
[mk-proof] #4204 monotonicity #4195 #4203
[mk-app] #4206 = #4200 #4200
[mk-proof] #4207 rewrite #4206
[mk-proof] #4208 trans #4204 #4207 #4203
[mk-proof] #4209 mp #4202 #4208 #4200
[instance] 0x106889850 #4202 ; 65
[attach-enode] #4187 65
[attach-enode] #4190 65
[attach-enode] #4193 65
[assign] #4193 justification -1: p50
[end-of-instance]
[eq-expl] #4187 root
[new-match] 0x106890760 #1477 #1476 #4187 #1545 ; #4190
[eq-expl] #3314 lit #4193 ; #4190
[eq-expl] #4190 root
[new-match] 0x106890798 #1522 #1506 #4187 #1545 ; #3315 (#3314 #4190)
[mk-app] #4211 offset_inj<Int> #4190 #1545
[mk-app] #4212 = #4211 #4187
[mk-app] #4213 = #4212 #4212
[mk-proof] #4214 refl #4213
[mk-app] #4215 or #1576 #4212
[mk-proof] #4590 quant-inst #4215
[instance] 0x106890760 #4590 ; 66
[attach-enode] #4211 66
[attach-enode] #4212 66
[assign] #4212 justification -1: p49
[end-of-instance]
[mk-app] #4213 next<Ptr32> #4190
[mk-app] #4214 address<Int> #4213
[mk-app] #4591 address<Int> #4190
[mk-app] #3874 * #176 #4591
[mk-app] #3875 + #4214 #3874
[mk-app] #3876 = #3875 #1503
[mk-app] #3877 = #3876 #3876
[mk-proof] #3878 refl #3877
[mk-app] #3879 or #3234 #3876
[mk-proof] #3880 quant-inst #3879
[instance] 0x106890798 #3880 ; 66
[attach-enode] #4213 66
[attach-enode] #4214 66
[attach-enode] #4591 66
[attach-enode] #3874 66
[attach-enode] #3875 66
[attach-enode] #3876 66
[mk-app] #4576 <= #3875 #1503
[mk-app] #4577 >= #3875 #1503
[assign] #3876 justification -1: p51
[end-of-instance]
[assign] #4576 clause p348 (not p347)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[assign] #4577 clause p349 (not p347)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[mk-app] #3877 = #3315 #4591
[attach-meaning] #176 arith (- 1)
[mk-app] #3878 + #3315 #3874
[mk-app] #3672 <= #3878 #36
[mk-app] #3673 >= #3878 #36
[assign] #3877 justification -1: p345
[attach-enode] #3877 0
[attach-enode] #3878 0
[assign] #3672 justification -1: p350
[assign] #3673 justification -1: p350
[new-match] 0x106891158 #1495 #1483 #4187 #1545 ; #4213 (#4190 #4190)
[mk-app] #3674 + #151 #4187
[mk-app] #3675 offset<Ptr32> #1545 #3674
[mk-app] #3676 = #4213 #3675
[mk-app] #3677 Int
[attach-meaning] #3677 arith 34
[inst-discovered] theory-solving 0x0 arith# ; #3674
[mk-app] #3678 = #3674 #3677
[mk-proof] #4494 rewrite #3678
[instance] 0x0 #3678
[end-of-instance]
[mk-app] #4495 offset<Ptr32> #1545 #3677
[mk-app] #3818 = #3675 #4495
[mk-proof] #3819 monotonicity #4494 #3818
[mk-app] #3820 = #4213 #4495
[mk-app] #3821 = #3676 #3820
[mk-proof] #3822 monotonicity #3819 #3821
[mk-app] #3823 or #1563 #3820
[mk-app] #3824 or #1563 #3676
[mk-proof] #4570 quant-inst #3824
[mk-app] #4571 = #3824 #3823
[mk-proof] #3597 monotonicity #3822 #4571
[mk-app] #3598 = #3823 #3823
[mk-proof] #3599 rewrite #3598
[mk-proof] #3600 trans #3597 #3599 #4571
[mk-proof] #3601 mp #4570 #3600 #3823
[instance] 0x106891158 #4570 ; 67
[attach-enode] #3677 67
[attach-enode] #4495 67
[attach-enode] #3820 67
[assign] #3820 justification -1: p50
[end-of-instance]
[eq-expl] #3677 root
[new-match] 0x1068913f8 #1477 #1476 #3677 #1545 ; #4495
[eq-expl] #4213 lit #3820 ; #4495
[eq-expl] #4495 root
[new-match] 0x106891430 #1522 #1506 #3677 #1545 ; #4214 (#4213 #4495)
[mk-app] #3602 offset_inj<Int> #4495 #1545
[mk-app] #3603 = #3602 #3677
[mk-app] #4534 = #3603 #3603
[mk-proof] #4535 refl #4534
[mk-app] #2989 or #1576 #3603
[mk-proof] #2990 quant-inst #2989
[instance] 0x1068913f8 #2990 ; 68
[attach-enode] #3602 68
[attach-enode] #3603 68
[assign] #3603 justification -1: p49
[end-of-instance]
[mk-app] #4534 next<Ptr32> #4495
[mk-app] #4535 address<Int> #4534
[mk-app] #2991 address<Int> #4495
[mk-app] #2992 * #176 #2991
[mk-app] #2993 + #4535 #2992
[mk-app] #2994 = #2993 #1503
[mk-app] #2995 + #2992 #4535
[inst-discovered] theory-solving 0x0 arith# ; #2993
[mk-app] #2997 = #2993 #2995
[mk-proof] #2998 rewrite #2997
[instance] 0x0 #2997
[end-of-instance]
[mk-app] #2996 = #2995 #1503
[mk-app] #2999 = #2994 #2996
[mk-proof] #3000 monotonicity #2998 #2999
[attach-meaning] #176 arith (- 1)
[mk-app] #3001 * #176 #4535
[mk-app] #3714 + #2991 #3001
[attach-meaning] #4108 arith (- 4)
[mk-app] #3715 = #3714 #4108
[inst-discovered] theory-solving 0x0 arith# ; #2996
[mk-app] #3716 = #2996 #3715
[mk-proof] #3717 rewrite #3716
[instance] 0x0 #3716
[end-of-instance]
[mk-app] #3718 = #2994 #3715
[mk-proof] #3719 trans #3000 #3717 #3718
[mk-app] #3720 or #3234 #3715
[mk-app] #3961 or #3234 #2994
[mk-proof] #3962 quant-inst #3961
[mk-app] #3963 = #3961 #3720
[mk-proof] #3964 monotonicity #3719 #3963
[mk-app] #3965 = #3720 #3720
[mk-proof] #3966 rewrite #3965
[mk-proof] #3967 trans #3964 #3966 #3963
[mk-proof] #3968 mp #3962 #3967 #3720
[instance] 0x106891430 #3962 ; 68
[attach-enode] #2991 68
[attach-enode] #4534 68
[attach-enode] #4535 68
[attach-enode] #3001 68
[attach-enode] #3714 68
[attach-enode] #3715 68
[mk-app] #3969 <= #3714 #4108
[mk-app] #3970 >= #3714 #4108
[assign] #3715 justification -1: p51
[end-of-instance]
[assign] #3969 clause p356 (not p355)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[assign] #3970 clause p357 (not p355)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[mk-app] #3971 = #2991 #4214
[attach-meaning] #176 arith (- 1)
[mk-app] #3972 * #176 #4214
[mk-app] #3973 + #2991 #3972
[mk-app] #3974 <= #3973 #36
[mk-app] #3976 >= #3973 #36
[assign] #3971 justification -1: p353
[attach-enode] #3971 0
[attach-enode] #3972 0
[attach-enode] #3973 0
[assign] #3974 justification -1: p358
[assign] #3976 justification -1: p358
[new-match] 0x106891e78 #1495 #1483 #3677 #1545 ; #4534 (#4495 #4495)
[mk-app] #3977 + #151 #3677
[mk-app] #3978 offset<Ptr32> #1545 #3977
[mk-app] #3979 = #4534 #3978
[mk-app] #3981 Int
[attach-meaning] #3981 arith 35
[inst-discovered] theory-solving 0x0 arith# ; #3977
[mk-app] #3982 = #3977 #3981
[mk-proof] #3983 rewrite #3982
[instance] 0x0 #3982
[end-of-instance]
[mk-app] #3984 offset<Ptr32> #1545 #3981
[mk-app] #3985 = #3978 #3984
[mk-proof] #4520 monotonicity #3983 #3985
[mk-app] #4521 = #4534 #3984
[mk-app] #3177 = #3979 #4521
[mk-proof] #3178 monotonicity #4520 #3177
[mk-app] #3179 or #1563 #4521
[mk-app] #3180 or #1563 #3979
[mk-proof] #3181 quant-inst #3180
[mk-app] #3182 = #3180 #3179
[mk-proof] #3186 monotonicity #3178 #3182
[mk-app] #3187 = #3179 #3179
[mk-proof] #3188 rewrite #3187
[mk-proof] #3189 trans #3186 #3188 #3182
[mk-proof] #3191 mp #3181 #3189 #3179
[instance] 0x106891e78 #3181 ; 69
[attach-enode] #3981 69
[attach-enode] #3984 69
[attach-enode] #4521 69
[assign] #4521 justification -1: p50
[end-of-instance]
[eq-expl] #3981 root
[new-match] 0x106892118 #1477 #1476 #3981 #1545 ; #3984
[eq-expl] #4534 lit #4521 ; #3984
[eq-expl] #3984 root
[new-match] 0x106892150 #1522 #1506 #3981 #1545 ; #4535 (#4534 #3984)
[mk-app] #3192 offset_inj<Int> #3984 #1545
[mk-app] #3193 = #3192 #3981
[mk-app] #3194 = #3193 #3193
[mk-proof] #3195 refl #3194
[mk-app] #3196 or #1576 #3193
[mk-proof] #3197 quant-inst #3196
[instance] 0x106892118 #3197 ; 70
[attach-enode] #3192 70
[attach-enode] #3193 70
[assign] #3193 justification -1: p49
[end-of-instance]
[mk-app] #3194 next<Ptr32> #3984
[mk-app] #3195 address<Int> #3194
[mk-app] #3198 address<Int> #3984
[mk-app] #3201 * #176 #3198
[mk-app] #3202 + #3195 #3201
[mk-app] #3203 = #3202 #1503
[mk-app] #3204 = #3203 #3203
[mk-proof] #3206 refl #3204
[mk-app] #3207 or #3234 #3203
[mk-proof] #3208 quant-inst #3207
[instance] 0x106892150 #3208 ; 70
[attach-enode] #3194 70
[attach-enode] #3195 70
[attach-enode] #3198 70
[attach-enode] #3201 70
[attach-enode] #3202 70
[attach-enode] #3203 70
[mk-app] #3209 <= #3202 #1503
[mk-app] #3210 >= #3202 #1503
[assign] #3203 justification -1: p51
[end-of-instance]
[assign] #3209 clause p364 (not p363)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[assign] #3210 clause p365 (not p363)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[mk-app] #3204 = #3198 #4535
[attach-meaning] #176 arith (- 1)
[mk-app] #3206 + #3198 #3001
[mk-app] #3211 <= #3206 #36
[mk-app] #3212 >= #3206 #36
[assign] #3204 justification -1: p361
[attach-enode] #3204 0
[attach-enode] #3206 0
[assign] #3211 justification -1: p366
[assign] #3212 justification -1: p366
[new-match] 0x10689a958 #1495 #1483 #3981 #1545 ; #3194 (#3984 #3984)
[mk-app] #3213 + #151 #3981
[mk-app] #3214 offset<Ptr32> #1545 #3213
[mk-app] #3215 = #3194 #3214
[mk-app] #3216 Int
[attach-meaning] #3216 arith 36
[inst-discovered] theory-solving 0x0 arith# ; #3213
[mk-app] #3218 = #3213 #3216
[mk-proof] #3219 rewrite #3218
[instance] 0x0 #3218
[end-of-instance]
[mk-app] #3217 offset<Ptr32> #1545 #3216
[mk-app] #3220 = #3214 #3217
[mk-proof] #3221 monotonicity #3219 #3220
[mk-app] #3222 = #3194 #3217
[mk-app] #3749 = #3215 #3222
[mk-proof] #3750 monotonicity #3221 #3749
[mk-app] #3751 or #1563 #3222
[mk-app] #3752 or #1563 #3215
[mk-proof] #3753 quant-inst #3752
[mk-app] #3754 = #3752 #3751
[mk-proof] #3755 monotonicity #3750 #3754
[mk-app] #4109 = #3751 #3751
[mk-proof] #4110 rewrite #4109
[mk-proof] #4112 trans #3755 #4110 #3754
[mk-proof] #4113 mp #3753 #4112 #3751
[instance] 0x10689a958 #3753 ; 71
[attach-enode] #3216 71
[attach-enode] #3217 71
[attach-enode] #3222 71
[assign] #3222 justification -1: p50
[end-of-instance]
[eq-expl] #3216 root
[new-match] 0x10689abf8 #1477 #1476 #3216 #1545 ; #3217
[eq-expl] #3194 lit #3222 ; #3217
[eq-expl] #3217 root
[new-match] 0x10689ac30 #1522 #1506 #3216 #1545 ; #3195 (#3194 #3217)
[mk-app] #4114 offset_inj<Int> #3217 #1545
[mk-app] #4115 = #4114 #3216
[mk-app] #4116 = #4115 #4115
[mk-proof] #4121 refl #4116
[mk-app] #4122 or #1576 #4115
[mk-proof] #4123 quant-inst #4122
[instance] 0x10689abf8 #4123 ; 72
[attach-enode] #4114 72
[attach-enode] #4115 72
[assign] #4115 justification -1: p49
[end-of-instance]
[mk-app] #4116 next<Ptr32> #3217
[mk-app] #4121 address<Int> #4116
[mk-app] #4124 address<Int> #3217
[mk-app] #4126 * #176 #4124
[mk-app] #4127 + #4121 #4126
[mk-app] #4128 = #4127 #1503
[mk-app] #4129 = #4128 #4128
[mk-proof] #4130 refl #4129
[mk-app] #4514 or #3234 #4128
[mk-proof] #4515 quant-inst #4514
[instance] 0x10689ac30 #4515 ; 72
[attach-enode] #4116 72
[attach-enode] #4121 72
[attach-enode] #4124 72
[attach-enode] #4126 72
[attach-enode] #4127 72
[attach-enode] #4128 72
[mk-app] #3658 <= #4127 #1503
[mk-app] #3659 >= #4127 #1503
[assign] #4128 justification -1: p51
[end-of-instance]
[assign] #3658 clause p372 (not p371)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[assign] #3659 clause p373 (not p371)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[mk-app] #4129 = #3195 #4124
[attach-meaning] #176 arith (- 1)
[mk-app] #4130 + #3195 #4126
[mk-app] #3660 <= #4130 #36
[mk-app] #3661 >= #4130 #36
[assign] #4129 justification -1: p369
[attach-enode] #4129 0
[attach-enode] #4130 0
[assign] #3660 justification -1: p374
[assign] #3661 justification -1: p374
[new-match] 0x10689b5f0 #1495 #1483 #3216 #1545 ; #4116 (#3217 #3217)
[mk-app] #3662 + #151 #3216
[mk-app] #3663 offset<Ptr32> #1545 #3662
[mk-app] #3664 = #4116 #3663
[mk-app] #4506 Int
[attach-meaning] #4506 arith 37
[inst-discovered] theory-solving 0x0 arith# ; #3662
[mk-app] #4507 = #3662 #4506
[mk-proof] #3651 rewrite #4507
[instance] 0x0 #4507
[end-of-instance]
[mk-app] #3652 offset<Ptr32> #1545 #4506
[mk-app] #3653 = #3663 #3652
[mk-proof] #3654 monotonicity #3651 #3653
[mk-app] #3655 = #4116 #3652
[mk-app] #3656 = #3664 #3655
[mk-proof] #3657 monotonicity #3654 #3656
[mk-app] #4504 or #1563 #3655
[mk-app] #4505 or #1563 #3664
[mk-proof] #3665 quant-inst #4505
[mk-app] #3666 = #4505 #4504
[mk-proof] #3667 monotonicity #3657 #3666
[mk-app] #3668 = #4504 #4504
[mk-proof] #3669 rewrite #3668
[mk-proof] #3670 trans #3667 #3669 #3666
[mk-proof] #3671 mp #3665 #3670 #4504
[instance] 0x10689b5f0 #3665 ; 73
[attach-enode] #4506 73
[attach-enode] #3652 73
[attach-enode] #3655 73
[assign] #3655 justification -1: p50
[end-of-instance]
[eq-expl] #4506 root
[new-match] 0x10689b890 #1477 #1476 #4506 #1545 ; #3652
[eq-expl] #4116 lit #3655 ; #3652
[eq-expl] #3652 root
[new-match] 0x10689b8c8 #1522 #1506 #4506 #1545 ; #4121 (#4116 #3652)
[mk-app] #4492 offset_inj<Int> #3652 #1545
[mk-app] #4493 = #4492 #4506
[mk-app] #4491 = #4493 #4493
[mk-proof] #4596 refl #4491
[mk-app] #4586 or #1576 #4493
[mk-proof] #4587 quant-inst #4586
[instance] 0x10689b890 #4587 ; 74
[attach-enode] #4492 74
[attach-enode] #4493 74
[assign] #4493 justification -1: p49
[end-of-instance]
[mk-app] #4491 next<Ptr32> #3652
[mk-app] #4596 address<Int> #4491
[mk-app] #4597 address<Int> #3652
[mk-app] #4584 * #176 #4597
[mk-app] #4585 + #4596 #4584
[mk-app] #4486 = #4585 #1503
[mk-app] #4487 = #4486 #4486
[mk-proof] #4488 refl #4487
[mk-app] #4489 or #3234 #4486
[mk-proof] #4598 quant-inst #4489
[instance] 0x10689b8c8 #4598 ; 74
[attach-enode] #4491 74
[attach-enode] #4596 74
[attach-enode] #4597 74
[attach-enode] #4584 74
[attach-enode] #4585 74
[attach-enode] #4486 74
[mk-app] #4599 <= #4585 #1503
[mk-app] #4600 >= #4585 #1503
[assign] #4486 justification -1: p51
[end-of-instance]
[assign] #4599 clause p380 (not p379)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[assign] #4600 clause p381 (not p379)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[mk-app] #4487 = #4121 #4597
[attach-meaning] #176 arith (- 1)
[mk-app] #4488 + #4121 #4584
[mk-app] #4601 <= #4488 #36
[mk-app] #4602 >= #4488 #36
[assign] #4487 justification -1: p377
[attach-enode] #4487 0
[attach-enode] #4488 0
[assign] #4601 justification -1: p382
[assign] #4602 justification -1: p382
[new-match] 0x10689c288 #1495 #1483 #4506 #1545 ; #4491 (#3652 #3652)
[mk-app] #4603 + #151 #4506
[mk-app] #4604 offset<Ptr32> #1545 #4603
[mk-app] #4605 = #4491 #4604
[mk-app] #4606 Int
[attach-meaning] #4606 arith 38
[inst-discovered] theory-solving 0x0 arith# ; #4603
[mk-app] #4607 = #4603 #4606
[mk-proof] #4608 rewrite #4607
[instance] 0x0 #4607
[end-of-instance]
[mk-app] #4609 offset<Ptr32> #1545 #4606
[mk-app] #4610 = #4604 #4609
[mk-proof] #4611 monotonicity #4608 #4610
[mk-app] #4612 = #4491 #4609
[mk-app] #4613 = #4605 #4612
[mk-proof] #4614 monotonicity #4611 #4613
[mk-app] #4615 or #1563 #4612
[mk-app] #4616 or #1563 #4605
[mk-proof] #4617 quant-inst #4616
[mk-app] #4618 = #4616 #4615
[mk-proof] #4619 monotonicity #4614 #4618
[mk-app] #4620 = #4615 #4615
[mk-proof] #4621 rewrite #4620
[mk-proof] #4622 trans #4619 #4621 #4618
[mk-proof] #4623 mp #4617 #4622 #4615
[instance] 0x10689c288 #4617 ; 75
[attach-enode] #4606 75
[attach-enode] #4609 75
[attach-enode] #4612 75
[assign] #4612 justification -1: p50
[end-of-instance]
[eq-expl] #4606 root
[new-match] 0x10684f560 #1477 #1476 #4606 #1545 ; #4609
[eq-expl] #4491 lit #4612 ; #4609
[eq-expl] #4609 root
[new-match] 0x10684f598 #1522 #1506 #4606 #1545 ; #4596 (#4491 #4609)
[mk-app] #4624 offset_inj<Int> #4609 #1545
[mk-app] #4625 = #4624 #4606
[mk-app] #4626 = #4625 #4625
[mk-proof] #4627 refl #4626
[mk-app] #4628 or #1576 #4625
[mk-proof] #4629 quant-inst #4628
[instance] 0x10684f560 #4629 ; 76
[attach-enode] #4624 76
[attach-enode] #4625 76
[assign] #4625 justification -1: p49
[end-of-instance]
[mk-app] #4626 next<Ptr32> #4609
[mk-app] #4627 address<Int> #4626
[mk-app] #4630 address<Int> #4609
[mk-app] #4631 * #176 #4630
[mk-app] #4632 + #4627 #4631
[mk-app] #4633 = #4632 #1503
[mk-app] #4634 = #4633 #4633
[mk-proof] #4635 refl #4634
[mk-app] #4636 or #3234 #4633
[mk-proof] #4637 quant-inst #4636
[instance] 0x10684f598 #4637 ; 76
[attach-enode] #4626 76
[attach-enode] #4627 76
[attach-enode] #4630 76
[attach-enode] #4631 76
[attach-enode] #4632 76
[attach-enode] #4633 76
[mk-app] #4638 <= #4632 #1503
[mk-app] #4639 >= #4632 #1503
[assign] #4633 justification -1: p51
[end-of-instance]
[assign] #4638 clause p388 (not p387)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[assign] #4639 clause p389 (not p387)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[mk-app] #4634 = #4596 #4630
[attach-meaning] #176 arith (- 1)
[mk-app] #4635 + #4596 #4631
[mk-app] #4640 <= #4635 #36
[mk-app] #4641 >= #4635 #36
[assign] #4634 justification -1: p385
[attach-enode] #4634 0
[attach-enode] #4635 0
[assign] #4640 justification -1: p390
[assign] #4641 justification -1: p390
[new-match] 0x10684ff58 #1495 #1483 #4606 #1545 ; #4626 (#4609 #4609)
[mk-app] #4642 + #151 #4606
[mk-app] #4643 offset<Ptr32> #1545 #4642
[mk-app] #4644 = #4626 #4643
[mk-app] #4645 Int
[attach-meaning] #4645 arith 39
[inst-discovered] theory-solving 0x0 arith# ; #4642
[mk-app] #4646 = #4642 #4645
[mk-proof] #4647 rewrite #4646
[instance] 0x0 #4646
[end-of-instance]
[mk-app] #4648 offset<Ptr32> #1545 #4645
[mk-app] #4649 = #4643 #4648
[mk-proof] #4650 monotonicity #4647 #4649
[mk-app] #4651 = #4626 #4648
[mk-app] #4652 = #4644 #4651
[mk-proof] #4653 monotonicity #4650 #4652
[mk-app] #4654 or #1563 #4651
[mk-app] #4655 or #1563 #4644
[mk-proof] #4656 quant-inst #4655
[mk-app] #4657 = #4655 #4654
[mk-proof] #4658 monotonicity #4653 #4657
[mk-app] #4659 = #4654 #4654
[mk-proof] #4660 rewrite #4659
[mk-proof] #4661 trans #4658 #4660 #4657
[mk-proof] #4662 mp #4656 #4661 #4654
[instance] 0x10684ff58 #4656 ; 77
[attach-enode] #4645 77
[attach-enode] #4648 77
[attach-enode] #4651 77
[assign] #4651 justification -1: p50
[end-of-instance]
[eq-expl] #4645 root
[new-match] 0x1068501f8 #1477 #1476 #4645 #1545 ; #4648
[eq-expl] #4626 lit #4651 ; #4648
[eq-expl] #4648 root
[new-match] 0x106850230 #1522 #1506 #4645 #1545 ; #4627 (#4626 #4648)
[mk-app] #4663 offset_inj<Int> #4648 #1545
[mk-app] #4664 = #4663 #4645
[mk-app] #4665 = #4664 #4664
[mk-proof] #4666 refl #4665
[mk-app] #4667 or #1576 #4664
[mk-proof] #4668 quant-inst #4667
[instance] 0x1068501f8 #4668 ; 78
[attach-enode] #4663 78
[attach-enode] #4664 78
[assign] #4664 justification -1: p49
[end-of-instance]
[mk-app] #4665 next<Ptr32> #4648
[mk-app] #4666 address<Int> #4665
[mk-app] #4669 address<Int> #4648
[mk-app] #4670 * #176 #4669
[mk-app] #4671 + #4666 #4670
[mk-app] #4672 = #4671 #1503
[mk-app] #4673 = #4672 #4672
[mk-proof] #4674 refl #4673
[mk-app] #4675 or #3234 #4672
[mk-proof] #4676 quant-inst #4675
[instance] 0x106850230 #4676 ; 78
[attach-enode] #4665 78
[attach-enode] #4666 78
[attach-enode] #4669 78
[attach-enode] #4670 78
[attach-enode] #4671 78
[attach-enode] #4672 78
[mk-app] #4677 <= #4671 #1503
[mk-app] #4678 >= #4671 #1503
[assign] #4672 justification -1: p51
[end-of-instance]
[assign] #4677 clause p396 (not p395)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[assign] #4678 clause p397 (not p395)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[mk-app] #4673 = #4627 #4669
[attach-meaning] #176 arith (- 1)
[mk-app] #4674 + #4627 #4670
[mk-app] #4679 <= #4674 #36
[mk-app] #4680 >= #4674 #36
[assign] #4673 justification -1: p393
[attach-enode] #4673 0
[attach-enode] #4674 0
[assign] #4679 justification -1: p398
[assign] #4680 justification -1: p398
[new-match] 0x106850bf0 #1495 #1483 #4645 #1545 ; #4665 (#4648 #4648)
[mk-app] #4681 + #151 #4645
[mk-app] #4682 offset<Ptr32> #1545 #4681
[mk-app] #4683 = #4665 #4682
[mk-app] #4684 Int
[attach-meaning] #4684 arith 40
[inst-discovered] theory-solving 0x0 arith# ; #4681
[mk-app] #4685 = #4681 #4684
[mk-proof] #4686 rewrite #4685
[instance] 0x0 #4685
[end-of-instance]
[mk-app] #4687 offset<Ptr32> #1545 #4684
[mk-app] #4688 = #4682 #4687
[mk-proof] #4689 monotonicity #4686 #4688
[mk-app] #4690 = #4665 #4687
[mk-app] #4691 = #4683 #4690
[mk-proof] #4692 monotonicity #4689 #4691
[mk-app] #4693 or #1563 #4690
[mk-app] #4694 or #1563 #4683
[mk-proof] #4695 quant-inst #4694
[mk-app] #4696 = #4694 #4693
[mk-proof] #4697 monotonicity #4692 #4696
[mk-app] #4698 = #4693 #4693
[mk-proof] #4699 rewrite #4698
[mk-proof] #4700 trans #4697 #4699 #4696
[mk-proof] #4701 mp #4695 #4700 #4693
[instance] 0x106850bf0 #4695 ; 79
[attach-enode] #4684 79
[attach-enode] #4687 79
[attach-enode] #4690 79
[assign] #4690 justification -1: p50
[end-of-instance]
[eq-expl] #4684 root
[new-match] 0x106850e90 #1477 #1476 #4684 #1545 ; #4687
[eq-expl] #4665 lit #4690 ; #4687
[eq-expl] #4687 root
[new-match] 0x106850ec8 #1522 #1506 #4684 #1545 ; #4666 (#4665 #4687)
[mk-app] #4702 offset_inj<Int> #4687 #1545
[mk-app] #4703 = #4702 #4684
[mk-app] #4704 = #4703 #4703
[mk-proof] #4705 refl #4704
[mk-app] #4706 or #1576 #4703
[mk-proof] #4707 quant-inst #4706
[instance] 0x106850e90 #4707 ; 80
[attach-enode] #4702 80
[attach-enode] #4703 80
[assign] #4703 justification -1: p49
[end-of-instance]
[mk-app] #4704 next<Ptr32> #4687
[mk-app] #4705 address<Int> #4704
[mk-app] #4708 address<Int> #4687
[mk-app] #4709 * #176 #4708
[mk-app] #4710 + #4705 #4709
[mk-app] #4711 = #4710 #1503
[mk-app] #4712 = #4711 #4711
[mk-proof] #4713 refl #4712
[mk-app] #4714 or #3234 #4711
[mk-proof] #4715 quant-inst #4714
[instance] 0x106850ec8 #4715 ; 80
[attach-enode] #4704 80
[attach-enode] #4705 80
[attach-enode] #4708 80
[attach-enode] #4709 80
[attach-enode] #4710 80
[attach-enode] #4711 80
[mk-app] #4716 <= #4710 #1503
[mk-app] #4717 >= #4710 #1503
[assign] #4711 justification -1: p51
[end-of-instance]
[assign] #4716 clause p404 (not p403)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[assign] #4717 clause p405 (not p403)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[mk-app] #4712 = #4666 #4708
[attach-meaning] #176 arith (- 1)
[mk-app] #4713 + #4666 #4709
[mk-app] #4718 <= #4713 #36
[mk-app] #4719 >= #4713 #36
[assign] #4712 justification -1: p401
[attach-enode] #4712 0
[attach-enode] #4713 0
[assign] #4718 justification -1: p406
[assign] #4719 justification -1: p406
[new-match] 0x10686e6a8 #1495 #1483 #4684 #1545 ; #4704 (#4687 #4687)
[mk-app] #4720 + #151 #4684
[mk-app] #4721 offset<Ptr32> #1545 #4720
[mk-app] #4722 = #4704 #4721
[mk-app] #4723 Int
[attach-meaning] #4723 arith 41
[inst-discovered] theory-solving 0x0 arith# ; #4720
[mk-app] #4724 = #4720 #4723
[mk-proof] #4725 rewrite #4724
[instance] 0x0 #4724
[end-of-instance]
[mk-app] #4726 offset<Ptr32> #1545 #4723
[mk-app] #4727 = #4721 #4726
[mk-proof] #4728 monotonicity #4725 #4727
[mk-app] #4729 = #4704 #4726
[mk-app] #4730 = #4722 #4729
[mk-proof] #4731 monotonicity #4728 #4730
[mk-app] #4732 or #1563 #4729
[mk-app] #4733 or #1563 #4722
[mk-proof] #4734 quant-inst #4733
[mk-app] #4735 = #4733 #4732
[mk-proof] #4736 monotonicity #4731 #4735
[mk-app] #4737 = #4732 #4732
[mk-proof] #4738 rewrite #4737
[mk-proof] #4739 trans #4736 #4738 #4735
[mk-proof] #4740 mp #4734 #4739 #4732
[instance] 0x10686e6a8 #4734 ; 81
[attach-enode] #4723 81
[attach-enode] #4726 81
[attach-enode] #4729 81
[assign] #4729 justification -1: p50
[end-of-instance]
[eq-expl] #4723 root
[new-match] 0x10686e948 #1477 #1476 #4723 #1545 ; #4726
[eq-expl] #4704 lit #4729 ; #4726
[eq-expl] #4726 root
[new-match] 0x10686e980 #1522 #1506 #4723 #1545 ; #4705 (#4704 #4726)
[mk-app] #4741 offset_inj<Int> #4726 #1545
[mk-app] #4742 = #4741 #4723
[mk-app] #4743 = #4742 #4742
[mk-proof] #4744 refl #4743
[mk-app] #4745 or #1576 #4742
[mk-proof] #4746 quant-inst #4745
[instance] 0x10686e948 #4746 ; 82
[attach-enode] #4741 82
[attach-enode] #4742 82
[assign] #4742 justification -1: p49
[end-of-instance]
[mk-app] #4743 next<Ptr32> #4726
[mk-app] #4744 address<Int> #4743
[mk-app] #4747 address<Int> #4726
[mk-app] #4748 * #176 #4747
[mk-app] #4749 + #4744 #4748
[mk-app] #4750 = #4749 #1503
[mk-app] #4751 = #4750 #4750
[mk-proof] #4752 refl #4751
[mk-app] #4753 or #3234 #4750
[mk-proof] #4754 quant-inst #4753
[instance] 0x10686e980 #4754 ; 82
[attach-enode] #4743 82
[attach-enode] #4744 82
[attach-enode] #4747 82
[attach-enode] #4748 82
[attach-enode] #4749 82
[attach-enode] #4750 82
[mk-app] #4755 <= #4749 #1503
[mk-app] #4756 >= #4749 #1503
[assign] #4750 justification -1: p51
[end-of-instance]
[assign] #4755 clause p412 (not p411)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[assign] #4756 clause p413 (not p411)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[mk-app] #4751 = #4705 #4747
[attach-meaning] #176 arith (- 1)
[mk-app] #4752 + #4705 #4748
[mk-app] #4757 <= #4752 #36
[mk-app] #4758 >= #4752 #36
[assign] #4751 justification -1: p409
[attach-enode] #4751 0
[attach-enode] #4752 0
[assign] #4757 justification -1: p414
[assign] #4758 justification -1: p414
[new-match] 0x10686f340 #1495 #1483 #4723 #1545 ; #4743 (#4726 #4726)
[mk-app] #4759 + #151 #4723
[mk-app] #4760 offset<Ptr32> #1545 #4759
[mk-app] #4761 = #4743 #4760
[mk-app] #4762 Int
[attach-meaning] #4762 arith 42
[inst-discovered] theory-solving 0x0 arith# ; #4759
[mk-app] #4763 = #4759 #4762
[mk-proof] #4764 rewrite #4763
[instance] 0x0 #4763
[end-of-instance]
[mk-app] #4765 offset<Ptr32> #1545 #4762
[mk-app] #4766 = #4760 #4765
[mk-proof] #4767 monotonicity #4764 #4766
[mk-app] #4768 = #4743 #4765
[mk-app] #4769 = #4761 #4768
[mk-proof] #4770 monotonicity #4767 #4769
[mk-app] #4771 or #1563 #4768
[mk-app] #4772 or #1563 #4761
[mk-proof] #4773 quant-inst #4772
[mk-app] #4774 = #4772 #4771
[mk-proof] #4775 monotonicity #4770 #4774
[mk-app] #4776 = #4771 #4771
[mk-proof] #4777 rewrite #4776
[mk-proof] #4778 trans #4775 #4777 #4774
[mk-proof] #4779 mp #4773 #4778 #4771
[instance] 0x10686f340 #4773 ; 83
[attach-enode] #4762 83
[attach-enode] #4765 83
[attach-enode] #4768 83
[assign] #4768 justification -1: p50
[end-of-instance]
[eq-expl] #4762 root
[new-match] 0x10686f5e0 #1477 #1476 #4762 #1545 ; #4765
[eq-expl] #4743 lit #4768 ; #4765
[eq-expl] #4765 root
[new-match] 0x10686f618 #1522 #1506 #4762 #1545 ; #4744 (#4743 #4765)
[mk-app] #4780 offset_inj<Int> #4765 #1545
[mk-app] #4781 = #4780 #4762
[mk-app] #4782 = #4781 #4781
[mk-proof] #4783 refl #4782
[mk-app] #4784 or #1576 #4781
[mk-proof] #4785 quant-inst #4784
[instance] 0x10686f5e0 #4785 ; 84
[attach-enode] #4780 84
[attach-enode] #4781 84
[assign] #4781 justification -1: p49
[end-of-instance]
[mk-app] #4782 next<Ptr32> #4765
[mk-app] #4783 address<Int> #4782
[mk-app] #4786 address<Int> #4765
[mk-app] #4787 * #176 #4786
[mk-app] #4788 + #4783 #4787
[mk-app] #4789 = #4788 #1503
[mk-app] #4790 = #4789 #4789
[mk-proof] #4791 refl #4790
[mk-app] #4792 or #3234 #4789
[mk-proof] #4793 quant-inst #4792
[instance] 0x10686f618 #4793 ; 84
[attach-enode] #4782 84
[attach-enode] #4783 84
[attach-enode] #4786 84
[attach-enode] #4787 84
[attach-enode] #4788 84
[attach-enode] #4789 84
[mk-app] #4794 <= #4788 #1503
[mk-app] #4795 >= #4788 #1503
[assign] #4789 justification -1: p51
[end-of-instance]
[assign] #4794 clause p420 (not p419)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[assign] #4795 clause p421 (not p419)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[mk-app] #4790 = #4744 #4786
[attach-meaning] #176 arith (- 1)
[mk-app] #4791 + #4744 #4787
[mk-app] #4796 <= #4791 #36
[mk-app] #4797 >= #4791 #36
[assign] #4790 justification -1: p417
[attach-enode] #4790 0
[attach-enode] #4791 0
[assign] #4796 justification -1: p422
[assign] #4797 justification -1: p422
[new-match] 0x10686ffd8 #1495 #1483 #4762 #1545 ; #4782 (#4765 #4765)
[mk-app] #4798 + #151 #4762
[mk-app] #4799 offset<Ptr32> #1545 #4798
[mk-app] #4800 = #4782 #4799
[mk-app] #4801 Int
[attach-meaning] #4801 arith 43
[inst-discovered] theory-solving 0x0 arith# ; #4798
[mk-app] #4802 = #4798 #4801
[mk-proof] #4803 rewrite #4802
[instance] 0x0 #4802
[end-of-instance]
[mk-app] #4804 offset<Ptr32> #1545 #4801
[mk-app] #4805 = #4799 #4804
[mk-proof] #4806 monotonicity #4803 #4805
[mk-app] #4807 = #4782 #4804
[mk-app] #4808 = #4800 #4807
[mk-proof] #4809 monotonicity #4806 #4808
[mk-app] #4810 or #1563 #4807
[mk-app] #4811 or #1563 #4800
[mk-proof] #4812 quant-inst #4811
[mk-app] #4813 = #4811 #4810
[mk-proof] #4814 monotonicity #4809 #4813
[mk-app] #4815 = #4810 #4810
[mk-proof] #4816 rewrite #4815
[mk-proof] #4817 trans #4814 #4816 #4813
[mk-proof] #4818 mp #4812 #4817 #4810
[instance] 0x10686ffd8 #4812 ; 85
[attach-enode] #4801 85
[attach-enode] #4804 85
[attach-enode] #4807 85
[assign] #4807 justification -1: p50
[end-of-instance]
[eq-expl] #4801 root
[new-match] 0x1068b1890 #1477 #1476 #4801 #1545 ; #4804
[eq-expl] #4782 lit #4807 ; #4804
[eq-expl] #4804 root
[new-match] 0x1068b18c8 #1522 #1506 #4801 #1545 ; #4783 (#4782 #4804)
[mk-app] #4819 offset_inj<Int> #4804 #1545
[mk-app] #4820 = #4819 #4801
[mk-app] #4821 = #4820 #4820
[mk-proof] #4822 refl #4821
[mk-app] #4823 or #1576 #4820
[mk-proof] #4824 quant-inst #4823
[instance] 0x1068b1890 #4824 ; 86
[attach-enode] #4819 86
[attach-enode] #4820 86
[assign] #4820 justification -1: p49
[end-of-instance]
[mk-app] #4821 next<Ptr32> #4804
[mk-app] #4822 address<Int> #4821
[mk-app] #4825 address<Int> #4804
[mk-app] #4826 * #176 #4825
[mk-app] #4827 + #4822 #4826
[mk-app] #4828 = #4827 #1503
[mk-app] #4829 = #4828 #4828
[mk-proof] #4830 refl #4829
[mk-app] #4831 or #3234 #4828
[mk-proof] #4832 quant-inst #4831
[instance] 0x1068b18c8 #4832 ; 86
[attach-enode] #4821 86
[attach-enode] #4822 86
[attach-enode] #4825 86
[attach-enode] #4826 86
[attach-enode] #4827 86
[attach-enode] #4828 86
[mk-app] #4833 <= #4827 #1503
[mk-app] #4834 >= #4827 #1503
[assign] #4828 justification -1: p51
[end-of-instance]
[assign] #4833 clause p428 (not p427)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[assign] #4834 clause p429 (not p427)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[mk-app] #4829 = #4783 #4825
[attach-meaning] #176 arith (- 1)
[mk-app] #4830 + #4783 #4826
[mk-app] #4835 <= #4830 #36
[mk-app] #4836 >= #4830 #36
[assign] #4829 justification -1: p425
[attach-enode] #4829 0
[attach-enode] #4830 0
[assign] #4835 justification -1: p430
[assign] #4836 justification -1: p430
[new-match] 0x1068b2288 #1495 #1483 #4801 #1545 ; #4821 (#4804 #4804)
[mk-app] #4837 + #151 #4801
[mk-app] #4838 offset<Ptr32> #1545 #4837
[mk-app] #4839 = #4821 #4838
[mk-app] #4840 Int
[attach-meaning] #4840 arith 44
[inst-discovered] theory-solving 0x0 arith# ; #4837
[mk-app] #4841 = #4837 #4840
[mk-proof] #4842 rewrite #4841
[instance] 0x0 #4841
[end-of-instance]
[mk-app] #4843 offset<Ptr32> #1545 #4840
[mk-app] #4844 = #4838 #4843
[mk-proof] #4845 monotonicity #4842 #4844
[mk-app] #4846 = #4821 #4843
[mk-app] #4847 = #4839 #4846
[mk-proof] #4848 monotonicity #4845 #4847
[mk-app] #4849 or #1563 #4846
[mk-app] #4850 or #1563 #4839
[mk-proof] #4851 quant-inst #4850
[mk-app] #4852 = #4850 #4849
[mk-proof] #4853 monotonicity #4848 #4852
[mk-app] #4854 = #4849 #4849
[mk-proof] #4855 rewrite #4854
[mk-proof] #4856 trans #4853 #4855 #4852
[mk-proof] #4857 mp #4851 #4856 #4849
[instance] 0x1068b2288 #4851 ; 87
[attach-enode] #4840 87
[attach-enode] #4843 87
[attach-enode] #4846 87
[assign] #4846 justification -1: p50
[end-of-instance]
[eq-expl] #4840 root
[new-match] 0x1068b2528 #1477 #1476 #4840 #1545 ; #4843
[eq-expl] #4821 lit #4846 ; #4843
[eq-expl] #4843 root
[new-match] 0x1068b2560 #1522 #1506 #4840 #1545 ; #4822 (#4821 #4843)
[mk-app] #4858 offset_inj<Int> #4843 #1545
[mk-app] #4859 = #4858 #4840
[mk-app] #4860 = #4859 #4859
[mk-proof] #4861 refl #4860
[mk-app] #4862 or #1576 #4859
[mk-proof] #4863 quant-inst #4862
[instance] 0x1068b2528 #4863 ; 88
[attach-enode] #4858 88
[attach-enode] #4859 88
[assign] #4859 justification -1: p49
[end-of-instance]
[mk-app] #4860 next<Ptr32> #4843
[mk-app] #4861 address<Int> #4860
[mk-app] #4864 address<Int> #4843
[mk-app] #4865 * #176 #4864
[mk-app] #4866 + #4861 #4865
[mk-app] #4867 = #4866 #1503
[mk-app] #4868 = #4867 #4867
[mk-proof] #4869 refl #4868
[mk-app] #4870 or #3234 #4867
[mk-proof] #4871 quant-inst #4870
[instance] 0x1068b2560 #4871 ; 88
[attach-enode] #4860 88
[attach-enode] #4861 88
[attach-enode] #4864 88
[attach-enode] #4865 88
[attach-enode] #4866 88
[attach-enode] #4867 88
[mk-app] #4872 <= #4866 #1503
[mk-app] #4873 >= #4866 #1503
[assign] #4867 justification -1: p51
[end-of-instance]
[assign] #4872 clause p436 (not p435)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[assign] #4873 clause p437 (not p435)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[mk-app] #4868 = #4822 #4864
[attach-meaning] #176 arith (- 1)
[mk-app] #4869 + #4822 #4865
[mk-app] #4874 <= #4869 #36
[mk-app] #4875 >= #4869 #36
[assign] #4868 justification -1: p433
[attach-enode] #4868 0
[attach-enode] #4869 0
[assign] #4874 justification -1: p438
[assign] #4875 justification -1: p438
[new-match] 0x1068b2f20 #1495 #1483 #4840 #1545 ; #4860 (#4843 #4843)
[mk-app] #4876 + #151 #4840
[mk-app] #4877 offset<Ptr32> #1545 #4876
[mk-app] #4878 = #4860 #4877
[mk-app] #4879 Int
[attach-meaning] #4879 arith 45
[inst-discovered] theory-solving 0x0 arith# ; #4876
[mk-app] #4880 = #4876 #4879
[mk-proof] #4881 rewrite #4880
[instance] 0x0 #4880
[end-of-instance]
[mk-app] #4882 offset<Ptr32> #1545 #4879
[mk-app] #4883 = #4877 #4882
[mk-proof] #4884 monotonicity #4881 #4883
[mk-app] #4885 = #4860 #4882
[mk-app] #4886 = #4878 #4885
[mk-proof] #4887 monotonicity #4884 #4886
[mk-app] #4888 or #1563 #4885
[mk-app] #4889 or #1563 #4878
[mk-proof] #4890 quant-inst #4889
[mk-app] #4891 = #4889 #4888
[mk-proof] #4892 monotonicity #4887 #4891
[mk-app] #4893 = #4888 #4888
[mk-proof] #4894 rewrite #4893
[mk-proof] #4895 trans #4892 #4894 #4891
[mk-proof] #4896 mp #4890 #4895 #4888
[instance] 0x1068b2f20 #4890 ; 89
[attach-enode] #4879 89
[attach-enode] #4882 89
[attach-enode] #4885 89
[assign] #4885 justification -1: p50
[end-of-instance]
[eq-expl] #4879 root
[new-match] 0x1068b31c0 #1477 #1476 #4879 #1545 ; #4882
[eq-expl] #4860 lit #4885 ; #4882
[eq-expl] #4882 root
[new-match] 0x1068b31f8 #1522 #1506 #4879 #1545 ; #4861 (#4860 #4882)
[mk-app] #4897 offset_inj<Int> #4882 #1545
[mk-app] #4898 = #4897 #4879
[mk-app] #4899 = #4898 #4898
[mk-proof] #4900 refl #4899
[mk-app] #4901 or #1576 #4898
[mk-proof] #4902 quant-inst #4901
[instance] 0x1068b31c0 #4902 ; 90
[attach-enode] #4897 90
[attach-enode] #4898 90
[assign] #4898 justification -1: p49
[end-of-instance]
[mk-app] #4899 next<Ptr32> #4882
[mk-app] #4900 address<Int> #4899
[mk-app] #4903 address<Int> #4882
[mk-app] #4904 * #176 #4903
[mk-app] #4905 + #4900 #4904
[mk-app] #4906 = #4905 #1503
[mk-app] #4907 = #4906 #4906
[mk-proof] #4908 refl #4907
[mk-app] #4909 or #3234 #4906
[mk-proof] #4910 quant-inst #4909
[instance] 0x1068b31f8 #4910 ; 90
[attach-enode] #4899 90
[attach-enode] #4900 90
[attach-enode] #4903 90
[attach-enode] #4904 90
[attach-enode] #4905 90
[attach-enode] #4906 90
[mk-app] #4911 <= #4905 #1503
[mk-app] #4912 >= #4905 #1503
[assign] #4906 justification -1: p51
[end-of-instance]
[assign] #4911 clause p444 (not p443)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[assign] #4912 clause p445 (not p443)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[mk-app] #4907 = #4861 #4903
[attach-meaning] #176 arith (- 1)
[mk-app] #4908 + #4861 #4904
[mk-app] #4913 <= #4908 #36
[mk-app] #4914 >= #4908 #36
[assign] #4907 justification -1: p441
[attach-enode] #4907 0
[attach-enode] #4908 0
[assign] #4913 justification -1: p446
[assign] #4914 justification -1: p446
[new-match] 0x1068ba9e8 #1495 #1483 #4879 #1545 ; #4899 (#4882 #4882)
[mk-app] #4915 + #151 #4879
[mk-app] #4916 offset<Ptr32> #1545 #4915
[mk-app] #4917 = #4899 #4916
[mk-app] #4918 Int
[attach-meaning] #4918 arith 46
[inst-discovered] theory-solving 0x0 arith# ; #4915
[mk-app] #4919 = #4915 #4918
[mk-proof] #4920 rewrite #4919
[instance] 0x0 #4919
[end-of-instance]
[mk-app] #4921 offset<Ptr32> #1545 #4918
[mk-app] #4922 = #4916 #4921
[mk-proof] #4923 monotonicity #4920 #4922
[mk-app] #4924 = #4899 #4921
[mk-app] #4925 = #4917 #4924
[mk-proof] #4926 monotonicity #4923 #4925
[mk-app] #4927 or #1563 #4924
[mk-app] #4928 or #1563 #4917
[mk-proof] #4929 quant-inst #4928
[mk-app] #4930 = #4928 #4927
[mk-proof] #4931 monotonicity #4926 #4930
[mk-app] #4932 = #4927 #4927
[mk-proof] #4933 rewrite #4932
[mk-proof] #4934 trans #4931 #4933 #4930
[mk-proof] #4935 mp #4929 #4934 #4927
[instance] 0x1068ba9e8 #4929 ; 91
[attach-enode] #4918 91
[attach-enode] #4921 91
[attach-enode] #4924 91
[assign] #4924 justification -1: p50
[end-of-instance]
[eq-expl] #4918 root
[new-match] 0x1068bac88 #1477 #1476 #4918 #1545 ; #4921
[eq-expl] #4899 lit #4924 ; #4921
[eq-expl] #4921 root
[new-match] 0x1068bacc0 #1522 #1506 #4918 #1545 ; #4900 (#4899 #4921)
[mk-app] #4936 offset_inj<Int> #4921 #1545
[mk-app] #4937 = #4936 #4918
[mk-app] #4938 = #4937 #4937
[mk-proof] #4939 refl #4938
[mk-app] #4940 or #1576 #4937
[mk-proof] #4941 quant-inst #4940
[instance] 0x1068bac88 #4941 ; 92
[attach-enode] #4936 92
[attach-enode] #4937 92
[assign] #4937 justification -1: p49
[end-of-instance]
[mk-app] #4938 next<Ptr32> #4921
[mk-app] #4939 address<Int> #4938
[mk-app] #4942 address<Int> #4921
[mk-app] #4943 * #176 #4942
[mk-app] #4944 + #4939 #4943
[mk-app] #4945 = #4944 #1503
[mk-app] #4946 = #4945 #4945
[mk-proof] #4947 refl #4946
[mk-app] #4948 or #3234 #4945
[mk-proof] #4949 quant-inst #4948
[instance] 0x1068bacc0 #4949 ; 92
[attach-enode] #4938 92
[attach-enode] #4939 92
[attach-enode] #4942 92
[attach-enode] #4943 92
[attach-enode] #4944 92
[attach-enode] #4945 92
[mk-app] #4950 <= #4944 #1503
[mk-app] #4951 >= #4944 #1503
[assign] #4945 justification -1: p51
[end-of-instance]
[assign] #4950 clause p452 (not p451)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[assign] #4951 clause p453 (not p451)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[mk-app] #4946 = #4900 #4942
[attach-meaning] #176 arith (- 1)
[mk-app] #4947 + #4900 #4943
[mk-app] #4952 <= #4947 #36
[mk-app] #4953 >= #4947 #36
[assign] #4946 justification -1: p449
[attach-enode] #4946 0
[attach-enode] #4947 0
[assign] #4952 justification -1: p454
[assign] #4953 justification -1: p454
[new-match] 0x1068bb680 #1495 #1483 #4918 #1545 ; #4938 (#4921 #4921)
[mk-app] #4954 + #151 #4918
[mk-app] #4955 offset<Ptr32> #1545 #4954
[mk-app] #4956 = #4938 #4955
[mk-app] #4957 Int
[attach-meaning] #4957 arith 47
[inst-discovered] theory-solving 0x0 arith# ; #4954
[mk-app] #4958 = #4954 #4957
[mk-proof] #4959 rewrite #4958
[instance] 0x0 #4958
[end-of-instance]
[mk-app] #4960 offset<Ptr32> #1545 #4957
[mk-app] #4961 = #4955 #4960
[mk-proof] #4962 monotonicity #4959 #4961
[mk-app] #4963 = #4938 #4960
[mk-app] #4964 = #4956 #4963
[mk-proof] #4965 monotonicity #4962 #4964
[mk-app] #4966 or #1563 #4963
[mk-app] #4967 or #1563 #4956
[mk-proof] #4968 quant-inst #4967
[mk-app] #4969 = #4967 #4966
[mk-proof] #4970 monotonicity #4965 #4969
[mk-app] #4971 = #4966 #4966
[mk-proof] #4972 rewrite #4971
[mk-proof] #4973 trans #4970 #4972 #4969
[mk-proof] #4974 mp #4968 #4973 #4966
[instance] 0x1068bb680 #4968 ; 93
[attach-enode] #4957 93
[attach-enode] #4960 93
[attach-enode] #4963 93
[assign] #4963 justification -1: p50
[end-of-instance]
[eq-expl] #4957 root
[new-match] 0x1068bb920 #1477 #1476 #4957 #1545 ; #4960
[eq-expl] #4938 lit #4963 ; #4960
[eq-expl] #4960 root
[new-match] 0x1068bb958 #1522 #1506 #4957 #1545 ; #4939 (#4938 #4960)
[mk-app] #4975 offset_inj<Int> #4960 #1545
[mk-app] #4976 = #4975 #4957
[mk-app] #4977 = #4976 #4976
[mk-proof] #4978 refl #4977
[mk-app] #4979 or #1576 #4976
[mk-proof] #4980 quant-inst #4979
[instance] 0x1068bb920 #4980 ; 94
[attach-enode] #4975 94
[attach-enode] #4976 94
[assign] #4976 justification -1: p49
[end-of-instance]
[mk-app] #4977 next<Ptr32> #4960
[mk-app] #4978 address<Int> #4977
[mk-app] #4981 address<Int> #4960
[mk-app] #4982 * #176 #4981
[mk-app] #4983 + #4978 #4982
[mk-app] #4984 = #4983 #1503
[mk-app] #4985 = #4984 #4984
[mk-proof] #4986 refl #4985
[mk-app] #4987 or #3234 #4984
[mk-proof] #4988 quant-inst #4987
[instance] 0x1068bb958 #4988 ; 94
[attach-enode] #4977 94
[attach-enode] #4978 94
[attach-enode] #4981 94
[attach-enode] #4982 94
[attach-enode] #4983 94
[attach-enode] #4984 94
[mk-app] #4989 <= #4983 #1503
[mk-app] #4990 >= #4983 #1503
[assign] #4984 justification -1: p51
[end-of-instance]
[assign] #4989 clause p460 (not p459)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[assign] #4990 clause p461 (not p459)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[mk-app] #4985 = #4939 #4981
[attach-meaning] #176 arith (- 1)
[mk-app] #4986 + #4939 #4982
[mk-app] #4991 <= #4986 #36
[mk-app] #4992 >= #4986 #36
[assign] #4985 justification -1: p457
[attach-enode] #4985 0
[attach-enode] #4986 0
[assign] #4991 justification -1: p462
[assign] #4992 justification -1: p462
[new-match] 0x1068bc318 #1495 #1483 #4957 #1545 ; #4977 (#4960 #4960)
[mk-app] #4993 + #151 #4957
[mk-app] #4994 offset<Ptr32> #1545 #4993
[mk-app] #4995 = #4977 #4994
[mk-app] #4996 Int
[attach-meaning] #4996 arith 48
[inst-discovered] theory-solving 0x0 arith# ; #4993
[mk-app] #4997 = #4993 #4996
[mk-proof] #4998 rewrite #4997
[instance] 0x0 #4997
[end-of-instance]
[mk-app] #4999 offset<Ptr32> #1545 #4996
[mk-app] #5000 = #4994 #4999
[mk-proof] #5001 monotonicity #4998 #5000
[mk-app] #5002 = #4977 #4999
[mk-app] #5003 = #4995 #5002
[mk-proof] #5004 monotonicity #5001 #5003
[mk-app] #5005 or #1563 #5002
[mk-app] #5006 or #1563 #4995
[mk-proof] #5007 quant-inst #5006
[mk-app] #5008 = #5006 #5005
[mk-proof] #5009 monotonicity #5004 #5008
[mk-app] #5010 = #5005 #5005
[mk-proof] #5011 rewrite #5010
[mk-proof] #5012 trans #5009 #5011 #5008
[mk-proof] #5013 mp #5007 #5012 #5005
[instance] 0x1068bc318 #5007 ; 95
[attach-enode] #4996 95
[attach-enode] #4999 95
[attach-enode] #5002 95
[assign] #5002 justification -1: p50
[end-of-instance]
[eq-expl] #4996 root
[new-match] 0x1068bc5b8 #1477 #1476 #4996 #1545 ; #4999
[eq-expl] #4977 lit #5002 ; #4999
[eq-expl] #4999 root
[new-match] 0x1068cdc10 #1522 #1506 #4996 #1545 ; #4978 (#4977 #4999)
[mk-app] #5014 offset_inj<Int> #4999 #1545
[mk-app] #5015 = #5014 #4996
[mk-app] #5016 = #5015 #5015
[mk-proof] #5017 refl #5016
[mk-app] #5018 or #1576 #5015
[mk-proof] #5019 quant-inst #5018
[instance] 0x1068bc5b8 #5019 ; 96
[attach-enode] #5014 96
[attach-enode] #5015 96
[assign] #5015 justification -1: p49
[end-of-instance]
[mk-app] #5016 next<Ptr32> #4999
[mk-app] #5017 address<Int> #5016
[mk-app] #5020 address<Int> #4999
[mk-app] #5021 * #176 #5020
[mk-app] #5022 + #5017 #5021
[mk-app] #5023 = #5022 #1503
[mk-app] #5024 = #5023 #5023
[mk-proof] #5025 refl #5024
[mk-app] #5026 or #3234 #5023
[mk-proof] #5027 quant-inst #5026
[instance] 0x1068cdc10 #5027 ; 96
[attach-enode] #5016 96
[attach-enode] #5017 96
[attach-enode] #5020 96
[attach-enode] #5021 96
[attach-enode] #5022 96
[attach-enode] #5023 96
[mk-app] #5028 <= #5022 #1503
[mk-app] #5029 >= #5022 #1503
[assign] #5023 justification -1: p51
[end-of-instance]
[assign] #5028 clause p468 (not p467)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[assign] #5029 clause p469 (not p467)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[mk-app] #5024 = #4978 #5020
[attach-meaning] #176 arith (- 1)
[mk-app] #5025 + #4978 #5021
[mk-app] #5030 <= #5025 #36
[mk-app] #5031 >= #5025 #36
[assign] #5024 justification -1: p465
[attach-enode] #5024 0
[attach-enode] #5025 0
[assign] #5030 justification -1: p470
[assign] #5031 justification -1: p470
[new-match] 0x1068ce5d0 #1495 #1483 #4996 #1545 ; #5016 (#4999 #4999)
[mk-app] #5032 + #151 #4996
[mk-app] #5033 offset<Ptr32> #1545 #5032
[mk-app] #5034 = #5016 #5033
[mk-app] #5035 Int
[attach-meaning] #5035 arith 49
[inst-discovered] theory-solving 0x0 arith# ; #5032
[mk-app] #5036 = #5032 #5035
[mk-proof] #5037 rewrite #5036
[instance] 0x0 #5036
[end-of-instance]
[mk-app] #5038 offset<Ptr32> #1545 #5035
[mk-app] #5039 = #5033 #5038
[mk-proof] #5040 monotonicity #5037 #5039
[mk-app] #5041 = #5016 #5038
[mk-app] #5042 = #5034 #5041
[mk-proof] #5043 monotonicity #5040 #5042
[mk-app] #5044 or #1563 #5041
[mk-app] #5045 or #1563 #5034
[mk-proof] #5046 quant-inst #5045
[mk-app] #5047 = #5045 #5044
[mk-proof] #5048 monotonicity #5043 #5047
[mk-app] #5049 = #5044 #5044
[mk-proof] #5050 rewrite #5049
[mk-proof] #5051 trans #5048 #5050 #5047
[mk-proof] #5052 mp #5046 #5051 #5044
[instance] 0x1068ce5d0 #5046 ; 97
[attach-enode] #5035 97
[attach-enode] #5038 97
[attach-enode] #5041 97
[assign] #5041 justification -1: p50
[end-of-instance]
[eq-expl] #5035 root
[new-match] 0x1068ce870 #1477 #1476 #5035 #1545 ; #5038
[eq-expl] #5016 lit #5041 ; #5038
[eq-expl] #5038 root
[new-match] 0x1068ce8a8 #1522 #1506 #5035 #1545 ; #5017 (#5016 #5038)
[mk-app] #5053 offset_inj<Int> #5038 #1545
[mk-app] #5054 = #5053 #5035
[mk-app] #5055 = #5054 #5054
[mk-proof] #5056 refl #5055
[mk-app] #5057 or #1576 #5054
[mk-proof] #5058 quant-inst #5057
[instance] 0x1068ce870 #5058 ; 98
[attach-enode] #5053 98
[attach-enode] #5054 98
[assign] #5054 justification -1: p49
[end-of-instance]
[mk-app] #5055 next<Ptr32> #5038
[mk-app] #5056 address<Int> #5055
[mk-app] #5059 address<Int> #5038
[mk-app] #5060 * #176 #5059
[mk-app] #5061 + #5056 #5060
[mk-app] #5062 = #5061 #1503
[mk-app] #5063 = #5062 #5062
[mk-proof] #5064 refl #5063
[mk-app] #5065 or #3234 #5062
[mk-proof] #5066 quant-inst #5065
[instance] 0x1068ce8a8 #5066 ; 98
[attach-enode] #5055 98
[attach-enode] #5056 98
[attach-enode] #5059 98
[attach-enode] #5060 98
[attach-enode] #5061 98
[attach-enode] #5062 98
[mk-app] #5067 <= #5061 #1503
[mk-app] #5068 >= #5061 #1503
[assign] #5062 justification -1: p51
[end-of-instance]
[assign] #5067 clause p476 (not p475)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[assign] #5068 clause p477 (not p475)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[mk-app] #5063 = #5017 #5059
[attach-meaning] #176 arith (- 1)
[mk-app] #5064 + #5017 #5060
[mk-app] #5069 <= #5064 #36
[mk-app] #5070 >= #5064 #36
[assign] #5063 justification -1: p473
[attach-enode] #5063 0
[attach-enode] #5064 0
[assign] #5069 justification -1: p478
[assign] #5070 justification -1: p478
[new-match] 0x1068cf268 #1495 #1483 #5035 #1545 ; #5055 (#5038 #5038)
[mk-app] #5071 + #151 #5035
[mk-app] #5072 offset<Ptr32> #1545 #5071
[mk-app] #5073 = #5055 #5072
[mk-app] #5074 Int
[attach-meaning] #5074 arith 50
[inst-discovered] theory-solving 0x0 arith# ; #5071
[mk-app] #5075 = #5071 #5074
[mk-proof] #5076 rewrite #5075
[instance] 0x0 #5075
[end-of-instance]
[mk-app] #5077 offset<Ptr32> #1545 #5074
[mk-app] #5078 = #5072 #5077
[mk-proof] #5079 monotonicity #5076 #5078
[mk-app] #5080 = #5055 #5077
[mk-app] #5081 = #5073 #5080
[mk-proof] #5082 monotonicity #5079 #5081
[mk-app] #5083 or #1563 #5080
[mk-app] #5084 or #1563 #5073
[mk-proof] #5085 quant-inst #5084
[mk-app] #5086 = #5084 #5083
[mk-proof] #5087 monotonicity #5082 #5086
[mk-app] #5088 = #5083 #5083
[mk-proof] #5089 rewrite #5088
[mk-proof] #5090 trans #5087 #5089 #5086
[mk-proof] #5091 mp #5085 #5090 #5083
[instance] 0x1068cf268 #5085 ; 99
[attach-enode] #5074 99
[attach-enode] #5077 99
[attach-enode] #5080 99
[assign] #5080 justification -1: p50
[end-of-instance]
[eq-expl] #5074 root
[new-match] 0x1068cf508 #1477 #1476 #5074 #1545 ; #5077
[eq-expl] #5055 lit #5080 ; #5077
[eq-expl] #5077 root
[new-match] 0x1068cf540 #1522 #1506 #5074 #1545 ; #5056 (#5055 #5077)
[mk-app] #5092 offset_inj<Int> #5077 #1545
[mk-app] #5093 = #5092 #5074
[mk-app] #5094 = #5093 #5093
[mk-proof] #5095 refl #5094
[mk-app] #5096 or #1576 #5093
[mk-proof] #5097 quant-inst #5096
[instance] 0x1068cf508 #5097 ; 100
[attach-enode] #5092 100
[attach-enode] #5093 100
[assign] #5093 justification -1: p49
[end-of-instance]
[mk-app] #5094 next<Ptr32> #5077
[mk-app] #5095 address<Int> #5094
[mk-app] #5098 address<Int> #5077
[mk-app] #5099 * #176 #5098
[mk-app] #5100 + #5095 #5099
[mk-app] #5101 = #5100 #1503
[mk-app] #5102 = #5101 #5101
[mk-proof] #5103 refl #5102
[mk-app] #5104 or #3234 #5101
[mk-proof] #5105 quant-inst #5104
[instance] 0x1068cf540 #5105 ; 100
[attach-enode] #5094 100
[attach-enode] #5095 100
[attach-enode] #5098 100
[attach-enode] #5099 100
[attach-enode] #5100 100
[attach-enode] #5101 100
[mk-app] #5106 <= #5100 #1503
[mk-app] #5107 >= #5100 #1503
[assign] #5101 justification -1: p51
[end-of-instance]
[assign] #5106 clause p484 (not p483)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[assign] #5107 clause p485 (not p483)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[mk-app] #5102 = #5056 #5098
[attach-meaning] #176 arith (- 1)
[mk-app] #5103 + #5056 #5099
[mk-app] #5108 <= #5103 #36
[mk-app] #5109 >= #5103 #36
[assign] #5102 justification -1: p481
[attach-enode] #5102 0
[attach-enode] #5103 0
[assign] #5108 justification -1: p486
[assign] #5109 justification -1: p486
[new-match] 0x1068e2d10 #1495 #1483 #5074 #1545 ; #5094 (#5077 #5077)
[decide-and-or] #2170 #2177
[push] 3
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 4
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[eq-expl] #3402 root
[new-match] 0x1068e4178 #263 #246 #3402 #3403 ; #4347
[eq-expl] #1529 root
[new-match] 0x1068e41b0 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e41e8 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4228 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4268 #124 #118 #1528 ; #3402
[new-match] 0x1068e4298 #143 #118 #1528 ; #3402
[new-match] 0x1068e42c8 #237 #229 #3402 #36 ; #3403
[mk-app] #5110 * #176 #3402
[mk-app] #5111 * #176 #4347
[mk-app] #5112 + #3403 #5110 #5111
[mk-app] #5113 = #5112 #36
[mk-app] #5114 + #5110 #3403 #5111
[inst-discovered] theory-solving 0x0 arith# ; #5112
[mk-app] #5115 = #5112 #5114
[mk-proof] #5116 rewrite #5115
[instance] 0x0 #5115
[end-of-instance]
[mk-app] #5117 = #5114 #36
[mk-app] #5118 = #5113 #5117
[mk-proof] #5119 monotonicity #5116 #5118
[attach-meaning] #176 arith (- 1)
[mk-app] #5120 * #176 #3403
[mk-app] #5121 + #3402 #5120 #4347
[mk-app] #5122 = #5121 #36
[inst-discovered] theory-solving 0x0 arith# ; #5117
[mk-app] #5123 = #5117 #5122
[mk-proof] #5124 rewrite #5123
[instance] 0x0 #5123
[end-of-instance]
[mk-app] #5125 = #5113 #5122
[mk-proof] #5126 trans #5119 #5124 #5125
[mk-app] #5127 not #263
[mk-app] #5128 or #5127 #5122
[mk-app] #5129 or #5127 #5113
[mk-proof] #5130 quant-inst #5129
[mk-app] #5131 = #5129 #5128
[mk-proof] #5132 monotonicity #5126 #5131
[mk-app] #5133 = #5128 #5128
[mk-proof] #5134 rewrite #5133
[mk-proof] #5135 trans #5132 #5134 #5131
[mk-proof] #5136 mp #5130 #5135 #5128
[instance] 0x1068e4178 #5130 ; 3
[attach-enode] #5120 3
[attach-enode] #5121 3
[attach-enode] #5122 3
[mk-app] #5137 <= #5121 #36
[mk-app] #5138 >= #5121 #36
[assign] #5122 justification -1: p21
[end-of-instance]
[mk-app] #5139 Seq_length #1529
[mk-app] #5140 * #176 #5139
[mk-app] #5141 + #3403 #5140
[mk-app] #5142 >= #5141 #36
[mk-app] #5143 >= #3403 #36
[mk-app] #5144 not #5143
[mk-app] #5145 Seq_contains_trigger #1529 #4352
[mk-app] #5146 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5146
[mk-app] #5147 = #5146 #5146
[mk-proof] #5148 rewrite #5147
[instance] 0x0 #5147
[end-of-instance]
[mk-app] #5149 or #4423 #5142 #5144 #5145
[mk-app] #5150 or #4423 #5146
[mk-proof] #5151 quant-inst #5150
[mk-app] #5152 = #5150 #5149
[mk-proof] #5153 rewrite #5152
[mk-proof] #5154 mp #5151 #5153 #5149
[instance] 0x1068e41b0 #5151 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5147 Seq_index #1528 #3403
[mk-app] #5148 = #4352 #5147
[mk-app] #5155 + #3403 #5110
[mk-app] #5156 >= #5155 #36
[mk-app] #5157 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5158 + #5110 #3403
[inst-discovered] theory-solving 0x0 arith# ; #5155
[mk-app] #5159 = #5155 #5158
[mk-proof] #5160 rewrite #5159
[instance] 0x0 #5159
[end-of-instance]
[mk-app] #5161 >= #5158 #36
[mk-app] #5162 = #5156 #5161
[mk-proof] #5163 monotonicity #5160 #5162
[attach-meaning] #176 arith (- 1)
[mk-app] #5164 + #3402 #5120
[mk-app] #5165 <= #5164 #36
[inst-discovered] theory-solving 0x0 arith# ; #5161
[mk-app] #5166 = #5161 #5165
[mk-proof] #5167 rewrite #5166
[instance] 0x0 #5166
[end-of-instance]
[mk-app] #5168 = #5156 #5165
[mk-proof] #5169 trans #5163 #5167 #5168
[mk-app] #5170 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5171 = #5157 #5170
[mk-proof] #5172 monotonicity #5169 #5171
[mk-app] #5173 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5170
[mk-app] #5174 = #5170 #5173
[mk-proof] #5175 rewrite #5174
[instance] 0x0 #5174
[end-of-instance]
[mk-app] #5176 = #5157 #5173
[mk-proof] #5177 trans #5172 #5175 #5176
[mk-app] #5178 not #1917
[mk-app] #5179 or #5178 #2172 #2353 #5144 #5148 #5165
[mk-app] #5180 or #5178 #5157
[mk-proof] #5181 quant-inst #5180
[mk-app] #5182 or #5178 #5173
[mk-app] #5183 = #5180 #5182
[mk-proof] #5184 monotonicity #5177 #5183
[mk-app] #5185 = #5182 #5179
[mk-proof] #5186 rewrite #5185
[mk-app] #5187 = #5180 #5179
[mk-proof] #5188 trans #5184 #5186 #5187
[mk-proof] #5189 mp #5181 #5188 #5179
[instance] 0x1068e41e8 #5181 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5190 >= #3402 #36
[mk-app] #5191 = #5190 #5190
[mk-proof] #5192 refl #5191
[mk-app] #5193 or #1546 #5190
[mk-proof] #5194 quant-inst #5193
[instance] 0x1068e4268 #5194 ; 3
[assign] #5190 justification -1: p13
[end-of-instance]
[mk-app] #5191 = #3402 #36
[mk-app] #5192 not #5191
[mk-app] #5195 or #5192 #2172
[mk-app] #5196 = #5195 #5195
[mk-proof] #5197 refl #5196
[mk-app] #5198 or #2307 #5192 #2172
[mk-app] #5199 or #2307 #5195
[mk-proof] #5200 quant-inst #5199
[mk-app] #5201 = #5199 #5198
[mk-proof] #5202 rewrite #5201
[mk-proof] #5203 mp #5200 #5202 #5198
[instance] 0x1068e4298 #5200 ; 3
[attach-enode] #5191 3
[mk-app] #5204 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[mk-app] #5196 + #36 #3402 #5120
[mk-app] #5197 = #5196 #36
[inst-discovered] theory-solving 0x0 arith# ; #5196
[mk-app] #5205 = #5196 #5164
[mk-proof] #5206 rewrite #5205
[instance] 0x0 #5205
[end-of-instance]
[mk-app] #5207 = #5164 #36
[mk-app] #5208 = #5197 #5207
[mk-proof] #5209 monotonicity #5206 #5208
[mk-app] #5210 not #237
[mk-app] #5211 or #5210 #5207
[mk-app] #5212 or #5210 #5197
[mk-proof] #5213 quant-inst #5212
[mk-app] #5214 = #5212 #5211
[mk-proof] #5215 monotonicity #5209 #5214
[mk-app] #5216 = #5211 #5211
[mk-proof] #5217 rewrite #5216
[mk-proof] #5218 trans #5215 #5217 #5214
[mk-proof] #5219 mp #5213 #5218 #5211
[instance] 0x1068e42c8 #5213 ; 3
[attach-enode] #5207 3
[mk-app] #5220 >= #5164 #36
[assign] #5207 justification -1: p20
[end-of-instance]
[assign] #5137 clause p490 (not p489)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5138 clause p491 (not p489)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5204) clause (not p499) p498
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p496 (not p500)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5220 clause p501 (not p500)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5221 <= #4347 #36
[mk-app] #5222 >= #4347 #36
[assign] #5221 justification -1: p78
[assign] #5222 justification -1: p78
[assign] #5143 clause p493 (not p496) (not p497)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5149 #5142
[push] 5
[assign] #5142 decision axiom
[new-match] 0x1068e9890 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98c8 #124 #118 #1529 ; #5139
[new-match] 0x1068e98f8 #143 #118 #1529 ; #5139
[mk-app] #5223 + #2347 #5140 #3402
[mk-app] #5224 = #5223 #36
[mk-app] #5225 or #2353 #2172 #5224
[mk-app] #5226 + #2347 #3402 #5140
[inst-discovered] theory-solving 0x0 arith# ; #5223
[mk-app] #5227 = #5223 #5226
[mk-proof] #5228 rewrite #5227
[instance] 0x0 #5227
[end-of-instance]
[mk-app] #5229 = #5226 #36
[mk-app] #5230 = #5224 #5229
[mk-proof] #5231 monotonicity #5228 #5230
[mk-app] #5232 or #2353 #2172 #5229
[mk-app] #5233 = #5225 #5232
[mk-proof] #5234 monotonicity #5231 #5233
[mk-app] #5235 or #2172 #2353 #5229
[inst-discovered] theory-solving 0x0 basic# ; #5232
[mk-app] #5236 = #5232 #5235
[mk-proof] #5237 rewrite #5236
[instance] 0x0 #5236
[end-of-instance]
[mk-app] #5238 = #5225 #5235
[mk-proof] #5239 trans #5234 #5237 #5238
[mk-app] #5240 not #2726
[mk-app] #5241 or #5240 #2172 #2353 #5229
[mk-app] #5242 or #5240 #5225
[mk-proof] #5243 quant-inst #5242
[mk-app] #5244 or #5240 #5235
[mk-app] #5245 = #5242 #5244
[mk-proof] #5246 monotonicity #5239 #5245
[mk-app] #5247 = #5244 #5241
[mk-proof] #5248 rewrite #5247
[mk-app] #5249 = #5242 #5241
[mk-proof] #5250 trans #5246 #5248 #5249
[mk-proof] #5251 mp #5243 #5250 #5241
[instance] 0x1068e9890 #5243 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5252 <= #5226 #36
[mk-app] #5253 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5254 >= #5139 #36
[mk-app] #5255 = #5254 #5254
[mk-proof] #5256 refl #5255
[mk-app] #5257 or #1546 #5254
[mk-proof] #5258 quant-inst #5257
[instance] 0x1068e98c8 #5258 ; 4
[assign] #5254 justification -1: p13
[end-of-instance]
[mk-app] #5255 = #5139 #36
[mk-app] #5256 not #5255
[mk-app] #5259 = #1529 #130
[mk-app] #5260 or #5256 #5259
[mk-app] #5261 = #5260 #5260
[mk-proof] #5262 refl #5261
[mk-app] #5263 or #2307 #5256 #5259
[mk-app] #5264 or #2307 #5260
[mk-proof] #5265 quant-inst #5264
[mk-app] #5266 = #5264 #5263
[mk-proof] #5267 rewrite #5266
[mk-proof] #5268 mp #5265 #5267 #5263
[instance] 0x1068e98f8 #5265 ; 4
[attach-enode] #5255 4
[mk-app] #5269 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5252 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5253 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5220)
[resolve-lit] 0 (not #5252)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5252)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[mk-proof] #5261 hypothesis #5142
[mk-proof] #5262 hypothesis #2294
[mk-proof] #5270 hypothesis #2177
[mk-proof] #5271 unit-resolution #5251 #2731 #5270 #5262 #5229
[mk-app] #5272 not #5229
[mk-app] #5273 or #5272 #5252
[mk-proof] #5274 th-lemma #5273
[mk-proof] #5275 unit-resolution #5274 #5271 #5252
[mk-app] #5276 not #2348
[mk-app] #5277 or #5276 #2136
[mk-proof] #5278 th-lemma #5277
[mk-proof] #5279 unit-resolution #5278 #2186 #2136
[mk-proof] #5280 unit-resolution #5219 #2853 #5207
[mk-app] #5281 not #5207
[mk-app] #5282 or #5281 #5220
[mk-proof] #5283 th-lemma #5282
[mk-proof] #5284 unit-resolution #5283 #5280 #5220
[mk-proof] #5285 th-lemma #5284 #5279 #5275 #5261 #2
[mk-app] #5286 not #5142
[mk-app] #5287 or #5286 #2353 #2172
[mk-proof] #5288 lemma #5285 #5287
[conflict] (not #5142) #2353 #2172
[pop] 1 6
[assign] (not #5142) clause (not p492) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p494 p492 (not p493)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068e9878 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98b0 #124 #118 #1529 ; #5139
[new-match] 0x1068e98e0 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5232
[instance] 0x0 #5236
[end-of-instance]
[instance] 0x1068e9878 #5243 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5257 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5258 = #5254 #5254
[mk-proof] #5264 refl #5258
[mk-app] #5265 or #1546 #5254
[mk-proof] #5263 quant-inst #5265
[instance] 0x1068e98b0 #5263 ; 4
[assign] #5254 justification -1: p13
[end-of-instance]
[mk-app] #5258 = #5260 #5260
[mk-proof] #5264 refl #5258
[mk-app] #5266 or #2307 #5256 #5259
[mk-app] #5267 or #2307 #5260
[mk-proof] #5268 quant-inst #5267
[mk-app] #5253 = #5267 #5266
[mk-proof] #5269 rewrite #5253
[mk-proof] #2189 mp #5268 #5269 #5266
[instance] 0x1068e98e0 #5268 ; 4
[attach-enode] #5255 4
[mk-app] #2190 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5252 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5257 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #2190) clause (not p509) (not p496) (not p497) p492
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p508) p509
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #1555 Seq<Int>!val!0
[mk-app] #1557 $Ref!val!0
[mk-app] #1556 $Ref!val!1
[mk-app] #5258 Ptr32!val!0
[mk-app] #5264 Ptr32!val!1
[mk-app] #2343 Seq<Int>!val!1
[mk-app] #2290 Seq<Int>!val!2
[mk-app] #2300 Seq<Int>!val!3
[mk-app] #2291 Int
[attach-meaning] #2291 arith 7720
[attach-meaning] #176 arith (- 1)
[mk-app] #2292 Ptr32!val!2
[mk-app] #2321 Ptr32!val!3
[attach-meaning] #3722 arith 16
[attach-meaning] #4108 arith (- 4)
[mk-app] #2288 Ptr32!val!4
[attach-meaning] #3161 arith 20
[mk-app] #2315 Ptr32!val!5
[attach-meaning] #4382 arith 24
[mk-app] #2316 Ptr32!val!6
[attach-meaning] #4389 arith 28
[mk-app] #2317 Ptr32!val!7
[attach-meaning] #3291 arith 32
[mk-app] #2193 Ptr32!val!8
[attach-meaning] #3216 arith 36
[mk-app] #2318 Ptr32!val!9
[attach-meaning] #4684 arith 40
[mk-app] #2188 Ptr32!val!10
[attach-meaning] #4840 arith 44
[mk-app] #2344 Ptr32!val!11
[attach-meaning] #4996 arith 48
[mk-app] #2356 Ptr32!val!12
[mk-app] #2192 Int
[attach-meaning] #2192 arith 52
[mk-app] #2339 Ptr32!val!13
[mk-app] #2340 Int
[attach-meaning] #2340 arith 56
[mk-app] #2341 Ptr32!val!14
[mk-app] #2342 Int
[attach-meaning] #2342 arith 60
[mk-app] #2185 Ptr32!val!15
[mk-app] #5289 Int
[attach-meaning] #5289 arith 64
[attach-meaning] #3722 arith 16
[mk-app] #5290 Ptr32!val!16
[mk-app] #5291 Int
[attach-meaning] #5291 arith 68
[attach-meaning] #3632 arith 17
[mk-app] #5292 Ptr32!val!17
[mk-app] #5293 Int
[attach-meaning] #5293 arith 72
[attach-meaning] #3800 arith 18
[mk-app] #5294 Ptr32!val!18
[mk-app] #5295 Int
[attach-meaning] #5295 arith 76
[attach-meaning] #4573 arith 19
[mk-app] #5296 Ptr32!val!19
[mk-app] #5297 Int
[attach-meaning] #5297 arith 80
[attach-meaning] #3161 arith 20
[mk-app] #5298 Ptr32!val!20
[mk-app] #5299 Int
[attach-meaning] #5299 arith 84
[attach-meaning] #4096 arith 21
[mk-app] #5300 Ptr32!val!21
[mk-app] #5301 Int
[attach-meaning] #5301 arith 88
[attach-meaning] #3898 arith 22
[mk-app] #5302 Ptr32!val!22
[mk-app] #5303 Int
[attach-meaning] #5303 arith 92
[attach-meaning] #3432 arith 23
[mk-app] #5304 Ptr32!val!23
[mk-app] #5305 Int
[attach-meaning] #5305 arith 96
[attach-meaning] #4382 arith 24
[mk-app] #5306 Ptr32!val!24
[mk-app] #5307 Int
[attach-meaning] #5307 arith 100
[attach-meaning] #4548 arith 25
[mk-app] #5308 Ptr32!val!25
[mk-app] #5309 Int
[attach-meaning] #5309 arith 104
[attach-meaning] #2916 arith 26
[mk-app] #5310 Ptr32!val!26
[mk-app] #5311 Int
[attach-meaning] #5311 arith 108
[attach-meaning] #3947 arith 27
[mk-app] #5312 Ptr32!val!27
[mk-app] #5313 Int
[attach-meaning] #5313 arith 112
[attach-meaning] #4389 arith 28
[mk-app] #5314 Ptr32!val!28
[mk-app] #5315 Int
[attach-meaning] #5315 arith 116
[attach-meaning] #3887 arith 29
[mk-app] #5316 Ptr32!val!29
[mk-app] #5317 Int
[attach-meaning] #5317 arith 120
[attach-meaning] #3867 arith 30
[mk-app] #5318 Ptr32!val!30
[mk-app] #5319 Int
[attach-meaning] #5319 arith 124
[attach-meaning] #3730 arith 31
[mk-app] #5320 Ptr32!val!31
[mk-app] #5321 Int
[attach-meaning] #5321 arith 128
[attach-meaning] #3291 arith 32
[mk-app] #5322 Ptr32!val!32
[mk-app] #5323 Int
[attach-meaning] #5323 arith 132
[attach-meaning] #4187 arith 33
[mk-app] #5324 Ptr32!val!33
[mk-app] #5325 Int
[attach-meaning] #5325 arith 136
[attach-meaning] #3677 arith 34
[mk-app] #5326 Ptr32!val!34
[mk-app] #5327 Int
[attach-meaning] #5327 arith 140
[attach-meaning] #3981 arith 35
[mk-app] #5328 Ptr32!val!35
[mk-app] #5329 Int
[attach-meaning] #5329 arith 144
[attach-meaning] #3216 arith 36
[mk-app] #5330 Ptr32!val!36
[mk-app] #5331 Int
[attach-meaning] #5331 arith 148
[attach-meaning] #4506 arith 37
[mk-app] #5332 Ptr32!val!37
[mk-app] #5333 Int
[attach-meaning] #5333 arith 152
[attach-meaning] #4606 arith 38
[mk-app] #5334 Ptr32!val!38
[mk-app] #5335 Int
[attach-meaning] #5335 arith 156
[attach-meaning] #4645 arith 39
[mk-app] #5336 Ptr32!val!39
[mk-app] #5337 Int
[attach-meaning] #5337 arith 160
[attach-meaning] #4684 arith 40
[mk-app] #5338 Ptr32!val!40
[mk-app] #5339 Int
[attach-meaning] #5339 arith 164
[attach-meaning] #4723 arith 41
[mk-app] #5340 Ptr32!val!41
[mk-app] #5341 Int
[attach-meaning] #5341 arith 168
[attach-meaning] #4762 arith 42
[mk-app] #5342 Ptr32!val!42
[mk-app] #5343 Int
[attach-meaning] #5343 arith 172
[attach-meaning] #4801 arith 43
[mk-app] #5344 Ptr32!val!43
[mk-app] #5345 Int
[attach-meaning] #5345 arith 176
[attach-meaning] #4840 arith 44
[mk-app] #5346 Ptr32!val!44
[mk-app] #5347 Int
[attach-meaning] #5347 arith 180
[attach-meaning] #4879 arith 45
[mk-app] #5348 Ptr32!val!45
[mk-app] #5349 Int
[attach-meaning] #5349 arith 184
[attach-meaning] #4918 arith 46
[mk-app] #5350 Ptr32!val!46
[mk-app] #5351 Int
[attach-meaning] #5351 arith 188
[attach-meaning] #4957 arith 47
[mk-app] #5352 Ptr32!val!47
[mk-app] #5353 Int
[attach-meaning] #5353 arith 192
[attach-meaning] #4996 arith 48
[mk-app] #5354 Ptr32!val!48
[mk-app] #5355 Int
[attach-meaning] #5355 arith 196
[attach-meaning] #5035 arith 49
[mk-app] #5356 Ptr32!val!49
[mk-app] #5357 Int
[attach-meaning] #5357 arith 200
[attach-meaning] #5074 arith 50
[mk-app] #5358 Ptr32!val!50
[mk-app] #5359 Ptr32!val!51
[mk-app] #5360 Int
[attach-meaning] #5360 arith 204
[mk-app] #5361 Int
[attach-meaning] #5361 arith 7721
[attach-meaning] #3722 arith 16
[attach-meaning] #3632 arith 17
[attach-meaning] #3800 arith 18
[attach-meaning] #4573 arith 19
[attach-meaning] #3161 arith 20
[attach-meaning] #4096 arith 21
[attach-meaning] #3898 arith 22
[attach-meaning] #3432 arith 23
[attach-meaning] #4382 arith 24
[attach-meaning] #4548 arith 25
[attach-meaning] #2916 arith 26
[attach-meaning] #3947 arith 27
[attach-meaning] #4389 arith 28
[attach-meaning] #3887 arith 29
[attach-meaning] #3867 arith 30
[attach-meaning] #3730 arith 31
[attach-meaning] #3291 arith 32
[attach-meaning] #4187 arith 33
[attach-meaning] #3677 arith 34
[attach-meaning] #3981 arith 35
[attach-meaning] #3216 arith 36
[attach-meaning] #4506 arith 37
[attach-meaning] #4606 arith 38
[attach-meaning] #4645 arith 39
[attach-meaning] #4684 arith 40
[attach-meaning] #4723 arith 41
[attach-meaning] #4762 arith 42
[attach-meaning] #4801 arith 43
[attach-meaning] #4840 arith 44
[attach-meaning] #4879 arith 45
[attach-meaning] #4918 arith 46
[attach-meaning] #4957 arith 47
[attach-meaning] #4996 arith 48
[attach-meaning] #5035 arith 49
[attach-meaning] #5074 arith 50
[mk-app] #5362 Int
[attach-meaning] #5362 arith 51
[attach-meaning] #2192 arith 52
[mk-app] #5363 Int
[attach-meaning] #5363 arith 53
[mk-app] #5364 Int
[attach-meaning] #5364 arith 54
[mk-app] #5365 Int
[attach-meaning] #5365 arith 55
[attach-meaning] #2340 arith 56
[mk-app] #5366 Int
[attach-meaning] #5366 arith 57
[mk-app] #5367 Int
[attach-meaning] #5367 arith 58
[mk-app] #5368 Int
[attach-meaning] #5368 arith 59
[attach-meaning] #2342 arith 60
[mk-app] #5369 Int
[attach-meaning] #5369 arith 61
[mk-app] #5370 Int
[attach-meaning] #5370 arith 62
[mk-app] #5371 Int
[attach-meaning] #5371 arith 63
[attach-meaning] #5289 arith 64
[mk-app] #5372 Int
[attach-meaning] #5372 arith 65
[mk-app] #5373 Int
[attach-meaning] #5373 arith 66
[mk-app] #5374 Int
[attach-meaning] #5374 arith 67
[attach-meaning] #5291 arith 68
[mk-app] #5375 Int
[attach-meaning] #5375 arith 69
[mk-app] #5376 Int
[attach-meaning] #5376 arith 70
[mk-app] #5377 Int
[attach-meaning] #5377 arith 71
[attach-meaning] #5293 arith 72
[mk-app] #5378 Int
[attach-meaning] #5378 arith 73
[mk-app] #5379 Int
[attach-meaning] #5379 arith 74
[mk-app] #5380 Int
[attach-meaning] #5380 arith 75
[attach-meaning] #5295 arith 76
[mk-app] #5381 Int
[attach-meaning] #5381 arith 77
[mk-app] #5382 Int
[attach-meaning] #5382 arith 78
[mk-app] #5383 Int
[attach-meaning] #5383 arith 79
[attach-meaning] #5297 arith 80
[mk-app] #5384 Int
[attach-meaning] #5384 arith 81
[mk-app] #5385 Int
[attach-meaning] #5385 arith 82
[mk-app] #5386 Int
[attach-meaning] #5386 arith 83
[attach-meaning] #5299 arith 84
[mk-app] #5387 Int
[attach-meaning] #5387 arith 85
[mk-app] #5388 Int
[attach-meaning] #5388 arith 86
[mk-app] #5389 Int
[attach-meaning] #5389 arith 87
[attach-meaning] #5301 arith 88
[mk-app] #5390 Int
[attach-meaning] #5390 arith 89
[mk-app] #5391 Int
[attach-meaning] #5391 arith 90
[mk-app] #5392 Int
[attach-meaning] #5392 arith 91
[attach-meaning] #5303 arith 92
[mk-app] #5393 Int
[attach-meaning] #5393 arith 93
[mk-app] #5394 Int
[attach-meaning] #5394 arith 94
[mk-app] #5395 Int
[attach-meaning] #5395 arith 95
[attach-meaning] #5305 arith 96
[mk-app] #5396 Int
[attach-meaning] #5396 arith 97
[mk-app] #5397 Int
[attach-meaning] #5397 arith 98
[mk-app] #5398 Int
[attach-meaning] #5398 arith 99
[attach-meaning] #5307 arith 100
[mk-app] #5399 Int
[attach-meaning] #5399 arith 101
[mk-app] #5400 Int
[attach-meaning] #5400 arith 102
[mk-app] #5401 Int
[attach-meaning] #5401 arith 103
[attach-meaning] #5309 arith 104
[mk-app] #5402 Int
[attach-meaning] #5402 arith 105
[mk-app] #5403 Int
[attach-meaning] #5403 arith 106
[mk-app] #5404 Int
[attach-meaning] #5404 arith 107
[attach-meaning] #5311 arith 108
[mk-app] #5405 Int
[attach-meaning] #5405 arith 109
[mk-app] #5406 Int
[attach-meaning] #5406 arith 110
[mk-app] #5407 Int
[attach-meaning] #5407 arith 111
[attach-meaning] #5313 arith 112
[mk-app] #5408 Int
[attach-meaning] #5408 arith 113
[mk-app] #5409 Int
[attach-meaning] #5409 arith 114
[mk-app] #5410 Int
[attach-meaning] #5410 arith 115
[attach-meaning] #5315 arith 116
[mk-app] #5411 Int
[attach-meaning] #5411 arith 117
[mk-app] #5412 Int
[attach-meaning] #5412 arith 118
[mk-app] #5413 Int
[attach-meaning] #5413 arith 119
[attach-meaning] #5317 arith 120
[mk-app] #5414 Int
[attach-meaning] #5414 arith 121
[mk-app] #5415 Int
[attach-meaning] #5415 arith 122
[mk-app] #5416 Int
[attach-meaning] #5416 arith 123
[attach-meaning] #5319 arith 124
[mk-app] #5417 Int
[attach-meaning] #5417 arith 125
[mk-app] #5418 Int
[attach-meaning] #5418 arith 126
[mk-app] #5419 Int
[attach-meaning] #5419 arith 127
[attach-meaning] #5321 arith 128
[mk-app] #5420 Int
[attach-meaning] #5420 arith 129
[mk-app] #5421 Int
[attach-meaning] #5421 arith 130
[mk-app] #5422 Int
[attach-meaning] #5422 arith 131
[attach-meaning] #5323 arith 132
[mk-app] #5423 Int
[attach-meaning] #5423 arith 133
[mk-app] #5424 Int
[attach-meaning] #5424 arith 134
[mk-app] #5425 Int
[attach-meaning] #5425 arith 135
[attach-meaning] #5325 arith 136
[mk-app] #5426 Int
[attach-meaning] #5426 arith 137
[mk-app] #5427 Int
[attach-meaning] #5427 arith 138
[mk-app] #5428 Int
[attach-meaning] #5428 arith 139
[attach-meaning] #5327 arith 140
[mk-app] #5429 Int
[attach-meaning] #5429 arith 141
[mk-app] #5430 Int
[attach-meaning] #5430 arith 142
[mk-app] #5431 Int
[attach-meaning] #5431 arith 143
[pop] 2 5
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 3
[push] 2
[mk-app] #4199 address<Int> #1558
[mk-app] #4205 mod #4199 #1503
[mk-app] #4210 = #4205 #36
[mk-app] #4158 not #4210
[mk-proof] #4159 asserted #4158
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[begin-check] 3
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4210 #2
[mk-proof] #4161 iff-false #4159 #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4210 #2
[mk-proof] #4161 iff-false #4159 #4160
[mk-app] #4160 ~ #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 rewrite #4160
[mk-proof] #4165 mp #4159 #4161 #4158
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[mk-app] #4160 = #4158 #4158
[mk-proof] #4161 refl #4160
[attach-enode] #4199 0
[attach-enode] #1503 0
[attach-enode] #4205 0
[attach-enode] #4210 0
[mk-app] #4160 <= #4205 #36
[mk-app] #4161 >= #4205 #36
[assign] (not #4210) justification -1: 
[mk-app] #4165 div #4199 #1503
[mk-app] #4171 < #1503 #36
[mk-app] #3234 - #36 #1503
[mk-app] #4107 if #4171 #3234 #1503
[mk-app] #3153 - #4107 #151
[inst-discovered] theory-solving 0x0 arith# ; #4171
[mk-app] #3101 = #4171 #3233
[mk-proof] #4063 rewrite #3101
[instance] 0x0 #3101
[end-of-instance]
[mk-app] #3021 = #4171 #2
[mk-proof] #3022 trans #4063 #3190 #3021
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3234
[mk-app] #4490 = #3234 #3205
[mk-proof] #3018 rewrite #4490
[instance] 0x0 #4490
[end-of-instance]
[mk-app] #3019 = #3234 #4108
[mk-proof] #3020 trans #3018 #3152 #3019
[mk-app] #3023 if #2 #4108 #1503
[mk-app] #3027 = #4107 #3023
[mk-proof] #3028 monotonicity #3022 #3020 #3027
[inst-discovered] theory-solving 0x0 arith# ; #3023
[mk-app] #3029 = #3023 #1503
[mk-proof] #3030 rewrite #3029
[instance] 0x0 #3029
[end-of-instance]
[mk-app] #3383 = #4107 #1503
[mk-proof] #3388 trans #3028 #3030 #3383
[mk-app] #3390 - #1503 #151
[mk-app] #3812 = #3153 #3390
[mk-proof] #3813 monotonicity #3388 #3812
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3390
[mk-app] #4332 = #3390 #4048
[mk-proof] #4333 rewrite #4332
[instance] 0x0 #4332
[end-of-instance]
[mk-app] #4325 = #3153 #4048
[mk-proof] #4326 trans #3813 #4333 #4325
[mk-app] #4330 = #3153 #4037
[mk-proof] #4331 trans #4326 #4000 #4330
[mk-app] #4334 = #1503 #36
[mk-app] #4336 * #1503 #4165
[mk-app] #4337 + #4336 #4205
[mk-app] #4338 = #4337 #4199
[mk-app] #4339 <= #4205 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4334
[mk-app] #4171 = #4334 #2
[mk-proof] #3101 rewrite #4171
[instance] 0x0 #4171
[end-of-instance]
[attach-enode] #4165 0
[attach-enode] #4336 0
[attach-enode] #4337 0
[attach-enode] #4338 0
[mk-app] #4063 or #4334 #4338
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4063
[assign] #4338 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4334
[mk-app] #4171 = #4334 #2
[mk-proof] #3101 rewrite #4171
[instance] 0x0 #4171
[end-of-instance]
[attach-enode] #4161 0
[mk-app] #4063 or #4334 #4161
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4063
[assign] #4161 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4334
[mk-app] #4171 = #4334 #2
[mk-proof] #3101 rewrite #4171
[instance] 0x0 #4171
[end-of-instance]
[attach-enode] #4339 0
[mk-app] #4063 or #4334 #4339
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4063
[assign] #4339 justification -1: true
[end-of-instance]
[mk-app] #4063 = #4210 #2
[mk-proof] #3021 iff-false #4159 #4063
[assign] (not #4160) clause (not p81) p80 (not p82)
  (not (<= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 
  (= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int) 
  (not (>= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 

[new-match] 0x106809eb0 #1522 #1506 #36 #1545 ; #4199 (#1558 #1559)
[mk-app] #5256 * #176 #4105
[mk-app] #5260 + #3235 #5256
[mk-app] #5254 = #5260 #1503
[mk-app] #4334 = #5254 #5254
[mk-proof] #4171 refl #4334
[mk-app] #3101 not #1522
[mk-app] #5192 or #3101 #5254
[mk-proof] #5195 quant-inst #5192
[instance] 0x106809eb0 #5195 ; 1
[attach-enode] #3235 1
[attach-enode] #4105 1
[attach-enode] #176 1
[attach-enode] #5256 1
[attach-enode] #5260 1
[attach-enode] #5254 1
[mk-app] #5190 <= #5260 #1503
[mk-app] #5157 >= #5260 #1503
[assign] #5254 justification -1: p51
[end-of-instance]
[assign] #5190 clause p86 (not p85)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[assign] #5157 clause p87 (not p85)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[mk-app] #4334 = #4105 #4337
[attach-meaning] #176 arith (- 1)
[mk-app] #4171 * #176 #4337
[mk-app] #5146 + #4105 #4171
[mk-app] #5111 <= #5146 #36
[mk-app] #5112 >= #5146 #36
[assign] #4334 justification -1: p83 p55
[attach-enode] #4334 0
[attach-enode] #4171 0
[attach-enode] #5146 0
[assign] #5111 justification -1: p88
[assign] #5112 justification -1: p88
[new-match] 0x1068171a0 #1522 #1506 #151 #1545 ; #3235 (#1574 #2367)
[mk-app] #5113 * #176 #4087
[mk-app] #5099 + #4086 #5113
[mk-app] #5100 = #5099 #1503
[mk-app] #5101 = #5100 #5100
[mk-proof] #5093 refl #5101
[mk-app] #5073 or #3101 #5100
[mk-proof] #5060 quant-inst #5073
[instance] 0x1068171a0 #5060 ; 2
[attach-enode] #3162 2
[attach-enode] #4086 2
[attach-enode] #4087 2
[attach-enode] #5113 2
[attach-enode] #5099 2
[attach-enode] #5100 2
[mk-app] #5061 <= #5099 #1503
[mk-app] #5062 >= #5099 #1503
[assign] #5100 justification -1: p51
[end-of-instance]
[assign] #5061 clause p92 (not p91)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[assign] #5062 clause p93 (not p91)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[mk-app] #5101 = #3235 #4087
[attach-meaning] #176 arith (- 1)
[mk-app] #5093 + #3235 #5113
[mk-app] #5054 <= #5093 #36
[mk-app] #5034 >= #5093 #36
[assign] #5101 justification -1: p58
[attach-enode] #5101 0
[attach-enode] #5093 0
[assign] #5054 justification -1: p94
[assign] #5034 justification -1: p94
[new-match] 0x106817a08 #1495 #1483 #151 #1545 ; #3162 (#2367 #2367)
[mk-app] #5021 = #3162 #2941
[mk-app] #5022 = #3162 #3955
[mk-app] #5023 = #5021 #5022
[mk-proof] #5015 monotonicity #3943 #5023
[mk-app] #4995 or #1563 #5022
[mk-app] #4982 or #1563 #5021
[mk-proof] #4983 quant-inst #4982
[mk-app] #4984 = #4982 #4995
[mk-proof] #4976 monotonicity #5015 #4984
[mk-app] #4956 = #4995 #4995
[mk-proof] #4943 rewrite #4956
[mk-proof] #4944 trans #4976 #4943 #4984
[mk-proof] #4945 mp #4983 #4944 #4995
[instance] 0x106817a08 #4983 ; 3
[attach-enode] #3950 3
[attach-enode] #3955 3
[attach-enode] #5022 3
[assign] #5022 justification -1: p50
[end-of-instance]
[eq-expl] #3950 root
[new-match] 0x106817cc8 #1477 #1476 #3950 #1545 ; #3955
[eq-expl] #3162 lit #5022 ; #3955
[eq-expl] #3955 root
[new-match] 0x106817d00 #1522 #1506 #3950 #1545 ; #4086 (#3162 #3955)
[mk-app] #4937 = #3384 #3950
[mk-app] #4917 = #4937 #4937
[mk-proof] #4904 refl #4917
[mk-app] #4905 or #1576 #4937
[mk-proof] #4906 quant-inst #4905
[instance] 0x106817cc8 #4906 ; 4
[attach-enode] #3384 4
[attach-enode] #4937 4
[assign] #4937 justification -1: p49
[end-of-instance]
[mk-app] #4917 * #176 #3391
[mk-app] #4904 + #3387 #4917
[mk-app] #4898 = #4904 #1503
[mk-app] #4878 = #4898 #4898
[mk-proof] #4865 refl #4878
[mk-app] #4866 or #3101 #4898
[mk-proof] #4867 quant-inst #4866
[instance] 0x106817d00 #4867 ; 4
[attach-enode] #3386 4
[attach-enode] #3387 4
[attach-enode] #3391 4
[attach-enode] #4917 4
[attach-enode] #4904 4
[attach-enode] #4898 4
[mk-app] #4859 <= #4904 #1503
[mk-app] #4839 >= #4904 #1503
[assign] #4898 justification -1: p51
[end-of-instance]
[assign] #4859 clause p100 (not p99)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[assign] #4839 clause p101 (not p99)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[mk-app] #4878 = #3391 #4086
[attach-meaning] #176 arith (- 1)
[mk-app] #4865 * #176 #4086
[mk-app] #4826 + #3391 #4865
[mk-app] #4827 <= #4826 #36
[mk-app] #4828 >= #4826 #36
[assign] #4878 justification -1: p97
[attach-enode] #4878 0
[attach-enode] #4865 0
[attach-enode] #4826 0
[assign] #4827 justification -1: p102
[assign] #4828 justification -1: p102
[new-match] 0x106818748 #1495 #1483 #3950 #1545 ; #3386 (#3955 #3955)
[mk-app] #4820 = #3386 #4318
[mk-app] #4800 = #3386 #4322
[mk-app] #4787 = #4820 #4800
[mk-proof] #4788 monotonicity #4324 #4787
[mk-app] #4789 or #1563 #4800
[mk-app] #4781 or #1563 #4820
[mk-proof] #4761 quant-inst #4781
[mk-app] #4748 = #4781 #4789
[mk-proof] #4749 monotonicity #4788 #4748
[mk-app] #4750 = #4789 #4789
[mk-proof] #4742 rewrite #4750
[mk-proof] #4722 trans #4749 #4742 #4748
[mk-proof] #4709 mp #4761 #4722 #4789
[instance] 0x106818748 #4761 ; 5
[attach-enode] #4037 5
[attach-enode] #4322 5
[attach-enode] #4800 5
[assign] #4800 justification -1: p50
[end-of-instance]
[eq-expl] #4037 root
[new-match] 0x1068189e8 #1477 #1476 #4037 #1545 ; #4322
[eq-expl] #3386 lit #4800 ; #4322
[eq-expl] #4322 root
[new-match] 0x106818a20 #1522 #1506 #4037 #1545 ; #3387 (#3386 #4322)
[mk-app] #4710 = #4342 #4037
[mk-app] #4711 = #4710 #4710
[mk-proof] #4703 refl #4711
[mk-app] #4683 or #1576 #4710
[mk-proof] #4670 quant-inst #4683
[instance] 0x1068189e8 #4670 ; 6
[attach-enode] #4342 6
[attach-enode] #4710 6
[assign] #4710 justification -1: p49
[end-of-instance]
[mk-app] #4711 * #176 #3488
[mk-app] #4703 + #4345 #4711
[mk-app] #4671 = #4703 #1503
[mk-app] #4672 + #4711 #4345
[inst-discovered] theory-solving 0x0 arith# ; #4703
[mk-app] #4664 = #4703 #4672
[mk-proof] #4644 rewrite #4664
[instance] 0x0 #4664
[end-of-instance]
[mk-app] #4631 = #4672 #1503
[mk-app] #4632 = #4671 #4631
[mk-proof] #4633 monotonicity #4644 #4632
[attach-meaning] #176 arith (- 1)
[mk-app] #4625 * #176 #4345
[mk-app] #4605 + #3488 #4625
[attach-meaning] #4108 arith (- 4)
[mk-app] #4584 = #4605 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4631
[mk-app] #4585 = #4631 #4584
[mk-proof] #4486 rewrite #4585
[instance] 0x0 #4585
[end-of-instance]
[mk-app] #4493 = #4671 #4584
[mk-proof] #3664 trans #4633 #4486 #4493
[mk-app] #4126 or #3101 #4584
[mk-app] #4127 or #3101 #4671
[mk-proof] #4128 quant-inst #4127
[mk-app] #4115 = #4127 #4126
[mk-proof] #3215 monotonicity #3664 #4115
[mk-app] #3201 = #4126 #4126
[mk-proof] #3202 rewrite #3201
[mk-proof] #3203 trans #3215 #3202 #4115
[mk-proof] #3193 mp #4128 #3203 #4126
[instance] 0x106818a20 #4128 ; 6
[attach-enode] #3488 6
[attach-enode] #4344 6
[attach-enode] #4345 6
[attach-enode] #4625 6
[attach-enode] #4605 6
[attach-enode] #4108 6
[attach-enode] #4584 6
[mk-app] #3979 <= #4605 #4108
[mk-app] #2992 >= #4605 #4108
[assign] #4584 justification -1: p51
[end-of-instance]
[assign] #3979 clause p108 (not p107)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[assign] #2992 clause p109 (not p107)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[mk-app] #2993 = #3387 #3488
[attach-meaning] #176 arith (- 1)
[mk-app] #2994 + #3387 #4711
[mk-app] #3603 <= #2994 #36
[mk-app] #3676 >= #2994 #36
[assign] #2993 justification -1: p105
[attach-enode] #2993 0
[attach-enode] #4711 0
[attach-enode] #2994 0
[assign] #3603 justification -1: p110
[assign] #3676 justification -1: p110
[new-match] 0x10681c558 #1495 #1483 #4037 #1545 ; #4344 (#4322 #4322)
[mk-app] #3874 = #4344 #4442
[mk-app] #3875 = #4344 #4446
[mk-app] #3876 = #3874 #3875
[mk-proof] #4212 monotonicity #4545 #3876
[mk-app] #4186 or #1563 #3875
[mk-app] #3320 or #1563 #3874
[mk-proof] #3321 quant-inst #3320
[mk-app] #3319 = #3320 #4186
[mk-proof] #3313 monotonicity #4212 #3319
[mk-app] #3290 = #4186 #4186
[mk-proof] #4043 rewrite #3290
[mk-proof] #4044 trans #3313 #4043 #3319
[mk-proof] #4045 mp #3321 #4044 #4186
[instance] 0x10681c558 #3321 ; 7
[attach-enode] #4446 7
[attach-enode] #3875 7
[assign] #3875 justification -1: p50
[end-of-instance]
[eq-expl] #1503 root
[new-match] 0x10681c768 #1477 #1476 #1503 #1545 ; #4446
[eq-expl] #4344 lit #3875 ; #4446
[eq-expl] #4446 root
[new-match] 0x10681c7a0 #1522 #1506 #1503 #1545 ; #4345 (#4344 #4446)
[mk-app] #4035 = #2974 #1503
[mk-app] #3729 = #4035 #4035
[mk-proof] #3607 refl #3729
[mk-app] #3608 or #1576 #4035
[mk-proof] #3609 quant-inst #3608
[instance] 0x10681c768 #3609 ; 8
[attach-enode] #2974 8
[attach-enode] #4035 8
[assign] #4035 justification -1: p49
[end-of-instance]
[mk-app] #3729 * #176 #3710
[mk-app] #3607 + #3707 #3729
[mk-app] #4434 = #3607 #1503
[mk-app] #3487 = #4434 #4434
[mk-proof] #3474 refl #3487
[mk-app] #3475 or #3101 #4434
[mk-proof] #3476 quant-inst #3475
[instance] 0x10681c7a0 #3476 ; 8
[attach-enode] #2976 8
[attach-enode] #3707 8
[attach-enode] #3710 8
[attach-enode] #3729 8
[attach-enode] #3607 8
[attach-enode] #4434 8
[mk-app] #3467 <= #3607 #1503
[mk-app] #3886 >= #3607 #1503
[assign] #4434 justification -1: p51
[end-of-instance]
[assign] #3467 clause p116 (not p115)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[assign] #3886 clause p117 (not p115)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[mk-app] #3487 = #3710 #4345
[attach-meaning] #176 arith (- 1)
[mk-app] #3474 + #3710 #4625
[mk-app] #3792 <= #3474 #36
[mk-app] #3793 >= #3474 #36
[assign] #3487 justification -1: p113
[attach-enode] #3487 0
[attach-enode] #3474 0
[assign] #3792 justification -1: p118
[assign] #3793 justification -1: p118
[new-match] 0x10681d160 #1495 #1483 #1503 #1545 ; #2976 (#4446 #4446)
[mk-app] #3794 = #2976 #4502
[mk-app] #4410 = #2976 #3398
[mk-app] #4388 = #3794 #4410
[mk-proof] #3586 monotonicity #3400 #4388
[mk-app] #3587 or #1563 #4410
[mk-app] #3588 or #1563 #3794
[mk-proof] #3582 quant-inst #3588
[mk-app] #3946 = #3588 #3587
[mk-proof] #3930 monotonicity #3586 #3946
[mk-app] #3931 = #3587 #3587
[mk-proof] #3932 rewrite #3931
[mk-proof] #3770 trans #3930 #3932 #3946
[mk-proof] #2915 mp #3582 #3770 #3587
[instance] 0x10681d160 #3582 ; 9
[attach-enode] #3395 9
[attach-enode] #3398 9
[attach-enode] #4410 9
[assign] #4410 justification -1: p50
[end-of-instance]
[eq-expl] #3395 root
[new-match] 0x10681d400 #1477 #1476 #3395 #1545 ; #3398
[eq-expl] #2976 lit #4410 ; #3398
[eq-expl] #3398 root
[new-match] 0x10681d438 #1522 #1506 #3395 #1545 ; #3707 (#2976 #3398)
[mk-app] #4308 = #3414 #3395
[mk-app] #4309 = #4308 #4308
[mk-proof] #4311 refl #4309
[mk-app] #4257 or #1576 #4308
[mk-proof] #4485 quant-inst #4257
[instance] 0x10681d400 #4485 ; 10
[attach-enode] #3414 10
[attach-enode] #4308 10
[assign] #4308 justification -1: p49
[end-of-instance]
[mk-app] #4309 * #176 #3848
[mk-app] #4311 + #3419 #4309
[mk-app] #3904 = #4311 #1503
[mk-app] #3905 = #3904 #3904
[mk-proof] #3906 refl #3905
[mk-app] #3551 or #3101 #3904
[mk-proof] #4380 quant-inst #3551
[instance] 0x10681d438 #4380 ; 10
[attach-enode] #3418 10
[attach-enode] #3419 10
[attach-enode] #3848 10
[attach-enode] #4309 10
[attach-enode] #4311 10
[attach-enode] #3904 10
[mk-app] #4365 <= #4311 #1503
[mk-app] #4366 >= #4311 #1503
[assign] #3904 justification -1: p51
[end-of-instance]
[assign] #4365 clause p124 (not p123)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[assign] #4366 clause p125 (not p123)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[mk-app] #3905 = #3707 #3848
[attach-meaning] #176 arith (- 1)
[mk-app] #3906 + #3707 #4309
[mk-app] #4367 <= #3906 #36
[mk-app] #3857 >= #3906 #36
[assign] #3905 justification -1: p121
[attach-enode] #3905 0
[attach-enode] #3906 0
[assign] #4367 justification -1: p126
[assign] #3857 justification -1: p126
[new-match] 0x106822a08 #1495 #1483 #3395 #1545 ; #3418 (#3398 #3398)
[mk-app] #3431 = #3418 #4360
[mk-app] #4470 = #3418 #2979
[mk-app] #4471 = #3431 #4470
[mk-proof] #4546 monotonicity #2981 #4471
[mk-app] #4463 or #1563 #4470
[mk-app] #3897 or #1563 #3431
[mk-proof] #3527 quant-inst #3897
[mk-app] #3528 = #3897 #4463
[mk-proof] #3529 monotonicity #4546 #3528
[mk-app] #3521 = #4463 #4463
[mk-proof] #4095 rewrite #3521
[mk-proof] #4077 trans #3529 #4095 #3528
[mk-proof] #4078 mp #3527 #4077 #4463
[instance] 0x106822a08 #3527 ; 11
[attach-enode] #4579 11
[attach-enode] #2979 11
[attach-enode] #4470 11
[assign] #4470 justification -1: p50
[end-of-instance]
[eq-expl] #4579 root
[new-match] 0x106822ca8 #1477 #1476 #4579 #1545 ; #2979
[eq-expl] #3418 lit #4470 ; #2979
[eq-expl] #2979 root
[new-match] 0x106822ce0 #1522 #1506 #4579 #1545 ; #3419 (#3418 #2979)
[mk-app] #4079 = #3228 #4579
[mk-app] #3746 = #4079 #4079
[mk-proof] #3160 refl #3746
[mk-app] #3141 or #1576 #4079
[mk-proof] #3142 quant-inst #3141
[instance] 0x106822ca8 #3142 ; 12
[attach-enode] #3228 12
[attach-enode] #4079 12
[assign] #4079 justification -1: p49
[end-of-instance]
[mk-app] #3746 * #176 #3237
[mk-app] #3160 + #3231 #3746
[mk-app] #3144 = #3160 #1503
[mk-app] #3134 = #3144 #3144
[mk-proof] #4572 refl #3134
[mk-app] #4298 or #3101 #3144
[mk-proof] #4299 quant-inst #4298
[instance] 0x106822ce0 #4299 ; 12
[attach-enode] #3230 12
[attach-enode] #3231 12
[attach-enode] #3237 12
[attach-enode] #3746 12
[attach-enode] #3160 12
[attach-enode] #3144 12
[mk-app] #4300 <= #3160 #1503
[mk-app] #4290 >= #3160 #1503
[assign] #3144 justification -1: p51
[end-of-instance]
[assign] #4300 clause p132 (not p131)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[assign] #4290 clause p133 (not p131)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[mk-app] #3134 = #3237 #3419
[attach-meaning] #176 arith (- 1)
[mk-app] #4572 * #176 #3419
[mk-app] #3799 + #3237 #4572
[mk-app] #3371 <= #3799 #36
[mk-app] #3372 >= #3799 #36
[assign] #3134 justification -1: p129
[attach-enode] #3134 0
[attach-enode] #4572 0
[attach-enode] #3799 0
[assign] #3371 justification -1: p134
[assign] #3372 justification -1: p134
[new-match] 0x106823728 #1495 #1483 #4579 #1545 ; #3230 (#2979 #2979)
[mk-app] #3373 = #3230 #3758
[mk-app] #4532 = #3230 #4131
[mk-app] #3625 = #3373 #4532
[mk-proof] #4010 monotonicity #4133 #3625
[mk-app] #4012 or #1563 #4532
[mk-app] #4013 or #1563 #3373
[mk-proof] #4003 quant-inst #4013
[mk-app] #3721 = #4013 #4012
[mk-proof] #3016 monotonicity #4010 #3721
[mk-app] #3017 = #4012 #4012
[mk-proof] #3031 rewrite #3017
[mk-proof] #3010 trans #3016 #3031 #3721
[mk-proof] #3571 mp #4003 #3010 #4012
[instance] 0x106823728 #4003 ; 13
[attach-enode] #3760 13
[attach-enode] #4131 13
[attach-enode] #4532 13
[assign] #4532 justification -1: p50
[end-of-instance]
[eq-expl] #3760 root
[new-match] 0x1068239c8 #1477 #1476 #3760 #1545 ; #4131
[eq-expl] #3230 lit #4532 ; #4131
[eq-expl] #4131 root
[new-match] 0x106823a00 #1522 #1506 #3760 #1545 ; #3231 (#3230 #4131)
[mk-app] #4501 = #4147 #3760
[mk-app] #3555 = #4501 #4501
[mk-proof] #3556 refl #3555
[mk-app] #3639 or #1576 #4501
[mk-proof] #2953 quant-inst #3639
[instance] 0x1068239c8 #2953 ; 14
[attach-enode] #4147 14
[attach-enode] #4501 14
[assign] #4501 justification -1: p49
[end-of-instance]
[mk-app] #3555 * #176 #4154
[mk-app] #3556 + #4151 #3555
[mk-app] #4242 = #3556 #1503
[mk-app] #4243 = #4242 #4242
[mk-proof] #4244 refl #4243
[mk-app] #4234 or #3101 #4242
[mk-proof] #3784 quant-inst #4234
[instance] 0x106823a00 #3784 ; 14
[attach-enode] #4149 14
[attach-enode] #4151 14
[attach-enode] #4154 14
[attach-enode] #3555 14
[attach-enode] #3556 14
[attach-enode] #4242 14
[mk-app] #3354 <= #3556 #1503
[mk-app] #3355 >= #3556 #1503
[assign] #4242 justification -1: p51
[end-of-instance]
[assign] #3354 clause p140 (not p139)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[assign] #3355 clause p141 (not p139)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[mk-app] #4243 = #3231 #4154
[attach-meaning] #176 arith (- 1)
[mk-app] #4244 + #3231 #3555
[mk-app] #3356 <= #4244 #36
[mk-app] #3345 >= #4244 #36
[assign] #4243 justification -1: p137
[attach-enode] #4243 0
[attach-enode] #4244 0
[assign] #3356 justification -1: p142
[assign] #3345 justification -1: p142
[new-match] 0x1068243c0 #1495 #1483 #3760 #1545 ; #4149 (#4131 #4131)
[mk-app] #4073 = #4149 #3956
[mk-app] #4058 = #4149 #4562
[mk-app] #4059 = #4073 #4058
[mk-proof] #4060 monotonicity #3249 #4059
[mk-app] #4052 or #1563 #4058
[mk-app] #3106 or #1563 #4073
[mk-proof] #3090 quant-inst #3106
[mk-app] #3091 = #3106 #4052
[mk-proof] #3092 monotonicity #4060 #3091
[mk-app] #3084 = #4052 #4052
[mk-proof] #3694 rewrite #3084
[mk-proof] #3619 trans #3092 #3694 #3091
[mk-proof] #3620 mp #3090 #3619 #4052
[instance] 0x1068243c0 #3090 ; 15
[attach-enode] #3958 15
[attach-enode] #4562 15
[attach-enode] #4058 15
[assign] #4058 justification -1: p50
[end-of-instance]
[eq-expl] #3958 root
[new-match] 0x106824660 #1477 #1476 #3958 #1545 ; #4562
[eq-expl] #4149 lit #4058 ; #4562
[eq-expl] #4562 root
[new-match] 0x106824698 #1522 #1506 #3958 #1545 ; #4151 (#4149 #4562)
[mk-app] #3621 = #3262 #3958
[mk-app] #4182 = #3621 #3621
[mk-proof] #3766 refl #4182
[mk-app] #3273 or #1576 #3621
[mk-proof] #3274 quant-inst #3273
[instance] 0x106824660 #3274 ; 16
[attach-enode] #3262 16
[attach-enode] #3621 16
[assign] #3621 justification -1: p49
[end-of-instance]
[mk-app] #4182 * #176 #3271
[mk-app] #3766 + #3268 #4182
[mk-app] #3275 = #3766 #1503
[mk-app] #3263 = #3275 #3275
[mk-proof] #3957 refl #3263
[mk-app] #4155 or #3101 #3275
[mk-proof] #4516 quant-inst #4155
[instance] 0x106824698 #4516 ; 16
[attach-enode] #3264 16
[attach-enode] #3268 16
[attach-enode] #3271 16
[attach-enode] #4182 16
[attach-enode] #3766 16
[attach-enode] #3275 16
[mk-app] #4517 <= #3766 #1503
[mk-app] #4148 >= #3766 #1503
[assign] #3275 justification -1: p51
[end-of-instance]
[assign] #4517 clause p148 (not p147)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[assign] #4148 clause p149 (not p147)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[mk-app] #3263 = #3271 #4151
[attach-meaning] #176 arith (- 1)
[mk-app] #3957 * #176 #4151
[mk-app] #3759 + #3271 #3957
[mk-app] #3238 <= #3759 #36
[mk-app] #3239 >= #3759 #36
[assign] #3263 justification -1: p145
[attach-enode] #3263 0
[attach-enode] #3957 0
[attach-enode] #3759 0
[assign] #3238 justification -1: p150
[assign] #3239 justification -1: p150
[new-match] 0x10682c6f0 #1495 #1483 #3958 #1545 ; #3264 (#4562 #4562)
[mk-app] #3240 = #3264 #3765
[mk-app] #3229 = #3264 #4156
[mk-app] #4578 = #3240 #3229
[mk-proof] #3849 monotonicity #4162 #4578
[mk-app] #3850 or #1563 #3229
[mk-app] #3851 or #1563 #3240
[mk-proof] #3417 quant-inst #3851
[mk-app] #4503 = #3851 #3850
[mk-proof] #3711 monotonicity #3849 #4503
[mk-app] #3712 = #3850 #3850
[mk-proof] #3713 rewrite #3712
[mk-proof] #2975 trans #3711 #3713 #4503
[mk-proof] #4443 mp #3417 #2975 #3850
[instance] 0x10682c6f0 #3417 ; 17
[attach-enode] #3767 17
[attach-enode] #4156 17
[attach-enode] #3229 17
[assign] #3229 justification -1: p50
[end-of-instance]
[eq-expl] #3767 root
[new-match] 0x10682c990 #1477 #1476 #3767 #1545 ; #4156
[eq-expl] #3264 lit #3229 ; #4156
[eq-expl] #4156 root
[new-match] 0x10682c9c8 #1522 #1506 #3767 #1545 ; #3268 (#3264 #4156)
[mk-app] #3489 = #4181 #3767
[mk-app] #3490 = #3489 #3489
[mk-proof] #3491 refl #3490
[mk-app] #4343 or #1576 #3489
[mk-proof] #4319 quant-inst #4343
[instance] 0x10682c990 #4319 ; 18
[attach-enode] #4181 18
[attach-enode] #3489 18
[assign] #3489 justification -1: p49
[end-of-instance]
[mk-app] #3490 * #176 #3618
[mk-app] #3491 + #4184 #3490
[mk-app] #3389 = #3491 #1503
[mk-app] #3392 + #3490 #4184
[inst-discovered] theory-solving 0x0 arith# ; #3491
[mk-app] #3393 = #3491 #3392
[mk-proof] #3385 rewrite #3393
[instance] 0x0 #3393
[end-of-instance]
[mk-app] #3949 = #3392 #1503
[mk-app] #4088 = #3389 #3949
[mk-proof] #4094 monotonicity #3385 #4088
[attach-meaning] #176 arith (- 1)
[mk-app] #4174 * #176 #4184
[mk-app] #3199 + #3618 #4174
[attach-meaning] #4108 arith (- 4)
[mk-app] #4172 = #3199 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3949
[mk-app] #4106 = #3949 #4172
[mk-proof] #3022 rewrite #4106
[instance] 0x0 #4106
[end-of-instance]
[mk-app] #3234 = #3389 #4172
[mk-proof] #4490 trans #4094 #3022 #3234
[mk-app] #3018 or #3101 #4172
[mk-app] #3019 or #3101 #3389
[mk-proof] #3020 quant-inst #3019
[mk-app] #4107 = #3019 #3018
[mk-proof] #3023 monotonicity #4490 #4107
[mk-app] #3027 = #3018 #3018
[mk-proof] #3028 rewrite #3027
[mk-proof] #3029 trans #3023 #3028 #4107
[mk-proof] #3030 mp #3020 #3029 #3018
[instance] 0x10682c9c8 #3020 ; 18
[attach-enode] #3618 18
[attach-enode] #4183 18
[attach-enode] #4184 18
[attach-enode] #4174 18
[attach-enode] #3199 18
[attach-enode] #4172 18
[mk-app] #3383 <= #3199 #4108
[mk-app] #3388 >= #3199 #4108
[assign] #4172 justification -1: p51
[end-of-instance]
[assign] #3383 clause p156 (not p155)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[assign] #3388 clause p157 (not p155)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[mk-app] #3153 = #3268 #3618
[attach-meaning] #176 arith (- 1)
[mk-app] #3390 + #3268 #3490
[mk-app] #3812 <= #3390 #36
[mk-app] #3813 >= #3390 #36
[assign] #3153 justification -1: p153
[attach-enode] #3153 0
[attach-enode] #3490 0
[attach-enode] #3390 0
[assign] #3812 justification -1: p158
[assign] #3813 justification -1: p158
[new-match] 0x10682d410 #1495 #1483 #3767 #1545 ; #4183 (#4156 #4156)
[mk-app] #4332 = #4183 #3693
[mk-app] #4333 = #4183 #3698
[mk-app] #4325 = #4332 #4333
[mk-proof] #4326 monotonicity #4564 #4325
[mk-app] #4330 or #1563 #4333
[mk-app] #4331 or #1563 #4332
[mk-proof] #4341 quant-inst #4331
[mk-app] #4556 = #4331 #4330
[mk-proof] #4557 monotonicity #4326 #4556
[mk-app] #3506 = #4330 #4330
[mk-proof] #3507 rewrite #3506
[mk-proof] #3492 trans #4557 #3507 #4556
[mk-proof] #3493 mp #4341 #3492 #4330
[instance] 0x10682d410 #4341 ; 19
[attach-enode] #3695 19
[attach-enode] #3698 19
[attach-enode] #4333 19
[assign] #4333 justification -1: p50
[end-of-instance]
[eq-expl] #3695 root
[new-match] 0x10682d6b0 #1477 #1476 #3695 #1545 ; #3698
[eq-expl] #4183 lit #4333 ; #3698
[eq-expl] #3698 root
[new-match] 0x10682d6e8 #1522 #1506 #3695 #1545 ; #4184 (#4183 #3698)
[mk-app] #3494 = #3083 #3695
[mk-app] #3495 = #3494 #3494
[mk-proof] #3496 refl #3495
[mk-app] #3497 or #1576 #3494
[mk-proof] #3498 quant-inst #3497
[instance] 0x10682d6b0 #3498 ; 20
[attach-enode] #3083 20
[attach-enode] #3494 20
[assign] #3494 justification -1: p49
[end-of-instance]
[mk-app] #3495 * #176 #3089
[mk-app] #3496 + #3086 #3495
[mk-app] #3499 = #3496 #1503
[mk-app] #3500 = #3499 #3499
[mk-proof] #3501 refl #3500
[mk-app] #3502 or #3101 #3499
[mk-proof] #3503 quant-inst #3502
[instance] 0x10682d6e8 #3503 ; 20
[attach-enode] #3085 20
[attach-enode] #3086 20
[attach-enode] #3089 20
[attach-enode] #3495 20
[attach-enode] #3496 20
[attach-enode] #3499 20
[mk-app] #3504 <= #3496 #1503
[mk-app] #3505 >= #3496 #1503
[assign] #3499 justification -1: p51
[end-of-instance]
[assign] #3504 clause p164 (not p163)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[assign] #3505 clause p165 (not p163)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[mk-app] #3500 = #3089 #4184
[attach-meaning] #176 arith (- 1)
[mk-app] #3501 + #3089 #4174
[mk-app] #3508 <= #3501 #36
[mk-app] #3509 >= #3501 #36
[assign] #3500 justification -1: p161
[attach-enode] #3500 0
[attach-enode] #3501 0
[assign] #3508 justification -1: p166
[assign] #3509 justification -1: p166
[new-match] 0x1068320d0 #1495 #1483 #3695 #1545 ; #3085 (#3698 #3698)
[mk-app] #3510 = #3085 #3105
[mk-app] #3511 = #3085 #3111
[mk-app] #3888 = #3510 #3511
[mk-proof] #3889 monotonicity #3110 #3888
[mk-app] #2966 or #1563 #3511
[mk-app] #2967 or #1563 #3510
[mk-proof] #2962 quant-inst #2967
[mk-app] #2963 = #2967 #2966
[mk-proof] #2964 monotonicity #3889 #2963
[mk-app] #2965 = #2966 #2966
[mk-proof] #2968 rewrite #2965
[mk-proof] #2969 trans #2964 #2968 #2963
[mk-proof] #2970 mp #2962 #2969 #2966
[instance] 0x1068320d0 #2962 ; 21
[attach-enode] #3107 21
[attach-enode] #3111 21
[attach-enode] #3511 21
[assign] #3511 justification -1: p50
[end-of-instance]
[eq-expl] #3107 root
[new-match] 0x106832370 #1477 #1476 #3107 #1545 ; #3111
[eq-expl] #3085 lit #3511 ; #3111
[eq-expl] #3111 root
[new-match] 0x1068323a8 #1522 #1506 #3107 #1545 ; #3086 (#3085 #3111)
[mk-app] #2971 = #4051 #3107
[mk-app] #2972 = #2971 #2971
[mk-proof] #2973 refl #2972
[mk-app] #3708 or #1576 #2971
[mk-proof] #3709 quant-inst #3708
[instance] 0x106832370 #3709 ; 22
[attach-enode] #4051 22
[attach-enode] #2971 22
[assign] #2971 justification -1: p49
[end-of-instance]
[mk-app] #2972 * #176 #4057
[mk-app] #2973 + #4054 #2972
[mk-app] #3644 = #2973 #1503
[mk-app] #3645 = #3644 #3644
[mk-proof] #3408 refl #3645
[mk-app] #3409 or #3101 #3644
[mk-proof] #3404 quant-inst #3409
[instance] 0x1068323a8 #3404 ; 22
[attach-enode] #4053 22
[attach-enode] #4054 22
[attach-enode] #4057 22
[attach-enode] #2972 22
[attach-enode] #2973 22
[attach-enode] #3644 22
[mk-app] #3405 <= #2973 #1503
[mk-app] #3406 >= #2973 #1503
[assign] #3644 justification -1: p51
[end-of-instance]
[assign] #3405 clause p172 (not p171)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[assign] #3406 clause p173 (not p171)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[mk-app] #3645 = #3086 #4057
[attach-meaning] #176 arith (- 1)
[mk-app] #3408 + #3086 #2972
[mk-app] #3407 <= #3408 #36
[mk-app] #3410 >= #3408 #36
[assign] #3645 justification -1: p169
[attach-enode] #3645 0
[attach-enode] #3408 0
[assign] #3407 justification -1: p174
[assign] #3410 justification -1: p174
[new-match] 0x106832d68 #1495 #1483 #3107 #1545 ; #4053 (#3111 #3111)
[mk-app] #3411 = #4053 #4072
[mk-app] #3412 = #4053 #3326
[mk-app] #3413 = #3411 #3412
[mk-proof] #3415 monotonicity #3328 #3413
[mk-app] #3416 or #1563 #3412
[mk-app] #3846 or #1563 #3411
[mk-proof] #3847 quant-inst #3846
[mk-app] #4351 = #3846 #3416
[mk-proof] #4353 monotonicity #3415 #4351
[mk-app] #2986 = #3416 #3416
[mk-proof] #2987 rewrite #2986
[mk-proof] #2982 trans #4353 #2987 #4351
[mk-proof] #2983 mp #3847 #2982 #3416
[instance] 0x106832d68 #3847 ; 23
[attach-enode] #4510 23
[attach-enode] #3326 23
[attach-enode] #3412 23
[assign] #3412 justification -1: p50
[end-of-instance]
[eq-expl] #4510 root
[new-match] 0x106833008 #1477 #1476 #4510 #1545 ; #3326
[eq-expl] #4053 lit #3412 ; #3326
[eq-expl] #3326 root
[new-match] 0x106833040 #1522 #1506 #4510 #1545 ; #4054 (#4053 #3326)
[mk-app] #2984 = #3344 #4510
[mk-app] #2985 = #2984 #2984
[mk-proof] #2988 refl #2985
[mk-app] #3223 or #1576 #2984
[mk-proof] #3224 quant-inst #3223
[instance] 0x106833008 #3224 ; 24
[attach-enode] #3344 24
[attach-enode] #2984 24
[assign] #2984 justification -1: p49
[end-of-instance]
[mk-app] #2985 * #176 #3353
[mk-app] #2988 + #3347 #2985
[mk-app] #3225 = #2988 #1503
[mk-app] #3226 = #3225 #3225
[mk-proof] #3227 refl #3226
[mk-app] #3232 or #3101 #3225
[mk-proof] #3236 quant-inst #3232
[instance] 0x106833040 #3236 ; 24
[attach-enode] #3346 24
[attach-enode] #3347 24
[attach-enode] #3353 24
[attach-enode] #2985 24
[attach-enode] #2988 24
[attach-enode] #3225 24
[mk-app] #3244 <= #2988 #1503
[mk-app] #3245 >= #2988 #1503
[assign] #3225 justification -1: p51
[end-of-instance]
[assign] #3244 clause p180 (not p179)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[assign] #3245 clause p181 (not p179)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[mk-app] #3226 = #3353 #4054
[attach-meaning] #176 arith (- 1)
[mk-app] #3227 * #176 #4054
[mk-app] #4138 + #3353 #3227
[mk-app] #4139 <= #4138 #36
[mk-app] #4134 >= #4138 #36
[assign] #3226 justification -1: p177
[attach-enode] #3226 0
[attach-enode] #3227 0
[attach-enode] #4138 0
[assign] #4139 justification -1: p182
[assign] #4134 justification -1: p182
[new-match] 0x106833a88 #1495 #1483 #4510 #1545 ; #3346 (#3326 #3326)
[mk-app] #4135 = #3346 #3783
[mk-app] #4136 = #3346 #3788
[mk-app] #4137 = #4135 #4136
[mk-proof] #4140 monotonicity #4216 #4137
[mk-app] #4141 or #1563 #4136
[mk-app] #4142 or #1563 #4135
[mk-proof] #4143 quant-inst #4142
[mk-app] #4144 = #4142 #4141
[mk-proof] #4146 monotonicity #4140 #4144
[mk-app] #4152 = #4141 #4141
[mk-proof] #4153 rewrite #4152
[mk-proof] #3688 trans #4146 #4153 #4144
[mk-proof] #3689 mp #4143 #3688 #4141
[instance] 0x106833a88 #4143 ; 25
[attach-enode] #3785 25
[attach-enode] #3788 25
[attach-enode] #4136 25
[assign] #4136 justification -1: p50
[end-of-instance]
[eq-expl] #3785 root
[new-match] 0x106833d28 #1477 #1476 #3785 #1545 ; #3788
[eq-expl] #3346 lit #4136 ; #3788
[eq-expl] #3788 root
[new-match] 0x106833d60 #1522 #1506 #3785 #1545 ; #3347 (#3346 #3788)
[mk-app] #3254 = #4233 #3785
[mk-app] #3255 = #3254 #3254
[mk-proof] #3250 refl #3255
[mk-app] #3251 or #1576 #3254
[mk-proof] #3252 quant-inst #3251
[instance] 0x106833d28 #3252 ; 26
[attach-enode] #4233 26
[attach-enode] #3254 26
[assign] #3254 justification -1: p49
[end-of-instance]
[mk-app] #3255 * #176 #4240
[mk-app] #3250 + #4237 #3255
[mk-app] #3253 = #3250 #1503
[mk-app] #3256 = #3253 #3253
[mk-proof] #3257 refl #3256
[mk-app] #3258 or #3101 #3253
[mk-proof] #3259 quant-inst #3258
[instance] 0x106833d60 #3259 ; 26
[attach-enode] #4235 26
[attach-enode] #4237 26
[attach-enode] #4240 26
[attach-enode] #3255 26
[attach-enode] #3250 26
[attach-enode] #3253 26
[mk-app] #3260 <= #3250 #1503
[mk-app] #3261 >= #3250 #1503
[assign] #3253 justification -1: p51
[end-of-instance]
[assign] #3260 clause p188 (not p187)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[assign] #3261 clause p189 (not p187)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[mk-app] #3256 = #3347 #4240
[attach-meaning] #176 arith (- 1)
[mk-app] #3257 + #3347 #3255
[mk-app] #3269 <= #3257 #36
[mk-app] #3270 >= #3257 #36
[assign] #3256 justification -1: p185
[attach-enode] #3256 0
[attach-enode] #3257 0
[assign] #3269 justification -1: p190
[assign] #3270 justification -1: p190
[new-match] 0x10683b398 #1495 #1483 #3785 #1545 ; #4235 (#3788 #3788)
[mk-app] #3279 = #4235 #2952
[mk-app] #3280 = #4235 #2957
[mk-app] #4168 = #3279 #3280
[mk-proof] #4169 monotonicity #2959 #4168
[mk-app] #4163 or #1563 #3280
[mk-app] #4164 or #1563 #3279
[mk-proof] #4166 quant-inst #4164
[mk-app] #4167 = #4164 #4163
[mk-proof] #4170 monotonicity #4169 #4167
[mk-app] #4175 = #4163 #4163
[mk-proof] #4176 rewrite #4175
[mk-proof] #4177 trans #4170 #4176 #4167
[mk-proof] #4178 mp #4166 #4177 #4163
[instance] 0x10683b398 #4166 ; 27
[attach-enode] #2954 27
[attach-enode] #2957 27
[attach-enode] #3280 27
[assign] #3280 justification -1: p50
[end-of-instance]
[eq-expl] #2954 root
[new-match] 0x10683b638 #1477 #1476 #2954 #1545 ; #2957
[eq-expl] #4235 lit #3280 ; #2957
[eq-expl] #2957 root
[new-match] 0x10683b670 #1522 #1506 #2954 #1545 ; #4237 (#4235 #2957)
[mk-app] #4180 = #3638 #2954
[mk-app] #4588 = #4180 #4180
[mk-proof] #4589 refl #4588
[mk-app] #2928 or #1576 #4180
[mk-proof] #2929 quant-inst #2928
[instance] 0x10683b638 #2929 ; 28
[attach-enode] #3638 28
[attach-enode] #4180 28
[assign] #4180 justification -1: p49
[end-of-instance]
[mk-app] #4588 * #176 #4500
[mk-app] #4589 + #3641 #4588
[mk-app] #3622 = #4589 #1503
[mk-app] #3623 = #3622 #3622
[mk-proof] #3636 refl #3623
[mk-app] #4540 or #3101 #3622
[mk-proof] #4541 quant-inst #4540
[instance] 0x10683b670 #4541 ; 28
[attach-enode] #3640 28
[attach-enode] #3641 28
[attach-enode] #4500 28
[attach-enode] #4588 28
[attach-enode] #4589 28
[attach-enode] #3622 28
[mk-app] #3832 <= #4589 #1503
[mk-app] #3833 >= #4589 #1503
[assign] #3622 justification -1: p51
[end-of-instance]
[assign] #3832 clause p196 (not p195)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[assign] #3833 clause p197 (not p195)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[mk-app] #3623 = #4237 #4500
[attach-meaning] #176 arith (- 1)
[mk-app] #3636 + #4237 #4588
[mk-app] #3834 <= #3636 #36
[mk-app] #3835 >= #3636 #36
[assign] #3623 justification -1: p193
[attach-enode] #3623 0
[attach-enode] #3636 0
[assign] #3834 justification -1: p198
[assign] #3835 justification -1: p198
[new-match] 0x10683c030 #1495 #1483 #2954 #1545 ; #3640 (#2957 #2957)
[mk-app] #3836 = #3640 #3570
[mk-app] #3837 = #3640 #3910
[mk-app] #3838 = #3836 #3837
[mk-proof] #4508 monotonicity #3912 #3838
[mk-app] #4509 or #1563 #3837
[mk-app] #2930 or #1563 #3836
[mk-proof] #2931 quant-inst #2930
[mk-app] #2932 = #2930 #4509
[mk-proof] #2933 monotonicity #4508 #2932
[mk-app] #2937 = #4509 #4509
[mk-proof] #2938 rewrite #2937
[mk-proof] #3614 trans #2933 #2938 #2932
[mk-proof] #3615 mp #2931 #3614 #4509
[instance] 0x10683c030 #2931 ; 29
[attach-enode] #3572 29
[attach-enode] #3910 29
[attach-enode] #3837 29
[assign] #3837 justification -1: p50
[end-of-instance]
[eq-expl] #3572 root
[new-match] 0x10683c2d0 #1477 #1476 #3572 #1545 ; #3910
[eq-expl] #3640 lit #3837 ; #3910
[eq-expl] #3910 root
[new-match] 0x10683c308 #1522 #1506 #3572 #1545 ; #3641 (#3640 #3910)
[mk-app] #4565 = #3009 #3572
[mk-app] #3611 = #4565 #4565
[mk-proof] #3612 refl #3611
[mk-app] #3613 or #1576 #4565
[mk-proof] #3616 quant-inst #3613
[instance] 0x10683c2d0 #3616 ; 30
[attach-enode] #3009 30
[attach-enode] #4565 30
[assign] #4565 justification -1: p49
[end-of-instance]
[mk-app] #3611 * #176 #3015
[mk-app] #3612 + #3012 #3611
[mk-app] #3617 = #3612 #1503
[mk-app] #4538 = #3617 #3617
[mk-proof] #4539 refl #4538
[mk-app] #3081 or #3101 #3617
[mk-proof] #3082 quant-inst #3081
[instance] 0x10683c308 #3082 ; 30
[attach-enode] #3011 30
[attach-enode] #3012 30
[attach-enode] #3015 30
[attach-enode] #3611 30
[attach-enode] #3612 30
[attach-enode] #3617 30
[mk-app] #3087 <= #3612 #1503
[mk-app] #3088 >= #3612 #1503
[assign] #3617 justification -1: p51
[end-of-instance]
[assign] #3087 clause p204 (not p203)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[assign] #3088 clause p205 (not p203)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[mk-app] #4538 = #3015 #3641
[attach-meaning] #176 arith (- 1)
[mk-app] #4539 * #176 #3641
[mk-app] #3095 + #3015 #4539
[mk-app] #3096 <= #3095 #36
[mk-app] #3736 >= #3095 #36
[assign] #4538 justification -1: p201
[attach-enode] #4538 0
[attach-enode] #4539 0
[attach-enode] #3095 0
[assign] #3096 justification -1: p206
[assign] #3736 justification -1: p206
[new-match] 0x106840f78 #1495 #1483 #3572 #1545 ; #3011 (#3910 #3910)
[mk-app] #3737 = #3011 #3042
[mk-app] #3113 = #3011 #3725
[mk-app] #3114 = #3737 #3113
[mk-proof] #3115 monotonicity #3727 #3114
[mk-app] #3735 or #1563 #3113
[mk-app] #3738 or #1563 #3737
[mk-proof] #3739 quant-inst #3738
[mk-app] #3740 = #3738 #3735
[mk-proof] #3741 monotonicity #3115 #3740
[mk-app] #4049 = #3735 #3735
[mk-proof] #4050 rewrite #4049
[mk-proof] #4055 trans #3741 #4050 #3740
[mk-proof] #4056 mp #3739 #4055 #3735
[instance] 0x106840f78 #3739 ; 31
[attach-enode] #3722 31
[attach-enode] #3725 31
[attach-enode] #3113 31
[assign] #3113 justification -1: p50
[end-of-instance]
[eq-expl] #3722 root
[new-match] 0x106841218 #1477 #1476 #3722 #1545 ; #3725
[eq-expl] #3011 lit #3113 ; #3725
[eq-expl] #3725 root
[new-match] 0x106841250 #1522 #1506 #3722 #1545 ; #3012 (#3011 #3725)
[mk-app] #4064 = #4002 #3722
[mk-app] #4065 = #4064 #4064
[mk-proof] #3333 refl #4065
[mk-app] #3334 or #1576 #4064
[mk-proof] #3329 quant-inst #3334
[instance] 0x106841218 #3329 ; 32
[attach-enode] #4002 32
[attach-enode] #4064 32
[assign] #4064 justification -1: p49
[end-of-instance]
[mk-app] #4065 * #176 #4009
[mk-app] #3333 + #4005 #4065
[mk-app] #3330 = #3333 #1503
[mk-app] #3331 = #3330 #3330
[mk-proof] #3332 refl #3331
[mk-app] #3338 or #3101 #3330
[mk-proof] #3339 quant-inst #3338
[instance] 0x106841250 #3339 ; 32
[attach-enode] #4004 32
[attach-enode] #4005 32
[attach-enode] #4009 32
[attach-enode] #4065 32
[attach-enode] #3333 32
[attach-enode] #3330 32
[mk-app] #3340 <= #3333 #1503
[mk-app] #3341 >= #3333 #1503
[assign] #3330 justification -1: p51
[end-of-instance]
[assign] #3340 clause p212 (not p211)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[assign] #3341 clause p213 (not p211)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[mk-app] #3331 = #3012 #4009
[attach-meaning] #176 arith (- 1)
[mk-app] #3332 + #3012 #4065
[mk-app] #3342 <= #3332 #36
[mk-app] #3343 >= #3332 #36
[assign] #3331 justification -1: p209
[attach-enode] #3331 0
[attach-enode] #3332 0
[assign] #3342 justification -1: p214
[assign] #3343 justification -1: p214
[new-match] 0x106841c10 #1495 #1483 #3722 #1545 ; #4004 (#3725 #3725)
[mk-app] #3351 = #4004 #3624
[mk-app] #3352 = #4004 #3633
[mk-app] #3359 = #3351 #3352
[mk-proof] #3360 monotonicity #3631 #3359
[mk-app] #4221 or #1563 #3352
[mk-app] #4222 or #1563 #3351
[mk-proof] #4217 quant-inst #4222
[mk-app] #4218 = #4222 #4221
[mk-proof] #4219 monotonicity #3360 #4218
[mk-app] #4220 = #4221 #4221
[mk-proof] #4223 rewrite #4220
[mk-proof] #4224 trans #4219 #4223 #4218
[mk-proof] #4225 mp #4217 #4224 #4221
[instance] 0x106841c10 #4217 ; 33
[attach-enode] #3632 33
[attach-enode] #3633 33
[attach-enode] #3352 33
[assign] #3352 justification -1: p50
[end-of-instance]
[eq-expl] #3632 root
[new-match] 0x106841eb0 #1477 #1476 #3632 #1545 ; #3633
[eq-expl] #4004 lit #3352 ; #3633
[eq-expl] #3633 root
[new-match] 0x106841ee8 #1522 #1506 #3632 #1545 ; #4005 (#4004 #3633)
[mk-app] #4226 = #3596 #3632
[mk-app] #4231 = #4226 #4226
[mk-proof] #4232 refl #4231
[mk-app] #4238 or #1576 #4226
[mk-proof] #4239 quant-inst #4238
[instance] 0x106841eb0 #4239 ; 34
[attach-enode] #3596 34
[attach-enode] #4226 34
[assign] #4226 justification -1: p49
[end-of-instance]
[mk-app] #4231 * #176 #3370
[mk-app] #4232 + #3367 #4231
[mk-app] #4592 = #4232 #1503
[mk-app] #4593 = #4592 #4592
[mk-proof] #3702 refl #4593
[mk-app] #3703 or #3101 #4592
[mk-proof] #2960 quant-inst #3703
[instance] 0x106841ee8 #2960 ; 34
[attach-enode] #4533 34
[attach-enode] #3367 34
[attach-enode] #3370 34
[attach-enode] #4231 34
[attach-enode] #4232 34
[attach-enode] #4592 34
[mk-app] #2961 <= #4232 #1503
[mk-app] #3700 >= #4232 #1503
[assign] #4592 justification -1: p51
[end-of-instance]
[assign] #2961 clause p220 (not p219)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[assign] #3700 clause p221 (not p219)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[mk-app] #4593 = #3370 #4005
[attach-meaning] #176 arith (- 1)
[mk-app] #3702 * #176 #4005
[mk-app] #3701 + #3370 #3702
[mk-app] #3704 <= #3701 #36
[mk-app] #3705 >= #3701 #36
[assign] #4593 justification -1: p217
[attach-enode] #4593 0
[attach-enode] #3702 0
[attach-enode] #3701 0
[assign] #3704 justification -1: p222
[assign] #3705 justification -1: p222
[new-match] 0x106842930 #1495 #1483 #3632 #1545 ; #4533 (#3633 #3633)
[mk-app] #3706 = #4533 #3798
[mk-app] #4566 = #4533 #3803
[mk-app] #4567 = #3706 #4566
[mk-proof] #3637 monotonicity #4273 #4567
[mk-app] #3642 or #1563 #4566
[mk-app] #3643 or #1563 #3706
[mk-proof] #3559 quant-inst #3643
[mk-app] #3560 = #3643 #3642
[mk-proof] #4559 monotonicity #3637 #3560
[mk-app] #3002 = #3642 #3642
[mk-proof] #3913 rewrite #3002
[mk-proof] #3914 trans #4559 #3913 #3560
[mk-proof] #3915 mp #3559 #3914 #3642
[instance] 0x106842930 #3559 ; 35
[attach-enode] #3800 35
[attach-enode] #3803 35
[attach-enode] #4566 35
[assign] #4566 justification -1: p50
[end-of-instance]
[eq-expl] #3800 root
[new-match] 0x106842bd0 #1477 #1476 #3800 #1545 ; #3803
[eq-expl] #4533 lit #4566 ; #3803
[eq-expl] #3803 root
[new-match] 0x106827e20 #1522 #1506 #3800 #1545 ; #3367 (#4533 #3803)
[mk-app] #4558 = #4289 #3800
[mk-app] #3003 = #4558 #4558
[mk-proof] #3004 refl #3003
[mk-app] #3005 or #1576 #4558
[mk-proof] #3006 quant-inst #3005
[instance] 0x106842bd0 #3006 ; 36
[attach-enode] #4289 36
[attach-enode] #4558 36
[assign] #4558 justification -1: p49
[end-of-instance]
[mk-app] #3003 * #176 #4297
[mk-app] #3004 + #4293 #3003
[mk-app] #3007 = #3004 #1503
[mk-app] #3008 = #3007 #3007
[mk-proof] #3013 refl #3008
[mk-app] #3014 or #3101 #3007
[mk-proof] #3034 quant-inst #3014
[instance] 0x106827e20 #3034 ; 36
[attach-enode] #4292 36
[attach-enode] #4293 36
[attach-enode] #4297 36
[attach-enode] #3003 36
[attach-enode] #3004 36
[attach-enode] #3007 36
[mk-app] #3035 <= #3004 #1503
[mk-app] #3990 >= #3004 #1503
[assign] #3007 justification -1: p51
[end-of-instance]
[assign] #3035 clause p228 (not p227)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[assign] #3990 clause p229 (not p227)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[mk-app] #3008 = #3367 #4297
[attach-meaning] #176 arith (- 1)
[mk-app] #3013 + #3367 #3003
[mk-app] #3991 <= #3013 #36
[mk-app] #3986 >= #3013 #36
[assign] #3008 justification -1: p225
[attach-enode] #3008 0
[attach-enode] #3013 0
[assign] #3991 justification -1: p230
[assign] #3986 justification -1: p230
[new-match] 0x1068287e0 #1495 #1483 #3800 #1545 ; #4292 (#3803 #3803)
[mk-app] #3987 = #4292 #3831
[mk-app] #3988 = #4292 #3118
[mk-app] #3989 = #3987 #3988
[mk-proof] #3992 monotonicity #3120 #3989
[mk-app] #3993 or #1563 #3988
[mk-app] #3994 or #1563 #3987
[mk-proof] #3995 quant-inst #3994
[mk-app] #3996 = #3994 #3993
[mk-proof] #4001 monotonicity #3992 #3996
[mk-app] #4007 = #3993 #3993
[mk-proof] #4008 rewrite #4007
[mk-proof] #4016 trans #4001 #4008 #3996
[mk-proof] #4496 mp #3995 #4016 #3993
[instance] 0x1068287e0 #3995 ; 37
[attach-enode] #4573 37
[attach-enode] #3118 37
[attach-enode] #3988 37
[assign] #3988 justification -1: p50
[end-of-instance]
[eq-expl] #4573 root
[new-match] 0x106828a80 #1477 #1476 #4573 #1545 ; #3118
[eq-expl] #4292 lit #3988 ; #3118
[eq-expl] #3118 root
[new-match] 0x106828ab8 #1522 #1506 #4573 #1545 ; #4293 (#4292 #3118)
[mk-app] #4526 = #3133 #4573
[mk-app] #4527 = #4526 #4526
[mk-proof] #3628 refl #4527
[mk-app] #3629 or #1576 #4526
[mk-proof] #3574 quant-inst #3629
[instance] 0x106828a80 #3574 ; 38
[attach-enode] #3133 38
[attach-enode] #4526 38
[assign] #4526 justification -1: p49
[end-of-instance]
[mk-app] #4527 * #176 #3140
[mk-app] #3628 + #3136 #4527
[mk-app] #3575 = #3628 #1503
[mk-app] #3590 = #3575 #3575
[mk-proof] #3591 refl #3590
[mk-app] #3592 or #3101 #3575
[mk-proof] #3593 quant-inst #3592
[instance] 0x106828ab8 #3593 ; 38
[attach-enode] #3135 38
[attach-enode] #3136 38
[attach-enode] #3140 38
[attach-enode] #4527 38
[attach-enode] #3628 38
[attach-enode] #3575 38
[mk-app] #3594 <= #3628 #1503
[mk-app] #3595 >= #3628 #1503
[assign] #3575 justification -1: p51
[end-of-instance]
[assign] #3594 clause p236 (not p235)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[assign] #3595 clause p237 (not p235)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[mk-app] #3590 = #3140 #4293
[attach-meaning] #176 arith (- 1)
[mk-app] #3591 * #176 #4293
[mk-app] #3368 + #3140 #3591
[mk-app] #3369 <= #3368 #36
[mk-app] #3376 >= #3368 #36
[assign] #3590 justification -1: p233
[attach-enode] #3590 0
[attach-enode] #3591 0
[attach-enode] #3368 0
[assign] #3369 justification -1: p238
[assign] #3376 justification -1: p238
[new-match] 0x106829500 #1495 #1483 #4573 #1545 ; #3135 (#3118 #3118)
[mk-app] #3378 = #3135 #3158
[mk-app] #4278 = #3135 #3165
[mk-app] #4279 = #3378 #4278
[mk-proof] #4274 monotonicity #3167 #4279
[mk-app] #4275 or #1563 #4278
[mk-app] #4276 or #1563 #3378
[mk-proof] #4277 quant-inst #4276
[mk-app] #4280 = #4276 #4275
[mk-proof] #4281 monotonicity #4274 #4280
[mk-app] #4282 = #4275 #4275
[mk-proof] #4286 rewrite #4282
[mk-proof] #4287 trans #4281 #4286 #4280
[mk-proof] #4288 mp #4277 #4287 #4275
[instance] 0x106829500 #4277 ; 39
[attach-enode] #3161 39
[attach-enode] #3165 39
[attach-enode] #4278 39
[assign] #4278 justification -1: p50
[end-of-instance]
[eq-expl] #3161 root
[new-match] 0x1068297a0 #1477 #1476 #3161 #1545 ; #3165
[eq-expl] #3135 lit #4278 ; #3165
[eq-expl] #3165 root
[new-match] 0x1068297d8 #1522 #1506 #3161 #1545 ; #3136 (#3135 #3165)
[mk-app] #4294 = #3745 #3161
[mk-app] #4295 = #4294 #4294
[mk-proof] #4553 refl #4295
[mk-app] #3825 or #1576 #4294
[mk-proof] #3125 quant-inst #3825
[instance] 0x1068297a0 #3125 ; 40
[attach-enode] #3745 40
[attach-enode] #4294 40
[assign] #4294 justification -1: p49
[end-of-instance]
[mk-app] #4295 * #176 #4076
[mk-app] #4553 + #3748 #4295
[mk-app] #3126 = #4553 #1503
[mk-app] #3121 = #3126 #3126
[mk-proof] #3122 refl #3121
[mk-app] #3123 or #3101 #3126
[mk-proof] #3124 quant-inst #3123
[instance] 0x1068297d8 #3124 ; 40
[attach-enode] #3747 40
[attach-enode] #3748 40
[attach-enode] #4076 40
[attach-enode] #4295 40
[attach-enode] #4553 40
[attach-enode] #3126 40
[mk-app] #3127 <= #4553 #1503
[mk-app] #3128 >= #4553 #1503
[assign] #3126 justification -1: p51
[end-of-instance]
[assign] #3127 clause p244 (not p243)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[assign] #3128 clause p245 (not p243)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[mk-app] #3121 = #3136 #4076
[attach-meaning] #176 arith (- 1)
[mk-app] #3122 + #3136 #4295
[mk-app] #3129 <= #3122 #36
[mk-app] #3130 >= #3122 #36
[assign] #3121 justification -1: p241
[attach-enode] #3121 0
[attach-enode] #3122 0
[assign] #3129 justification -1: p246
[assign] #3130 justification -1: p246
[new-match] 0x106859ba8 #1495 #1483 #3161 #1545 ; #3747 (#3165 #3165)
[mk-app] #3131 = #3747 #4093
[mk-app] #3132 = #3747 #4100
[mk-app] #3137 = #3131 #3132
[mk-proof] #3139 monotonicity #4102 #3137
[mk-app] #3147 or #1563 #3132
[mk-app] #3148 or #1563 #3131
[mk-proof] #3173 quant-inst #3148
[mk-app] #3171 = #3148 #3147
[mk-proof] #3168 monotonicity #3139 #3171
[mk-app] #3169 = #3147 #3147
[mk-proof] #3170 rewrite #3169
[mk-proof] #3172 trans #3168 #3170 #3171
[mk-proof] #3174 mp #3173 #3172 #3147
[instance] 0x106859ba8 #3173 ; 41
[attach-enode] #4096 41
[attach-enode] #4100 41
[attach-enode] #3132 41
[assign] #3132 justification -1: p50
[end-of-instance]
[eq-expl] #4096 root
[new-match] 0x106859e48 #1477 #1476 #4096 #1545 ; #4100
[eq-expl] #3747 lit #3132 ; #4100
[eq-expl] #4100 root
[new-match] 0x106859e80 #1522 #1506 #4096 #1545 ; #3748 (#3747 #4100)
[mk-app] #3175 = #3520 #4096
[mk-app] #3176 = #3175 #3175
[mk-proof] #3742 refl #3176
[mk-app] #3743 or #1576 #3175
[mk-proof] #3744 quant-inst #3743
[instance] 0x106859e48 #3744 ; 42
[attach-enode] #3520 42
[attach-enode] #3175 42
[assign] #3175 justification -1: p49
[end-of-instance]
[mk-app] #3176 * #176 #3526
[mk-app] #3742 + #3523 #3176
[mk-app] #4074 = #3742 #1503
[mk-app] #4075 = #4074 #4074
[mk-proof] #4082 refl #4075
[mk-app] #4083 or #3101 #4074
[mk-proof] #3512 quant-inst #4083
[instance] 0x106859e80 #3512 ; 42
[attach-enode] #3522 42
[attach-enode] #3523 42
[attach-enode] #3526 42
[attach-enode] #3176 42
[attach-enode] #3742 42
[attach-enode] #4074 42
[mk-app] #3513 <= #3742 #1503
[mk-app] #4103 >= #3742 #1503
[assign] #4074 justification -1: p51
[end-of-instance]
[assign] #3513 clause p252 (not p251)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[assign] #4103 clause p253 (not p251)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[mk-app] #4075 = #3526 #3748
[attach-meaning] #176 arith (- 1)
[mk-app] #4082 * #176 #3748
[mk-app] #4104 + #3526 #4082
[mk-app] #4512 <= #4104 #36
[mk-app] #4513 >= #4104 #36
[assign] #4075 justification -1: p249
[attach-enode] #4075 0
[attach-enode] #4082 0
[attach-enode] #4104 0
[assign] #4512 justification -1: p254
[assign] #4513 justification -1: p254
[new-match] 0x10685a8c8 #1495 #1483 #4096 #1545 ; #3522 (#4100 #4100)
[mk-app] #3514 = #3522 #3896
[mk-app] #3515 = #3522 #3901
[mk-app] #3516 = #3514 #3515
[mk-proof] #3517 monotonicity #4448 #3516
[mk-app] #3518 or #1563 #3515
[mk-app] #3519 or #1563 #3514
[mk-proof] #3524 quant-inst #3519
[mk-app] #3525 = #3519 #3518
[mk-proof] #3532 monotonicity #3517 #3525
[mk-app] #3533 = #3518 #3518
[mk-proof] #4453 rewrite #3533
[mk-proof] #4454 trans #3532 #4453 #3525
[mk-proof] #4449 mp #3524 #4454 #3518
[instance] 0x10685a8c8 #3524 ; 43
[attach-enode] #3898 43
[attach-enode] #3901 43
[attach-enode] #3515 43
[assign] #3515 justification -1: p50
[end-of-instance]
[eq-expl] #3898 root
[new-match] 0x10685ab68 #1477 #1476 #3898 #1545 ; #3901
[eq-expl] #3522 lit #3515 ; #3901
[eq-expl] #3901 root
[new-match] 0x10685aba0 #1522 #1506 #3898 #1545 ; #3523 (#3522 #3901)
[mk-app] #4450 = #4462 #3898
[mk-app] #4451 = #4450 #4450
[mk-proof] #4452 refl #4451
[mk-app] #4455 or #1576 #4450
[mk-proof] #4456 quant-inst #4455
[instance] 0x10685ab68 #4456 ; 44
[attach-enode] #4462 44
[attach-enode] #4450 44
[assign] #4450 justification -1: p49
[end-of-instance]
[mk-app] #4451 * #176 #4469
[mk-app] #4452 + #4465 #4451
[mk-app] #4457 = #4452 #1503
[mk-app] #4458 = #4457 #4457
[mk-proof] #4459 refl #4458
[mk-app] #4460 or #3101 #4457
[mk-proof] #4467 quant-inst #4460
[instance] 0x10685aba0 #4467 ; 44
[attach-enode] #4464 44
[attach-enode] #4465 44
[attach-enode] #4469 44
[attach-enode] #4451 44
[attach-enode] #4452 44
[attach-enode] #4457 44
[mk-app] #4468 <= #4452 #1503
[mk-app] #3421 >= #4452 #1503
[assign] #4457 justification -1: p51
[end-of-instance]
[assign] #4468 clause p260 (not p259)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[assign] #3421 clause p261 (not p259)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[mk-app] #4458 = #3523 #4469
[attach-meaning] #176 arith (- 1)
[mk-app] #4459 + #3523 #4451
[mk-app] #3422 <= #4459 #36
[mk-app] #3443 >= #4459 #36
[assign] #4458 justification -1: p257
[attach-enode] #4458 0
[attach-enode] #4459 0
[assign] #3422 justification -1: p262
[assign] #3443 justification -1: p262
[new-match] 0x10685b560 #1495 #1483 #3898 #1545 ; #4464 (#3901 #3901)
[mk-app] #3441 = #4464 #3430
[mk-app] #3438 = #4464 #3435
[mk-app] #3439 = #3441 #3438
[mk-proof] #3440 monotonicity #3437 #3439
[mk-app] #3442 or #1563 #3438
[mk-app] #3444 or #1563 #3441
[mk-proof] #3445 quant-inst #3444
[mk-app] #3446 = #3444 #3442
[mk-proof] #3853 monotonicity #3440 #3446
[mk-app] #3854 = #3442 #3442
[mk-proof] #3855 rewrite #3854
[mk-proof] #4362 trans #3853 #3855 #3446
[mk-proof] #4363 mp #3445 #4362 #3442
[instance] 0x10685b560 #3445 ; 45
[attach-enode] #3432 45
[attach-enode] #3435 45
[attach-enode] #3438 45
[assign] #3438 justification -1: p50
[end-of-instance]
[eq-expl] #3432 root
[new-match] 0x106862810 #1477 #1476 #3432 #1545 ; #3435
[eq-expl] #4464 lit #3438 ; #3435
[eq-expl] #3435 root
[new-match] 0x106862848 #1522 #1506 #3432 #1545 ; #4465 (#4464 #3435)
[mk-app] #4370 = #3856 #3432
[mk-app] #4371 = #4370 #4370
[mk-proof] #3542 refl #4371
[mk-app] #3543 or #1576 #4370
[mk-proof] #4581 quant-inst #3543
[instance] 0x106862810 #4581 ; 46
[attach-enode] #3856 46
[attach-enode] #4370 46
[assign] #4370 justification -1: p49
[end-of-instance]
[mk-app] #4371 * #176 #4364
[mk-app] #3542 + #3859 #4371
[mk-app] #3539 = #3542 #1503
[mk-app] #3540 = #3539 #3539
[mk-proof] #3541 refl #3540
[mk-app] #3544 or #3101 #3539
[mk-proof] #3545 quant-inst #3544
[instance] 0x106862848 #3545 ; 46
[attach-enode] #3858 46
[attach-enode] #3859 46
[attach-enode] #4364 46
[attach-enode] #4371 46
[attach-enode] #3542 46
[attach-enode] #3539 46
[mk-app] #3546 <= #3542 #1503
[mk-app] #3547 >= #3542 #1503
[assign] #3539 justification -1: p51
[end-of-instance]
[assign] #3546 clause p268 (not p267)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[assign] #3547 clause p269 (not p267)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[mk-app] #3540 = #4364 #4465
[attach-meaning] #176 arith (- 1)
[mk-app] #3541 * #176 #4465
[mk-app] #3548 + #4364 #3541
[mk-app] #3549 <= #3548 #36
[mk-app] #3554 >= #3548 #36
[assign] #3540 justification -1: p265
[attach-enode] #3540 0
[attach-enode] #3541 0
[attach-enode] #3548 0
[assign] #3549 justification -1: p270
[assign] #3554 justification -1: p270
[new-match] 0x106863290 #1495 #1483 #3432 #1545 ; #3858 (#3435 #3435)
[mk-app] #3902 = #3858 #4379
[mk-app] #4475 = #3858 #4385
[mk-app] #4476 = #3902 #4475
[mk-proof] #4248 monotonicity #4580 #4476
[mk-app] #4249 or #1563 #4475
[mk-app] #3808 or #1563 #3902
[mk-proof] #3809 quant-inst #3808
[mk-app] #3810 = #3808 #4249
[mk-proof] #4247 monotonicity #4248 #3810
[mk-app] #4250 = #4249 #4249
[mk-proof] #4251 rewrite #4250
[mk-proof] #4252 trans #4247 #4251 #3810
[mk-proof] #4253 mp #3809 #4252 #4249
[instance] 0x106863290 #3809 ; 47
[attach-enode] #4382 47
[attach-enode] #4385 47
[attach-enode] #4475 47
[assign] #4475 justification -1: p50
[end-of-instance]
[eq-expl] #4382 root
[new-match] 0x106863530 #1477 #1476 #4382 #1545 ; #4385
[eq-expl] #3858 lit #4475 ; #4385
[eq-expl] #4385 root
[new-match] 0x106863568 #1522 #1506 #4382 #1545 ; #3859 (#3858 #4385)
[mk-app] #4254 = #3550 #4382
[mk-app] #4255 = #4254 #4254
[mk-proof] #4304 refl #4255
[mk-app] #4306 or #1576 #4254
[mk-proof] #4314 quant-inst #4306
[instance] 0x106863530 #4314 ; 48
[attach-enode] #3550 48
[attach-enode] #4254 48
[assign] #4254 justification -1: p49
[end-of-instance]
[mk-app] #4255 * #176 #3903
[mk-app] #4304 + #3553 #4255
[mk-app] #4315 = #4304 #1503
[mk-app] #2926 = #4315 #4315
[mk-proof] #2927 refl #2926
[mk-app] #2922 or #3101 #4315
[mk-proof] #2923 quant-inst #2922
[instance] 0x106863568 #2923 ; 48
[attach-enode] #3552 48
[attach-enode] #3553 48
[attach-enode] #3903 48
[attach-enode] #4255 48
[attach-enode] #4304 48
[attach-enode] #4315 48
[mk-app] #2924 <= #4304 #1503
[mk-app] #2925 >= #4304 #1503
[assign] #4315 justification -1: p51
[end-of-instance]
[assign] #2924 clause p276 (not p275)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[assign] #2925 clause p277 (not p275)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[mk-app] #2926 = #3859 #3903
[attach-meaning] #176 arith (- 1)
[mk-app] #2927 + #3859 #4255
[mk-app] #3679 <= #2927 #36
[mk-app] #3680 >= #2927 #36
[assign] #2926 justification -1: p273
[attach-enode] #2926 0
[attach-enode] #2927 0
[assign] #3679 justification -1: p278
[assign] #3680 justification -1: p278
[new-match] 0x106863f28 #1495 #1483 #4382 #1545 ; #3552 (#4385 #4385)
[mk-app] #3681 = #3552 #4484
[mk-app] #3682 = #3552 #3805
[mk-app] #3683 = #3681 #3682
[mk-proof] #3684 monotonicity #3807 #3683
[mk-app] #3773 or #1563 #3682
[mk-app] #3774 or #1563 #3681
[mk-proof] #3935 quant-inst #3774
[mk-app] #3936 = #3774 #3773
[mk-proof] #3922 monotonicity #3684 #3936
[mk-app] #4522 = #3773 #3773
[mk-proof] #3918 rewrite #4522
[mk-proof] #3919 trans #3922 #3918 #3936
[mk-proof] #3920 mp #3935 #3919 #3773
[instance] 0x106863f28 #3935 ; 49
[attach-enode] #4548 49
[attach-enode] #3805 49
[attach-enode] #3682 49
[assign] #3682 justification -1: p50
[end-of-instance]
[eq-expl] #4548 root
[new-match] 0x1068641c8 #1477 #1476 #4548 #1545 ; #3805
[eq-expl] #3552 lit #3682 ; #3805
[eq-expl] #3805 root
[new-match] 0x106864200 #1522 #1506 #4548 #1545 ; #3553 (#3552 #3805)
[mk-app] #3921 = #4256 #4548
[mk-app] #4523 = #3921 #3921
[mk-proof] #3576 refl #4523
[mk-app] #3577 or #1576 #3921
[mk-proof] #3578 quant-inst #3577
[instance] 0x1068641c8 #3578 ; 50
[attach-enode] #4256 50
[attach-enode] #3921 50
[assign] #3921 justification -1: p49
[end-of-instance]
[mk-app] #4523 * #176 #4307
[mk-app] #3576 + #4303 #4523
[mk-app] #3579 = #3576 #1503
[mk-app] #3580 = #3579 #3579
[mk-proof] #3583 refl #3580
[mk-app] #3584 or #3101 #3579
[mk-proof] #3449 quant-inst #3584
[instance] 0x106864200 #3449 ; 50
[attach-enode] #4302 50
[attach-enode] #4303 50
[attach-enode] #4307 50
[attach-enode] #4523 50
[attach-enode] #3576 50
[attach-enode] #3579 50
[mk-app] #3450 <= #3576 #1503
[mk-app] #3589 >= #3576 #1503
[assign] #3579 justification -1: p51
[end-of-instance]
[assign] #3450 clause p284 (not p283)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[assign] #3589 clause p285 (not p283)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[mk-app] #3580 = #3553 #4307
[attach-meaning] #176 arith (- 1)
[mk-app] #3583 + #3553 #4523
[mk-app] #4530 <= #3583 #36
[mk-app] #4531 >= #3583 #36
[assign] #3580 justification -1: p281
[attach-enode] #3580 0
[attach-enode] #3583 0
[assign] #4530 justification -1: p286
[assign] #4531 justification -1: p286
[new-match] 0x1068675e8 #1495 #1483 #4548 #1545 ; #4302 (#3805 #3805)
[mk-app] #3043 = #4302 #2914
[mk-app] #3044 = #4302 #2919
[mk-app] #3045 = #3043 #3044
[mk-proof] #3046 monotonicity #2921 #3045
[mk-app] #3047 or #1563 #3044
[mk-app] #3048 or #1563 #3043
[mk-proof] #3049 quant-inst #3048
[mk-app] #3050 = #3048 #3047
[mk-proof] #3051 monotonicity #3046 #3050
[mk-app] #3447 = #3047 #3047
[mk-proof] #3448 rewrite #3447
[mk-proof] #3451 trans #3051 #3448 #3050
[mk-proof] #3452 mp #3049 #3451 #3047
[instance] 0x1068675e8 #3049 ; 51
[attach-enode] #2916 51
[attach-enode] #2919 51
[attach-enode] #3044 51
[assign] #3044 justification -1: p50
[end-of-instance]
[eq-expl] #2916 root
[new-match] 0x106867888 #1477 #1476 #2916 #1545 ; #2919
[eq-expl] #4302 lit #3044 ; #2919
[eq-expl] #2919 root
[new-match] 0x1068678c0 #1522 #1506 #2916 #1545 ; #4303 (#4302 #2919)
[mk-app] #3453 = #3685 #2916
[mk-app] #3454 = #3453 #3453
[mk-proof] #3455 refl #3454
[mk-app] #3456 or #1576 #3453
[mk-proof] #4399 quant-inst #3456
[instance] 0x106867888 #4399 ; 52
[attach-enode] #3685 52
[attach-enode] #3453 52
[assign] #3453 justification -1: p49
[end-of-instance]
[mk-app] #3454 * #176 #3775
[mk-app] #3455 + #3772 #3454
[mk-app] #4400 = #3455 #1503
[mk-app] #4395 = #4400 #4400
[mk-proof] #4396 refl #4395
[mk-app] #4397 or #3101 #4400
[mk-proof] #4398 quant-inst #4397
[instance] 0x1068678c0 #4398 ; 52
[attach-enode] #3771 52
[attach-enode] #3772 52
[attach-enode] #3775 52
[attach-enode] #3454 52
[attach-enode] #3455 52
[attach-enode] #4400 52
[mk-app] #4402 <= #3455 #1503
[mk-app] #4403 >= #3455 #1503
[assign] #4400 justification -1: p51
[end-of-instance]
[assign] #4402 clause p292 (not p291)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[assign] #4403 clause p293 (not p291)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[mk-app] #4395 = #3775 #4303
[attach-meaning] #176 arith (- 1)
[mk-app] #4396 * #176 #4303
[mk-app] #4404 + #3775 #4396
[mk-app] #4405 <= #4404 #36
[mk-app] #4407 >= #4404 #36
[assign] #4395 justification -1: p289
[attach-enode] #4395 0
[attach-enode] #4396 0
[attach-enode] #4404 0
[assign] #4405 justification -1: p294
[assign] #4407 justification -1: p294
[new-match] 0x106868308 #1495 #1483 #2916 #1545 ; #3771 (#2919 #2919)
[mk-app] #4408 = #3771 #3945
[mk-app] #4583 = #3771 #4561
[mk-app] #3790 = #4408 #4583
[mk-proof] #4550 monotonicity #3917 #3790
[mk-app] #4551 or #1563 #4583
[mk-app] #3795 or #1563 #4408
[mk-proof] #3796 quant-inst #3795
[mk-app] #4258 = #3795 #4551
[mk-proof] #4259 monotonicity #4550 #4258
[mk-app] #4260 = #4551 #4551
[mk-proof] #4262 rewrite #4260
[mk-proof] #4263 trans #4259 #4262 #4258
[mk-proof] #4264 mp #3796 #4263 #4551
[instance] 0x106868308 #3796 ; 53
[attach-enode] #3947 53
[attach-enode] #4561 53
[attach-enode] #4583 53
[assign] #4583 justification -1: p50
[end-of-instance]
[eq-expl] #3947 root
[new-match] 0x1068685a8 #1477 #1476 #3947 #1545 ; #4561
[eq-expl] #3771 lit #4583 ; #4561
[eq-expl] #4561 root
[new-match] 0x1068685e0 #1522 #1506 #3947 #1545 ; #3772 (#3771 #4561)
[mk-app] #4265 = #3581 #3947
[mk-app] #4267 = #4265 #4265
[mk-proof] #4268 refl #4267
[mk-app] #4269 or #1576 #4265
[mk-proof] #4270 quant-inst #4269
[instance] 0x1068685a8 #4270 ; 54
[attach-enode] #3581 54
[attach-enode] #4265 54
[assign] #4265 justification -1: p49
[end-of-instance]
[mk-app] #4267 * #176 #3585
[mk-app] #4268 + #4529 #4267
[mk-app] #4271 = #4268 #1503
[mk-app] #3839 + #4267 #4529
[inst-discovered] theory-solving 0x0 arith# ; #4268
[mk-app] #3840 = #4268 #3839
[mk-proof] #3841 rewrite #3840
[instance] 0x0 #3840
[end-of-instance]
[mk-app] #3842 = #3839 #1503
[mk-app] #3843 = #4271 #3842
[mk-proof] #3844 monotonicity #3841 #3843
[attach-meaning] #176 arith (- 1)
[mk-app] #4594 * #176 #4529
[mk-app] #4595 + #3585 #4594
[attach-meaning] #4108 arith (- 4)
[mk-app] #3926 = #4595 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3842
[mk-app] #3927 = #3842 #3926
[mk-proof] #3928 rewrite #3927
[instance] 0x0 #3927
[end-of-instance]
[mk-app] #3929 = #4271 #3926
[mk-proof] #3458 trans #3844 #3928 #3929
[mk-app] #3459 or #3101 #3926
[mk-app] #3460 or #3101 #4271
[mk-proof] #3461 quant-inst #3460
[mk-app] #3462 = #3460 #3459
[mk-proof] #3463 monotonicity #3458 #3462
[mk-app] #3471 = #3459 #3459
[mk-proof] #3472 rewrite #3471
[mk-proof] #3479 trans #3463 #3472 #3462
[mk-proof] #3480 mp #3461 #3479 #3459
[instance] 0x1068685e0 #3461 ; 54
[attach-enode] #3585 54
[attach-enode] #4528 54
[attach-enode] #4529 54
[attach-enode] #4594 54
[attach-enode] #4595 54
[attach-enode] #3926 54
[mk-app] #4419 <= #4595 #4108
[mk-app] #4424 >= #4595 #4108
[assign] #3926 justification -1: p51
[end-of-instance]
[assign] #4419 clause p300 (not p299)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[assign] #4424 clause p301 (not p299)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[mk-app] #3873 = #3585 #3772
[attach-meaning] #176 arith (- 1)
[mk-app] #4414 * #176 #3772
[mk-app] #4415 + #3585 #4414
[mk-app] #4418 <= #4415 #36
[mk-app] #4425 >= #4415 #36
[assign] #3873 justification -1: p297
[attach-enode] #3873 0
[attach-enode] #4414 0
[attach-enode] #4415 0
[assign] #4418 justification -1: p302
[assign] #4425 justification -1: p302
[new-match] 0x106869028 #1495 #1483 #3947 #1545 ; #4528 (#4561 #4561)
[mk-app] #4427 = #4528 #4387
[mk-app] #4428 = #4528 #4392
[mk-app] #4430 = #4427 #4428
[mk-proof] #4431 monotonicity #4394 #4430
[mk-app] #4432 or #1563 #4428
[mk-app] #3604 or #1563 #4427
[mk-proof] #3605 quant-inst #3604
[mk-app] #3066 = #3604 #4432
[mk-proof] #3067 monotonicity #4431 #3066
[mk-app] #3610 = #4432 #4432
[mk-proof] #4536 rewrite #3610
[mk-proof] #4537 trans #3067 #4536 #3066
[mk-proof] #3052 mp #3605 #4537 #4432
[instance] 0x106869028 #3605 ; 55
[attach-enode] #4389 55
[attach-enode] #4392 55
[attach-enode] #4428 55
[assign] #4428 justification -1: p50
[end-of-instance]
[eq-expl] #4389 root
[new-match] 0x106847ad8 #1477 #1476 #4389 #1545 ; #4392
[eq-expl] #4528 lit #4428 ; #4392
[eq-expl] #4392 root
[new-match] 0x106847b10 #1522 #1506 #4389 #1545 ; #4529 (#4528 #4392)
[mk-app] #3053 = #4409 #4389
[mk-app] #3054 = #3053 #3053
[mk-proof] #3055 refl #3054
[mk-app] #3056 or #1576 #3053
[mk-proof] #3057 quant-inst #3056
[instance] 0x106847ad8 #3057 ; 56
[attach-enode] #4409 56
[attach-enode] #3053 56
[assign] #3053 justification -1: p49
[end-of-instance]
[mk-app] #3054 * #176 #3791
[mk-app] #3055 + #4582 #3054
[mk-app] #3058 = #3055 #1503
[mk-app] #3059 + #3054 #4582
[inst-discovered] theory-solving 0x0 arith# ; #3055
[mk-app] #3060 = #3055 #3059
[mk-proof] #3061 rewrite #3060
[instance] 0x0 #3060
[end-of-instance]
[mk-app] #3065 = #3059 #1503
[mk-app] #3068 = #3058 #3065
[mk-proof] #3069 monotonicity #3061 #3068
[attach-meaning] #176 arith (- 1)
[mk-app] #3070 * #176 #4582
[mk-app] #3071 + #3791 #3070
[attach-meaning] #4108 arith (- 4)
[mk-app] #3072 = #3071 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3065
[mk-app] #3073 = #3065 #3072
[mk-proof] #4022 rewrite #3073
[instance] 0x0 #3073
[end-of-instance]
[mk-app] #4023 = #3058 #3072
[mk-proof] #4018 trans #3069 #4022 #4023
[mk-app] #4019 or #3101 #3072
[mk-app] #4020 or #3101 #3058
[mk-proof] #4021 quant-inst #4020
[mk-app] #4024 = #4020 #4019
[mk-proof] #4025 monotonicity #4018 #4024
[mk-app] #4026 = #4019 #4019
[mk-proof] #4027 rewrite #4026
[mk-proof] #4032 trans #4025 #4027 #4024
[mk-proof] #4033 mp #4021 #4032 #4019
[instance] 0x106847b10 #4021 ; 56
[attach-enode] #3791 56
[attach-enode] #4411 56
[attach-enode] #4582 56
[attach-enode] #3070 56
[attach-enode] #3071 56
[attach-enode] #3072 56
[mk-app] #4039 <= #3071 #4108
[mk-app] #4040 >= #3071 #4108
[assign] #3072 justification -1: p51
[end-of-instance]
[assign] #4039 clause p308 (not p307)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[assign] #4040 clause p309 (not p307)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[mk-app] #4498 = #3791 #4529
[attach-meaning] #176 arith (- 1)
[mk-app] #4499 + #3791 #4594
[mk-app] #3301 <= #4499 #36
[mk-app] #3302 >= #4499 #36
[assign] #4498 justification -1: p305
[attach-enode] #4498 0
[attach-enode] #4499 0
[assign] #3301 justification -1: p310
[assign] #3302 justification -1: p310
[new-match] 0x1068484d0 #1495 #1483 #4389 #1545 ; #4411 (#4392 #4392)
[mk-app] #3297 = #4411 #3885
[mk-app] #3298 = #4411 #3923
[mk-app] #3299 = #3297 #3298
[mk-proof] #3300 monotonicity #3925 #3299
[mk-app] #3303 or #1563 #3298
[mk-app] #3304 or #1563 #3297
[mk-proof] #3305 quant-inst #3304
[mk-app] #3309 = #3304 #3303
[mk-proof] #3310 monotonicity #3300 #3309
[mk-app] #3311 = #3303 #3303
[mk-proof] #3316 rewrite #3311
[mk-proof] #3317 trans #3310 #3316 #3309
[mk-proof] #3324 mp #3305 #3317 #3303
[instance] 0x1068484d0 #3305 ; 57
[attach-enode] #3887 57
[attach-enode] #3923 57
[attach-enode] #3298 57
[assign] #3298 justification -1: p50
[end-of-instance]
[eq-expl] #3887 root
[new-match] 0x106848770 #1477 #1476 #3887 #1545 ; #3923
[eq-expl] #4411 lit #3298 ; #3923
[eq-expl] #3923 root
[new-match] 0x1068487a8 #1522 #1506 #3887 #1545 ; #4582 (#4411 #3923)
[mk-app] #3776 = #3466 #3887
[mk-app] #4201 = #3776 #3776
[mk-proof] #4202 refl #4201
[mk-app] #4193 or #1576 #3776
[mk-proof] #4194 quant-inst #4193
[instance] 0x106848770 #4194 ; 58
[attach-enode] #3466 58
[attach-enode] #3776 58
[assign] #3776 justification -1: p49
[end-of-instance]
[mk-app] #4201 * #176 #3473
[mk-app] #4202 + #3469 #4201
[mk-app] #4195 = #4202 #1503
[mk-app] #4200 = #4195 #4195
[mk-proof] #4203 refl #4200
[mk-app] #4204 or #3101 #4195
[mk-proof] #4206 quant-inst #4204
[instance] 0x1068487a8 #4206 ; 58
[attach-enode] #3468 58
[attach-enode] #3469 58
[attach-enode] #3473 58
[attach-enode] #4201 58
[attach-enode] #4202 58
[attach-enode] #4195 58
[mk-app] #4207 <= #4202 #1503
[mk-app] #4208 >= #4202 #1503
[assign] #4195 justification -1: p51
[end-of-instance]
[assign] #4207 clause p316 (not p315)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[assign] #4208 clause p317 (not p315)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[mk-app] #4200 = #3473 #4582
[attach-meaning] #176 arith (- 1)
[mk-app] #4203 + #3473 #3070
[mk-app] #4209 <= #4203 #36
[mk-app] #4215 >= #4203 #36
[assign] #4200 justification -1: p313
[attach-enode] #4200 0
[attach-enode] #4203 0
[assign] #4209 justification -1: p318
[assign] #4215 justification -1: p318
[new-match] 0x106849168 #1495 #1483 #3887 #1545 ; #3468 (#3923 #3923)
[mk-app] #4590 = #3468 #3486
[mk-app] #3879 = #3468 #3870
[mk-app] #3880 = #4590 #3879
[mk-proof] #3824 monotonicity #3872 #3880
[mk-app] #4570 or #1563 #3879
[mk-app] #3820 or #1563 #4590
[mk-proof] #3821 quant-inst #3820
[mk-app] #3822 = #3820 #4570
[mk-proof] #3823 monotonicity #3824 #3822
[mk-app] #4571 = #4570 #4570
[mk-proof] #3597 rewrite #4571
[mk-proof] #3598 trans #3823 #3597 #3822
[mk-proof] #3599 mp #3821 #3598 #4570
[instance] 0x106849168 #3821 ; 59
[attach-enode] #3867 59
[attach-enode] #3870 59
[attach-enode] #3879 59
[assign] #3879 justification -1: p50
[end-of-instance]
[eq-expl] #3867 root
[new-match] 0x106849408 #1477 #1476 #3867 #1545 ; #3870
[eq-expl] #3468 lit #3879 ; #3870
[eq-expl] #3870 root
[new-match] 0x106849440 #1522 #1506 #3867 #1545 ; #3469 (#3468 #3870)
[mk-app] #3600 = #4433 #3867
[mk-app] #3601 = #3600 #3600
[mk-proof] #2989 refl #3601
[mk-app] #2990 or #1576 #3600
[mk-proof] #3961 quant-inst #2990
[instance] 0x106849408 #3961 ; 60
[attach-enode] #4433 60
[attach-enode] #3600 60
[assign] #3600 justification -1: p49
[end-of-instance]
[mk-app] #3601 * #176 #3606
[mk-app] #2989 + #4575 #3601
[mk-app] #3962 = #2989 #1503
[mk-app] #2995 + #3601 #4575
[inst-discovered] theory-solving 0x0 arith# ; #2989
[mk-app] #2997 = #2989 #2995
[mk-proof] #2998 rewrite #2997
[instance] 0x0 #2997
[end-of-instance]
[mk-app] #2996 = #2995 #1503
[mk-app] #2999 = #3962 #2996
[mk-proof] #3000 monotonicity #2998 #2999
[attach-meaning] #176 arith (- 1)
[mk-app] #3001 * #176 #4575
[mk-app] #3714 + #3606 #3001
[attach-meaning] #4108 arith (- 4)
[mk-app] #3715 = #3714 #4108
[inst-discovered] theory-solving 0x0 arith# ; #2996
[mk-app] #3716 = #2996 #3715
[mk-proof] #3717 rewrite #3716
[instance] 0x0 #3716
[end-of-instance]
[mk-app] #3718 = #3962 #3715
[mk-proof] #3719 trans #3000 #3717 #3718
[mk-app] #3720 or #3101 #3715
[mk-app] #3963 or #3101 #3962
[mk-proof] #3964 quant-inst #3963
[mk-app] #3965 = #3963 #3720
[mk-proof] #3966 monotonicity #3719 #3965
[mk-app] #3967 = #3720 #3720
[mk-proof] #3968 rewrite #3967
[mk-proof] #3180 trans #3966 #3968 #3965
[mk-proof] #3181 mp #3964 #3180 #3720
[instance] 0x106849440 #3964 ; 60
[attach-enode] #3606 60
[attach-enode] #4574 60
[attach-enode] #4575 60
[attach-enode] #3001 60
[attach-enode] #3714 60
[attach-enode] #3715 60
[mk-app] #4521 <= #3714 #4108
[mk-app] #3177 >= #3714 #4108
[assign] #3715 justification -1: p51
[end-of-instance]
[assign] #4521 clause p324 (not p323)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[assign] #3177 clause p325 (not p323)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[mk-app] #3178 = #3469 #3606
[attach-meaning] #176 arith (- 1)
[mk-app] #3179 + #3469 #3601
[mk-app] #3182 <= #3179 #36
[mk-app] #3186 >= #3179 #36
[assign] #3178 justification -1: p321
[attach-enode] #3178 0
[attach-enode] #3601 0
[attach-enode] #3179 0
[assign] #3182 justification -1: p326
[assign] #3186 justification -1: p326
[new-match] 0x106887e98 #1495 #1483 #3867 #1545 ; #4574 (#3870 #3870)
[mk-app] #3187 = #4574 #3728
[mk-app] #3188 = #4574 #3733
[mk-app] #3189 = #3187 #3188
[mk-proof] #3191 monotonicity #4017 #3189
[mk-app] #3196 or #1563 #3188
[mk-app] #3197 or #1563 #3187
[mk-proof] #3207 quant-inst #3197
[mk-app] #3208 = #3197 #3196
[mk-proof] #3752 monotonicity #3191 #3208
[mk-app] #3753 = #3196 #3196
[mk-proof] #3222 rewrite #3753
[mk-proof] #3749 trans #3752 #3222 #3208
[mk-proof] #3750 mp #3207 #3749 #3196
[instance] 0x106887e98 #3207 ; 61
[attach-enode] #3730 61
[attach-enode] #3733 61
[attach-enode] #3188 61
[assign] #3188 justification -1: p50
[end-of-instance]
[eq-expl] #3730 root
[new-match] 0x106888138 #1477 #1476 #3730 #1545 ; #3733
[eq-expl] #4574 lit #3188 ; #3733
[eq-expl] #3733 root
[new-match] 0x106888170 #1522 #1506 #3730 #1545 ; #4575 (#4574 #3733)
[mk-app] #3751 = #4034 #3730
[mk-app] #3754 = #3751 #3751
[mk-proof] #3755 refl #3754
[mk-app] #4109 or #1576 #3751
[mk-proof] #4110 quant-inst #4109
[instance] 0x106888138 #4110 ; 62
[attach-enode] #4034 62
[attach-enode] #3751 62
[assign] #3751 justification -1: p49
[end-of-instance]
[mk-app] #3754 * #176 #4041
[mk-app] #3755 + #4038 #3754
[mk-app] #4112 = #3755 #1503
[mk-app] #4113 = #4112 #4112
[mk-proof] #4122 refl #4113
[mk-app] #4123 or #3101 #4112
[mk-proof] #4514 quant-inst #4123
[instance] 0x106888170 #4514 ; 62
[attach-enode] #4036 62
[attach-enode] #4038 62
[attach-enode] #4041 62
[attach-enode] #3754 62
[attach-enode] #3755 62
[attach-enode] #4112 62
[mk-app] #4515 <= #3755 #1503
[mk-app] #4505 >= #3755 #1503
[assign] #4112 justification -1: p51
[end-of-instance]
[assign] #4515 clause p332 (not p331)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[assign] #4505 clause p333 (not p331)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[mk-app] #4113 = #4041 #4575
[attach-meaning] #176 arith (- 1)
[mk-app] #4122 + #4041 #3001
[mk-app] #3665 <= #4122 #36
[mk-app] #3655 >= #4122 #36
[assign] #4113 justification -1: p329
[attach-enode] #4113 0
[attach-enode] #4122 0
[assign] #3665 justification -1: p334
[assign] #3655 justification -1: p334
[new-match] 0x106888b30 #1495 #1483 #3730 #1545 ; #4036 (#3733 #3733)
[mk-app] #3656 = #4036 #3289
[mk-app] #3657 = #4036 #3294
[mk-app] #4504 = #3656 #3657
[mk-proof] #3666 monotonicity #3296 #4504
[mk-app] #3667 or #1563 #3657
[mk-app] #3668 or #1563 #3656
[mk-proof] #3669 quant-inst #3668
[mk-app] #3670 = #3668 #3667
[mk-proof] #3671 monotonicity #3666 #3670
[mk-app] #4586 = #3667 #3667
[mk-proof] #4587 rewrite #4586
[mk-proof] #4489 trans #3671 #4587 #3670
[mk-proof] #4598 mp #3669 #4489 #3667
[instance] 0x106888b30 #3669 ; 63
[attach-enode] #3291 63
[attach-enode] #3294 63
[attach-enode] #3657 63
[assign] #3657 justification -1: p50
[end-of-instance]
[eq-expl] #3291 root
[new-match] 0x106888dd0 #1477 #1476 #3291 #1545 ; #3294
[eq-expl] #4036 lit #3657 ; #3294
[eq-expl] #3294 root
[new-match] 0x106888e08 #1522 #1506 #3291 #1545 ; #4038 (#4036 #3294)
[mk-app] #4616 = #3312 #3291
[mk-app] #4617 = #4616 #4616
[mk-proof] #4612 refl #4617
[mk-app] #4613 or #1576 #4616
[mk-proof] #4614 quant-inst #4613
[instance] 0x106888dd0 #4614 ; 64
[attach-enode] #3312 64
[attach-enode] #4616 64
[assign] #4616 justification -1: p49
[end-of-instance]
[mk-app] #4617 * #176 #3318
[mk-app] #4612 + #3315 #4617
[mk-app] #4615 = #4612 #1503
[mk-app] #4618 = #4615 #4615
[mk-proof] #4619 refl #4618
[mk-app] #4620 or #3101 #4615
[mk-proof] #4621 quant-inst #4620
[instance] 0x106888e08 #4621 ; 64
[attach-enode] #3314 64
[attach-enode] #3315 64
[attach-enode] #3318 64
[attach-enode] #4617 64
[attach-enode] #4612 64
[attach-enode] #4615 64
[mk-app] #4622 <= #4612 #1503
[mk-app] #4623 >= #4612 #1503
[assign] #4615 justification -1: p51
[end-of-instance]
[assign] #4622 clause p340 (not p339)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[assign] #4623 clause p341 (not p339)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[mk-app] #4618 = #3318 #4038
[attach-meaning] #176 arith (- 1)
[mk-app] #4619 * #176 #4038
[mk-app] #4628 + #3318 #4619
[mk-app] #4629 <= #4628 #36
[mk-app] #4636 >= #4628 #36
[assign] #4618 justification -1: p337
[attach-enode] #4618 0
[attach-enode] #4619 0
[attach-enode] #4628 0
[assign] #4629 justification -1: p342
[assign] #4636 justification -1: p342
[new-match] 0x106889850 #1495 #1483 #3291 #1545 ; #3314 (#3294 #3294)
[mk-app] #4637 = #3314 #4185
[mk-app] #4655 = #3314 #4190
[mk-app] #4656 = #4637 #4655
[mk-proof] #4651 monotonicity #4192 #4656
[mk-app] #4652 or #1563 #4655
[mk-app] #4653 or #1563 #4637
[mk-proof] #4654 quant-inst #4653
[mk-app] #4657 = #4653 #4652
[mk-proof] #4658 monotonicity #4651 #4657
[mk-app] #4659 = #4652 #4652
[mk-proof] #4660 rewrite #4659
[mk-proof] #4661 trans #4658 #4660 #4657
[mk-proof] #4662 mp #4654 #4661 #4652
[instance] 0x106889850 #4654 ; 65
[attach-enode] #4187 65
[attach-enode] #4190 65
[attach-enode] #4655 65
[assign] #4655 justification -1: p50
[end-of-instance]
[eq-expl] #4187 root
[new-match] 0x106890760 #1477 #1476 #4187 #1545 ; #4190
[eq-expl] #3314 lit #4655 ; #4190
[eq-expl] #4190 root
[new-match] 0x106890798 #1522 #1506 #4187 #1545 ; #3315 (#3314 #4190)
[mk-app] #4667 = #4211 #4187
[mk-app] #4668 = #4667 #4667
[mk-proof] #4675 refl #4668
[mk-app] #4676 or #1576 #4667
[mk-proof] #4694 quant-inst #4676
[instance] 0x106890760 #4694 ; 66
[attach-enode] #4211 66
[attach-enode] #4667 66
[assign] #4667 justification -1: p49
[end-of-instance]
[mk-app] #4668 * #176 #4591
[mk-app] #4675 + #4214 #4668
[mk-app] #4695 = #4675 #1503
[mk-app] #4690 = #4695 #4695
[mk-proof] #4691 refl #4690
[mk-app] #4692 or #3101 #4695
[mk-proof] #4693 quant-inst #4692
[instance] 0x106890798 #4693 ; 66
[attach-enode] #4213 66
[attach-enode] #4214 66
[attach-enode] #4591 66
[attach-enode] #4668 66
[attach-enode] #4675 66
[attach-enode] #4695 66
[mk-app] #4696 <= #4675 #1503
[mk-app] #4697 >= #4675 #1503
[assign] #4695 justification -1: p51
[end-of-instance]
[assign] #4696 clause p348 (not p347)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[assign] #4697 clause p349 (not p347)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[mk-app] #4690 = #3315 #4591
[attach-meaning] #176 arith (- 1)
[mk-app] #4691 + #3315 #4668
[mk-app] #4698 <= #4691 #36
[mk-app] #4699 >= #4691 #36
[assign] #4690 justification -1: p345
[attach-enode] #4690 0
[attach-enode] #4691 0
[assign] #4698 justification -1: p350
[assign] #4699 justification -1: p350
[new-match] 0x106891158 #1495 #1483 #4187 #1545 ; #4213 (#4190 #4190)
[mk-app] #4700 = #4213 #3675
[mk-app] #4701 = #4213 #4495
[mk-app] #4706 = #4700 #4701
[mk-proof] #4707 monotonicity #3819 #4706
[mk-app] #4714 or #1563 #4701
[mk-app] #4715 or #1563 #4700
[mk-proof] #4733 quant-inst #4715
[mk-app] #4734 = #4715 #4714
[mk-proof] #4729 monotonicity #4707 #4734
[mk-app] #4730 = #4714 #4714
[mk-proof] #4731 rewrite #4730
[mk-proof] #4732 trans #4729 #4731 #4734
[mk-proof] #4735 mp #4733 #4732 #4714
[instance] 0x106891158 #4733 ; 67
[attach-enode] #3677 67
[attach-enode] #4495 67
[attach-enode] #4701 67
[assign] #4701 justification -1: p50
[end-of-instance]
[eq-expl] #3677 root
[new-match] 0x1068913f8 #1477 #1476 #3677 #1545 ; #4495
[eq-expl] #4213 lit #4701 ; #4495
[eq-expl] #4495 root
[new-match] 0x106891430 #1522 #1506 #3677 #1545 ; #4214 (#4213 #4495)
[mk-app] #4736 = #3602 #3677
[mk-app] #4737 = #4736 #4736
[mk-proof] #4738 refl #4737
[mk-app] #4739 or #1576 #4736
[mk-proof] #4740 quant-inst #4739
[instance] 0x1068913f8 #4740 ; 68
[attach-enode] #3602 68
[attach-enode] #4736 68
[assign] #4736 justification -1: p49
[end-of-instance]
[mk-app] #4737 * #176 #2991
[mk-app] #4738 + #4535 #4737
[mk-app] #4745 = #4738 #1503
[mk-app] #4746 + #4737 #4535
[inst-discovered] theory-solving 0x0 arith# ; #4738
[mk-app] #4753 = #4738 #4746
[mk-proof] #4754 rewrite #4753
[instance] 0x0 #4753
[end-of-instance]
[mk-app] #4772 = #4746 #1503
[mk-app] #4773 = #4745 #4772
[mk-proof] #4768 monotonicity #4754 #4773
[attach-meaning] #176 arith (- 1)
[mk-app] #4769 * #176 #4535
[mk-app] #4770 + #2991 #4769
[attach-meaning] #4108 arith (- 4)
[mk-app] #4771 = #4770 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4772
[mk-app] #4774 = #4772 #4771
[mk-proof] #4775 rewrite #4774
[instance] 0x0 #4774
[end-of-instance]
[mk-app] #4776 = #4745 #4771
[mk-proof] #4777 trans #4768 #4775 #4776
[mk-app] #4778 or #3101 #4771
[mk-app] #4779 or #3101 #4745
[mk-proof] #4784 quant-inst #4779
[mk-app] #4785 = #4779 #4778
[mk-proof] #4792 monotonicity #4777 #4785
[mk-app] #4793 = #4778 #4778
[mk-proof] #4811 rewrite #4793
[mk-proof] #4812 trans #4792 #4811 #4785
[mk-proof] #4807 mp #4784 #4812 #4778
[instance] 0x106891430 #4784 ; 68
[attach-enode] #2991 68
[attach-enode] #4534 68
[attach-enode] #4535 68
[attach-enode] #4769 68
[attach-enode] #4770 68
[attach-enode] #4771 68
[mk-app] #4808 <= #4770 #4108
[mk-app] #4809 >= #4770 #4108
[assign] #4771 justification -1: p51
[end-of-instance]
[assign] #4808 clause p356 (not p355)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[assign] #4809 clause p357 (not p355)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[mk-app] #4810 = #2991 #4214
[attach-meaning] #176 arith (- 1)
[mk-app] #4813 * #176 #4214
[mk-app] #4814 + #2991 #4813
[mk-app] #4815 <= #4814 #36
[mk-app] #4816 >= #4814 #36
[assign] #4810 justification -1: p353
[attach-enode] #4810 0
[attach-enode] #4813 0
[attach-enode] #4814 0
[assign] #4815 justification -1: p358
[assign] #4816 justification -1: p358
[new-match] 0x106891e78 #1495 #1483 #3677 #1545 ; #4534 (#4495 #4495)
[mk-app] #4817 = #4534 #3978
[mk-app] #4818 = #4534 #3984
[mk-app] #4823 = #4817 #4818
[mk-proof] #4824 monotonicity #4520 #4823
[mk-app] #4831 or #1563 #4818
[mk-app] #4832 or #1563 #4817
[mk-proof] #4850 quant-inst #4832
[mk-app] #4851 = #4832 #4831
[mk-proof] #4846 monotonicity #4824 #4851
[mk-app] #4847 = #4831 #4831
[mk-proof] #4848 rewrite #4847
[mk-proof] #4849 trans #4846 #4848 #4851
[mk-proof] #4852 mp #4850 #4849 #4831
[instance] 0x106891e78 #4850 ; 69
[attach-enode] #3981 69
[attach-enode] #3984 69
[attach-enode] #4818 69
[assign] #4818 justification -1: p50
[end-of-instance]
[eq-expl] #3981 root
[new-match] 0x106892118 #1477 #1476 #3981 #1545 ; #3984
[eq-expl] #4534 lit #4818 ; #3984
[eq-expl] #3984 root
[new-match] 0x106892150 #1522 #1506 #3981 #1545 ; #4535 (#4534 #3984)
[mk-app] #4853 = #3192 #3981
[mk-app] #4854 = #4853 #4853
[mk-proof] #4855 refl #4854
[mk-app] #4856 or #1576 #4853
[mk-proof] #4857 quant-inst #4856
[instance] 0x106892118 #4857 ; 70
[attach-enode] #3192 70
[attach-enode] #4853 70
[assign] #4853 justification -1: p49
[end-of-instance]
[mk-app] #4854 * #176 #3198
[mk-app] #4855 + #3195 #4854
[mk-app] #4862 = #4855 #1503
[mk-app] #4863 = #4862 #4862
[mk-proof] #4870 refl #4863
[mk-app] #4871 or #3101 #4862
[mk-proof] #4889 quant-inst #4871
[instance] 0x106892150 #4889 ; 70
[attach-enode] #3194 70
[attach-enode] #3195 70
[attach-enode] #3198 70
[attach-enode] #4854 70
[attach-enode] #4855 70
[attach-enode] #4862 70
[mk-app] #4890 <= #4855 #1503
[mk-app] #4885 >= #4855 #1503
[assign] #4862 justification -1: p51
[end-of-instance]
[assign] #4890 clause p364 (not p363)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[assign] #4885 clause p365 (not p363)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[mk-app] #4863 = #3198 #4535
[attach-meaning] #176 arith (- 1)
[mk-app] #4870 + #3198 #4769
[mk-app] #4886 <= #4870 #36
[mk-app] #4887 >= #4870 #36
[assign] #4863 justification -1: p361
[attach-enode] #4863 0
[attach-enode] #4870 0
[assign] #4886 justification -1: p366
[assign] #4887 justification -1: p366
[new-match] 0x10689a958 #1495 #1483 #3981 #1545 ; #3194 (#3984 #3984)
[mk-app] #4888 = #3194 #3214
[mk-app] #4891 = #3194 #3217
[mk-app] #4892 = #4888 #4891
[mk-proof] #4893 monotonicity #3221 #4892
[mk-app] #4894 or #1563 #4891
[mk-app] #4895 or #1563 #4888
[mk-proof] #4896 quant-inst #4895
[mk-app] #4901 = #4895 #4894
[mk-proof] #4902 monotonicity #4893 #4901
[mk-app] #4909 = #4894 #4894
[mk-proof] #4910 rewrite #4909
[mk-proof] #4928 trans #4902 #4910 #4901
[mk-proof] #4929 mp #4896 #4928 #4894
[instance] 0x10689a958 #4896 ; 71
[attach-enode] #3216 71
[attach-enode] #3217 71
[attach-enode] #4891 71
[assign] #4891 justification -1: p50
[end-of-instance]
[eq-expl] #3216 root
[new-match] 0x10689abf8 #1477 #1476 #3216 #1545 ; #3217
[eq-expl] #3194 lit #4891 ; #3217
[eq-expl] #3217 root
[new-match] 0x10689ac30 #1522 #1506 #3216 #1545 ; #3195 (#3194 #3217)
[mk-app] #4924 = #4114 #3216
[mk-app] #4925 = #4924 #4924
[mk-proof] #4926 refl #4925
[mk-app] #4927 or #1576 #4924
[mk-proof] #4930 quant-inst #4927
[instance] 0x10689abf8 #4930 ; 72
[attach-enode] #4114 72
[attach-enode] #4924 72
[assign] #4924 justification -1: p49
[end-of-instance]
[mk-app] #4925 * #176 #4124
[mk-app] #4926 + #4121 #4925
[mk-app] #4931 = #4926 #1503
[mk-app] #4932 = #4931 #4931
[mk-proof] #4933 refl #4932
[mk-app] #4934 or #3101 #4931
[mk-proof] #4935 quant-inst #4934
[instance] 0x10689ac30 #4935 ; 72
[attach-enode] #4116 72
[attach-enode] #4121 72
[attach-enode] #4124 72
[attach-enode] #4925 72
[attach-enode] #4926 72
[attach-enode] #4931 72
[mk-app] #4940 <= #4926 #1503
[mk-app] #4941 >= #4926 #1503
[assign] #4931 justification -1: p51
[end-of-instance]
[assign] #4940 clause p372 (not p371)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[assign] #4941 clause p373 (not p371)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[mk-app] #4932 = #3195 #4124
[attach-meaning] #176 arith (- 1)
[mk-app] #4933 + #3195 #4925
[mk-app] #4948 <= #4933 #36
[mk-app] #4949 >= #4933 #36
[assign] #4932 justification -1: p369
[attach-enode] #4932 0
[attach-enode] #4933 0
[assign] #4948 justification -1: p374
[assign] #4949 justification -1: p374
[new-match] 0x10689b5f0 #1495 #1483 #3216 #1545 ; #4116 (#3217 #3217)
[mk-app] #4967 = #4116 #3663
[mk-app] #4968 = #4116 #3652
[mk-app] #4963 = #4967 #4968
[mk-proof] #4964 monotonicity #3654 #4963
[mk-app] #4965 or #1563 #4968
[mk-app] #4966 or #1563 #4967
[mk-proof] #4969 quant-inst #4966
[mk-app] #4970 = #4966 #4965
[mk-proof] #4971 monotonicity #4964 #4970
[mk-app] #4972 = #4965 #4965
[mk-proof] #4973 rewrite #4972
[mk-proof] #4974 trans #4971 #4973 #4970
[mk-proof] #4979 mp #4969 #4974 #4965
[instance] 0x10689b5f0 #4969 ; 73
[attach-enode] #4506 73
[attach-enode] #3652 73
[attach-enode] #4968 73
[assign] #4968 justification -1: p50
[end-of-instance]
[eq-expl] #4506 root
[new-match] 0x10689b890 #1477 #1476 #4506 #1545 ; #3652
[eq-expl] #4116 lit #4968 ; #3652
[eq-expl] #3652 root
[new-match] 0x10689b8c8 #1522 #1506 #4506 #1545 ; #4121 (#4116 #3652)
[mk-app] #4980 = #4492 #4506
[mk-app] #4987 = #4980 #4980
[mk-proof] #4988 refl #4987
[mk-app] #5006 or #1576 #4980
[mk-proof] #5007 quant-inst #5006
[instance] 0x10689b890 #5007 ; 74
[attach-enode] #4492 74
[attach-enode] #4980 74
[assign] #4980 justification -1: p49
[end-of-instance]
[mk-app] #4987 * #176 #4597
[mk-app] #4988 + #4596 #4987
[mk-app] #5002 = #4988 #1503
[mk-app] #5003 = #5002 #5002
[mk-proof] #5004 refl #5003
[mk-app] #5005 or #3101 #5002
[mk-proof] #5008 quant-inst #5005
[instance] 0x10689b8c8 #5008 ; 74
[attach-enode] #4491 74
[attach-enode] #4596 74
[attach-enode] #4597 74
[attach-enode] #4987 74
[attach-enode] #4988 74
[attach-enode] #5002 74
[mk-app] #5009 <= #4988 #1503
[mk-app] #5010 >= #4988 #1503
[assign] #5002 justification -1: p51
[end-of-instance]
[assign] #5009 clause p380 (not p379)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[assign] #5010 clause p381 (not p379)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[mk-app] #5003 = #4121 #4597
[attach-meaning] #176 arith (- 1)
[mk-app] #5004 + #4121 #4987
[mk-app] #5011 <= #5004 #36
[mk-app] #5012 >= #5004 #36
[assign] #5003 justification -1: p377
[attach-enode] #5003 0
[attach-enode] #5004 0
[assign] #5011 justification -1: p382
[assign] #5012 justification -1: p382
[new-match] 0x10689c288 #1495 #1483 #4506 #1545 ; #4491 (#3652 #3652)
[mk-app] #5013 = #4491 #4604
[mk-app] #5018 = #4491 #4609
[mk-app] #5019 = #5013 #5018
[mk-proof] #5026 monotonicity #4611 #5019
[mk-app] #5027 or #1563 #5018
[mk-app] #5045 or #1563 #5013
[mk-proof] #5046 quant-inst #5045
[mk-app] #5041 = #5045 #5027
[mk-proof] #5042 monotonicity #5026 #5041
[mk-app] #5043 = #5027 #5027
[mk-proof] #5044 rewrite #5043
[mk-proof] #5047 trans #5042 #5044 #5041
[mk-proof] #5048 mp #5046 #5047 #5027
[instance] 0x10689c288 #5046 ; 75
[attach-enode] #4606 75
[attach-enode] #4609 75
[attach-enode] #5018 75
[assign] #5018 justification -1: p50
[end-of-instance]
[eq-expl] #4606 root
[new-match] 0x10684f560 #1477 #1476 #4606 #1545 ; #4609
[eq-expl] #4491 lit #5018 ; #4609
[eq-expl] #4609 root
[new-match] 0x10684f598 #1522 #1506 #4606 #1545 ; #4596 (#4491 #4609)
[mk-app] #5049 = #4624 #4606
[mk-app] #5050 = #5049 #5049
[mk-proof] #5051 refl #5050
[mk-app] #5052 or #1576 #5049
[mk-proof] #5057 quant-inst #5052
[instance] 0x10684f560 #5057 ; 76
[attach-enode] #4624 76
[attach-enode] #5049 76
[assign] #5049 justification -1: p49
[end-of-instance]
[mk-app] #5050 * #176 #4630
[mk-app] #5051 + #4627 #5050
[mk-app] #5058 = #5051 #1503
[mk-app] #5065 = #5058 #5058
[mk-proof] #5066 refl #5065
[mk-app] #5084 or #3101 #5058
[mk-proof] #5085 quant-inst #5084
[instance] 0x10684f598 #5085 ; 76
[attach-enode] #4626 76
[attach-enode] #4627 76
[attach-enode] #4630 76
[attach-enode] #5050 76
[attach-enode] #5051 76
[attach-enode] #5058 76
[mk-app] #5080 <= #5051 #1503
[mk-app] #5081 >= #5051 #1503
[assign] #5058 justification -1: p51
[end-of-instance]
[assign] #5080 clause p388 (not p387)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[assign] #5081 clause p389 (not p387)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[mk-app] #5065 = #4596 #4630
[attach-meaning] #176 arith (- 1)
[mk-app] #5066 + #4596 #5050
[mk-app] #5082 <= #5066 #36
[mk-app] #5083 >= #5066 #36
[assign] #5065 justification -1: p385
[attach-enode] #5065 0
[attach-enode] #5066 0
[assign] #5082 justification -1: p390
[assign] #5083 justification -1: p390
[new-match] 0x10684ff58 #1495 #1483 #4606 #1545 ; #4626 (#4609 #4609)
[mk-app] #5086 = #4626 #4643
[mk-app] #5087 = #4626 #4648
[mk-app] #5088 = #5086 #5087
[mk-proof] #5089 monotonicity #4650 #5088
[mk-app] #5090 or #1563 #5087
[mk-app] #5091 or #1563 #5086
[mk-proof] #5096 quant-inst #5091
[mk-app] #5097 = #5091 #5090
[mk-proof] #5104 monotonicity #5089 #5097
[mk-app] #5105 = #5090 #5090
[mk-proof] #3265 rewrite #5105
[mk-proof] #3266 trans #5104 #3265 #5097
[mk-proof] #3267 mp #5096 #3266 #5090
[instance] 0x10684ff58 #5096 ; 77
[attach-enode] #4645 77
[attach-enode] #4648 77
[attach-enode] #5087 77
[assign] #5087 justification -1: p50
[end-of-instance]
[eq-expl] #4645 root
[new-match] 0x1068501f8 #1477 #1476 #4645 #1545 ; #4648
[eq-expl] #4626 lit #5087 ; #4648
[eq-expl] #4648 root
[new-match] 0x106850230 #1522 #1506 #4645 #1545 ; #4627 (#4626 #4648)
[mk-app] #3980 = #4663 #4645
[mk-app] #2934 = #3980 #3980
[mk-proof] #2935 refl #2934
[mk-app] #2936 or #1576 #3980
[mk-proof] #3154 quant-inst #2936
[instance] 0x1068501f8 #3154 ; 78
[attach-enode] #4663 78
[attach-enode] #3980 78
[assign] #3980 justification -1: p49
[end-of-instance]
[mk-app] #2934 * #176 #4669
[mk-app] #2935 + #4666 #2934
[mk-app] #4173 = #2935 #1503
[mk-app] #3975 = #4173 #4173
[mk-proof] #3272 refl #3975
[mk-app] #3159 or #3101 #4173
[mk-proof] #4085 quant-inst #3159
[instance] 0x106850230 #4085 ; 78
[attach-enode] #4665 78
[attach-enode] #4666 78
[attach-enode] #4669 78
[attach-enode] #2934 78
[attach-enode] #2935 78
[attach-enode] #4173 78
[mk-app] #4068 <= #2935 #1503
[mk-app] #3062 >= #2935 #1503
[assign] #4173 justification -1: p51
[end-of-instance]
[assign] #4068 clause p396 (not p395)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[assign] #3062 clause p397 (not p395)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[mk-app] #3975 = #4627 #4669
[attach-meaning] #176 arith (- 1)
[mk-app] #3272 + #4627 #2934
[mk-app] #4099 <= #3272 #36
[mk-app] #3100 >= #3272 #36
[assign] #3975 justification -1: p393
[attach-enode] #3975 0
[attach-enode] #3272 0
[assign] #4099 justification -1: p398
[assign] #3100 justification -1: p398
[new-match] 0x106850bf0 #1495 #1483 #4645 #1545 ; #4665 (#4648 #4648)
[mk-app] #3063 = #4665 #4682
[mk-app] #4006 = #4665 #4687
[mk-app] #3814 = #3063 #4006
[mk-proof] #3815 monotonicity #4689 #3814
[mk-app] #3394 or #1563 #4006
[mk-app] #3811 or #1563 #3063
[mk-proof] #3816 quant-inst #3811
[mk-app] #3817 = #3811 #3394
[mk-proof] #4316 monotonicity #3815 #3817
[mk-app] #3890 = #3394 #3394
[mk-proof] #3891 rewrite #3890
[mk-proof] #3892 trans #4316 #3891 #3817
[mk-proof] #3893 mp #3816 #3892 #3394
[instance] 0x106850bf0 #3816 ; 79
[attach-enode] #4684 79
[attach-enode] #4687 79
[attach-enode] #4006 79
[assign] #4006 justification -1: p50
[end-of-instance]
[eq-expl] #4684 root
[new-match] 0x106850e90 #1477 #1476 #4684 #1545 ; #4687
[eq-expl] #4665 lit #4006 ; #4687
[eq-expl] #4687 root
[new-match] 0x106850ec8 #1522 #1506 #4684 #1545 ; #4666 (#4665 #4687)
[mk-app] #3894 = #4702 #4684
[mk-app] #4439 = #3894 #3894
[mk-proof] #3646 refl #4439
[mk-app] #3647 or #1576 #3894
[mk-proof] #4518 quant-inst #3647
[instance] 0x106850e90 #4518 ; 80
[attach-enode] #4702 80
[attach-enode] #3894 80
[assign] #3894 justification -1: p49
[end-of-instance]
[mk-app] #4439 * #176 #4708
[mk-app] #3646 + #4705 #4439
[mk-app] #4519 = #3646 #1503
[mk-app] #3648 = #4519 #4519
[mk-proof] #3649 refl #3648
[mk-app] #4354 or #3101 #4519
[mk-proof] #4356 quant-inst #4354
[instance] 0x106850ec8 #4356 ; 80
[attach-enode] #4704 80
[attach-enode] #4705 80
[attach-enode] #4708 80
[attach-enode] #4439 80
[attach-enode] #3646 80
[attach-enode] #4519 80
[mk-app] #3852 <= #3646 #1503
[mk-app] #4350 >= #3646 #1503
[assign] #4519 justification -1: p51
[end-of-instance]
[assign] #3852 clause p404 (not p403)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[assign] #4350 clause p405 (not p403)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[mk-app] #3648 = #4666 #4708
[attach-meaning] #176 arith (- 1)
[mk-app] #3649 + #4666 #4439
[mk-app] #4357 <= #3649 #36
[mk-app] #4358 >= #3649 #36
[assign] #3648 justification -1: p401
[attach-enode] #3648 0
[attach-enode] #3649 0
[assign] #4357 justification -1: p406
[assign] #4358 justification -1: p406
[new-match] 0x10686e6a8 #1495 #1483 #4684 #1545 ; #4704 (#4687 #4687)
[mk-app] #3243 = #4704 #4721
[mk-app] #3246 = #4704 #4726
[mk-app] #3241 = #3243 #3246
[mk-proof] #3242 monotonicity #4728 #3241
[mk-app] #3247 or #1563 #3246
[mk-app] #3248 or #1563 #3243
[mk-proof] #3756 quant-inst #3248
[mk-app] #3690 = #3248 #3247
[mk-proof] #3691 monotonicity #3242 #3690
[mk-app] #3686 = #3247 #3247
[mk-proof] #3687 rewrite #3686
[mk-proof] #3692 trans #3691 #3687 #3690
[mk-proof] #3953 mp #3756 #3692 #3247
[instance] 0x10686e6a8 #3756 ; 81
[attach-enode] #4723 81
[attach-enode] #4726 81
[attach-enode] #3246 81
[assign] #3246 justification -1: p50
[end-of-instance]
[eq-expl] #4723 root
[new-match] 0x10686e948 #1477 #1476 #4723 #1545 ; #4726
[eq-expl] #4704 lit #3246 ; #4726
[eq-expl] #4726 root
[new-match] 0x10686e980 #1522 #1506 #4723 #1545 ; #4705 (#4704 #4726)
[mk-app] #3278 = #4741 #4723
[mk-app] #3281 = #3278 #3278
[mk-proof] #3276 refl #3281
[mk-app] #3277 or #1576 #3278
[mk-proof] #3282 quant-inst #3277
[instance] 0x10686e948 #3282 ; 82
[attach-enode] #4741 82
[attach-enode] #3278 82
[assign] #3278 justification -1: p49
[end-of-instance]
[mk-app] #3281 * #176 #4747
[mk-app] #3276 + #4744 #3281
[mk-app] #3283 = #3276 #1503
[mk-app] #3763 = #3283 #3283
[mk-proof] #2939 refl #3763
[mk-app] #2940 or #3101 #3283
[mk-proof] #2942 quant-inst #2940
[instance] 0x10686e980 #2942 ; 82
[attach-enode] #4743 82
[attach-enode] #4744 82
[attach-enode] #4747 82
[attach-enode] #3281 82
[attach-enode] #3276 82
[attach-enode] #3283 82
[mk-app] #2943 <= #3276 #1503
[mk-app] #2944 >= #3276 #1503
[assign] #3283 justification -1: p51
[end-of-instance]
[assign] #2943 clause p412 (not p411)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[assign] #2944 clause p413 (not p411)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[mk-app] #3763 = #4705 #4747
[attach-meaning] #176 arith (- 1)
[mk-app] #2939 + #4705 #3281
[mk-app] #2945 <= #2939 #36
[mk-app] #3097 >= #2939 #36
[assign] #3763 justification -1: p409
[attach-enode] #3763 0
[attach-enode] #2939 0
[assign] #2945 justification -1: p414
[assign] #3097 justification -1: p414
[new-match] 0x10686f340 #1495 #1483 #4723 #1545 ; #4743 (#4726 #4726)
[mk-app] #3098 = #4743 #4760
[mk-app] #3093 = #4743 #4765
[mk-app] #3094 = #3098 #3093
[mk-proof] #3099 monotonicity #4767 #3094
[mk-app] #3103 or #1563 #3093
[mk-app] #4066 or #1563 #3098
[mk-proof] #4067 quant-inst #4066
[mk-app] #4061 = #4066 #3103
[mk-proof] #4062 monotonicity #3099 #4061
[mk-app] #4069 = #3103 #3103
[mk-proof] #4070 rewrite #4069
[mk-proof] #3362 trans #4062 #4070 #4061
[mk-proof] #3363 mp #4067 #3362 #3103
[instance] 0x10686f340 #4067 ; 83
[attach-enode] #4762 83
[attach-enode] #4765 83
[attach-enode] #3093 83
[assign] #3093 justification -1: p50
[end-of-instance]
[eq-expl] #4762 root
[new-match] 0x10686f5e0 #1477 #1476 #4762 #1545 ; #4765
[eq-expl] #4743 lit #3093 ; #4765
[eq-expl] #4765 root
[new-match] 0x10686f618 #1522 #1506 #4762 #1545 ; #4744 (#4743 #4765)
[mk-app] #3357 = #4780 #4762
[mk-app] #3358 = #3357 #3357
[mk-proof] #3361 refl #3358
[mk-app] #3364 or #1576 #3357
[mk-proof] #3365 quant-inst #3364
[instance] 0x10686f5e0 #3365 ; 84
[attach-enode] #4780 84
[attach-enode] #3357 84
[assign] #3357 justification -1: p49
[end-of-instance]
[mk-app] #3358 * #176 #4786
[mk-app] #3361 + #4783 #3358
[mk-app] #2947 = #3361 #1503
[mk-app] #2948 = #2947 #2947
[mk-proof] #4245 refl #2948
[mk-app] #4246 or #3101 #2947
[mk-proof] #2949 quant-inst #4246
[instance] 0x10686f618 #2949 ; 84
[attach-enode] #4782 84
[attach-enode] #4783 84
[attach-enode] #4786 84
[attach-enode] #3358 84
[attach-enode] #3361 84
[attach-enode] #2947 84
[mk-app] #2950 <= #3361 #1503
[mk-app] #3564 >= #3361 #1503
[assign] #2947 justification -1: p51
[end-of-instance]
[assign] #2950 clause p420 (not p419)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[assign] #3564 clause p421 (not p419)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[mk-app] #2948 = #4744 #4786
[attach-meaning] #176 arith (- 1)
[mk-app] #4245 + #4744 #3358
[mk-app] #3565 <= #4245 #36
[mk-app] #3557 >= #4245 #36
[assign] #2948 justification -1: p417
[attach-enode] #2948 0
[attach-enode] #4245 0
[assign] #3565 justification -1: p422
[assign] #3557 justification -1: p422
[new-match] 0x10686ffd8 #1495 #1483 #4762 #1545 ; #4782 (#4765 #4765)
[mk-app] #3558 = #4782 #4799
[mk-app] #3566 = #4782 #4804
[mk-app] #3567 = #3558 #3566
[mk-proof] #3036 monotonicity #4806 #3567
[mk-app] #3038 or #1563 #3566
[mk-app] #3032 or #1563 #3558
[mk-proof] #3033 quant-inst #3032
[mk-app] #3039 = #3032 #3038
[mk-proof] #3037 monotonicity #3036 #3039
[mk-app] #3040 = #3038 #3038
[mk-proof] #4497 rewrite #3040
[mk-proof] #3634 trans #3037 #4497 #3039
[mk-proof] #4014 mp #3033 #3634 #3038
[instance] 0x10686ffd8 #3033 ; 85
[attach-enode] #4801 85
[attach-enode] #4804 85
[attach-enode] #3566 85
[assign] #3566 justification -1: p50
[end-of-instance]
[eq-expl] #4801 root
[new-match] 0x1068b1890 #1477 #1476 #4801 #1545 ; #4804
[eq-expl] #4782 lit #3566 ; #4804
[eq-expl] #4804 root
[new-match] 0x1068b18c8 #1522 #1506 #4801 #1545 ; #4783 (#4782 #4804)
[mk-app] #4015 = #4819 #4801
[mk-app] #3635 = #4015 #4015
[mk-proof] #3626 refl #3635
[mk-app] #3379 or #1576 #4015
[mk-proof] #3377 quant-inst #3379
[instance] 0x1068b1890 #3377 ; 86
[attach-enode] #4819 86
[attach-enode] #4015 86
[assign] #4015 justification -1: p49
[end-of-instance]
[mk-app] #3635 * #176 #4825
[mk-app] #3626 + #4822 #3635
[mk-app] #3374 = #3626 #1503
[mk-app] #3375 = #3374 #3374
[mk-proof] #3380 refl #3375
[mk-app] #3381 or #3101 #3374
[mk-proof] #3382 quant-inst #3381
[instance] 0x1068b18c8 #3382 ; 86
[attach-enode] #4821 86
[attach-enode] #4822 86
[attach-enode] #4825 86
[attach-enode] #3635 86
[attach-enode] #3626 86
[attach-enode] #3374 86
[mk-app] #3826 <= #3626 #1503
[mk-app] #3827 >= #3626 #1503
[assign] #3374 justification -1: p51
[end-of-instance]
[assign] #3826 clause p428 (not p427)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[assign] #3827 clause p429 (not p427)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[mk-app] #3375 = #4783 #4825
[attach-meaning] #176 arith (- 1)
[mk-app] #3380 + #4783 #3635
[mk-app] #4301 <= #3380 #36
[mk-app] #4552 >= #3380 #36
[assign] #3375 justification -1: p425
[attach-enode] #3375 0
[attach-enode] #3380 0
[assign] #4301 justification -1: p430
[assign] #4552 justification -1: p430
[new-match] 0x1068b2288 #1495 #1483 #4801 #1545 ; #4821 (#4804 #4804)
[mk-app] #3828 = #4821 #4838
[mk-app] #3829 = #4821 #4843
[mk-app] #3149 = #3828 #3829
[mk-proof] #3150 monotonicity #4845 #3149
[mk-app] #3145 or #1563 #3829
[mk-app] #3146 or #1563 #3828
[mk-proof] #3151 quant-inst #3146
[mk-app] #3155 = #3146 #3145
[mk-proof] #3156 monotonicity #3150 #3155
[mk-app] #4084 = #3145 #3145
[mk-proof] #4089 rewrite #4084
[mk-proof] #4080 trans #3156 #4089 #3155
[mk-proof] #4081 mp #3151 #4080 #3145
[instance] 0x1068b2288 #3151 ; 87
[attach-enode] #4840 87
[attach-enode] #4843 87
[attach-enode] #3829 87
[assign] #3829 justification -1: p50
[end-of-instance]
[eq-expl] #4840 root
[new-match] 0x1068b2528 #1477 #1476 #4840 #1545 ; #4843
[eq-expl] #4821 lit #3829 ; #4843
[eq-expl] #4843 root
[new-match] 0x1068b2560 #1522 #1506 #4840 #1545 ; #4822 (#4821 #4843)
[mk-app] #4090 = #4858 #4840
[mk-app] #4091 = #4090 #4090
[mk-proof] #3534 refl #4091
[mk-app] #3535 or #1576 #4090
[mk-proof] #3530 quant-inst #3535
[instance] 0x1068b2528 #3530 ; 88
[attach-enode] #4858 88
[attach-enode] #4090 88
[assign] #4090 justification -1: p49
[end-of-instance]
[mk-app] #4091 * #176 #4864
[mk-app] #3534 + #4861 #4091
[mk-app] #3531 = #3534 #1503
[mk-app] #3536 = #3531 #3531
[mk-proof] #3537 refl #3536
[mk-app] #3538 or #3101 #3531
[mk-proof] #3423 quant-inst #3538
[instance] 0x1068b2560 #3423 ; 88
[attach-enode] #4860 88
[attach-enode] #4861 88
[attach-enode] #4864 88
[attach-enode] #4091 88
[attach-enode] #3534 88
[attach-enode] #3531 88
[mk-app] #3424 <= #3534 #1503
[mk-app] #4547 >= #3534 #1503
[assign] #3531 justification -1: p51
[end-of-instance]
[assign] #3424 clause p436 (not p435)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[assign] #4547 clause p437 (not p435)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[mk-app] #3536 = #4822 #4864
[attach-meaning] #176 arith (- 1)
[mk-app] #3537 + #4822 #4091
[mk-app] #3420 <= #3537 #36
[mk-app] #3425 >= #3537 #36
[assign] #3536 justification -1: p433
[attach-enode] #3536 0
[attach-enode] #3537 0
[assign] #3420 justification -1: p438
[assign] #3425 justification -1: p438
[new-match] 0x1068b2f20 #1495 #1483 #4840 #1545 ; #4860 (#4843 #4843)
[mk-app] #3428 = #4860 #4877
[mk-app] #4372 = #4860 #4882
[mk-app] #4373 = #3428 #4372
[mk-proof] #4368 monotonicity #4884 #4373
[mk-app] #4369 or #1563 #4372
[mk-app] #4374 or #1563 #3428
[mk-proof] #4375 quant-inst #4374
[mk-app] #4377 = #4374 #4369
[mk-proof] #4478 monotonicity #4368 #4377
[mk-app] #4479 = #4369 #4369
[mk-proof] #3907 rewrite #4479
[mk-proof] #3908 trans #4478 #3907 #4377
[mk-proof] #4481 mp #4375 #3908 #4369
[instance] 0x1068b2f20 #4375 ; 89
[attach-enode] #4879 89
[attach-enode] #4882 89
[attach-enode] #4372 89
[assign] #4372 justification -1: p50
[end-of-instance]
[eq-expl] #4879 root
[new-match] 0x1068b31c0 #1477 #1476 #4879 #1545 ; #4882
[eq-expl] #4860 lit #4372 ; #4882
[eq-expl] #4882 root
[new-match] 0x1068b31f8 #1522 #1506 #4879 #1545 ; #4861 (#4860 #4882)
[mk-app] #4482 = #4897 #4879
[mk-app] #4554 = #4482 #4482
[mk-proof] #4555 refl #4554
[mk-app] #4312 or #1576 #4482
[mk-proof] #4313 quant-inst #4312
[instance] 0x1068b31c0 #4313 ; 90
[attach-enode] #4897 90
[attach-enode] #4482 90
[assign] #4482 justification -1: p49
[end-of-instance]
[mk-app] #4554 * #176 #4903
[mk-app] #4555 + #4900 #4554
[mk-app] #2911 = #4555 #1503
[mk-app] #2912 = #2911 #2911
[mk-proof] #3937 refl #2912
[mk-app] #3939 or #3101 #2911
[mk-proof] #3933 quant-inst #3939
[instance] 0x1068b31f8 #3933 ; 90
[attach-enode] #4899 90
[attach-enode] #4900 90
[attach-enode] #4903 90
[attach-enode] #4554 90
[attach-enode] #4555 90
[attach-enode] #2911 90
[mk-app] #3934 <= #4555 #1503
[mk-app] #3940 >= #4555 #1503
[assign] #2911 justification -1: p51
[end-of-instance]
[assign] #3934 clause p444 (not p443)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[assign] #3940 clause p445 (not p443)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[mk-app] #2912 = #4861 #4903
[attach-meaning] #176 arith (- 1)
[mk-app] #3937 + #4861 #4554
[mk-app] #3941 <= #3937 #36
[mk-app] #3942 >= #3937 #36
[assign] #2912 justification -1: p441
[attach-enode] #2912 0
[attach-enode] #3937 0
[assign] #3941 justification -1: p446
[assign] #3942 justification -1: p446
[new-match] 0x1068ba9e8 #1495 #1483 #4879 #1545 ; #4899 (#4882 #4882)
[mk-app] #3457 = #4899 #4916
[mk-app] #3860 = #4899 #4921
[mk-app] #3861 = #3457 #3860
[mk-proof] #3862 monotonicity #4923 #3861
[mk-app] #3863 or #1563 #3860
[mk-app] #3864 or #1563 #3457
[mk-proof] #3865 quant-inst #3864
[mk-app] #3845 = #3864 #3863
[mk-proof] #4568 monotonicity #3862 #3845
[mk-app] #4569 = #3863 #3863
[mk-proof] #3881 rewrite #4569
[mk-proof] #3882 trans #4568 #3881 #3845
[mk-proof] #3883 mp #3865 #3882 #3863
[instance] 0x1068ba9e8 #3865 ; 91
[attach-enode] #4918 91
[attach-enode] #4921 91
[attach-enode] #3860 91
[assign] #3860 justification -1: p50
[end-of-instance]
[eq-expl] #4918 root
[new-match] 0x1068bac88 #1477 #1476 #4918 #1545 ; #4921
[eq-expl] #4899 lit #3860 ; #4921
[eq-expl] #4921 root
[new-match] 0x1068bacc0 #1522 #1506 #4918 #1545 ; #4900 (#4899 #4921)
[mk-app] #3481 = #4936 #4918
[mk-app] #3483 = #3481 #3481
[mk-proof] #3477 refl #3483
[mk-app] #3478 or #1576 #3481
[mk-proof] #3484 quant-inst #3478
[instance] 0x1068bac88 #3484 ; 92
[attach-enode] #4936 92
[attach-enode] #3481 92
[assign] #3481 justification -1: p49
[end-of-instance]
[mk-app] #3483 * #176 #4942
[mk-app] #3477 + #4939 #3483
[mk-app] #3482 = #3477 #1503
[mk-app] #3074 = #3482 #3482
[mk-proof] #3076 refl #3074
[mk-app] #3077 or #3101 #3482
[mk-proof] #3075 quant-inst #3077
[instance] 0x1068bacc0 #3075 ; 92
[attach-enode] #4938 92
[attach-enode] #4939 92
[attach-enode] #4942 92
[attach-enode] #3483 92
[attach-enode] #3477 92
[attach-enode] #3482 92
[mk-app] #3078 <= #3477 #1503
[mk-app] #3079 >= #3477 #1503
[assign] #3482 justification -1: p51
[end-of-instance]
[assign] #3078 clause p452 (not p451)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[assign] #3079 clause p453 (not p451)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[mk-app] #3074 = #4900 #4942
[attach-meaning] #176 arith (- 1)
[mk-app] #3076 + #4900 #3483
[mk-app] #3284 <= #3076 #36
[mk-app] #3285 >= #3076 #36
[assign] #3074 justification -1: p449
[attach-enode] #3074 0
[attach-enode] #3076 0
[assign] #3284 justification -1: p454
[assign] #3285 justification -1: p454
[new-match] 0x1068bb680 #1495 #1483 #4918 #1545 ; #4938 (#4921 #4921)
[mk-app] #4046 = #4938 #4955
[mk-app] #4047 = #4938 #4960
[mk-app] #3286 = #4046 #4047
[mk-proof] #3287 monotonicity #4962 #3286
[mk-app] #3777 or #1563 #4047
[mk-app] #3778 or #1563 #4046
[mk-proof] #3322 quant-inst #3778
[mk-app] #3323 = #3778 #3777
[mk-proof] #3779 monotonicity #3287 #3323
[mk-app] #3780 = #3777 #3777
[mk-proof] #3781 rewrite #3780
[mk-proof] #4576 trans #3779 #3781 #3323
[mk-proof] #4577 mp #3322 #4576 #3777
[instance] 0x1068bb680 #3322 ; 93
[attach-enode] #4957 93
[attach-enode] #4960 93
[attach-enode] #4047 93
[assign] #4047 justification -1: p50
[end-of-instance]
[eq-expl] #4957 root
[new-match] 0x1068bb920 #1477 #1476 #4957 #1545 ; #4960
[eq-expl] #4938 lit #4047 ; #4960
[eq-expl] #4960 root
[new-match] 0x1068bb958 #1522 #1506 #4957 #1545 ; #4939 (#4938 #4960)
[mk-app] #3877 = #4975 #4957
[mk-app] #3878 = #3877 #3877
[mk-proof] #3672 refl #3878
[mk-app] #3673 or #1576 #3877
[mk-proof] #3969 quant-inst #3673
[instance] 0x1068bb920 #3969 ; 94
[attach-enode] #4975 94
[attach-enode] #3877 94
[assign] #3877 justification -1: p49
[end-of-instance]
[mk-app] #3878 * #176 #4981
[mk-app] #3672 + #4978 #3878
[mk-app] #3970 = #3672 #1503
[mk-app] #3971 = #3970 #3970
[mk-proof] #3972 refl #3971
[mk-app] #3973 or #3101 #3970
[mk-proof] #3974 quant-inst #3973
[instance] 0x1068bb958 #3974 ; 94
[attach-enode] #4977 94
[attach-enode] #4978 94
[attach-enode] #4981 94
[attach-enode] #3878 94
[attach-enode] #3672 94
[attach-enode] #3970 94
[mk-app] #3976 <= #3672 #1503
[mk-app] #3209 >= #3672 #1503
[assign] #3970 justification -1: p51
[end-of-instance]
[assign] #3976 clause p460 (not p459)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[assign] #3209 clause p461 (not p459)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[mk-app] #3971 = #4939 #4981
[attach-meaning] #176 arith (- 1)
[mk-app] #3972 + #4939 #3878
[mk-app] #3210 <= #3972 #36
[mk-app] #3204 >= #3972 #36
[assign] #3971 justification -1: p457
[attach-enode] #3971 0
[attach-enode] #3972 0
[assign] #3210 justification -1: p462
[assign] #3204 justification -1: p462
[new-match] 0x1068bc318 #1495 #1483 #4957 #1545 ; #4977 (#4960 #4960)
[mk-app] #3206 = #4977 #4994
[mk-app] #3211 = #4977 #4999
[mk-app] #3212 = #3206 #3211
[mk-proof] #3658 monotonicity #5001 #3212
[mk-app] #3659 or #1563 #3211
[mk-app] #4129 or #1563 #3206
[mk-proof] #4130 quant-inst #4129
[mk-app] #3660 = #4129 #3659
[mk-proof] #3661 monotonicity #3658 #3660
[mk-app] #4599 = #3659 #3659
[mk-proof] #4600 rewrite #4599
[mk-proof] #4487 trans #3661 #4600 #3660
[mk-proof] #4488 mp #4130 #4487 #3659
[instance] 0x1068bc318 #4130 ; 95
[attach-enode] #4996 95
[attach-enode] #4999 95
[attach-enode] #3211 95
[assign] #3211 justification -1: p50
[end-of-instance]
[eq-expl] #4996 root
[new-match] 0x1068bc5b8 #1477 #1476 #4996 #1545 ; #4999
[eq-expl] #4977 lit #3211 ; #4999
[eq-expl] #4999 root
[new-match] 0x1068cdc10 #1522 #1506 #4996 #1545 ; #4978 (#4977 #4999)
[mk-app] #4601 = #5014 #4996
[mk-app] #4602 = #4601 #4601
[mk-proof] #4638 refl #4602
[mk-app] #4639 or #1576 #4601
[mk-proof] #4634 quant-inst #4639
[instance] 0x1068bc5b8 #4634 ; 96
[attach-enode] #5014 96
[attach-enode] #4601 96
[assign] #4601 justification -1: p49
[end-of-instance]
[mk-app] #4602 * #176 #5020
[mk-app] #4638 + #5017 #4602
[mk-app] #4635 = #4638 #1503
[mk-app] #4640 = #4635 #4635
[mk-proof] #4641 refl #4640
[mk-app] #4677 or #3101 #4635
[mk-proof] #4678 quant-inst #4677
[instance] 0x1068cdc10 #4678 ; 96
[attach-enode] #5016 96
[attach-enode] #5017 96
[attach-enode] #5020 96
[attach-enode] #4602 96
[attach-enode] #4638 96
[attach-enode] #4635 96
[mk-app] #4673 <= #4638 #1503
[mk-app] #4674 >= #4638 #1503
[assign] #4635 justification -1: p51
[end-of-instance]
[assign] #4673 clause p468 (not p467)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[assign] #4674 clause p469 (not p467)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[mk-app] #4640 = #4978 #5020
[attach-meaning] #176 arith (- 1)
[mk-app] #4641 + #4978 #4602
[mk-app] #4679 <= #4641 #36
[mk-app] #4680 >= #4641 #36
[assign] #4640 justification -1: p465
[attach-enode] #4640 0
[attach-enode] #4641 0
[assign] #4679 justification -1: p470
[assign] #4680 justification -1: p470
[new-match] 0x1068ce5d0 #1495 #1483 #4996 #1545 ; #5016 (#4999 #4999)
[mk-app] #4716 = #5016 #5033
[mk-app] #4717 = #5016 #5038
[mk-app] #4712 = #4716 #4717
[mk-proof] #4713 monotonicity #5040 #4712
[mk-app] #4718 or #1563 #4717
[mk-app] #4719 or #1563 #4716
[mk-proof] #4755 quant-inst #4719
[mk-app] #4756 = #4719 #4718
[mk-proof] #4751 monotonicity #4713 #4756
[mk-app] #4752 = #4718 #4718
[mk-proof] #4757 rewrite #4752
[mk-proof] #4758 trans #4751 #4757 #4756
[mk-proof] #4794 mp #4755 #4758 #4718
[instance] 0x1068ce5d0 #4755 ; 97
[attach-enode] #5035 97
[attach-enode] #5038 97
[attach-enode] #4717 97
[assign] #4717 justification -1: p50
[end-of-instance]
[eq-expl] #5035 root
[new-match] 0x1068ce870 #1477 #1476 #5035 #1545 ; #5038
[eq-expl] #5016 lit #4717 ; #5038
[eq-expl] #5038 root
[new-match] 0x1068ce8a8 #1522 #1506 #5035 #1545 ; #5017 (#5016 #5038)
[mk-app] #4795 = #5053 #5035
[mk-app] #4790 = #4795 #4795
[mk-proof] #4791 refl #4790
[mk-app] #4796 or #1576 #4795
[mk-proof] #4797 quant-inst #4796
[instance] 0x1068ce870 #4797 ; 98
[attach-enode] #5053 98
[attach-enode] #4795 98
[assign] #4795 justification -1: p49
[end-of-instance]
[mk-app] #4790 * #176 #5059
[mk-app] #4791 + #5056 #4790
[mk-app] #4833 = #4791 #1503
[mk-app] #4834 = #4833 #4833
[mk-proof] #4829 refl #4834
[mk-app] #4830 or #3101 #4833
[mk-proof] #4835 quant-inst #4830
[instance] 0x1068ce8a8 #4835 ; 98
[attach-enode] #5055 98
[attach-enode] #5056 98
[attach-enode] #5059 98
[attach-enode] #4790 98
[attach-enode] #4791 98
[attach-enode] #4833 98
[mk-app] #4836 <= #4791 #1503
[mk-app] #4872 >= #4791 #1503
[assign] #4833 justification -1: p51
[end-of-instance]
[assign] #4836 clause p476 (not p475)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[assign] #4872 clause p477 (not p475)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[mk-app] #4834 = #5017 #5059
[attach-meaning] #176 arith (- 1)
[mk-app] #4829 + #5017 #4790
[mk-app] #4873 <= #4829 #36
[mk-app] #4868 >= #4829 #36
[assign] #4834 justification -1: p473
[attach-enode] #4834 0
[attach-enode] #4829 0
[assign] #4873 justification -1: p478
[assign] #4868 justification -1: p478
[new-match] 0x1068cf268 #1495 #1483 #5035 #1545 ; #5055 (#5038 #5038)
[mk-app] #4869 = #5055 #5072
[mk-app] #4874 = #5055 #5077
[mk-app] #4875 = #4869 #4874
[mk-proof] #4911 monotonicity #5079 #4875
[mk-app] #4912 or #1563 #4874
[mk-app] #4907 or #1563 #4869
[mk-proof] #4908 quant-inst #4907
[mk-app] #4913 = #4907 #4912
[mk-proof] #4914 monotonicity #4911 #4913
[mk-app] #4950 = #4912 #4912
[mk-proof] #4951 rewrite #4950
[mk-proof] #4946 trans #4914 #4951 #4913
[mk-proof] #4947 mp #4908 #4946 #4912
[instance] 0x1068cf268 #4908 ; 99
[attach-enode] #5074 99
[attach-enode] #5077 99
[attach-enode] #4874 99
[assign] #4874 justification -1: p50
[end-of-instance]
[eq-expl] #5074 root
[new-match] 0x1068cf508 #1477 #1476 #5074 #1545 ; #5077
[eq-expl] #5055 lit #4874 ; #5077
[eq-expl] #5077 root
[new-match] 0x1068cf540 #1522 #1506 #5074 #1545 ; #5056 (#5055 #5077)
[mk-app] #4952 = #5092 #5074
[mk-app] #4953 = #4952 #4952
[mk-proof] #4989 refl #4953
[mk-app] #4990 or #1576 #4952
[mk-proof] #4985 quant-inst #4990
[instance] 0x1068cf508 #4985 ; 100
[attach-enode] #5092 100
[attach-enode] #4952 100
[assign] #4952 justification -1: p49
[end-of-instance]
[mk-app] #4953 * #176 #5098
[mk-app] #4989 + #5095 #4953
[mk-app] #4986 = #4989 #1503
[mk-app] #4991 = #4986 #4986
[mk-proof] #4992 refl #4991
[mk-app] #5028 or #3101 #4986
[mk-proof] #5029 quant-inst #5028
[instance] 0x1068cf540 #5029 ; 100
[attach-enode] #5094 100
[attach-enode] #5095 100
[attach-enode] #5098 100
[attach-enode] #4953 100
[attach-enode] #4989 100
[attach-enode] #4986 100
[mk-app] #5024 <= #4989 #1503
[mk-app] #5025 >= #4989 #1503
[assign] #4986 justification -1: p51
[end-of-instance]
[assign] #5024 clause p484 (not p483)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[assign] #5025 clause p485 (not p483)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[mk-app] #4991 = #5056 #5098
[attach-meaning] #176 arith (- 1)
[mk-app] #4992 + #5056 #4953
[mk-app] #5030 <= #4992 #36
[mk-app] #5031 >= #4992 #36
[assign] #4991 justification -1: p481
[attach-enode] #4991 0
[attach-enode] #4992 0
[assign] #5030 justification -1: p486
[assign] #5031 justification -1: p486
[new-match] 0x1068e2d10 #1495 #1483 #5074 #1545 ; #5094 (#5077 #5077)
[decide-and-or] #2170 #2177
[push] 3
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 4
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[new-match] 0x1068e4178 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e41b0 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e41e8 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4228 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4268 #124 #118 #1528 ; #3402
[new-match] 0x1068e4298 #143 #118 #1528 ; #3402
[new-match] 0x1068e42c8 #237 #229 #3402 #36 ; #3403
[mk-app] #5067 * #176 #4347
[mk-app] #5068 + #3403 #5110 #5067
[mk-app] #5063 = #5068 #36
[mk-app] #5064 + #5110 #3403 #5067
[inst-discovered] theory-solving 0x0 arith# ; #5068
[mk-app] #5069 = #5068 #5064
[mk-proof] #5070 rewrite #5069
[instance] 0x0 #5069
[end-of-instance]
[mk-app] #5106 = #5064 #36
[mk-app] #5107 = #5063 #5106
[mk-proof] #5102 monotonicity #5070 #5107
[attach-meaning] #176 arith (- 1)
[mk-app] #5103 + #3402 #5120 #4347
[mk-app] #5108 = #5103 #36
[inst-discovered] theory-solving 0x0 arith# ; #5106
[mk-app] #5109 = #5106 #5108
[mk-proof] #2190 rewrite #5109
[instance] 0x0 #5109
[end-of-instance]
[mk-app] #5127 = #5063 #5108
[mk-proof] #5129 trans #5102 #2190 #5127
[mk-app] #5130 not #263
[mk-app] #5114 or #5130 #5108
[mk-app] #5115 or #5130 #5063
[mk-proof] #5116 quant-inst #5115
[mk-app] #5117 = #5115 #5114
[mk-proof] #5118 monotonicity #5129 #5117
[mk-app] #5119 = #5114 #5114
[mk-proof] #5121 rewrite #5119
[mk-proof] #5122 trans #5118 #5121 #5117
[mk-proof] #5123 mp #5116 #5122 #5114
[instance] 0x1068e4178 #5116 ; 3
[attach-enode] #5120 3
[attach-enode] #5103 3
[attach-enode] #5108 3
[mk-app] #5124 <= #5103 #36
[mk-app] #5125 >= #5103 #36
[assign] #5108 justification -1: p21
[end-of-instance]
[mk-app] #5126 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5126
[mk-app] #5128 = #5126 #5126
[mk-proof] #5131 rewrite #5128
[instance] 0x0 #5128
[end-of-instance]
[mk-app] #5132 or #4423 #5142 #5144 #5145
[mk-app] #5133 or #4423 #5126
[mk-proof] #5134 quant-inst #5133
[mk-app] #5135 = #5133 #5132
[mk-proof] #5136 rewrite #5135
[mk-proof] #5150 mp #5134 #5136 #5132
[instance] 0x1068e41b0 #5134 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5128 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5131 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5151 = #5128 #5131
[mk-proof] #5149 monotonicity #5169 #5151
[mk-app] #5152 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5131
[mk-app] #5153 = #5131 #5152
[mk-proof] #5154 rewrite #5153
[instance] 0x0 #5153
[end-of-instance]
[mk-app] #5178 = #5128 #5152
[mk-proof] #5180 trans #5149 #5154 #5178
[mk-app] #5181 not #1917
[mk-app] #5170 or #5181 #2172 #2353 #5144 #5148 #5165
[mk-app] #5171 or #5181 #5128
[mk-proof] #5172 quant-inst #5171
[mk-app] #5173 or #5181 #5152
[mk-app] #5174 = #5171 #5173
[mk-proof] #5175 monotonicity #5180 #5174
[mk-app] #5176 = #5173 #5170
[mk-proof] #5177 rewrite #5176
[mk-app] #5182 = #5171 #5170
[mk-proof] #5183 trans #5175 #5177 #5182
[mk-proof] #5184 mp #5172 #5183 #5170
[instance] 0x1068e41e8 #5172 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5179 >= #3402 #36
[mk-app] #5185 = #5179 #5179
[mk-proof] #5186 refl #5185
[mk-app] #5187 or #1546 #5179
[mk-proof] #5188 quant-inst #5187
[instance] 0x1068e4268 #5188 ; 3
[assign] #5179 justification -1: p13
[end-of-instance]
[mk-app] #5185 not #5191
[mk-app] #5186 or #5185 #2172
[mk-app] #5189 = #5186 #5186
[mk-proof] #5193 refl #5189
[mk-app] #5194 or #2307 #5185 #2172
[mk-app] #5199 or #2307 #5186
[mk-proof] #5200 quant-inst #5199
[mk-app] #5198 = #5199 #5194
[mk-proof] #5201 rewrite #5198
[mk-proof] #5202 mp #5200 #5201 #5194
[instance] 0x1068e4298 #5200 ; 3
[attach-enode] #5191 3
[mk-app] #5203 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #5196
[instance] 0x0 #5205
[end-of-instance]
[instance] 0x1068e42c8 #5213 ; 3
[attach-enode] #5207 3
[assign] #5207 justification -1: p20
[end-of-instance]
[assign] #5124 clause p490 (not p489)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5125 clause p491 (not p489)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5203) clause (not p499) p498
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p496 (not p500)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5220 clause p501 (not p500)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5189 <= #4347 #36
[mk-app] #5193 >= #4347 #36
[assign] #5189 justification -1: p78
[assign] #5193 justification -1: p78
[assign] #5143 clause p493 (not p496) (not p497)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5132 #5142
[push] 5
[assign] #5142 decision axiom
[new-match] 0x1068e9890 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98c8 #124 #118 #1529 ; #5139
[new-match] 0x1068e98f8 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5232
[instance] 0x0 #5236
[end-of-instance]
[instance] 0x1068e9890 #5243 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5265 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5263 >= #5139 #36
[mk-app] #5267 = #5263 #5263
[mk-proof] #5268 refl #5267
[mk-app] #5266 or #1546 #5263
[mk-proof] #5253 quant-inst #5266
[instance] 0x1068e98c8 #5253 ; 4
[assign] #5263 justification -1: p13
[end-of-instance]
[mk-app] #5267 not #5255
[mk-app] #5268 or #5267 #5259
[mk-app] #5269 = #5268 #5268
[mk-proof] #2189 refl #5269
[mk-app] #5137 or #2307 #5267 #5259
[mk-app] #5138 or #2307 #5268
[mk-proof] #5204 quant-inst #5138
[mk-app] #5221 = #5138 #5137
[mk-proof] #5222 rewrite #5221
[mk-proof] #5257 mp #5204 #5222 #5137
[instance] 0x1068e98f8 #5204 ; 4
[attach-enode] #5255 4
[mk-app] #5432 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5252 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5265 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5220)
[resolve-lit] 0 (not #5252)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5252)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[conflict] (not #5142) #2353 #2172
[pop] 1 6
[assign] (not #5142) clause (not p492) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p494 p492 (not p493)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068e9878 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98b0 #124 #118 #1529 ; #5139
[new-match] 0x1068e98e0 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5232
[instance] 0x0 #5236
[end-of-instance]
[instance] 0x1068e9878 #5243 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5266 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5253 = #5263 #5263
[mk-proof] #5138 refl #5253
[mk-app] #5204 or #1546 #5263
[mk-proof] #5137 quant-inst #5204
[instance] 0x1068e98b0 #5137 ; 4
[assign] #5263 justification -1: p13
[end-of-instance]
[mk-app] #5253 = #5268 #5268
[mk-proof] #5138 refl #5253
[mk-app] #5221 or #2307 #5267 #5259
[mk-app] #5222 or #2307 #5268
[mk-proof] #5257 quant-inst #5222
[mk-app] #5265 = #5222 #5221
[mk-proof] #5432 rewrite #5265
[mk-proof] #5269 mp #5257 #5432 #5221
[instance] 0x1068e98e0 #5257 ; 4
[attach-enode] #5255 4
[mk-app] #2189 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5252 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5266 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #2189) clause (not p509) (not p496) (not p497) p492
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p508) p509
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #5253 >= #4165 #36
[mk-app] #5138 not #5253
[mk-app] #5433 or #5253 #5138
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5433
[end-of-instance]
[push] 5
[assign] (not #5253) decision axiom
[mk-app] #1555 Seq<Int>!val!0
[mk-app] #5264 $Ref!val!0
[mk-app] #1556 $Ref!val!1
[mk-app] #2300 Ptr32!val!0
[mk-app] #2290 Ptr32!val!1
[mk-app] #5258 Seq<Int>!val!1
[mk-app] #1557 Seq<Int>!val!2
[mk-app] #5431 Seq<Int>!val!3
[mk-app] #5430 Int
[attach-meaning] #5430 arith 2438
[mk-app] #5429 Int
[attach-meaning] #5429 arith (- 3)
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #5428 Ptr32!val!2
[mk-app] #5427 Ptr32!val!3
[attach-meaning] #4108 arith (- 4)
[mk-app] #5426 Ptr32!val!4
[attach-meaning] #3632 arith 17
[mk-app] #5425 Ptr32!val!5
[attach-meaning] #4096 arith 21
[mk-app] #5424 Ptr32!val!6
[attach-meaning] #4548 arith 25
[mk-app] #5423 Ptr32!val!7
[attach-meaning] #3887 arith 29
[mk-app] #5422 Ptr32!val!8
[attach-meaning] #4187 arith 33
[mk-app] #5421 Ptr32!val!9
[attach-meaning] #4506 arith 37
[mk-app] #5420 Ptr32!val!10
[attach-meaning] #4723 arith 41
[mk-app] #5419 Ptr32!val!11
[attach-meaning] #4879 arith 45
[mk-app] #5418 Ptr32!val!12
[attach-meaning] #5035 arith 49
[mk-app] #5417 Ptr32!val!13
[mk-app] #5416 Int
[attach-meaning] #5416 arith 53
[mk-app] #5415 Ptr32!val!14
[mk-app] #5414 Int
[attach-meaning] #5414 arith 57
[mk-app] #5413 Ptr32!val!15
[mk-app] #5412 Int
[attach-meaning] #5412 arith 61
[attach-meaning] #3722 arith 16
[mk-app] #5411 Ptr32!val!16
[mk-app] #5410 Int
[attach-meaning] #5410 arith 65
[attach-meaning] #3632 arith 17
[mk-app] #5409 Ptr32!val!17
[mk-app] #5408 Int
[attach-meaning] #5408 arith 69
[attach-meaning] #3800 arith 18
[mk-app] #5407 Ptr32!val!18
[mk-app] #5406 Int
[attach-meaning] #5406 arith 73
[attach-meaning] #4573 arith 19
[mk-app] #5405 Ptr32!val!19
[mk-app] #5404 Int
[attach-meaning] #5404 arith 77
[attach-meaning] #3161 arith 20
[mk-app] #5403 Ptr32!val!20
[mk-app] #5402 Int
[attach-meaning] #5402 arith 81
[attach-meaning] #4096 arith 21
[mk-app] #5401 Ptr32!val!21
[mk-app] #5400 Int
[attach-meaning] #5400 arith 85
[attach-meaning] #3898 arith 22
[mk-app] #5399 Ptr32!val!22
[mk-app] #5398 Int
[attach-meaning] #5398 arith 89
[attach-meaning] #3432 arith 23
[mk-app] #5397 Ptr32!val!23
[mk-app] #5396 Int
[attach-meaning] #5396 arith 93
[attach-meaning] #4382 arith 24
[mk-app] #5395 Ptr32!val!24
[mk-app] #5394 Int
[attach-meaning] #5394 arith 97
[attach-meaning] #4548 arith 25
[mk-app] #5393 Ptr32!val!25
[mk-app] #5392 Int
[attach-meaning] #5392 arith 101
[attach-meaning] #2916 arith 26
[mk-app] #5391 Ptr32!val!26
[mk-app] #5390 Int
[attach-meaning] #5390 arith 105
[attach-meaning] #3947 arith 27
[mk-app] #5389 Ptr32!val!27
[mk-app] #5388 Int
[attach-meaning] #5388 arith 109
[attach-meaning] #4389 arith 28
[mk-app] #5387 Ptr32!val!28
[mk-app] #5386 Int
[attach-meaning] #5386 arith 113
[attach-meaning] #3887 arith 29
[mk-app] #5385 Ptr32!val!29
[mk-app] #5384 Int
[attach-meaning] #5384 arith 117
[attach-meaning] #3867 arith 30
[mk-app] #5383 Ptr32!val!30
[mk-app] #5382 Int
[attach-meaning] #5382 arith 121
[attach-meaning] #3730 arith 31
[mk-app] #5381 Ptr32!val!31
[mk-app] #5380 Int
[attach-meaning] #5380 arith 125
[attach-meaning] #3291 arith 32
[mk-app] #5379 Ptr32!val!32
[mk-app] #5378 Int
[attach-meaning] #5378 arith 129
[attach-meaning] #4187 arith 33
[mk-app] #5377 Ptr32!val!33
[mk-app] #5376 Int
[attach-meaning] #5376 arith 133
[attach-meaning] #3677 arith 34
[mk-app] #5375 Ptr32!val!34
[mk-app] #5374 Int
[attach-meaning] #5374 arith 137
[attach-meaning] #3981 arith 35
[mk-app] #5373 Ptr32!val!35
[mk-app] #5372 Int
[attach-meaning] #5372 arith 141
[attach-meaning] #3216 arith 36
[mk-app] #5371 Ptr32!val!36
[mk-app] #5370 Int
[attach-meaning] #5370 arith 145
[attach-meaning] #4506 arith 37
[mk-app] #5369 Ptr32!val!37
[mk-app] #5368 Int
[attach-meaning] #5368 arith 149
[attach-meaning] #4606 arith 38
[mk-app] #5367 Ptr32!val!38
[mk-app] #5366 Int
[attach-meaning] #5366 arith 153
[attach-meaning] #4645 arith 39
[mk-app] #5365 Ptr32!val!39
[mk-app] #5364 Int
[attach-meaning] #5364 arith 157
[attach-meaning] #4684 arith 40
[mk-app] #5363 Ptr32!val!40
[mk-app] #5362 Int
[attach-meaning] #5362 arith 161
[attach-meaning] #4723 arith 41
[mk-app] #5361 Ptr32!val!41
[mk-app] #5360 Int
[attach-meaning] #5360 arith 165
[attach-meaning] #4762 arith 42
[mk-app] #5357 Ptr32!val!42
[mk-app] #5355 Int
[attach-meaning] #5355 arith 169
[attach-meaning] #4801 arith 43
[mk-app] #5353 Ptr32!val!43
[mk-app] #5351 Int
[attach-meaning] #5351 arith 173
[attach-meaning] #4840 arith 44
[mk-app] #5349 Ptr32!val!44
[mk-app] #5347 Int
[attach-meaning] #5347 arith 177
[attach-meaning] #4879 arith 45
[mk-app] #5345 Ptr32!val!45
[mk-app] #5343 Int
[attach-meaning] #5343 arith 181
[attach-meaning] #4918 arith 46
[mk-app] #5341 Ptr32!val!46
[mk-app] #5339 Int
[attach-meaning] #5339 arith 185
[attach-meaning] #4957 arith 47
[mk-app] #5337 Ptr32!val!47
[mk-app] #5335 Int
[attach-meaning] #5335 arith 189
[attach-meaning] #4996 arith 48
[mk-app] #5333 Ptr32!val!48
[mk-app] #5331 Int
[attach-meaning] #5331 arith 193
[attach-meaning] #5035 arith 49
[mk-app] #5329 Ptr32!val!49
[mk-app] #5327 Int
[attach-meaning] #5327 arith 197
[attach-meaning] #5074 arith 50
[mk-app] #5325 Ptr32!val!50
[mk-app] #5323 Ptr32!val!51
[mk-app] #5321 Int
[attach-meaning] #5321 arith 201
[mk-app] #5319 Int
[attach-meaning] #5319 arith 2439
[attach-meaning] #3722 arith 16
[attach-meaning] #3632 arith 17
[attach-meaning] #3800 arith 18
[attach-meaning] #4573 arith 19
[attach-meaning] #3161 arith 20
[attach-meaning] #4096 arith 21
[attach-meaning] #3898 arith 22
[attach-meaning] #3432 arith 23
[attach-meaning] #4382 arith 24
[attach-meaning] #4548 arith 25
[attach-meaning] #2916 arith 26
[attach-meaning] #3947 arith 27
[attach-meaning] #4389 arith 28
[attach-meaning] #3887 arith 29
[attach-meaning] #3867 arith 30
[attach-meaning] #3730 arith 31
[attach-meaning] #3291 arith 32
[attach-meaning] #4187 arith 33
[attach-meaning] #3677 arith 34
[attach-meaning] #3981 arith 35
[attach-meaning] #3216 arith 36
[attach-meaning] #4506 arith 37
[attach-meaning] #4606 arith 38
[attach-meaning] #4645 arith 39
[attach-meaning] #4684 arith 40
[attach-meaning] #4723 arith 41
[attach-meaning] #4762 arith 42
[attach-meaning] #4801 arith 43
[attach-meaning] #4840 arith 44
[attach-meaning] #4879 arith 45
[attach-meaning] #4918 arith 46
[attach-meaning] #4957 arith 47
[attach-meaning] #4996 arith 48
[attach-meaning] #5035 arith 49
[attach-meaning] #5074 arith 50
[mk-app] #5317 Int
[attach-meaning] #5317 arith 51
[mk-app] #5315 Int
[attach-meaning] #5315 arith 52
[attach-meaning] #5416 arith 53
[mk-app] #5313 Int
[attach-meaning] #5313 arith 54
[mk-app] #5311 Int
[attach-meaning] #5311 arith 55
[mk-app] #5309 Int
[attach-meaning] #5309 arith 56
[attach-meaning] #5414 arith 57
[mk-app] #5307 Int
[attach-meaning] #5307 arith 58
[mk-app] #5305 Int
[attach-meaning] #5305 arith 59
[mk-app] #5303 Int
[attach-meaning] #5303 arith 60
[attach-meaning] #5412 arith 61
[mk-app] #5301 Int
[attach-meaning] #5301 arith 62
[mk-app] #5299 Int
[attach-meaning] #5299 arith 63
[mk-app] #5297 Int
[attach-meaning] #5297 arith 64
[attach-meaning] #5410 arith 65
[mk-app] #5295 Int
[attach-meaning] #5295 arith 66
[mk-app] #5293 Int
[attach-meaning] #5293 arith 67
[mk-app] #5291 Int
[attach-meaning] #5291 arith 68
[attach-meaning] #5408 arith 69
[mk-app] #5289 Int
[attach-meaning] #5289 arith 70
[mk-app] #2342 Int
[attach-meaning] #2342 arith 71
[mk-app] #2340 Int
[attach-meaning] #2340 arith 72
[attach-meaning] #5406 arith 73
[mk-app] #2192 Int
[attach-meaning] #2192 arith 74
[mk-app] #2291 Int
[attach-meaning] #2291 arith 75
[mk-app] #5359 Int
[attach-meaning] #5359 arith 76
[attach-meaning] #5404 arith 77
[mk-app] #5358 Int
[attach-meaning] #5358 arith 78
[mk-app] #5356 Int
[attach-meaning] #5356 arith 79
[mk-app] #5354 Int
[attach-meaning] #5354 arith 80
[attach-meaning] #5402 arith 81
[mk-app] #5352 Int
[attach-meaning] #5352 arith 82
[mk-app] #5350 Int
[attach-meaning] #5350 arith 83
[mk-app] #5348 Int
[attach-meaning] #5348 arith 84
[attach-meaning] #5400 arith 85
[mk-app] #5346 Int
[attach-meaning] #5346 arith 86
[mk-app] #5344 Int
[attach-meaning] #5344 arith 87
[mk-app] #5342 Int
[attach-meaning] #5342 arith 88
[attach-meaning] #5398 arith 89
[mk-app] #5340 Int
[attach-meaning] #5340 arith 90
[mk-app] #5338 Int
[attach-meaning] #5338 arith 91
[mk-app] #5336 Int
[attach-meaning] #5336 arith 92
[attach-meaning] #5396 arith 93
[mk-app] #5334 Int
[attach-meaning] #5334 arith 94
[mk-app] #5332 Int
[attach-meaning] #5332 arith 95
[mk-app] #5330 Int
[attach-meaning] #5330 arith 96
[attach-meaning] #5394 arith 97
[mk-app] #5328 Int
[attach-meaning] #5328 arith 98
[mk-app] #5326 Int
[attach-meaning] #5326 arith 99
[mk-app] #5324 Int
[attach-meaning] #5324 arith 100
[attach-meaning] #5392 arith 101
[mk-app] #5322 Int
[attach-meaning] #5322 arith 102
[mk-app] #5320 Int
[attach-meaning] #5320 arith 103
[mk-app] #5318 Int
[attach-meaning] #5318 arith 104
[attach-meaning] #5390 arith 105
[mk-app] #5316 Int
[attach-meaning] #5316 arith 106
[mk-app] #5314 Int
[attach-meaning] #5314 arith 107
[mk-app] #5312 Int
[attach-meaning] #5312 arith 108
[attach-meaning] #5388 arith 109
[mk-app] #5310 Int
[attach-meaning] #5310 arith 110
[mk-app] #5308 Int
[attach-meaning] #5308 arith 111
[mk-app] #5306 Int
[attach-meaning] #5306 arith 112
[attach-meaning] #5386 arith 113
[mk-app] #5304 Int
[attach-meaning] #5304 arith 114
[mk-app] #5302 Int
[attach-meaning] #5302 arith 115
[mk-app] #5300 Int
[attach-meaning] #5300 arith 116
[attach-meaning] #5384 arith 117
[mk-app] #5298 Int
[attach-meaning] #5298 arith 118
[mk-app] #5296 Int
[attach-meaning] #5296 arith 119
[mk-app] #5294 Int
[attach-meaning] #5294 arith 120
[attach-meaning] #5382 arith 121
[mk-app] #5292 Int
[attach-meaning] #5292 arith 122
[mk-app] #5290 Int
[attach-meaning] #5290 arith 123
[mk-app] #2185 Int
[attach-meaning] #2185 arith 124
[attach-meaning] #5380 arith 125
[mk-app] #2341 Int
[attach-meaning] #2341 arith 126
[mk-app] #2339 Int
[attach-meaning] #2339 arith 127
[mk-app] #2356 Int
[attach-meaning] #2356 arith 128
[attach-meaning] #5378 arith 129
[mk-app] #2344 Int
[attach-meaning] #2344 arith 130
[mk-app] #2188 Int
[attach-meaning] #2188 arith 131
[mk-app] #2318 Int
[attach-meaning] #2318 arith 132
[attach-meaning] #5376 arith 133
[mk-app] #2193 Int
[attach-meaning] #2193 arith 134
[mk-app] #2317 Int
[attach-meaning] #2317 arith 135
[mk-app] #2316 Int
[attach-meaning] #2316 arith 136
[attach-meaning] #5374 arith 137
[mk-app] #2315 Int
[attach-meaning] #2315 arith 138
[mk-app] #2288 Int
[attach-meaning] #2288 arith 139
[mk-app] #2321 Int
[attach-meaning] #2321 arith 140
[attach-meaning] #5372 arith 141
[mk-app] #2292 Int
[attach-meaning] #2292 arith 142
[mk-app] #2343 Int
[attach-meaning] #2343 arith 143
[mk-app] #5138 Int
[attach-meaning] #5138 arith 144
[pop] 3 6
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 3
[push] 2
[mk-app] #4199 address<Int> #1558
[mk-app] #4205 mod #4199 #1503
[mk-app] #4210 = #4205 #36
[mk-proof] #4158 asserted #4210
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 ~ #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 rewrite #4159
[mk-proof] #3021 mp #4158 #4063 #4210
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[mk-app] #4159 = #4210 #4210
[mk-proof] #4063 refl #4159
[attach-enode] #4199 0
[attach-enode] #1503 0
[attach-enode] #4205 0
[attach-enode] #4210 0
[mk-app] #4159 <= #4205 #36
[mk-app] #4063 >= #4205 #36
[assign] #4210 justification -1: 
[mk-app] #3021 div #4199 #1503
[mk-app] #3101 < #1503 #36
[mk-app] #5192 - #36 #1503
[mk-app] #5195 if #3101 #5192 #1503
[mk-app] #5073 - #5195 #151
[inst-discovered] theory-solving 0x0 arith# ; #3101
[mk-app] #5060 = #3101 #3233
[mk-proof] #4982 rewrite #5060
[instance] 0x0 #5060
[end-of-instance]
[mk-app] #4983 = #3101 #2
[mk-proof] #5022 trans #4982 #3190 #4983
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5192
[mk-app] #5023 = #5192 #3205
[mk-proof] #5015 rewrite #5023
[instance] 0x0 #5023
[end-of-instance]
[mk-app] #4995 = #5192 #4108
[mk-proof] #4984 trans #5015 #3152 #4995
[mk-app] #4976 if #2 #4108 #1503
[mk-app] #4956 = #5195 #4976
[mk-proof] #4943 monotonicity #5022 #4984 #4956
[inst-discovered] theory-solving 0x0 arith# ; #4976
[mk-app] #4944 = #4976 #1503
[mk-proof] #4945 rewrite #4944
[instance] 0x0 #4944
[end-of-instance]
[mk-app] #4905 = #5195 #1503
[mk-proof] #4906 trans #4943 #4945 #4905
[mk-app] #4866 - #1503 #151
[mk-app] #4867 = #5073 #4866
[mk-proof] #4781 monotonicity #4906 #4867
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #4866
[mk-app] #4761 = #4866 #4048
[mk-proof] #4800 rewrite #4761
[instance] 0x0 #4761
[end-of-instance]
[mk-app] #4787 = #5073 #4048
[mk-proof] #4788 trans #4781 #4800 #4787
[mk-app] #4789 = #5073 #4037
[mk-proof] #4748 trans #4788 #4000 #4789
[mk-app] #4749 = #1503 #36
[mk-app] #4750 * #1503 #3021
[mk-app] #4742 + #4750 #4205
[mk-app] #4722 = #4742 #4199
[mk-app] #4709 <= #4205 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4749
[mk-app] #3101 = #4749 #2
[mk-proof] #5060 rewrite #3101
[instance] 0x0 #3101
[end-of-instance]
[attach-enode] #3021 0
[attach-enode] #4750 0
[attach-enode] #4742 0
[attach-enode] #4722 0
[mk-app] #4982 or #4749 #4722
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4982
[assign] #4722 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4749
[mk-app] #3101 = #4749 #2
[mk-proof] #5060 rewrite #3101
[instance] 0x0 #3101
[end-of-instance]
[attach-enode] #4063 0
[mk-app] #4982 or #4749 #4063
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4982
[assign] #4063 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4749
[mk-app] #3101 = #4749 #2
[mk-proof] #5060 rewrite #3101
[instance] 0x0 #3101
[end-of-instance]
[attach-enode] #4709 0
[mk-app] #4982 or #4749 #4709
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4982
[assign] #4709 justification -1: true
[end-of-instance]
[assign] #4159 clause p81 (not p80)
  (<= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int) 
  (not (= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 

[new-match] 0x106809ed0 #1522 #1506 #36 #1545 ; #4199 (#1558 #1559)
[mk-app] #4749 = #5254 #5254
[mk-proof] #3101 refl #4749
[mk-app] #5060 not #1522
[mk-app] #4982 or #5060 #5254
[mk-proof] #4983 quant-inst #4982
[instance] 0x106809ed0 #4983 ; 1
[attach-enode] #3235 1
[attach-enode] #4105 1
[attach-enode] #176 1
[attach-enode] #5256 1
[attach-enode] #5260 1
[attach-enode] #5254 1
[mk-app] #5022 <= #5260 #1503
[mk-app] #5192 >= #5260 #1503
[assign] #5254 justification -1: p51
[end-of-instance]
[assign] #5022 clause p86 (not p85)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[assign] #5192 clause p87 (not p85)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[mk-app] #4749 = #4105 #4742
[attach-meaning] #176 arith (- 1)
[mk-app] #3101 * #176 #4742
[mk-app] #5023 + #4105 #3101
[mk-app] #5015 <= #5023 #36
[mk-app] #4995 >= #5023 #36
[assign] #4749 justification -1: p83 p55
[attach-enode] #4749 0
[attach-enode] #3101 0
[attach-enode] #5023 0
[assign] #5015 justification -1: p88
[assign] #4995 justification -1: p88
[new-match] 0x1068171a0 #1522 #1506 #151 #1545 ; #3235 (#1574 #2367)
[mk-app] #4984 = #5100 #5100
[mk-proof] #5195 refl #4984
[mk-app] #4976 or #5060 #5100
[mk-proof] #4956 quant-inst #4976
[instance] 0x1068171a0 #4956 ; 2
[attach-enode] #3162 2
[attach-enode] #4086 2
[attach-enode] #4087 2
[attach-enode] #5113 2
[attach-enode] #5099 2
[attach-enode] #5100 2
[mk-app] #4943 <= #5099 #1503
[mk-app] #4944 >= #5099 #1503
[assign] #5100 justification -1: p51
[end-of-instance]
[assign] #4943 clause p92 (not p91)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[assign] #4944 clause p93 (not p91)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[mk-app] #4984 = #3235 #4087
[attach-meaning] #176 arith (- 1)
[mk-app] #5195 + #3235 #5113
[mk-app] #4945 <= #5195 #36
[mk-app] #4905 >= #5195 #36
[assign] #4984 justification -1: p58
[attach-enode] #4984 0
[attach-enode] #5195 0
[assign] #4945 justification -1: p94
[assign] #4905 justification -1: p94
[new-match] 0x106817a08 #1495 #1483 #151 #1545 ; #3162 (#2367 #2367)
[mk-app] #4906 = #3162 #3955
[mk-app] #5073 = #5021 #4906
[mk-proof] #4866 monotonicity #3943 #5073
[mk-app] #4867 or #1563 #4906
[mk-app] #4781 or #1563 #5021
[mk-proof] #4761 quant-inst #4781
[mk-app] #4800 = #4781 #4867
[mk-proof] #4787 monotonicity #4866 #4800
[mk-app] #4788 = #4867 #4867
[mk-proof] #4789 rewrite #4788
[mk-proof] #4748 trans #4787 #4789 #4800
[mk-proof] #4683 mp #4761 #4748 #4867
[instance] 0x106817a08 #4761 ; 3
[attach-enode] #3950 3
[attach-enode] #3955 3
[attach-enode] #4906 3
[assign] #4906 justification -1: p50
[end-of-instance]
[eq-expl] #3950 root
[new-match] 0x106817cc8 #1477 #1476 #3950 #1545 ; #3955
[eq-expl] #3162 lit #4906 ; #3955
[eq-expl] #3955 root
[new-match] 0x106817d00 #1522 #1506 #3950 #1545 ; #4086 (#3162 #3955)
[mk-app] #4670 = #4937 #4937
[mk-proof] #4127 refl #4670
[mk-app] #4128 or #1576 #4937
[mk-proof] #4672 quant-inst #4128
[instance] 0x106817cc8 #4672 ; 4
[attach-enode] #3384 4
[attach-enode] #4937 4
[assign] #4937 justification -1: p49
[end-of-instance]
[mk-app] #4670 = #4898 #4898
[mk-proof] #4127 refl #4670
[mk-app] #4664 or #5060 #4898
[mk-proof] #4644 quant-inst #4664
[instance] 0x106817d00 #4644 ; 4
[attach-enode] #3386 4
[attach-enode] #3387 4
[attach-enode] #3391 4
[attach-enode] #4917 4
[attach-enode] #4904 4
[attach-enode] #4898 4
[mk-app] #4631 <= #4904 #1503
[mk-app] #4632 >= #4904 #1503
[assign] #4898 justification -1: p51
[end-of-instance]
[assign] #4631 clause p100 (not p99)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[assign] #4632 clause p101 (not p99)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[mk-app] #4670 = #3391 #4086
[attach-meaning] #176 arith (- 1)
[mk-app] #4127 * #176 #4086
[mk-app] #4633 + #3391 #4127
[mk-app] #4625 <= #4633 #36
[mk-app] #4605 >= #4633 #36
[assign] #4670 justification -1: p97
[attach-enode] #4670 0
[attach-enode] #4127 0
[attach-enode] #4633 0
[assign] #4625 justification -1: p102
[assign] #4605 justification -1: p102
[new-match] 0x106818748 #1495 #1483 #3950 #1545 ; #3386 (#3955 #3955)
[mk-app] #4584 = #3386 #4322
[mk-app] #4585 = #4820 #4584
[mk-proof] #4486 monotonicity #4324 #4585
[mk-app] #4493 or #1563 #4584
[mk-app] #3664 or #1563 #4820
[mk-proof] #4126 quant-inst #3664
[mk-app] #4115 = #3664 #4493
[mk-proof] #3215 monotonicity #4486 #4115
[mk-app] #3201 = #4493 #4493
[mk-proof] #3202 rewrite #3201
[mk-proof] #3203 trans #3215 #3202 #4115
[mk-proof] #3193 mp #4126 #3203 #4493
[instance] 0x106818748 #4126 ; 5
[attach-enode] #4037 5
[attach-enode] #4322 5
[attach-enode] #4584 5
[assign] #4584 justification -1: p50
[end-of-instance]
[eq-expl] #4037 root
[new-match] 0x1068189e8 #1477 #1476 #4037 #1545 ; #4322
[eq-expl] #3386 lit #4584 ; #4322
[eq-expl] #4322 root
[new-match] 0x106818a20 #1522 #1506 #4037 #1545 ; #3387 (#3386 #4322)
[mk-app] #3320 = #4710 #4710
[mk-proof] #3321 refl #3320
[mk-app] #3875 or #1576 #4710
[mk-proof] #3876 quant-inst #3875
[instance] 0x1068189e8 #3876 ; 6
[attach-enode] #4342 6
[attach-enode] #4710 6
[assign] #4710 justification -1: p49
[end-of-instance]
[mk-app] #3320 + #4711 #4345
[inst-discovered] theory-solving 0x0 arith# ; #4703
[mk-app] #3321 = #4703 #3320
[mk-proof] #4212 rewrite #3321
[instance] 0x0 #3321
[end-of-instance]
[mk-app] #4186 = #3320 #1503
[mk-app] #3319 = #4671 #4186
[mk-proof] #3313 monotonicity #4212 #3319
[attach-meaning] #176 arith (- 1)
[mk-app] #3290 * #176 #4345
[mk-app] #4043 + #3488 #3290
[attach-meaning] #4108 arith (- 4)
[mk-app] #4044 = #4043 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4186
[mk-app] #4045 = #4186 #4044
[mk-proof] #3608 rewrite #4045
[instance] 0x0 #4045
[end-of-instance]
[mk-app] #3609 = #4671 #4044
[mk-proof] #3475 trans #3313 #3608 #3609
[mk-app] #3476 or #5060 #4044
[mk-app] #3588 or #5060 #4671
[mk-proof] #3582 quant-inst #3588
[mk-app] #4410 = #3588 #3476
[mk-proof] #4388 monotonicity #3475 #4410
[mk-app] #3586 = #3476 #3476
[mk-proof] #3587 rewrite #3586
[mk-proof] #3946 trans #4388 #3587 #4410
[mk-proof] #3930 mp #3582 #3946 #3476
[instance] 0x106818a20 #3582 ; 6
[attach-enode] #3488 6
[attach-enode] #4344 6
[attach-enode] #4345 6
[attach-enode] #3290 6
[attach-enode] #4043 6
[attach-enode] #4108 6
[attach-enode] #4044 6
[mk-app] #3931 <= #4043 #4108
[mk-app] #3932 >= #4043 #4108
[assign] #4044 justification -1: p51
[end-of-instance]
[assign] #3931 clause p108 (not p107)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[assign] #3932 clause p109 (not p107)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[mk-app] #3770 = #3387 #3488
[attach-meaning] #176 arith (- 1)
[mk-app] #2915 + #3387 #4711
[mk-app] #4257 <= #2915 #36
[mk-app] #4485 >= #2915 #36
[assign] #3770 justification -1: p105
[attach-enode] #3770 0
[attach-enode] #4711 0
[attach-enode] #2915 0
[assign] #4257 justification -1: p110
[assign] #4485 justification -1: p110
[new-match] 0x10681c558 #1495 #1483 #4037 #1545 ; #4344 (#4322 #4322)
[mk-app] #3551 = #4344 #4446
[mk-app] #4380 = #3874 #3551
[mk-proof] #3897 monotonicity #4545 #4380
[mk-app] #3527 or #1563 #3551
[mk-app] #4470 or #1563 #3874
[mk-proof] #4471 quant-inst #4470
[mk-app] #4546 = #4470 #3527
[mk-proof] #4463 monotonicity #3897 #4546
[mk-app] #3528 = #3527 #3527
[mk-proof] #3529 rewrite #3528
[mk-proof] #3521 trans #4463 #3529 #4546
[mk-proof] #4095 mp #4471 #3521 #3527
[instance] 0x10681c558 #4471 ; 7
[attach-enode] #4446 7
[attach-enode] #3551 7
[assign] #3551 justification -1: p50
[end-of-instance]
[eq-expl] #1503 root
[new-match] 0x10681c768 #1477 #1476 #1503 #1545 ; #4446
[eq-expl] #4344 lit #3551 ; #4446
[eq-expl] #4446 root
[new-match] 0x10681c7a0 #1522 #1506 #1503 #1545 ; #4345 (#4344 #4446)
[mk-app] #4077 = #4035 #4035
[mk-proof] #4078 refl #4077
[mk-app] #3141 or #1576 #4035
[mk-proof] #3142 quant-inst #3141
[instance] 0x10681c768 #3142 ; 8
[attach-enode] #2974 8
[attach-enode] #4035 8
[assign] #4035 justification -1: p49
[end-of-instance]
[mk-app] #4077 = #4434 #4434
[mk-proof] #4078 refl #4077
[mk-app] #4298 or #5060 #4434
[mk-proof] #4299 quant-inst #4298
[instance] 0x10681c7a0 #4299 ; 8
[attach-enode] #2976 8
[attach-enode] #3707 8
[attach-enode] #3710 8
[attach-enode] #3729 8
[attach-enode] #3607 8
[attach-enode] #4434 8
[mk-app] #4013 <= #3607 #1503
[mk-app] #4003 >= #3607 #1503
[assign] #4434 justification -1: p51
[end-of-instance]
[assign] #4013 clause p116 (not p115)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[assign] #4003 clause p117 (not p115)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[mk-app] #4077 = #3710 #4345
[attach-meaning] #176 arith (- 1)
[mk-app] #4078 + #3710 #3290
[mk-app] #4532 <= #4078 #36
[mk-app] #3625 >= #4078 #36
[assign] #4077 justification -1: p113
[attach-enode] #4077 0
[attach-enode] #4078 0
[assign] #4532 justification -1: p118
[assign] #3625 justification -1: p118
[new-match] 0x10681d160 #1495 #1483 #1503 #1545 ; #2976 (#4446 #4446)
[mk-app] #4010 = #2976 #3398
[mk-app] #4012 = #3794 #4010
[mk-proof] #3721 monotonicity #3400 #4012
[mk-app] #3016 or #1563 #4010
[mk-app] #3017 or #1563 #3794
[mk-proof] #3031 quant-inst #3017
[mk-app] #3010 = #3017 #3016
[mk-proof] #3571 monotonicity #3721 #3010
[mk-app] #3639 = #3016 #3016
[mk-proof] #2953 rewrite #3639
[mk-proof] #4234 trans #3571 #2953 #3010
[mk-proof] #3784 mp #3031 #4234 #3016
[instance] 0x10681d160 #3031 ; 9
[attach-enode] #3395 9
[attach-enode] #3398 9
[attach-enode] #4010 9
[assign] #4010 justification -1: p50
[end-of-instance]
[eq-expl] #3395 root
[new-match] 0x10681d400 #1477 #1476 #3395 #1545 ; #3398
[eq-expl] #2976 lit #4010 ; #3398
[eq-expl] #3398 root
[new-match] 0x10681d438 #1522 #1506 #3395 #1545 ; #3707 (#2976 #3398)
[mk-app] #3106 = #4308 #4308
[mk-proof] #3090 refl #3106
[mk-app] #4058 or #1576 #4308
[mk-proof] #4059 quant-inst #4058
[instance] 0x10681d400 #4059 ; 10
[attach-enode] #3414 10
[attach-enode] #4308 10
[assign] #4308 justification -1: p49
[end-of-instance]
[mk-app] #3106 = #3904 #3904
[mk-proof] #3090 refl #3106
[mk-app] #4060 or #5060 #3904
[mk-proof] #4052 quant-inst #4060
[instance] 0x10681d438 #4052 ; 10
[attach-enode] #3418 10
[attach-enode] #3419 10
[attach-enode] #3848 10
[attach-enode] #4309 10
[attach-enode] #4311 10
[attach-enode] #3904 10
[mk-app] #3091 <= #4311 #1503
[mk-app] #3092 >= #4311 #1503
[assign] #3904 justification -1: p51
[end-of-instance]
[assign] #3091 clause p124 (not p123)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[assign] #3092 clause p125 (not p123)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[mk-app] #3106 = #3707 #3848
[attach-meaning] #176 arith (- 1)
[mk-app] #3090 + #3707 #4309
[mk-app] #3084 <= #3090 #36
[mk-app] #3694 >= #3090 #36
[assign] #3106 justification -1: p121
[attach-enode] #3106 0
[attach-enode] #3090 0
[assign] #3084 justification -1: p126
[assign] #3694 justification -1: p126
[new-match] 0x106822a38 #1495 #1483 #3395 #1545 ; #3418 (#3398 #3398)
[mk-app] #3619 = #3418 #2979
[mk-app] #3620 = #3431 #3619
[mk-proof] #3273 monotonicity #2981 #3620
[mk-app] #3274 or #1563 #3619
[mk-app] #4155 or #1563 #3431
[mk-proof] #4516 quant-inst #4155
[mk-app] #3851 = #4155 #3274
[mk-proof] #3417 monotonicity #3273 #3851
[mk-app] #3229 = #3274 #3274
[mk-proof] #4578 rewrite #3229
[mk-proof] #3849 trans #3417 #4578 #3851
[mk-proof] #3850 mp #4516 #3849 #3274
[instance] 0x106822a38 #4516 ; 11
[attach-enode] #4579 11
[attach-enode] #2979 11
[attach-enode] #3619 11
[assign] #3619 justification -1: p50
[end-of-instance]
[eq-expl] #4579 root
[new-match] 0x106822cd8 #1477 #1476 #4579 #1545 ; #2979
[eq-expl] #3418 lit #3619 ; #2979
[eq-expl] #2979 root
[new-match] 0x106822d10 #1522 #1506 #4579 #1545 ; #3419 (#3418 #2979)
[mk-app] #4503 = #4079 #4079
[mk-proof] #3711 refl #4503
[mk-app] #3712 or #1576 #4079
[mk-proof] #3713 quant-inst #3712
[instance] 0x106822cd8 #3713 ; 12
[attach-enode] #3228 12
[attach-enode] #4079 12
[assign] #4079 justification -1: p49
[end-of-instance]
[mk-app] #4503 = #3144 #3144
[mk-proof] #3711 refl #4503
[mk-app] #2975 or #5060 #3144
[mk-proof] #4443 quant-inst #2975
[instance] 0x106822d10 #4443 ; 12
[attach-enode] #3230 12
[attach-enode] #3231 12
[attach-enode] #3237 12
[attach-enode] #3746 12
[attach-enode] #3160 12
[attach-enode] #3144 12
[mk-app] #4343 <= #3160 #1503
[mk-app] #4319 >= #3160 #1503
[assign] #3144 justification -1: p51
[end-of-instance]
[assign] #4343 clause p132 (not p131)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[assign] #4319 clause p133 (not p131)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[mk-app] #4503 = #3237 #3419
[attach-meaning] #176 arith (- 1)
[mk-app] #3711 * #176 #3419
[mk-app] #3019 + #3237 #3711
[mk-app] #3020 <= #3019 #36
[mk-app] #3392 >= #3019 #36
[assign] #4503 justification -1: p129
[attach-enode] #4503 0
[attach-enode] #3711 0
[attach-enode] #3019 0
[assign] #3020 justification -1: p134
[assign] #3392 justification -1: p134
[new-match] 0x106823758 #1495 #1483 #4579 #1545 ; #3230 (#2979 #2979)
[mk-app] #3393 = #3230 #4131
[mk-app] #3385 = #3373 #3393
[mk-proof] #3949 monotonicity #4133 #3385
[mk-app] #4088 or #1563 #3393
[mk-app] #4094 or #1563 #3373
[mk-proof] #4174 quant-inst #4094
[mk-app] #3199 = #4094 #4088
[mk-proof] #4172 monotonicity #3949 #3199
[mk-app] #4106 = #4088 #4088
[mk-proof] #3022 rewrite #4106
[mk-proof] #3234 trans #4172 #3022 #3199
[mk-proof] #4490 mp #4174 #3234 #4088
[instance] 0x106823758 #4174 ; 13
[attach-enode] #3760 13
[attach-enode] #4131 13
[attach-enode] #3393 13
[assign] #3393 justification -1: p50
[end-of-instance]
[eq-expl] #3760 root
[new-match] 0x1068239f8 #1477 #1476 #3760 #1545 ; #4131
[eq-expl] #3230 lit #3393 ; #4131
[eq-expl] #4131 root
[new-match] 0x106823a30 #1522 #1506 #3760 #1545 ; #3231 (#3230 #4131)
[mk-app] #3018 = #4501 #4501
[mk-proof] #4107 refl #3018
[mk-app] #3023 or #1576 #4501
[mk-proof] #3027 quant-inst #3023
[instance] 0x1068239f8 #3027 ; 14
[attach-enode] #4147 14
[attach-enode] #4501 14
[assign] #4501 justification -1: p49
[end-of-instance]
[mk-app] #3018 = #4242 #4242
[mk-proof] #4107 refl #3018
[mk-app] #3028 or #5060 #4242
[mk-proof] #3029 quant-inst #3028
[instance] 0x106823a30 #3029 ; 14
[attach-enode] #4149 14
[attach-enode] #4151 14
[attach-enode] #4154 14
[attach-enode] #3555 14
[attach-enode] #3556 14
[attach-enode] #4242 14
[mk-app] #3030 <= #3556 #1503
[mk-app] #4331 >= #3556 #1503
[assign] #4242 justification -1: p51
[end-of-instance]
[assign] #3030 clause p140 (not p139)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[assign] #4331 clause p141 (not p139)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[mk-app] #3018 = #3231 #4154
[attach-meaning] #176 arith (- 1)
[mk-app] #4107 + #3231 #3555
[mk-app] #4341 <= #4107 #36
[mk-app] #4333 >= #4107 #36
[assign] #3018 justification -1: p137
[attach-enode] #3018 0
[attach-enode] #4107 0
[assign] #4341 justification -1: p142
[assign] #4333 justification -1: p142
[new-match] 0x1068243f0 #1495 #1483 #3760 #1545 ; #4149 (#4131 #4131)
[mk-app] #4325 = #4149 #4562
[mk-app] #4326 = #4073 #4325
[mk-proof] #4330 monotonicity #3249 #4326
[mk-app] #4556 or #1563 #4325
[mk-app] #4557 or #1563 #4073
[mk-proof] #3506 quant-inst #4557
[mk-app] #3507 = #4557 #4556
[mk-proof] #3492 monotonicity #4330 #3507
[mk-app] #3493 = #4556 #4556
[mk-proof] #3497 rewrite #3493
[mk-proof] #3498 trans #3492 #3497 #3507
[mk-proof] #3502 mp #3506 #3498 #4556
[instance] 0x1068243f0 #3506 ; 15
[attach-enode] #3958 15
[attach-enode] #4562 15
[attach-enode] #4325 15
[assign] #4325 justification -1: p50
[end-of-instance]
[eq-expl] #3958 root
[new-match] 0x106824690 #1477 #1476 #3958 #1545 ; #4562
[eq-expl] #4149 lit #4325 ; #4562
[eq-expl] #4562 root
[new-match] 0x1068246c8 #1522 #1506 #3958 #1545 ; #4151 (#4149 #4562)
[mk-app] #3503 = #3621 #3621
[mk-proof] #2967 refl #3503
[mk-app] #2962 or #1576 #3621
[mk-proof] #3511 quant-inst #2962
[instance] 0x106824690 #3511 ; 16
[attach-enode] #3262 16
[attach-enode] #3621 16
[assign] #3621 justification -1: p49
[end-of-instance]
[mk-app] #3503 = #3275 #3275
[mk-proof] #2967 refl #3503
[mk-app] #3888 or #5060 #3275
[mk-proof] #3889 quant-inst #3888
[instance] 0x1068246c8 #3889 ; 16
[attach-enode] #3264 16
[attach-enode] #3268 16
[attach-enode] #3271 16
[attach-enode] #4182 16
[attach-enode] #3766 16
[attach-enode] #3275 16
[mk-app] #2966 <= #3766 #1503
[mk-app] #2963 >= #3766 #1503
[assign] #3275 justification -1: p51
[end-of-instance]
[assign] #2966 clause p148 (not p147)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[assign] #2963 clause p149 (not p147)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[mk-app] #3503 = #3271 #4151
[attach-meaning] #176 arith (- 1)
[mk-app] #2967 * #176 #4151
[mk-app] #2964 + #3271 #2967
[mk-app] #2965 <= #2964 #36
[mk-app] #2968 >= #2964 #36
[assign] #3503 justification -1: p145
[attach-enode] #3503 0
[attach-enode] #2967 0
[attach-enode] #2964 0
[assign] #2965 justification -1: p150
[assign] #2968 justification -1: p150
[new-match] 0x10682c798 #1495 #1483 #3958 #1545 ; #3264 (#4562 #4562)
[mk-app] #2969 = #3264 #4156
[mk-app] #2970 = #3240 #2969
[mk-proof] #3708 monotonicity #4162 #2970
[mk-app] #3709 or #1563 #2969
[mk-app] #3409 or #1563 #3240
[mk-proof] #3404 quant-inst #3409
[mk-app] #3846 = #3409 #3709
[mk-proof] #3847 monotonicity #3708 #3846
[mk-app] #3412 = #3709 #3709
[mk-proof] #3413 rewrite #3412
[mk-proof] #3415 trans #3847 #3413 #3846
[mk-proof] #3416 mp #3404 #3415 #3709
[instance] 0x10682c798 #3404 ; 17
[attach-enode] #3767 17
[attach-enode] #4156 17
[attach-enode] #2969 17
[assign] #2969 justification -1: p50
[end-of-instance]
[eq-expl] #3767 root
[new-match] 0x10682ca38 #1477 #1476 #3767 #1545 ; #4156
[eq-expl] #3264 lit #2969 ; #4156
[eq-expl] #4156 root
[new-match] 0x10682ca70 #1522 #1506 #3767 #1545 ; #3268 (#3264 #4156)
[mk-app] #4351 = #3489 #3489
[mk-proof] #4353 refl #4351
[mk-app] #2986 or #1576 #3489
[mk-proof] #2987 quant-inst #2986
[instance] 0x10682ca38 #2987 ; 18
[attach-enode] #4181 18
[attach-enode] #3489 18
[assign] #3489 justification -1: p49
[end-of-instance]
[mk-app] #4351 + #3490 #4184
[inst-discovered] theory-solving 0x0 arith# ; #3491
[mk-app] #4353 = #3491 #4351
[mk-proof] #2982 rewrite #4353
[instance] 0x0 #4353
[end-of-instance]
[mk-app] #2983 = #4351 #1503
[mk-app] #3223 = #3389 #2983
[mk-proof] #3224 monotonicity #2982 #3223
[attach-meaning] #176 arith (- 1)
[mk-app] #3232 * #176 #4184
[mk-app] #3236 + #3618 #3232
[attach-meaning] #4108 arith (- 4)
[mk-app] #4142 = #3236 #4108
[inst-discovered] theory-solving 0x0 arith# ; #2983
[mk-app] #4143 = #2983 #4142
[mk-proof] #4136 rewrite #4143
[instance] 0x0 #4143
[end-of-instance]
[mk-app] #4137 = #3389 #4142
[mk-proof] #4140 trans #3224 #4136 #4137
[mk-app] #4141 or #5060 #4142
[mk-app] #4144 or #5060 #3389
[mk-proof] #4146 quant-inst #4144
[mk-app] #4152 = #4144 #4141
[mk-proof] #4153 monotonicity #4140 #4152
[mk-app] #3688 = #4141 #4141
[mk-proof] #3689 rewrite #3688
[mk-proof] #3251 trans #4153 #3689 #4152
[mk-proof] #3252 mp #4146 #3251 #4141
[instance] 0x10682ca70 #4146 ; 18
[attach-enode] #3618 18
[attach-enode] #4183 18
[attach-enode] #4184 18
[attach-enode] #3232 18
[attach-enode] #3236 18
[attach-enode] #4142 18
[mk-app] #3258 <= #3236 #4108
[mk-app] #3259 >= #3236 #4108
[assign] #4142 justification -1: p51
[end-of-instance]
[assign] #3258 clause p156 (not p155)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[assign] #3259 clause p157 (not p155)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[mk-app] #4164 = #3268 #3618
[attach-meaning] #176 arith (- 1)
[mk-app] #4166 + #3268 #3490
[mk-app] #3280 <= #4166 #36
[mk-app] #4168 >= #4166 #36
[assign] #4164 justification -1: p153
[attach-enode] #4164 0
[attach-enode] #3490 0
[attach-enode] #4166 0
[assign] #3280 justification -1: p158
[assign] #4168 justification -1: p158
[new-match] 0x10682d4b8 #1495 #1483 #3767 #1545 ; #4183 (#4156 #4156)
[mk-app] #4169 = #4183 #3698
[mk-app] #4163 = #4332 #4169
[mk-proof] #4167 monotonicity #4564 #4163
[mk-app] #4170 or #1563 #4169
[mk-app] #4175 or #1563 #4332
[mk-proof] #4176 quant-inst #4175
[mk-app] #4177 = #4175 #4170
[mk-proof] #4178 monotonicity #4167 #4177
[mk-app] #2928 = #4170 #4170
[mk-proof] #2929 rewrite #2928
[mk-proof] #4540 trans #4178 #2929 #4177
[mk-proof] #4541 mp #4176 #4540 #4170
[instance] 0x10682d4b8 #4176 ; 19
[attach-enode] #3695 19
[attach-enode] #3698 19
[attach-enode] #4169 19
[assign] #4169 justification -1: p50
[end-of-instance]
[eq-expl] #3695 root
[new-match] 0x10682d758 #1477 #1476 #3695 #1545 ; #3698
[eq-expl] #4183 lit #4169 ; #3698
[eq-expl] #3698 root
[new-match] 0x10682d790 #1522 #1506 #3695 #1545 ; #4184 (#4183 #3698)
[mk-app] #2930 = #3494 #3494
[mk-proof] #2931 refl #2930
[mk-app] #3837 or #1576 #3494
[mk-proof] #3838 quant-inst #3837
[instance] 0x10682d758 #3838 ; 20
[attach-enode] #3083 20
[attach-enode] #3494 20
[assign] #3494 justification -1: p49
[end-of-instance]
[mk-app] #2930 = #3499 #3499
[mk-proof] #2931 refl #2930
[mk-app] #4508 or #5060 #3499
[mk-proof] #4509 quant-inst #4508
[instance] 0x10682d790 #4509 ; 20
[attach-enode] #3085 20
[attach-enode] #3086 20
[attach-enode] #3089 20
[attach-enode] #3495 20
[attach-enode] #3496 20
[attach-enode] #3499 20
[mk-app] #2932 <= #3496 #1503
[mk-app] #2933 >= #3496 #1503
[assign] #3499 justification -1: p51
[end-of-instance]
[assign] #2932 clause p164 (not p163)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[assign] #2933 clause p165 (not p163)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[mk-app] #2930 = #3089 #4184
[attach-meaning] #176 arith (- 1)
[mk-app] #2931 + #3089 #3232
[mk-app] #2937 <= #2931 #36
[mk-app] #2938 >= #2931 #36
[assign] #2930 justification -1: p161
[attach-enode] #2930 0
[attach-enode] #2931 0
[assign] #2937 justification -1: p166
[assign] #2938 justification -1: p166
[new-match] 0x106832160 #1495 #1483 #3695 #1545 ; #3085 (#3698 #3698)
[mk-app] #3614 = #3085 #3111
[mk-app] #3615 = #3510 #3614
[mk-proof] #3613 monotonicity #3110 #3615
[mk-app] #3616 or #1563 #3614
[mk-app] #3081 or #1563 #3510
[mk-proof] #3082 quant-inst #3081
[mk-app] #3738 = #3081 #3616
[mk-proof] #3739 monotonicity #3613 #3738
[mk-app] #3113 = #3616 #3616
[mk-proof] #3114 rewrite #3113
[mk-proof] #3115 trans #3739 #3114 #3738
[mk-proof] #3735 mp #3082 #3115 #3616
[instance] 0x106832160 #3082 ; 21
[attach-enode] #3107 21
[attach-enode] #3111 21
[attach-enode] #3614 21
[assign] #3614 justification -1: p50
[end-of-instance]
[eq-expl] #3107 root
[new-match] 0x106832400 #1477 #1476 #3107 #1545 ; #3111
[eq-expl] #3085 lit #3614 ; #3111
[eq-expl] #3111 root
[new-match] 0x106832438 #1522 #1506 #3107 #1545 ; #3086 (#3085 #3111)
[mk-app] #3740 = #2971 #2971
[mk-proof] #3741 refl #3740
[mk-app] #4049 or #1576 #2971
[mk-proof] #4050 quant-inst #4049
[instance] 0x106832400 #4050 ; 22
[attach-enode] #4051 22
[attach-enode] #2971 22
[assign] #2971 justification -1: p49
[end-of-instance]
[mk-app] #3740 = #3644 #3644
[mk-proof] #3741 refl #3740
[mk-app] #4055 or #5060 #3644
[mk-proof] #4056 quant-inst #4055
[instance] 0x106832438 #4056 ; 22
[attach-enode] #4053 22
[attach-enode] #4054 22
[attach-enode] #4057 22
[attach-enode] #2972 22
[attach-enode] #2973 22
[attach-enode] #3644 22
[mk-app] #3334 <= #2973 #1503
[mk-app] #3329 >= #2973 #1503
[assign] #3644 justification -1: p51
[end-of-instance]
[assign] #3334 clause p172 (not p171)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[assign] #3329 clause p173 (not p171)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[mk-app] #3740 = #3086 #4057
[attach-meaning] #176 arith (- 1)
[mk-app] #3741 + #3086 #2972
[mk-app] #3338 <= #3741 #36
[mk-app] #3339 >= #3741 #36
[assign] #3740 justification -1: p169
[attach-enode] #3740 0
[attach-enode] #3741 0
[assign] #3338 justification -1: p174
[assign] #3339 justification -1: p174
[new-match] 0x106832df8 #1495 #1483 #3107 #1545 ; #4053 (#3111 #3111)
[mk-app] #4222 = #4053 #3326
[mk-app] #4217 = #3411 #4222
[mk-proof] #3352 monotonicity #3328 #4217
[mk-app] #3359 or #1563 #4222
[mk-app] #3360 or #1563 #3411
[mk-proof] #4221 quant-inst #3360
[mk-app] #4218 = #3360 #3359
[mk-proof] #4219 monotonicity #3352 #4218
[mk-app] #4220 = #3359 #3359
[mk-proof] #4223 rewrite #4220
[mk-proof] #4224 trans #4219 #4223 #4218
[mk-proof] #4225 mp #4221 #4224 #3359
[instance] 0x106832df8 #4221 ; 23
[attach-enode] #4510 23
[attach-enode] #3326 23
[attach-enode] #4222 23
[assign] #4222 justification -1: p50
[end-of-instance]
[eq-expl] #4510 root
[new-match] 0x106833098 #1477 #1476 #4510 #1545 ; #3326
[eq-expl] #4053 lit #4222 ; #3326
[eq-expl] #3326 root
[new-match] 0x1068330d0 #1522 #1506 #4510 #1545 ; #4054 (#4053 #3326)
[mk-app] #4238 = #2984 #2984
[mk-proof] #4239 refl #4238
[mk-app] #3703 or #1576 #2984
[mk-proof] #2960 quant-inst #3703
[instance] 0x106833098 #2960 ; 24
[attach-enode] #3344 24
[attach-enode] #2984 24
[assign] #2984 justification -1: p49
[end-of-instance]
[mk-app] #4238 = #3225 #3225
[mk-proof] #4239 refl #4238
[mk-app] #3643 or #5060 #3225
[mk-proof] #3559 quant-inst #3643
[instance] 0x1068330d0 #3559 ; 24
[attach-enode] #3346 24
[attach-enode] #3347 24
[attach-enode] #3353 24
[attach-enode] #2985 24
[attach-enode] #2988 24
[attach-enode] #3225 24
[mk-app] #4566 <= #2988 #1503
[mk-app] #4567 >= #2988 #1503
[assign] #3225 justification -1: p51
[end-of-instance]
[assign] #4566 clause p180 (not p179)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[assign] #4567 clause p181 (not p179)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[mk-app] #4238 = #3353 #4054
[attach-meaning] #176 arith (- 1)
[mk-app] #4239 * #176 #4054
[mk-app] #3637 + #3353 #4239
[mk-app] #3642 <= #3637 #36
[mk-app] #3560 >= #3637 #36
[assign] #4238 justification -1: p177
[attach-enode] #4238 0
[attach-enode] #4239 0
[attach-enode] #3637 0
[assign] #3642 justification -1: p182
[assign] #3560 justification -1: p182
[new-match] 0x106833b18 #1495 #1483 #4510 #1545 ; #3346 (#3326 #3326)
[mk-app] #4559 = #3346 #3788
[mk-app] #3002 = #4135 #4559
[mk-proof] #3913 monotonicity #4216 #3002
[mk-app] #3914 or #1563 #4559
[mk-app] #3915 or #1563 #4135
[mk-proof] #3005 quant-inst #3915
[mk-app] #3006 = #3915 #3914
[mk-proof] #3014 monotonicity #3913 #3006
[mk-app] #3034 = #3914 #3914
[mk-proof] #3994 rewrite #3034
[mk-proof] #3995 trans #3014 #3994 #3006
[mk-proof] #3988 mp #3005 #3995 #3914
[instance] 0x106833b18 #3005 ; 25
[attach-enode] #3785 25
[attach-enode] #3788 25
[attach-enode] #4559 25
[assign] #4559 justification -1: p50
[end-of-instance]
[eq-expl] #3785 root
[new-match] 0x106833db8 #1477 #1476 #3785 #1545 ; #3788
[eq-expl] #3346 lit #4559 ; #3788
[eq-expl] #3788 root
[new-match] 0x10683aa10 #1522 #1506 #3785 #1545 ; #3347 (#3346 #3788)
[mk-app] #3989 = #3254 #3254
[mk-proof] #3992 refl #3989
[mk-app] #3993 or #1576 #3254
[mk-proof] #3996 quant-inst #3993
[instance] 0x106833db8 #3996 ; 26
[attach-enode] #4233 26
[attach-enode] #3254 26
[assign] #3254 justification -1: p49
[end-of-instance]
[mk-app] #3989 = #3253 #3253
[mk-proof] #3992 refl #3989
[mk-app] #4001 or #5060 #3253
[mk-proof] #4007 quant-inst #4001
[instance] 0x10683aa10 #4007 ; 26
[attach-enode] #4235 26
[attach-enode] #4237 26
[attach-enode] #4240 26
[attach-enode] #3255 26
[attach-enode] #3250 26
[attach-enode] #3253 26
[mk-app] #4008 <= #3250 #1503
[mk-app] #4016 >= #3250 #1503
[assign] #3253 justification -1: p51
[end-of-instance]
[assign] #4008 clause p188 (not p187)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[assign] #4016 clause p189 (not p187)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[mk-app] #3989 = #3347 #4240
[attach-meaning] #176 arith (- 1)
[mk-app] #3992 + #3347 #3255
[mk-app] #4496 <= #3992 #36
[mk-app] #3629 >= #3992 #36
[assign] #3989 justification -1: p185
[attach-enode] #3989 0
[attach-enode] #3992 0
[assign] #4496 justification -1: p190
[assign] #3629 justification -1: p190
[new-match] 0x10683b3d0 #1495 #1483 #3785 #1545 ; #4235 (#3788 #3788)
[mk-app] #3574 = #4235 #2957
[mk-app] #3592 = #3279 #3574
[mk-proof] #3593 monotonicity #2959 #3592
[mk-app] #4276 or #1563 #3574
[mk-app] #4277 or #1563 #3279
[mk-proof] #4278 quant-inst #4277
[mk-app] #4279 = #4277 #4276
[mk-proof] #4274 monotonicity #3593 #4279
[mk-app] #4275 = #4276 #4276
[mk-proof] #4280 rewrite #4275
[mk-proof] #4281 trans #4274 #4280 #4279
[mk-proof] #4282 mp #4278 #4281 #4276
[instance] 0x10683b3d0 #4278 ; 27
[attach-enode] #2954 27
[attach-enode] #2957 27
[attach-enode] #3574 27
[assign] #3574 justification -1: p50
[end-of-instance]
[eq-expl] #2954 root
[new-match] 0x10683b670 #1477 #1476 #2954 #1545 ; #2957
[eq-expl] #4235 lit #3574 ; #2957
[eq-expl] #2957 root
[new-match] 0x10683b6a8 #1522 #1506 #2954 #1545 ; #4237 (#4235 #2957)
[mk-app] #4286 = #4180 #4180
[mk-proof] #4287 refl #4286
[mk-app] #4288 or #1576 #4180
[mk-proof] #3825 quant-inst #4288
[instance] 0x10683b670 #3825 ; 28
[attach-enode] #3638 28
[attach-enode] #4180 28
[assign] #4180 justification -1: p49
[end-of-instance]
[mk-app] #4286 = #3622 #3622
[mk-proof] #4287 refl #4286
[mk-app] #3125 or #5060 #3622
[mk-proof] #3123 quant-inst #3125
[instance] 0x10683b6a8 #3123 ; 28
[attach-enode] #3640 28
[attach-enode] #3641 28
[attach-enode] #4500 28
[attach-enode] #4588 28
[attach-enode] #4589 28
[attach-enode] #3622 28
[mk-app] #3124 <= #4589 #1503
[mk-app] #3148 >= #4589 #1503
[assign] #3622 justification -1: p51
[end-of-instance]
[assign] #3124 clause p196 (not p195)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[assign] #3148 clause p197 (not p195)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[mk-app] #4286 = #4237 #4500
[attach-meaning] #176 arith (- 1)
[mk-app] #4287 + #4237 #4588
[mk-app] #3173 <= #4287 #36
[mk-app] #3132 >= #4287 #36
[assign] #4286 justification -1: p193
[attach-enode] #4286 0
[attach-enode] #4287 0
[assign] #3173 justification -1: p198
[assign] #3132 justification -1: p198
[new-match] 0x10683c068 #1495 #1483 #2954 #1545 ; #3640 (#2957 #2957)
[mk-app] #3137 = #3640 #3910
[mk-app] #3139 = #3836 #3137
[mk-proof] #3147 monotonicity #3912 #3139
[mk-app] #3171 or #1563 #3137
[mk-app] #3168 or #1563 #3836
[mk-proof] #3169 quant-inst #3168
[mk-app] #3170 = #3168 #3171
[mk-proof] #3172 monotonicity #3147 #3170
[mk-app] #3174 = #3171 #3171
[mk-proof] #3743 rewrite #3174
[mk-proof] #3744 trans #3172 #3743 #3170
[mk-proof] #4083 mp #3169 #3744 #3171
[instance] 0x10683c068 #3169 ; 29
[attach-enode] #3572 29
[attach-enode] #3910 29
[attach-enode] #3137 29
[assign] #3137 justification -1: p50
[end-of-instance]
[eq-expl] #3572 root
[new-match] 0x10683c308 #1477 #1476 #3572 #1545 ; #3910
[eq-expl] #3640 lit #3137 ; #3910
[eq-expl] #3910 root
[new-match] 0x10683c340 #1522 #1506 #3572 #1545 ; #3641 (#3640 #3910)
[mk-app] #3512 = #4565 #4565
[mk-proof] #3519 refl #3512
[mk-app] #3524 or #1576 #4565
[mk-proof] #3515 quant-inst #3524
[instance] 0x10683c308 #3515 ; 30
[attach-enode] #3009 30
[attach-enode] #4565 30
[assign] #4565 justification -1: p49
[end-of-instance]
[mk-app] #3512 = #3617 #3617
[mk-proof] #3519 refl #3512
[mk-app] #3516 or #5060 #3617
[mk-proof] #3517 quant-inst #3516
[instance] 0x10683c340 #3517 ; 30
[attach-enode] #3011 30
[attach-enode] #3012 30
[attach-enode] #3015 30
[attach-enode] #3611 30
[attach-enode] #3612 30
[attach-enode] #3617 30
[mk-app] #3518 <= #3612 #1503
[mk-app] #3525 >= #3612 #1503
[assign] #3617 justification -1: p51
[end-of-instance]
[assign] #3518 clause p204 (not p203)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[assign] #3525 clause p205 (not p203)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[mk-app] #3512 = #3015 #3641
[attach-meaning] #176 arith (- 1)
[mk-app] #3519 * #176 #3641
[mk-app] #3532 + #3015 #3519
[mk-app] #3533 <= #3532 #36
[mk-app] #4453 >= #3532 #36
[assign] #3512 justification -1: p201
[attach-enode] #3512 0
[attach-enode] #3519 0
[attach-enode] #3532 0
[assign] #3533 justification -1: p206
[assign] #4453 justification -1: p206
[new-match] 0x106840fa8 #1495 #1483 #3572 #1545 ; #3011 (#3910 #3910)
[mk-app] #4454 = #3011 #3725
[mk-app] #4449 = #3737 #4454
[mk-proof] #4455 monotonicity #3727 #4449
[mk-app] #4456 or #1563 #4454
[mk-app] #4460 or #1563 #3737
[mk-proof] #4467 quant-inst #4460
[mk-app] #3444 = #4460 #4456
[mk-proof] #3445 monotonicity #4455 #3444
[mk-app] #3438 = #4456 #4456
[mk-proof] #3439 rewrite #3438
[mk-proof] #3440 trans #3445 #3439 #3444
[mk-proof] #3442 mp #4467 #3440 #4456
[instance] 0x106840fa8 #4467 ; 31
[attach-enode] #3722 31
[attach-enode] #3725 31
[attach-enode] #4454 31
[assign] #4454 justification -1: p50
[end-of-instance]
[eq-expl] #3722 root
[new-match] 0x106841248 #1477 #1476 #3722 #1545 ; #3725
[eq-expl] #3011 lit #4454 ; #3725
[eq-expl] #3725 root
[new-match] 0x106841280 #1522 #1506 #3722 #1545 ; #3012 (#3011 #3725)
[mk-app] #3446 = #4064 #4064
[mk-proof] #3853 refl #3446
[mk-app] #3854 or #1576 #4064
[mk-proof] #3855 quant-inst #3854
[instance] 0x106841248 #3855 ; 32
[attach-enode] #4002 32
[attach-enode] #4064 32
[assign] #4064 justification -1: p49
[end-of-instance]
[mk-app] #3446 = #3330 #3330
[mk-proof] #3853 refl #3446
[mk-app] #4362 or #5060 #3330
[mk-proof] #4363 quant-inst #4362
[instance] 0x106841280 #4363 ; 32
[attach-enode] #4004 32
[attach-enode] #4005 32
[attach-enode] #4009 32
[attach-enode] #4065 32
[attach-enode] #3333 32
[attach-enode] #3330 32
[mk-app] #3543 <= #3333 #1503
[mk-app] #4581 >= #3333 #1503
[assign] #3330 justification -1: p51
[end-of-instance]
[assign] #3543 clause p212 (not p211)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[assign] #4581 clause p213 (not p211)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[mk-app] #3446 = #3012 #4009
[attach-meaning] #176 arith (- 1)
[mk-app] #3853 + #3012 #4065
[mk-app] #3544 <= #3853 #36
[mk-app] #3545 >= #3853 #36
[assign] #3446 justification -1: p209
[attach-enode] #3446 0
[attach-enode] #3853 0
[assign] #3544 justification -1: p214
[assign] #3545 justification -1: p214
[new-match] 0x106841c40 #1495 #1483 #3722 #1545 ; #4004 (#3725 #3725)
[mk-app] #3808 = #4004 #3633
[mk-app] #3809 = #3351 #3808
[mk-proof] #4475 monotonicity #3631 #3809
[mk-app] #4476 or #1563 #3808
[mk-app] #4248 or #1563 #3351
[mk-proof] #4249 quant-inst #4248
[mk-app] #3810 = #4248 #4476
[mk-proof] #4247 monotonicity #4475 #3810
[mk-app] #4250 = #4476 #4476
[mk-proof] #4251 rewrite #4250
[mk-proof] #4252 trans #4247 #4251 #3810
[mk-proof] #4253 mp #4249 #4252 #4476
[instance] 0x106841c40 #4249 ; 33
[attach-enode] #3632 33
[attach-enode] #3633 33
[attach-enode] #3808 33
[assign] #3808 justification -1: p50
[end-of-instance]
[eq-expl] #3632 root
[new-match] 0x106841ee0 #1477 #1476 #3632 #1545 ; #3633
[eq-expl] #4004 lit #3808 ; #3633
[eq-expl] #3633 root
[new-match] 0x106841f18 #1522 #1506 #3632 #1545 ; #4005 (#4004 #3633)
[mk-app] #4306 = #4226 #4226
[mk-proof] #4314 refl #4306
[mk-app] #2922 or #1576 #4226
[mk-proof] #2923 quant-inst #2922
[instance] 0x106841ee0 #2923 ; 34
[attach-enode] #3596 34
[attach-enode] #4226 34
[assign] #4226 justification -1: p49
[end-of-instance]
[mk-app] #4306 = #4592 #4592
[mk-proof] #4314 refl #4306
[mk-app] #3774 or #5060 #4592
[mk-proof] #3935 quant-inst #3774
[instance] 0x106841f18 #3935 ; 34
[attach-enode] #4533 34
[attach-enode] #3367 34
[attach-enode] #3370 34
[attach-enode] #4231 34
[attach-enode] #4232 34
[attach-enode] #4592 34
[mk-app] #3682 <= #4232 #1503
[mk-app] #3683 >= #4232 #1503
[assign] #4592 justification -1: p51
[end-of-instance]
[assign] #3682 clause p220 (not p219)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[assign] #3683 clause p221 (not p219)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[mk-app] #4306 = #3370 #4005
[attach-meaning] #176 arith (- 1)
[mk-app] #4314 * #176 #4005
[mk-app] #3684 + #3370 #4314
[mk-app] #3773 <= #3684 #36
[mk-app] #3936 >= #3684 #36
[assign] #4306 justification -1: p217
[attach-enode] #4306 0
[attach-enode] #4314 0
[attach-enode] #3684 0
[assign] #3773 justification -1: p222
[assign] #3936 justification -1: p222
[new-match] 0x106842960 #1495 #1483 #3632 #1545 ; #4533 (#3633 #3633)
[mk-app] #3922 = #4533 #3803
[mk-app] #4522 = #3706 #3922
[mk-proof] #3918 monotonicity #4273 #4522
[mk-app] #3919 or #1563 #3922
[mk-app] #3920 or #1563 #3706
[mk-proof] #3577 quant-inst #3920
[mk-app] #3578 = #3920 #3919
[mk-proof] #3584 monotonicity #3918 #3578
[mk-app] #3449 = #3919 #3919
[mk-proof] #3048 rewrite #3449
[mk-proof] #3049 trans #3584 #3048 #3578
[mk-proof] #3044 mp #3577 #3049 #3919
[instance] 0x106842960 #3577 ; 35
[attach-enode] #3800 35
[attach-enode] #3803 35
[attach-enode] #3922 35
[assign] #3922 justification -1: p50
[end-of-instance]
[eq-expl] #3800 root
[new-match] 0x106827e10 #1477 #1476 #3800 #1545 ; #3803
[eq-expl] #4533 lit #3922 ; #3803
[eq-expl] #3803 root
[new-match] 0x106827e48 #1522 #1506 #3800 #1545 ; #3367 (#4533 #3803)
[mk-app] #3045 = #4558 #4558
[mk-proof] #3046 refl #3045
[mk-app] #3047 or #1576 #4558
[mk-proof] #3050 quant-inst #3047
[instance] 0x106827e10 #3050 ; 36
[attach-enode] #4289 36
[attach-enode] #4558 36
[assign] #4558 justification -1: p49
[end-of-instance]
[mk-app] #3045 = #3007 #3007
[mk-proof] #3046 refl #3045
[mk-app] #3051 or #5060 #3007
[mk-proof] #3447 quant-inst #3051
[instance] 0x106827e48 #3447 ; 36
[attach-enode] #4292 36
[attach-enode] #4293 36
[attach-enode] #4297 36
[attach-enode] #3003 36
[attach-enode] #3004 36
[attach-enode] #3007 36
[mk-app] #3448 <= #3004 #1503
[mk-app] #3451 >= #3004 #1503
[assign] #3007 justification -1: p51
[end-of-instance]
[assign] #3448 clause p228 (not p227)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[assign] #3451 clause p229 (not p227)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[mk-app] #3045 = #3367 #4297
[attach-meaning] #176 arith (- 1)
[mk-app] #3046 + #3367 #3003
[mk-app] #3452 <= #3046 #36
[mk-app] #3456 >= #3046 #36
[assign] #3045 justification -1: p225
[attach-enode] #3045 0
[attach-enode] #3046 0
[assign] #3452 justification -1: p230
[assign] #3456 justification -1: p230
[new-match] 0x106828808 #1495 #1483 #3800 #1545 ; #4292 (#3803 #3803)
[mk-app] #4399 = #4292 #3118
[mk-app] #4397 = #3987 #4399
[mk-proof] #4398 monotonicity #3120 #4397
[mk-app] #3795 or #1563 #4399
[mk-app] #3796 or #1563 #3987
[mk-proof] #4583 quant-inst #3796
[mk-app] #3790 = #3796 #3795
[mk-proof] #4550 monotonicity #4398 #3790
[mk-app] #4551 = #3795 #3795
[mk-proof] #4258 rewrite #4551
[mk-proof] #4259 trans #4550 #4258 #3790
[mk-proof] #4260 mp #4583 #4259 #3795
[instance] 0x106828808 #4583 ; 37
[attach-enode] #4573 37
[attach-enode] #3118 37
[attach-enode] #4399 37
[assign] #4399 justification -1: p50
[end-of-instance]
[eq-expl] #4573 root
[new-match] 0x106828aa8 #1477 #1476 #4573 #1545 ; #3118
[eq-expl] #4292 lit #4399 ; #3118
[eq-expl] #3118 root
[new-match] 0x106828ae0 #1522 #1506 #4573 #1545 ; #4293 (#4292 #3118)
[mk-app] #4262 = #4526 #4526
[mk-proof] #4263 refl #4262
[mk-app] #4264 or #1576 #4526
[mk-proof] #4269 quant-inst #4264
[instance] 0x106828aa8 #4269 ; 38
[attach-enode] #3133 38
[attach-enode] #4526 38
[assign] #4526 justification -1: p49
[end-of-instance]
[mk-app] #4262 = #3575 #3575
[mk-proof] #4263 refl #4262
[mk-app] #4270 or #5060 #3575
[mk-proof] #3460 quant-inst #4270
[instance] 0x106828ae0 #3460 ; 38
[attach-enode] #3135 38
[attach-enode] #3136 38
[attach-enode] #3140 38
[attach-enode] #4527 38
[attach-enode] #3628 38
[attach-enode] #3575 38
[mk-app] #3461 <= #3628 #1503
[mk-app] #3839 >= #3628 #1503
[assign] #3575 justification -1: p51
[end-of-instance]
[assign] #3461 clause p236 (not p235)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[assign] #3839 clause p237 (not p235)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[mk-app] #4262 = #3140 #4293
[attach-meaning] #176 arith (- 1)
[mk-app] #4263 * #176 #4293
[mk-app] #3840 + #3140 #4263
[mk-app] #3841 <= #3840 #36
[mk-app] #3842 >= #3840 #36
[assign] #4262 justification -1: p233
[attach-enode] #4262 0
[attach-enode] #4263 0
[attach-enode] #3840 0
[assign] #3841 justification -1: p238
[assign] #3842 justification -1: p238
[new-match] 0x106829528 #1495 #1483 #4573 #1545 ; #3135 (#3118 #3118)
[mk-app] #3843 = #3135 #3165
[mk-app] #3844 = #3378 #3843
[mk-proof] #4594 monotonicity #3167 #3844
[mk-app] #4595 or #1563 #3843
[mk-app] #3926 or #1563 #3378
[mk-proof] #3927 quant-inst #3926
[mk-app] #3928 = #3926 #4595
[mk-proof] #3929 monotonicity #4594 #3928
[mk-app] #3458 = #4595 #4595
[mk-proof] #3459 rewrite #3458
[mk-proof] #3462 trans #3929 #3459 #3928
[mk-proof] #3463 mp #3927 #3462 #4595
[instance] 0x106829528 #3927 ; 39
[attach-enode] #3161 39
[attach-enode] #3165 39
[attach-enode] #3843 39
[assign] #3843 justification -1: p50
[end-of-instance]
[eq-expl] #3161 root
[new-match] 0x1068297c8 #1477 #1476 #3161 #1545 ; #3165
[eq-expl] #3135 lit #3843 ; #3165
[eq-expl] #3165 root
[new-match] 0x106829800 #1522 #1506 #3161 #1545 ; #3136 (#3135 #3165)
[mk-app] #3471 = #4294 #4294
[mk-proof] #3472 refl #3471
[mk-app] #3479 or #1576 #4294
[mk-proof] #3480 quant-inst #3479
[instance] 0x1068297c8 #3480 ; 40
[attach-enode] #3745 40
[attach-enode] #4294 40
[assign] #4294 justification -1: p49
[end-of-instance]
[mk-app] #3471 = #3126 #3126
[mk-proof] #3472 refl #3471
[mk-app] #3604 or #5060 #3126
[mk-proof] #3605 quant-inst #3604
[instance] 0x106829800 #3605 ; 40
[attach-enode] #3747 40
[attach-enode] #3748 40
[attach-enode] #4076 40
[attach-enode] #4295 40
[attach-enode] #4553 40
[attach-enode] #3126 40
[mk-app] #4428 <= #4553 #1503
[mk-app] #4430 >= #4553 #1503
[assign] #3126 justification -1: p51
[end-of-instance]
[assign] #4428 clause p244 (not p243)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[assign] #4430 clause p245 (not p243)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[mk-app] #3471 = #3136 #4076
[attach-meaning] #176 arith (- 1)
[mk-app] #3472 + #3136 #4295
[mk-app] #4431 <= #3472 #36
[mk-app] #4432 >= #3472 #36
[assign] #3471 justification -1: p241
[attach-enode] #3471 0
[attach-enode] #3472 0
[assign] #4431 justification -1: p246
[assign] #4432 justification -1: p246
[new-match] 0x106859bd8 #1495 #1483 #3161 #1545 ; #3747 (#3165 #3165)
[mk-app] #3066 = #3747 #4100
[mk-app] #3067 = #3131 #3066
[mk-proof] #3610 monotonicity #4102 #3067
[mk-app] #4536 or #1563 #3066
[mk-app] #4537 or #1563 #3131
[mk-proof] #3052 quant-inst #4537
[mk-app] #3056 = #4537 #4536
[mk-proof] #3057 monotonicity #3610 #3056
[mk-app] #4020 = #4536 #4536
[mk-proof] #4021 rewrite #4020
[mk-proof] #3059 trans #3057 #4021 #3056
[mk-proof] #3060 mp #3052 #3059 #4536
[instance] 0x106859bd8 #3052 ; 41
[attach-enode] #4096 41
[attach-enode] #4100 41
[attach-enode] #3066 41
[assign] #3066 justification -1: p50
[end-of-instance]
[eq-expl] #4096 root
[new-match] 0x106859e78 #1477 #1476 #4096 #1545 ; #4100
[eq-expl] #3747 lit #3066 ; #4100
[eq-expl] #4100 root
[new-match] 0x106859eb0 #1522 #1506 #4096 #1545 ; #3748 (#3747 #4100)
[mk-app] #3061 = #3175 #3175
[mk-proof] #3065 refl #3061
[mk-app] #3068 or #1576 #3175
[mk-proof] #3069 quant-inst #3068
[instance] 0x106859e78 #3069 ; 42
[attach-enode] #3520 42
[attach-enode] #3175 42
[assign] #3175 justification -1: p49
[end-of-instance]
[mk-app] #3061 = #4074 #4074
[mk-proof] #3065 refl #3061
[mk-app] #3070 or #5060 #4074
[mk-proof] #3071 quant-inst #3070
[instance] 0x106859eb0 #3071 ; 42
[attach-enode] #3522 42
[attach-enode] #3523 42
[attach-enode] #3526 42
[attach-enode] #3176 42
[attach-enode] #3742 42
[attach-enode] #4074 42
[mk-app] #3072 <= #3742 #1503
[mk-app] #3073 >= #3742 #1503
[assign] #4074 justification -1: p51
[end-of-instance]
[assign] #3072 clause p252 (not p251)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[assign] #3073 clause p253 (not p251)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[mk-app] #3061 = #3526 #3748
[attach-meaning] #176 arith (- 1)
[mk-app] #3065 * #176 #3748
[mk-app] #4022 + #3526 #3065
[mk-app] #4023 <= #4022 #36
[mk-app] #4018 >= #4022 #36
[assign] #3061 justification -1: p249
[attach-enode] #3061 0
[attach-enode] #3065 0
[attach-enode] #4022 0
[assign] #4023 justification -1: p254
[assign] #4018 justification -1: p254
[new-match] 0x10685a8f8 #1495 #1483 #4096 #1545 ; #3522 (#4100 #4100)
[mk-app] #4019 = #3522 #3901
[mk-app] #4024 = #3514 #4019
[mk-proof] #4025 monotonicity #4448 #4024
[mk-app] #4026 or #1563 #4019
[mk-app] #4027 or #1563 #3514
[mk-proof] #4032 quant-inst #4027
[mk-app] #4033 = #4027 #4026
[mk-proof] #3304 monotonicity #4025 #4033
[mk-app] #3305 = #4026 #4026
[mk-proof] #3298 rewrite #3305
[mk-proof] #3299 trans #3304 #3298 #4033
[mk-proof] #3300 mp #4032 #3299 #4026
[instance] 0x10685a8f8 #4032 ; 43
[attach-enode] #3898 43
[attach-enode] #3901 43
[attach-enode] #4019 43
[assign] #4019 justification -1: p50
[end-of-instance]
[eq-expl] #3898 root
[new-match] 0x10685ab98 #1477 #1476 #3898 #1545 ; #3901
[eq-expl] #3522 lit #4019 ; #3901
[eq-expl] #3901 root
[new-match] 0x10685abd0 #1522 #1506 #3898 #1545 ; #3523 (#3522 #3901)
[mk-app] #3303 = #4450 #4450
[mk-proof] #3309 refl #3303
[mk-app] #3310 or #1576 #4450
[mk-proof] #3311 quant-inst #3310
[instance] 0x10685ab98 #3311 ; 44
[attach-enode] #4462 44
[attach-enode] #4450 44
[assign] #4450 justification -1: p49
[end-of-instance]
[mk-app] #3303 = #4457 #4457
[mk-proof] #3309 refl #3303
[mk-app] #3316 or #5060 #4457
[mk-proof] #3317 quant-inst #3316
[instance] 0x10685abd0 #3317 ; 44
[attach-enode] #4464 44
[attach-enode] #4465 44
[attach-enode] #4469 44
[attach-enode] #4451 44
[attach-enode] #4452 44
[attach-enode] #4457 44
[mk-app] #3324 <= #4452 #1503
[mk-app] #4193 >= #4452 #1503
[assign] #4457 justification -1: p51
[end-of-instance]
[assign] #3324 clause p260 (not p259)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[assign] #4193 clause p261 (not p259)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[mk-app] #3303 = #3523 #4469
[attach-meaning] #176 arith (- 1)
[mk-app] #3309 + #3523 #4451
[mk-app] #4194 <= #3309 #36
[mk-app] #4204 >= #3309 #36
[assign] #3303 justification -1: p257
[attach-enode] #3303 0
[attach-enode] #3309 0
[assign] #4194 justification -1: p262
[assign] #4204 justification -1: p262
[new-match] 0x10685b590 #1495 #1483 #3898 #1545 ; #4464 (#3901 #3901)
[mk-app] #4206 = #4464 #3435
[mk-app] #3820 = #3441 #4206
[mk-proof] #3821 monotonicity #3437 #3820
[mk-app] #3879 or #1563 #4206
[mk-app] #3880 or #1563 #3441
[mk-proof] #3824 quant-inst #3880
[mk-app] #4570 = #3880 #3879
[mk-proof] #3822 monotonicity #3821 #4570
[mk-app] #3823 = #3879 #3879
[mk-proof] #4571 rewrite #3823
[mk-proof] #3597 trans #3822 #4571 #4570
[mk-proof] #3598 mp #3824 #3597 #3879
[instance] 0x10685b590 #3824 ; 45
[attach-enode] #3432 45
[attach-enode] #3435 45
[attach-enode] #4206 45
[assign] #4206 justification -1: p50
[end-of-instance]
[eq-expl] #3432 root
[new-match] 0x106862858 #1477 #1476 #3432 #1545 ; #3435
[eq-expl] #4464 lit #4206 ; #3435
[eq-expl] #3435 root
[new-match] 0x106862890 #1522 #1506 #3432 #1545 ; #4465 (#4464 #3435)
[mk-app] #3599 = #4370 #4370
[mk-proof] #2990 refl #3599
[mk-app] #3961 or #1576 #4370
[mk-proof] #3963 quant-inst #3961
[instance] 0x106862858 #3963 ; 46
[attach-enode] #3856 46
[attach-enode] #4370 46
[assign] #4370 justification -1: p49
[end-of-instance]
[mk-app] #3599 = #3539 #3539
[mk-proof] #2990 refl #3599
[mk-app] #3964 or #5060 #3539
[mk-proof] #2995 quant-inst #3964
[instance] 0x106862890 #2995 ; 46
[attach-enode] #3858 46
[attach-enode] #3859 46
[attach-enode] #4364 46
[attach-enode] #4371 46
[attach-enode] #3542 46
[attach-enode] #3539 46
[mk-app] #2997 <= #3542 #1503
[mk-app] #2998 >= #3542 #1503
[assign] #3539 justification -1: p51
[end-of-instance]
[assign] #2997 clause p268 (not p267)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[assign] #2998 clause p269 (not p267)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[mk-app] #3599 = #4364 #4465
[attach-meaning] #176 arith (- 1)
[mk-app] #2990 * #176 #4465
[mk-app] #2996 + #4364 #2990
[mk-app] #2999 <= #2996 #36
[mk-app] #3000 >= #2996 #36
[assign] #3599 justification -1: p265
[attach-enode] #3599 0
[attach-enode] #2990 0
[attach-enode] #2996 0
[assign] #2999 justification -1: p270
[assign] #3000 justification -1: p270
[new-match] 0x1068632d8 #1495 #1483 #3432 #1545 ; #3858 (#3435 #3435)
[mk-app] #3001 = #3858 #4385
[mk-app] #3714 = #3902 #3001
[mk-proof] #3715 monotonicity #4580 #3714
[mk-app] #3716 or #1563 #3001
[mk-app] #3717 or #1563 #3902
[mk-proof] #3718 quant-inst #3717
[mk-app] #3719 = #3717 #3716
[mk-proof] #3720 monotonicity #3715 #3719
[mk-app] #3965 = #3716 #3716
[mk-proof] #3966 rewrite #3965
[mk-proof] #3967 trans #3720 #3966 #3719
[mk-proof] #3968 mp #3718 #3967 #3716
[instance] 0x1068632d8 #3718 ; 47
[attach-enode] #4382 47
[attach-enode] #4385 47
[attach-enode] #3001 47
[assign] #3001 justification -1: p50
[end-of-instance]
[eq-expl] #4382 root
[new-match] 0x106863578 #1477 #1476 #4382 #1545 ; #4385
[eq-expl] #3858 lit #3001 ; #4385
[eq-expl] #4385 root
[new-match] 0x1068635b0 #1522 #1506 #4382 #1545 ; #3859 (#3858 #4385)
[mk-app] #3180 = #4254 #4254
[mk-proof] #3181 refl #3180
[mk-app] #3197 or #1576 #4254
[mk-proof] #3207 quant-inst #3197
[instance] 0x106863578 #3207 ; 48
[attach-enode] #3550 48
[attach-enode] #4254 48
[assign] #4254 justification -1: p49
[end-of-instance]
[mk-app] #3180 = #4315 #4315
[mk-proof] #3181 refl #3180
[mk-app] #3188 or #5060 #4315
[mk-proof] #3189 quant-inst #3188
[instance] 0x1068635b0 #3189 ; 48
[attach-enode] #3552 48
[attach-enode] #3553 48
[attach-enode] #3903 48
[attach-enode] #4255 48
[attach-enode] #4304 48
[attach-enode] #4315 48
[mk-app] #3191 <= #4304 #1503
[mk-app] #3196 >= #4304 #1503
[assign] #4315 justification -1: p51
[end-of-instance]
[assign] #3191 clause p276 (not p275)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[assign] #3196 clause p277 (not p275)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[mk-app] #3180 = #3859 #3903
[attach-meaning] #176 arith (- 1)
[mk-app] #3181 + #3859 #4255
[mk-app] #3208 <= #3181 #36
[mk-app] #3752 >= #3181 #36
[assign] #3180 justification -1: p273
[attach-enode] #3180 0
[attach-enode] #3181 0
[assign] #3208 justification -1: p278
[assign] #3752 justification -1: p278
[new-match] 0x106863f70 #1495 #1483 #4382 #1545 ; #3552 (#4385 #4385)
[mk-app] #3753 = #3552 #3805
[mk-app] #3222 = #3681 #3753
[mk-proof] #3749 monotonicity #3807 #3222
[mk-app] #3750 or #1563 #3753
[mk-app] #4109 or #1563 #3681
[mk-proof] #4110 quant-inst #4109
[mk-app] #4123 = #4109 #3750
[mk-proof] #4514 monotonicity #3749 #4123
[mk-app] #3668 = #3750 #3750
[mk-proof] #3669 rewrite #3668
[mk-proof] #3657 trans #4514 #3669 #4123
[mk-proof] #4504 mp #4110 #3657 #3750
[instance] 0x106863f70 #4110 ; 49
[attach-enode] #4548 49
[attach-enode] #3805 49
[attach-enode] #3753 49
[assign] #3753 justification -1: p50
[end-of-instance]
[eq-expl] #4548 root
[new-match] 0x106864210 #1477 #1476 #4548 #1545 ; #3805
[eq-expl] #3552 lit #3753 ; #3805
[eq-expl] #3805 root
[new-match] 0x106864248 #1522 #1506 #4548 #1545 ; #3553 (#3552 #3805)
[mk-app] #3666 = #3921 #3921
[mk-proof] #3667 refl #3666
[mk-app] #3670 or #1576 #3921
[mk-proof] #3671 quant-inst #3670
[instance] 0x106864210 #3671 ; 50
[attach-enode] #4256 50
[attach-enode] #3921 50
[assign] #3921 justification -1: p49
[end-of-instance]
[mk-app] #3666 = #3579 #3579
[mk-proof] #3667 refl #3666
[mk-app] #4586 or #5060 #3579
[mk-proof] #4587 quant-inst #4586
[instance] 0x106864248 #4587 ; 50
[attach-enode] #4302 50
[attach-enode] #4303 50
[attach-enode] #4307 50
[attach-enode] #4523 50
[attach-enode] #3576 50
[attach-enode] #3579 50
[mk-app] #4489 <= #3576 #1503
[mk-app] #4598 >= #3576 #1503
[assign] #3579 justification -1: p51
[end-of-instance]
[assign] #4489 clause p284 (not p283)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[assign] #4598 clause p285 (not p283)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[mk-app] #3666 = #3553 #4307
[attach-meaning] #176 arith (- 1)
[mk-app] #3667 + #3553 #4523
[mk-app] #4613 <= #3667 #36
[mk-app] #4614 >= #3667 #36
[assign] #3666 justification -1: p281
[attach-enode] #3666 0
[attach-enode] #3667 0
[assign] #4613 justification -1: p286
[assign] #4614 justification -1: p286
[new-match] 0x106867618 #1495 #1483 #4548 #1545 ; #4302 (#3805 #3805)
[mk-app] #4620 = #4302 #2919
[mk-app] #4621 = #3043 #4620
[mk-proof] #4653 monotonicity #2921 #4621
[mk-app] #4654 or #1563 #4620
[mk-app] #4655 or #1563 #3043
[mk-proof] #4656 quant-inst #4655
[mk-app] #4651 = #4655 #4654
[mk-proof] #4652 monotonicity #4653 #4651
[mk-app] #4657 = #4654 #4654
[mk-proof] #4658 rewrite #4657
[mk-proof] #4659 trans #4652 #4658 #4651
[mk-proof] #4660 mp #4656 #4659 #4654
[instance] 0x106867618 #4656 ; 51
[attach-enode] #2916 51
[attach-enode] #2919 51
[attach-enode] #4620 51
[assign] #4620 justification -1: p50
[end-of-instance]
[eq-expl] #2916 root
[new-match] 0x1068678b8 #1477 #1476 #2916 #1545 ; #2919
[eq-expl] #4302 lit #4620 ; #2919
[eq-expl] #2919 root
[new-match] 0x1068678f0 #1522 #1506 #2916 #1545 ; #4303 (#4302 #2919)
[mk-app] #4661 = #3453 #3453
[mk-proof] #4662 refl #4661
[mk-app] #4676 or #1576 #3453
[mk-proof] #4694 quant-inst #4676
[instance] 0x1068678b8 #4694 ; 52
[attach-enode] #3685 52
[attach-enode] #3453 52
[assign] #3453 justification -1: p49
[end-of-instance]
[mk-app] #4661 = #4400 #4400
[mk-proof] #4662 refl #4661
[mk-app] #4692 or #5060 #4400
[mk-proof] #4693 quant-inst #4692
[instance] 0x1068678f0 #4693 ; 52
[attach-enode] #3771 52
[attach-enode] #3772 52
[attach-enode] #3775 52
[attach-enode] #3454 52
[attach-enode] #3455 52
[attach-enode] #4400 52
[mk-app] #4715 <= #3455 #1503
[mk-app] #4733 >= #3455 #1503
[assign] #4400 justification -1: p51
[end-of-instance]
[assign] #4715 clause p292 (not p291)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[assign] #4733 clause p293 (not p291)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[mk-app] #4661 = #3775 #4303
[attach-meaning] #176 arith (- 1)
[mk-app] #4662 * #176 #4303
[mk-app] #4701 + #3775 #4662
[mk-app] #4706 <= #4701 #36
[mk-app] #4707 >= #4701 #36
[assign] #4661 justification -1: p289
[attach-enode] #4661 0
[attach-enode] #4662 0
[attach-enode] #4701 0
[assign] #4706 justification -1: p294
[assign] #4707 justification -1: p294
[new-match] 0x106868338 #1495 #1483 #2916 #1545 ; #3771 (#2919 #2919)
[mk-app] #4714 = #3771 #4561
[mk-app] #4734 = #4408 #4714
[mk-proof] #4729 monotonicity #3917 #4734
[mk-app] #4730 or #1563 #4714
[mk-app] #4731 or #1563 #4408
[mk-proof] #4732 quant-inst #4731
[mk-app] #4735 = #4731 #4730
[mk-proof] #4739 monotonicity #4729 #4735
[mk-app] #4740 = #4730 #4730
[mk-proof] #4779 rewrite #4740
[mk-proof] #4784 trans #4739 #4779 #4735
[mk-proof] #4746 mp #4732 #4784 #4730
[instance] 0x106868338 #4732 ; 53
[attach-enode] #3947 53
[attach-enode] #4561 53
[attach-enode] #4714 53
[assign] #4714 justification -1: p50
[end-of-instance]
[eq-expl] #3947 root
[new-match] 0x1068685d8 #1477 #1476 #3947 #1545 ; #4561
[eq-expl] #3771 lit #4714 ; #4561
[eq-expl] #4561 root
[new-match] 0x106868610 #1522 #1506 #3947 #1545 ; #3772 (#3771 #4561)
[mk-app] #4753 = #4265 #4265
[mk-proof] #4754 refl #4753
[mk-app] #4772 or #1576 #4265
[mk-proof] #4773 quant-inst #4772
[instance] 0x1068685d8 #4773 ; 54
[attach-enode] #3581 54
[attach-enode] #4265 54
[assign] #4265 justification -1: p49
[end-of-instance]
[mk-app] #4753 + #4267 #4529
[inst-discovered] theory-solving 0x0 arith# ; #4268
[mk-app] #4754 = #4268 #4753
[mk-proof] #4768 rewrite #4754
[instance] 0x0 #4754
[end-of-instance]
[mk-app] #4769 = #4753 #1503
[mk-app] #4770 = #4271 #4769
[mk-proof] #4771 monotonicity #4768 #4770
[attach-meaning] #176 arith (- 1)
[mk-app] #4774 * #176 #4529
[mk-app] #4775 + #3585 #4774
[attach-meaning] #4108 arith (- 4)
[mk-app] #4776 = #4775 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4769
[mk-app] #4777 = #4769 #4776
[mk-proof] #4778 rewrite #4777
[instance] 0x0 #4777
[end-of-instance]
[mk-app] #4785 = #4271 #4776
[mk-proof] #4792 trans #4771 #4778 #4785
[mk-app] #4793 or #5060 #4776
[mk-app] #4811 or #5060 #4271
[mk-proof] #4812 quant-inst #4811
[mk-app] #4807 = #4811 #4793
[mk-proof] #4832 monotonicity #4792 #4807
[mk-app] #4850 = #4793 #4793
[mk-proof] #4818 rewrite #4850
[mk-proof] #4823 trans #4832 #4818 #4807
[mk-proof] #4824 mp #4812 #4823 #4793
[instance] 0x106868610 #4812 ; 54
[attach-enode] #3585 54
[attach-enode] #4528 54
[attach-enode] #4529 54
[attach-enode] #4774 54
[attach-enode] #4775 54
[attach-enode] #4776 54
[mk-app] #4831 <= #4775 #4108
[mk-app] #4851 >= #4775 #4108
[assign] #4776 justification -1: p51
[end-of-instance]
[assign] #4831 clause p300 (not p299)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[assign] #4851 clause p301 (not p299)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[mk-app] #4846 = #3585 #3772
[attach-meaning] #176 arith (- 1)
[mk-app] #4847 * #176 #3772
[mk-app] #4848 + #3585 #4847
[mk-app] #4849 <= #4848 #36
[mk-app] #4852 >= #4848 #36
[assign] #4846 justification -1: p297
[attach-enode] #4846 0
[attach-enode] #4847 0
[attach-enode] #4848 0
[assign] #4849 justification -1: p302
[assign] #4852 justification -1: p302
[new-match] 0x106869058 #1495 #1483 #3947 #1545 ; #4528 (#4561 #4561)
[mk-app] #4856 = #4528 #4392
[mk-app] #4857 = #4427 #4856
[mk-proof] #4871 monotonicity #4394 #4857
[mk-app] #4889 or #1563 #4856
[mk-app] #4895 or #1563 #4427
[mk-proof] #4896 quant-inst #4895
[mk-app] #4891 = #4895 #4889
[mk-proof] #4892 monotonicity #4871 #4891
[mk-app] #4893 = #4889 #4889
[mk-proof] #4894 rewrite #4893
[mk-proof] #4901 trans #4892 #4894 #4891
[mk-proof] #4902 mp #4896 #4901 #4889
[instance] 0x106869058 #4896 ; 55
[attach-enode] #4389 55
[attach-enode] #4392 55
[attach-enode] #4856 55
[assign] #4856 justification -1: p50
[end-of-instance]
[eq-expl] #4389 root
[new-match] 0x106847b60 #1477 #1476 #4389 #1545 ; #4392
[eq-expl] #4528 lit #4856 ; #4392
[eq-expl] #4392 root
[new-match] 0x106847b98 #1522 #1506 #4389 #1545 ; #4529 (#4528 #4392)
[mk-app] #4909 = #3053 #3053
[mk-proof] #4910 refl #4909
[mk-app] #4928 or #1576 #3053
[mk-proof] #4929 quant-inst #4928
[instance] 0x106847b60 #4929 ; 56
[attach-enode] #4409 56
[attach-enode] #3053 56
[assign] #3053 justification -1: p49
[end-of-instance]
[mk-app] #4909 + #3054 #4582
[inst-discovered] theory-solving 0x0 arith# ; #3055
[mk-app] #4910 = #3055 #4909
[mk-proof] #4927 rewrite #4910
[instance] 0x0 #4910
[end-of-instance]
[mk-app] #4930 = #4909 #1503
[mk-app] #4934 = #3058 #4930
[mk-proof] #4935 monotonicity #4927 #4934
[attach-meaning] #176 arith (- 1)
[mk-app] #4966 * #176 #4582
[mk-app] #4969 + #3791 #4966
[attach-meaning] #4108 arith (- 4)
[mk-app] #4968 = #4969 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4930
[mk-app] #4963 = #4930 #4968
[mk-proof] #4964 rewrite #4963
[instance] 0x0 #4963
[end-of-instance]
[mk-app] #4965 = #3058 #4968
[mk-proof] #4970 trans #4935 #4964 #4965
[mk-app] #4971 or #5060 #4968
[mk-app] #4972 or #5060 #3058
[mk-proof] #4973 quant-inst #4972
[mk-app] #4974 = #4972 #4971
[mk-proof] #4979 monotonicity #4970 #4974
[mk-app] #5006 = #4971 #4971
[mk-proof] #5007 rewrite #5006
[mk-proof] #5005 trans #4979 #5007 #4974
[mk-proof] #5008 mp #4973 #5005 #4971
[instance] 0x106847b98 #4973 ; 56
[attach-enode] #3791 56
[attach-enode] #4411 56
[attach-enode] #4582 56
[attach-enode] #4966 56
[attach-enode] #4969 56
[attach-enode] #4968 56
[mk-app] #5045 <= #4969 #4108
[mk-app] #5046 >= #4969 #4108
[assign] #4968 justification -1: p51
[end-of-instance]
[assign] #5045 clause p308 (not p307)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[assign] #5046 clause p309 (not p307)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[mk-app] #5018 = #3791 #4529
[attach-meaning] #176 arith (- 1)
[mk-app] #5019 + #3791 #4774
[mk-app] #5026 <= #5019 #36
[mk-app] #5027 >= #5019 #36
[assign] #5018 justification -1: p305
[attach-enode] #5018 0
[attach-enode] #5019 0
[assign] #5026 justification -1: p310
[assign] #5027 justification -1: p310
[new-match] 0x106848558 #1495 #1483 #4389 #1545 ; #4411 (#4392 #4392)
[mk-app] #5041 = #4411 #3923
[mk-app] #5042 = #3297 #5041
[mk-proof] #5043 monotonicity #3925 #5042
[mk-app] #5044 or #1563 #5041
[mk-app] #5047 or #1563 #3297
[mk-proof] #5048 quant-inst #5047
[mk-app] #5052 = #5047 #5044
[mk-proof] #5057 monotonicity #5043 #5052
[mk-app] #5084 = #5044 #5044
[mk-proof] #5085 rewrite #5084
[mk-proof] #5091 trans #5057 #5085 #5052
[mk-proof] #5096 mp #5048 #5091 #5044
[instance] 0x106848558 #5048 ; 57
[attach-enode] #3887 57
[attach-enode] #3923 57
[attach-enode] #5041 57
[assign] #5041 justification -1: p50
[end-of-instance]
[eq-expl] #3887 root
[new-match] 0x1068487f8 #1477 #1476 #3887 #1545 ; #3923
[eq-expl] #4411 lit #5041 ; #3923
[eq-expl] #3923 root
[new-match] 0x106848830 #1522 #1506 #3887 #1545 ; #4582 (#4411 #3923)
[mk-app] #5087 = #3776 #3776
[mk-proof] #5088 refl #5087
[mk-app] #5089 or #1576 #3776
[mk-proof] #5090 quant-inst #5089
[instance] 0x1068487f8 #5090 ; 58
[attach-enode] #3466 58
[attach-enode] #3776 58
[assign] #3776 justification -1: p49
[end-of-instance]
[mk-app] #5087 = #4195 #4195
[mk-proof] #5088 refl #5087
[mk-app] #5097 or #5060 #4195
[mk-proof] #5104 quant-inst #5097
[instance] 0x106848830 #5104 ; 58
[attach-enode] #3468 58
[attach-enode] #3469 58
[attach-enode] #3473 58
[attach-enode] #4201 58
[attach-enode] #4202 58
[attach-enode] #4195 58
[mk-app] #5105 <= #4202 #1503
[mk-app] #3265 >= #4202 #1503
[assign] #4195 justification -1: p51
[end-of-instance]
[assign] #5105 clause p316 (not p315)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[assign] #3265 clause p317 (not p315)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[mk-app] #5087 = #3473 #4582
[attach-meaning] #176 arith (- 1)
[mk-app] #5088 + #3473 #4966
[mk-app] #3266 <= #5088 #36
[mk-app] #3267 >= #5088 #36
[assign] #5087 justification -1: p313
[attach-enode] #5087 0
[attach-enode] #5088 0
[assign] #3266 justification -1: p318
[assign] #3267 justification -1: p318
[new-match] 0x1068491f0 #1495 #1483 #3887 #1545 ; #3468 (#3923 #3923)
[mk-app] #2936 = #3468 #3870
[mk-app] #3154 = #4590 #2936
[mk-proof] #3159 monotonicity #3872 #3154
[mk-app] #4085 or #1563 #2936
[mk-app] #3811 or #1563 #4590
[mk-proof] #3816 quant-inst #3811
[mk-app] #4006 = #3811 #4085
[mk-proof] #3814 monotonicity #3159 #4006
[mk-app] #3815 = #4085 #4085
[mk-proof] #3394 rewrite #3815
[mk-proof] #3817 trans #3814 #3394 #4006
[mk-proof] #4316 mp #3816 #3817 #4085
[instance] 0x1068491f0 #3816 ; 59
[attach-enode] #3867 59
[attach-enode] #3870 59
[attach-enode] #2936 59
[assign] #2936 justification -1: p50
[end-of-instance]
[eq-expl] #3867 root
[new-match] 0x106849490 #1477 #1476 #3867 #1545 ; #3870
[eq-expl] #3468 lit #2936 ; #3870
[eq-expl] #3870 root
[new-match] 0x1068494c8 #1522 #1506 #3867 #1545 ; #3469 (#3468 #3870)
[mk-app] #3890 = #3600 #3600
[mk-proof] #3891 refl #3890
[mk-app] #3892 or #1576 #3600
[mk-proof] #3893 quant-inst #3892
[instance] 0x106849490 #3893 ; 60
[attach-enode] #4433 60
[attach-enode] #3600 60
[assign] #3600 justification -1: p49
[end-of-instance]
[mk-app] #3890 + #3601 #4575
[inst-discovered] theory-solving 0x0 arith# ; #2989
[mk-app] #3891 = #2989 #3890
[mk-proof] #3647 rewrite #3891
[instance] 0x0 #3891
[end-of-instance]
[mk-app] #4518 = #3890 #1503
[mk-app] #4354 = #3962 #4518
[mk-proof] #4356 monotonicity #3647 #4354
[attach-meaning] #176 arith (- 1)
[mk-app] #3248 * #176 #4575
[mk-app] #3756 + #3606 #3248
[attach-meaning] #4108 arith (- 4)
[mk-app] #3246 = #3756 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4518
[mk-app] #3241 = #4518 #3246
[mk-proof] #3242 rewrite #3241
[instance] 0x0 #3241
[end-of-instance]
[mk-app] #3247 = #3962 #3246
[mk-proof] #3690 trans #4356 #3242 #3247
[mk-app] #3691 or #5060 #3246
[mk-app] #3686 or #5060 #3962
[mk-proof] #3687 quant-inst #3686
[mk-app] #3692 = #3686 #3691
[mk-proof] #3953 monotonicity #3690 #3692
[mk-app] #3277 = #3691 #3691
[mk-proof] #3282 rewrite #3277
[mk-proof] #2940 trans #3953 #3282 #3692
[mk-proof] #2942 mp #3687 #2940 #3691
[instance] 0x1068494c8 #3687 ; 60
[attach-enode] #3606 60
[attach-enode] #4574 60
[attach-enode] #4575 60
[attach-enode] #3248 60
[attach-enode] #3756 60
[attach-enode] #3246 60
[mk-app] #4066 <= #3756 #4108
[mk-app] #4067 >= #3756 #4108
[assign] #3246 justification -1: p51
[end-of-instance]
[assign] #4066 clause p324 (not p323)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[assign] #4067 clause p325 (not p323)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[mk-app] #3093 = #3469 #3606
[attach-meaning] #176 arith (- 1)
[mk-app] #3094 + #3469 #3601
[mk-app] #3099 <= #3094 #36
[mk-app] #3103 >= #3094 #36
[assign] #3093 justification -1: p321
[attach-enode] #3093 0
[attach-enode] #3601 0
[attach-enode] #3094 0
[assign] #3099 justification -1: p326
[assign] #3103 justification -1: p326
[new-match] 0x106887f30 #1495 #1483 #3867 #1545 ; #4574 (#3870 #3870)
[mk-app] #4061 = #4574 #3733
[mk-app] #4062 = #3187 #4061
[mk-proof] #4069 monotonicity #4017 #4062
[mk-app] #4070 or #1563 #4061
[mk-app] #3362 or #1563 #3187
[mk-proof] #3363 quant-inst #3362
[mk-app] #3364 = #3362 #4070
[mk-proof] #3365 monotonicity #4069 #3364
[mk-app] #4246 = #4070 #4070
[mk-proof] #2949 rewrite #4246
[mk-proof] #3032 trans #3365 #2949 #3364
[mk-proof] #3033 mp #3363 #3032 #4070
[instance] 0x106887f30 #3363 ; 61
[attach-enode] #3730 61
[attach-enode] #3733 61
[attach-enode] #4061 61
[assign] #4061 justification -1: p50
[end-of-instance]
[eq-expl] #3730 root
[new-match] 0x1068881d0 #1477 #1476 #3730 #1545 ; #3733
[eq-expl] #4574 lit #4061 ; #3733
[eq-expl] #3733 root
[new-match] 0x106888208 #1522 #1506 #3730 #1545 ; #4575 (#4574 #3733)
[mk-app] #3566 = #3751 #3751
[mk-proof] #3567 refl #3566
[mk-app] #3036 or #1576 #3751
[mk-proof] #3038 quant-inst #3036
[instance] 0x1068881d0 #3038 ; 62
[attach-enode] #4034 62
[attach-enode] #3751 62
[assign] #3751 justification -1: p49
[end-of-instance]
[mk-app] #3566 = #4112 #4112
[mk-proof] #3567 refl #3566
[mk-app] #3039 or #5060 #4112
[mk-proof] #3037 quant-inst #3039
[instance] 0x106888208 #3037 ; 62
[attach-enode] #4036 62
[attach-enode] #4038 62
[attach-enode] #4041 62
[attach-enode] #3754 62
[attach-enode] #3755 62
[attach-enode] #4112 62
[mk-app] #3040 <= #3755 #1503
[mk-app] #4497 >= #3755 #1503
[assign] #4112 justification -1: p51
[end-of-instance]
[assign] #3040 clause p332 (not p331)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[assign] #4497 clause p333 (not p331)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[mk-app] #3566 = #4041 #4575
[attach-meaning] #176 arith (- 1)
[mk-app] #3567 + #4041 #3248
[mk-app] #3634 <= #3567 #36
[mk-app] #4014 >= #3567 #36
[assign] #3566 justification -1: p329
[attach-enode] #3566 0
[attach-enode] #3567 0
[assign] #3634 justification -1: p334
[assign] #4014 justification -1: p334
[new-match] 0x106888bc8 #1495 #1483 #3730 #1545 ; #4036 (#3733 #3733)
[mk-app] #3379 = #4036 #3294
[mk-app] #3377 = #3656 #3379
[mk-proof] #3381 monotonicity #3296 #3377
[mk-app] #3382 or #1563 #3379
[mk-app] #3146 or #1563 #3656
[mk-proof] #3151 quant-inst #3146
[mk-app] #3829 = #3146 #3382
[mk-proof] #3149 monotonicity #3381 #3829
[mk-app] #3150 = #3382 #3382
[mk-proof] #3145 rewrite #3150
[mk-proof] #3155 trans #3149 #3145 #3829
[mk-proof] #3156 mp #3151 #3155 #3382
[instance] 0x106888bc8 #3151 ; 63
[attach-enode] #3291 63
[attach-enode] #3294 63
[attach-enode] #3379 63
[assign] #3379 justification -1: p50
[end-of-instance]
[eq-expl] #3291 root
[new-match] 0x106888e68 #1477 #1476 #3291 #1545 ; #3294
[eq-expl] #4036 lit #3379 ; #3294
[eq-expl] #3294 root
[new-match] 0x106888ea0 #1522 #1506 #3291 #1545 ; #4038 (#4036 #3294)
[mk-app] #4084 = #4616 #4616
[mk-proof] #4089 refl #4084
[mk-app] #4080 or #1576 #4616
[mk-proof] #4081 quant-inst #4080
[instance] 0x106888e68 #4081 ; 64
[attach-enode] #3312 64
[attach-enode] #4616 64
[assign] #4616 justification -1: p49
[end-of-instance]
[mk-app] #4084 = #4615 #4615
[mk-proof] #4089 refl #4084
[mk-app] #3535 or #5060 #4615
[mk-proof] #3530 quant-inst #3535
[instance] 0x106888ea0 #3530 ; 64
[attach-enode] #3314 64
[attach-enode] #3315 64
[attach-enode] #3318 64
[attach-enode] #4617 64
[attach-enode] #4612 64
[attach-enode] #4615 64
[mk-app] #3538 <= #4612 #1503
[mk-app] #3423 >= #4612 #1503
[assign] #4615 justification -1: p51
[end-of-instance]
[assign] #3538 clause p340 (not p339)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[assign] #3423 clause p341 (not p339)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[mk-app] #4084 = #3318 #4038
[attach-meaning] #176 arith (- 1)
[mk-app] #4089 * #176 #4038
[mk-app] #4374 + #3318 #4089
[mk-app] #4375 <= #4374 #36
[mk-app] #4372 >= #4374 #36
[assign] #4084 justification -1: p337
[attach-enode] #4084 0
[attach-enode] #4089 0
[attach-enode] #4374 0
[assign] #4375 justification -1: p342
[assign] #4372 justification -1: p342
[new-match] 0x1068898e8 #1495 #1483 #3291 #1545 ; #3314 (#3294 #3294)
[mk-app] #4373 = #3314 #4190
[mk-app] #4368 = #4637 #4373
[mk-proof] #4369 monotonicity #4192 #4368
[mk-app] #4377 or #1563 #4373
[mk-app] #4478 or #1563 #4637
[mk-proof] #4479 quant-inst #4478
[mk-app] #3907 = #4478 #4377
[mk-proof] #3908 monotonicity #4369 #3907
[mk-app] #4481 = #4377 #4377
[mk-proof] #4312 rewrite #4481
[mk-proof] #4313 trans #3908 #4312 #3907
[mk-proof] #3939 mp #4479 #4313 #4377
[instance] 0x1068898e8 #4479 ; 65
[attach-enode] #4187 65
[attach-enode] #4190 65
[attach-enode] #4373 65
[assign] #4373 justification -1: p50
[end-of-instance]
[eq-expl] #4187 root
[new-match] 0x1068907e8 #1477 #1476 #4187 #1545 ; #4190
[eq-expl] #3314 lit #4373 ; #4190
[eq-expl] #4190 root
[new-match] 0x106890820 #1522 #1506 #4187 #1545 ; #3315 (#3314 #4190)
[mk-app] #3933 = #4667 #4667
[mk-proof] #3864 refl #3933
[mk-app] #3865 or #1576 #4667
[mk-proof] #3860 quant-inst #3865
[instance] 0x1068907e8 #3860 ; 66
[attach-enode] #4211 66
[attach-enode] #4667 66
[assign] #4667 justification -1: p49
[end-of-instance]
[mk-app] #3933 = #4695 #4695
[mk-proof] #3864 refl #3933
[mk-app] #3861 or #5060 #4695
[mk-proof] #3862 quant-inst #3861
[instance] 0x106890820 #3862 ; 66
[attach-enode] #4213 66
[attach-enode] #4214 66
[attach-enode] #4591 66
[attach-enode] #4668 66
[attach-enode] #4675 66
[attach-enode] #4695 66
[mk-app] #3863 <= #4675 #1503
[mk-app] #3845 >= #4675 #1503
[assign] #4695 justification -1: p51
[end-of-instance]
[assign] #3863 clause p348 (not p347)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[assign] #3845 clause p349 (not p347)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[mk-app] #3933 = #3315 #4591
[attach-meaning] #176 arith (- 1)
[mk-app] #3864 + #3315 #4668
[mk-app] #4568 <= #3864 #36
[mk-app] #4569 >= #3864 #36
[assign] #3933 justification -1: p345
[attach-enode] #3933 0
[attach-enode] #3864 0
[assign] #4568 justification -1: p350
[assign] #4569 justification -1: p350
[new-match] 0x1068911e0 #1495 #1483 #4187 #1545 ; #4213 (#4190 #4190)
[mk-app] #3881 = #4213 #4495
[mk-app] #3882 = #4700 #3881
[mk-proof] #3883 monotonicity #3819 #3882
[mk-app] #3478 or #1563 #3881
[mk-app] #3484 or #1563 #4700
[mk-proof] #3077 quant-inst #3484
[mk-app] #3075 = #3484 #3478
[mk-proof] #3778 monotonicity #3883 #3075
[mk-app] #3322 = #3478 #3478
[mk-proof] #4047 rewrite #3322
[mk-proof] #3286 trans #3778 #4047 #3075
[mk-proof] #3287 mp #3077 #3286 #3478
[instance] 0x1068911e0 #3077 ; 67
[attach-enode] #3677 67
[attach-enode] #4495 67
[attach-enode] #3881 67
[assign] #3881 justification -1: p50
[end-of-instance]
[eq-expl] #3677 root
[new-match] 0x106891480 #1477 #1476 #3677 #1545 ; #4495
[eq-expl] #4213 lit #3881 ; #4495
[eq-expl] #4495 root
[new-match] 0x1068914b8 #1522 #1506 #3677 #1545 ; #4214 (#4213 #4495)
[mk-app] #3777 = #4736 #4736
[mk-proof] #3323 refl #3777
[mk-app] #3779 or #1576 #4736
[mk-proof] #3780 quant-inst #3779
[instance] 0x106891480 #3780 ; 68
[attach-enode] #3602 68
[attach-enode] #4736 68
[assign] #4736 justification -1: p49
[end-of-instance]
[mk-app] #3777 + #4737 #4535
[inst-discovered] theory-solving 0x0 arith# ; #4738
[mk-app] #3323 = #4738 #3777
[mk-proof] #3781 rewrite #3323
[instance] 0x0 #3323
[end-of-instance]
[mk-app] #4576 = #3777 #1503
[mk-app] #4577 = #4745 #4576
[mk-proof] #3673 monotonicity #3781 #4577
[attach-meaning] #176 arith (- 1)
[mk-app] #3969 * #176 #4535
[mk-app] #3973 + #2991 #3969
[attach-meaning] #4108 arith (- 4)
[mk-app] #3974 = #3973 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4576
[mk-app] #4129 = #4576 #3974
[mk-proof] #4130 rewrite #4129
[instance] 0x0 #4129
[end-of-instance]
[mk-app] #3211 = #4745 #3974
[mk-proof] #3212 trans #3673 #4130 #3211
[mk-app] #3658 or #5060 #3974
[mk-app] #3659 or #5060 #4745
[mk-proof] #3660 quant-inst #3659
[mk-app] #3661 = #3659 #3658
[mk-proof] #4599 monotonicity #3212 #3661
[mk-app] #4600 = #3658 #3658
[mk-proof] #4487 rewrite #4600
[mk-proof] #4488 trans #4599 #4487 #3661
[mk-proof] #4639 mp #3660 #4488 #3658
[instance] 0x1068914b8 #3660 ; 68
[attach-enode] #2991 68
[attach-enode] #4534 68
[attach-enode] #4535 68
[attach-enode] #3969 68
[attach-enode] #3973 68
[attach-enode] #3974 68
[mk-app] #4634 <= #3973 #4108
[mk-app] #4677 >= #3973 #4108
[assign] #3974 justification -1: p51
[end-of-instance]
[assign] #4634 clause p356 (not p355)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[assign] #4677 clause p357 (not p355)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[mk-app] #4678 = #2991 #4214
[attach-meaning] #176 arith (- 1)
[mk-app] #4719 * #176 #4214
[mk-app] #4755 + #2991 #4719
[mk-app] #4717 <= #4755 #36
[mk-app] #4712 >= #4755 #36
[assign] #4678 justification -1: p353
[attach-enode] #4678 0
[attach-enode] #4719 0
[attach-enode] #4755 0
[assign] #4717 justification -1: p358
[assign] #4712 justification -1: p358
[new-match] 0x106891f00 #1495 #1483 #3677 #1545 ; #4534 (#4495 #4495)
[mk-app] #4713 = #4534 #3984
[mk-app] #4718 = #4817 #4713
[mk-proof] #4756 monotonicity #4520 #4718
[mk-app] #4751 or #1563 #4713
[mk-app] #4752 or #1563 #4817
[mk-proof] #4757 quant-inst #4752
[mk-app] #4758 = #4752 #4751
[mk-proof] #4794 monotonicity #4756 #4758
[mk-app] #4796 = #4751 #4751
[mk-proof] #4797 rewrite #4796
[mk-proof] #4830 trans #4794 #4797 #4758
[mk-proof] #4835 mp #4757 #4830 #4751
[instance] 0x106891f00 #4757 ; 69
[attach-enode] #3981 69
[attach-enode] #3984 69
[attach-enode] #4713 69
[assign] #4713 justification -1: p50
[end-of-instance]
[eq-expl] #3981 root
[new-match] 0x1068921a0 #1477 #1476 #3981 #1545 ; #3984
[eq-expl] #4534 lit #4713 ; #3984
[eq-expl] #3984 root
[new-match] 0x1068921d8 #1522 #1506 #3981 #1545 ; #4535 (#4534 #3984)
[mk-app] #4907 = #4853 #4853
[mk-proof] #4908 refl #4907
[mk-app] #4874 or #1576 #4853
[mk-proof] #4875 quant-inst #4874
[instance] 0x1068921a0 #4875 ; 70
[attach-enode] #3192 70
[attach-enode] #4853 70
[assign] #4853 justification -1: p49
[end-of-instance]
[mk-app] #4907 = #4862 #4862
[mk-proof] #4908 refl #4907
[mk-app] #4911 or #5060 #4862
[mk-proof] #4912 quant-inst #4911
[instance] 0x1068921d8 #4912 ; 70
[attach-enode] #3194 70
[attach-enode] #3195 70
[attach-enode] #3198 70
[attach-enode] #4854 70
[attach-enode] #4855 70
[attach-enode] #4862 70
[mk-app] #4913 <= #4855 #1503
[mk-app] #4914 >= #4855 #1503
[assign] #4862 justification -1: p51
[end-of-instance]
[assign] #4913 clause p364 (not p363)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[assign] #4914 clause p365 (not p363)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[mk-app] #4907 = #3198 #4535
[attach-meaning] #176 arith (- 1)
[mk-app] #4908 + #3198 #3969
[mk-app] #4950 <= #4908 #36
[mk-app] #4951 >= #4908 #36
[assign] #4907 justification -1: p361
[attach-enode] #4907 0
[attach-enode] #4908 0
[assign] #4950 justification -1: p366
[assign] #4951 justification -1: p366
[new-match] 0x10689a9f8 #1495 #1483 #3981 #1545 ; #3194 (#3984 #3984)
[mk-app] #4946 = #3194 #3217
[mk-app] #4947 = #4888 #4946
[mk-proof] #4990 monotonicity #3221 #4947
[mk-app] #4985 or #1563 #4946
[mk-app] #5028 or #1563 #4888
[mk-proof] #5029 quant-inst #5028
[mk-app] #4160 = #5028 #4985
[mk-proof] #4161 monotonicity #4990 #4160
[mk-app] #4165 = #4985 #4985
[mk-proof] #4336 rewrite #4165
[mk-proof] #4337 trans #4161 #4336 #4160
[mk-proof] #4338 mp #5029 #4337 #4985
[instance] 0x10689a9f8 #5029 ; 71
[attach-enode] #3216 71
[attach-enode] #3217 71
[attach-enode] #4946 71
[assign] #4946 justification -1: p50
[end-of-instance]
[eq-expl] #3216 root
[new-match] 0x10689ac98 #1477 #1476 #3216 #1545 ; #3217
[eq-expl] #3194 lit #4946 ; #3217
[eq-expl] #3217 root
[new-match] 0x10689acd0 #1522 #1506 #3216 #1545 ; #3195 (#3194 #3217)
[mk-app] #4339 = #4924 #4924
[mk-proof] #5190 refl #4339
[mk-app] #5157 or #1576 #4924
[mk-proof] #4334 quant-inst #5157
[instance] 0x10689ac98 #4334 ; 72
[attach-enode] #4114 72
[attach-enode] #4924 72
[assign] #4924 justification -1: p49
[end-of-instance]
[mk-app] #4339 = #4931 #4931
[mk-proof] #5190 refl #4339
[mk-app] #4171 or #5060 #4931
[mk-proof] #5146 quant-inst #4171
[instance] 0x10689acd0 #5146 ; 72
[attach-enode] #4116 72
[attach-enode] #4121 72
[attach-enode] #4124 72
[attach-enode] #4925 72
[attach-enode] #4926 72
[attach-enode] #4931 72
[mk-app] #5111 <= #4926 #1503
[mk-app] #5112 >= #4926 #1503
[assign] #4931 justification -1: p51
[end-of-instance]
[assign] #5111 clause p372 (not p371)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[assign] #5112 clause p373 (not p371)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[mk-app] #4339 = #3195 #4124
[attach-meaning] #176 arith (- 1)
[mk-app] #5190 + #3195 #4925
[mk-app] #5061 <= #5190 #36
[mk-app] #5062 >= #5190 #36
[assign] #4339 justification -1: p369
[attach-enode] #4339 0
[attach-enode] #5190 0
[assign] #5061 justification -1: p374
[assign] #5062 justification -1: p374
[new-match] 0x10689b690 #1495 #1483 #3216 #1545 ; #4116 (#3217 #3217)
[mk-app] #5101 = #4116 #3652
[mk-app] #5093 = #4967 #5101
[mk-proof] #5054 monotonicity #3654 #5093
[mk-app] #5034 or #1563 #5101
[mk-app] #4859 or #1563 #4967
[mk-proof] #4839 quant-inst #4859
[mk-app] #4878 = #4859 #5034
[mk-proof] #4865 monotonicity #5054 #4878
[mk-app] #4826 = #5034 #5034
[mk-proof] #4827 rewrite #4826
[mk-proof] #4828 trans #4865 #4827 #4878
[mk-proof] #3979 mp #4839 #4828 #5034
[instance] 0x10689b690 #4839 ; 73
[attach-enode] #4506 73
[attach-enode] #3652 73
[attach-enode] #5101 73
[assign] #5101 justification -1: p50
[end-of-instance]
[eq-expl] #4506 root
[new-match] 0x10689b930 #1477 #1476 #4506 #1545 ; #3652
[eq-expl] #4116 lit #5101 ; #3652
[eq-expl] #3652 root
[new-match] 0x10689b968 #1522 #1506 #4506 #1545 ; #4121 (#4116 #3652)
[mk-app] #2992 = #4980 #4980
[mk-proof] #2993 refl #2992
[mk-app] #2994 or #1576 #4980
[mk-proof] #3603 quant-inst #2994
[instance] 0x10689b930 #3603 ; 74
[attach-enode] #4492 74
[attach-enode] #4980 74
[assign] #4980 justification -1: p49
[end-of-instance]
[mk-app] #2992 = #5002 #5002
[mk-proof] #2993 refl #2992
[mk-app] #3676 or #5060 #5002
[mk-proof] #3467 quant-inst #3676
[instance] 0x10689b968 #3467 ; 74
[attach-enode] #4491 74
[attach-enode] #4596 74
[attach-enode] #4597 74
[attach-enode] #4987 74
[attach-enode] #4988 74
[attach-enode] #5002 74
[mk-app] #3886 <= #4988 #1503
[mk-app] #3487 >= #4988 #1503
[assign] #5002 justification -1: p51
[end-of-instance]
[assign] #3886 clause p380 (not p379)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[assign] #3487 clause p381 (not p379)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[mk-app] #2992 = #4121 #4597
[attach-meaning] #176 arith (- 1)
[mk-app] #2993 + #4121 #4987
[mk-app] #3474 <= #2993 #36
[mk-app] #3792 >= #2993 #36
[assign] #2992 justification -1: p377
[attach-enode] #2992 0
[attach-enode] #2993 0
[assign] #3474 justification -1: p382
[assign] #3792 justification -1: p382
[new-match] 0x10689c328 #1495 #1483 #4506 #1545 ; #4491 (#3652 #3652)
[mk-app] #3793 = #4491 #4609
[mk-app] #4365 = #5013 #3793
[mk-proof] #4366 monotonicity #4611 #4365
[mk-app] #3905 or #1563 #3793
[mk-app] #3906 or #1563 #5013
[mk-proof] #4367 quant-inst #3906
[mk-app] #3857 = #3906 #3905
[mk-proof] #4300 monotonicity #4366 #3857
[mk-app] #4290 = #3905 #3905
[mk-proof] #3134 rewrite #4290
[mk-proof] #4572 trans #4300 #3134 #3857
[mk-proof] #3799 mp #4367 #4572 #3905
[instance] 0x10689c328 #4367 ; 75
[attach-enode] #4606 75
[attach-enode] #4609 75
[attach-enode] #3793 75
[assign] #3793 justification -1: p50
[end-of-instance]
[eq-expl] #4606 root
[new-match] 0x10684f5e8 #1477 #1476 #4606 #1545 ; #4609
[eq-expl] #4491 lit #3793 ; #4609
[eq-expl] #4609 root
[new-match] 0x10684f620 #1522 #1506 #4606 #1545 ; #4596 (#4491 #4609)
[mk-app] #3371 = #5049 #5049
[mk-proof] #3372 refl #3371
[mk-app] #3354 or #1576 #5049
[mk-proof] #3355 quant-inst #3354
[instance] 0x10684f5e8 #3355 ; 76
[attach-enode] #4624 76
[attach-enode] #5049 76
[assign] #5049 justification -1: p49
[end-of-instance]
[mk-app] #3371 = #5058 #5058
[mk-proof] #3372 refl #3371
[mk-app] #4243 or #5060 #5058
[mk-proof] #4244 quant-inst #4243
[instance] 0x10684f620 #4244 ; 76
[attach-enode] #4626 76
[attach-enode] #4627 76
[attach-enode] #4630 76
[attach-enode] #5050 76
[attach-enode] #5051 76
[attach-enode] #5058 76
[mk-app] #3356 <= #5051 #1503
[mk-app] #3345 >= #5051 #1503
[assign] #5058 justification -1: p51
[end-of-instance]
[assign] #3356 clause p388 (not p387)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[assign] #3345 clause p389 (not p387)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[mk-app] #3371 = #4596 #4630
[attach-meaning] #176 arith (- 1)
[mk-app] #3372 + #4596 #5050
[mk-app] #4517 <= #3372 #36
[mk-app] #4148 >= #3372 #36
[assign] #3371 justification -1: p385
[attach-enode] #3371 0
[attach-enode] #3372 0
[assign] #4517 justification -1: p390
[assign] #4148 justification -1: p390
[new-match] 0x10684ffe0 #1495 #1483 #4606 #1545 ; #4626 (#4609 #4609)
[mk-app] #3263 = #4626 #4648
[mk-app] #3957 = #5086 #3263
[mk-proof] #3759 monotonicity #4650 #3957
[mk-app] #3238 or #1563 #3263
[mk-app] #3239 or #1563 #5086
[mk-proof] #3383 quant-inst #3239
[mk-app] #3388 = #3239 #3238
[mk-proof] #3153 monotonicity #3759 #3388
[mk-app] #3390 = #3238 #3238
[mk-proof] #3812 rewrite #3390
[mk-proof] #3813 trans #3153 #3812 #3388
[mk-proof] #3504 mp #3383 #3813 #3238
[instance] 0x10684ffe0 #3383 ; 77
[attach-enode] #4645 77
[attach-enode] #4648 77
[attach-enode] #3263 77
[assign] #3263 justification -1: p50
[end-of-instance]
[eq-expl] #4645 root
[new-match] 0x106850280 #1477 #1476 #4645 #1545 ; #4648
[eq-expl] #4626 lit #3263 ; #4648
[eq-expl] #4648 root
[new-match] 0x1068502b8 #1522 #1506 #4645 #1545 ; #4627 (#4626 #4648)
[mk-app] #3505 = #3980 #3980
[mk-proof] #3500 refl #3505
[mk-app] #3501 or #1576 #3980
[mk-proof] #3508 quant-inst #3501
[instance] 0x106850280 #3508 ; 78
[attach-enode] #4663 78
[attach-enode] #3980 78
[assign] #3980 justification -1: p49
[end-of-instance]
[mk-app] #3505 = #4173 #4173
[mk-proof] #3500 refl #3505
[mk-app] #3509 or #5060 #4173
[mk-proof] #3405 quant-inst #3509
[instance] 0x1068502b8 #3405 ; 78
[attach-enode] #4665 78
[attach-enode] #4666 78
[attach-enode] #4669 78
[attach-enode] #2934 78
[attach-enode] #2935 78
[attach-enode] #4173 78
[mk-app] #3406 <= #2935 #1503
[mk-app] #3645 >= #2935 #1503
[assign] #4173 justification -1: p51
[end-of-instance]
[assign] #3406 clause p396 (not p395)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[assign] #3645 clause p397 (not p395)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[mk-app] #3505 = #4627 #4669
[attach-meaning] #176 arith (- 1)
[mk-app] #3500 + #4627 #2934
[mk-app] #3408 <= #3500 #36
[mk-app] #3407 >= #3500 #36
[assign] #3505 justification -1: p393
[attach-enode] #3505 0
[attach-enode] #3500 0
[assign] #3408 justification -1: p398
[assign] #3407 justification -1: p398
[new-match] 0x106850c78 #1495 #1483 #4645 #1545 ; #4665 (#4648 #4648)
[mk-app] #3410 = #4665 #4687
[mk-app] #3244 = #3063 #3410
[mk-proof] #3245 monotonicity #4689 #3244
[mk-app] #3226 or #1563 #3410
[mk-app] #3227 or #1563 #3063
[mk-proof] #4138 quant-inst #3227
[mk-app] #4139 = #3227 #3226
[mk-proof] #4134 monotonicity #3245 #4139
[mk-app] #3260 = #3226 #3226
[mk-proof] #3261 rewrite #3260
[mk-proof] #3256 trans #4134 #3261 #4139
[mk-proof] #3257 mp #4138 #3256 #3226
[instance] 0x106850c78 #4138 ; 79
[attach-enode] #4684 79
[attach-enode] #4687 79
[attach-enode] #3410 79
[assign] #3410 justification -1: p50
[end-of-instance]
[eq-expl] #4684 root
[new-match] 0x106850f18 #1477 #1476 #4684 #1545 ; #4687
[eq-expl] #4665 lit #3410 ; #4687
[eq-expl] #4687 root
[new-match] 0x106850f50 #1522 #1506 #4684 #1545 ; #4666 (#4665 #4687)
[mk-app] #3269 = #3894 #3894
[mk-proof] #3270 refl #3269
[mk-app] #3832 or #1576 #3894
[mk-proof] #3833 quant-inst #3832
[instance] 0x106850f18 #3833 ; 80
[attach-enode] #4702 80
[attach-enode] #3894 80
[assign] #3894 justification -1: p49
[end-of-instance]
[mk-app] #3269 = #4519 #4519
[mk-proof] #3270 refl #3269
[mk-app] #3623 or #5060 #4519
[mk-proof] #3636 quant-inst #3623
[instance] 0x106850f50 #3636 ; 80
[attach-enode] #4704 80
[attach-enode] #4705 80
[attach-enode] #4708 80
[attach-enode] #4439 80
[attach-enode] #3646 80
[attach-enode] #4519 80
[mk-app] #3834 <= #3646 #1503
[mk-app] #3835 >= #3646 #1503
[assign] #4519 justification -1: p51
[end-of-instance]
[assign] #3834 clause p404 (not p403)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[assign] #3835 clause p405 (not p403)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[mk-app] #3269 = #4666 #4708
[attach-meaning] #176 arith (- 1)
[mk-app] #3270 + #4666 #4439
[mk-app] #3087 <= #3270 #36
[mk-app] #3088 >= #3270 #36
[assign] #3269 justification -1: p401
[attach-enode] #3269 0
[attach-enode] #3270 0
[assign] #3087 justification -1: p406
[assign] #3088 justification -1: p406
[new-match] 0x10686e758 #1495 #1483 #4684 #1545 ; #4704 (#4687 #4687)
[mk-app] #4538 = #4704 #4726
[mk-app] #4539 = #3243 #4538
[mk-proof] #3095 monotonicity #4728 #4539
[mk-app] #3096 or #1563 #4538
[mk-app] #3736 or #1563 #3243
[mk-proof] #3340 quant-inst #3736
[mk-app] #3341 = #3736 #3096
[mk-proof] #3331 monotonicity #3095 #3341
[mk-app] #3332 = #3096 #3096
[mk-proof] #3342 rewrite #3332
[mk-proof] #3343 trans #3331 #3342 #3341
[mk-proof] #2961 mp #3340 #3343 #3096
[instance] 0x10686e758 #3340 ; 81
[attach-enode] #4723 81
[attach-enode] #4726 81
[attach-enode] #4538 81
[assign] #4538 justification -1: p50
[end-of-instance]
[eq-expl] #4723 root
[new-match] 0x10686e9f8 #1477 #1476 #4723 #1545 ; #4726
[eq-expl] #4704 lit #4538 ; #4726
[eq-expl] #4726 root
[new-match] 0x10686ea30 #1522 #1506 #4723 #1545 ; #4705 (#4704 #4726)
[mk-app] #3700 = #3278 #3278
[mk-proof] #4593 refl #3700
[mk-app] #3702 or #1576 #3278
[mk-proof] #3701 quant-inst #3702
[instance] 0x10686e9f8 #3701 ; 82
[attach-enode] #4741 82
[attach-enode] #3278 82
[assign] #3278 justification -1: p49
[end-of-instance]
[mk-app] #3700 = #3283 #3283
[mk-proof] #4593 refl #3700
[mk-app] #3704 or #5060 #3283
[mk-proof] #3705 quant-inst #3704
[instance] 0x10686ea30 #3705 ; 82
[attach-enode] #4743 82
[attach-enode] #4744 82
[attach-enode] #4747 82
[attach-enode] #3281 82
[attach-enode] #3276 82
[attach-enode] #3283 82
[mk-app] #3035 <= #3276 #1503
[mk-app] #3990 >= #3276 #1503
[assign] #3283 justification -1: p51
[end-of-instance]
[assign] #3035 clause p412 (not p411)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[assign] #3990 clause p413 (not p411)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[mk-app] #3700 = #4705 #4747
[attach-meaning] #176 arith (- 1)
[mk-app] #4593 + #4705 #3281
[mk-app] #3008 <= #4593 #36
[mk-app] #3013 >= #4593 #36
[assign] #3700 justification -1: p409
[attach-enode] #3700 0
[attach-enode] #4593 0
[assign] #3008 justification -1: p414
[assign] #3013 justification -1: p414
[new-match] 0x10686f3f0 #1495 #1483 #4723 #1545 ; #4743 (#4726 #4726)
[mk-app] #3991 = #4743 #4765
[mk-app] #3986 = #3098 #3991
[mk-proof] #3594 monotonicity #4767 #3986
[mk-app] #3595 or #1563 #3991
[mk-app] #3590 or #1563 #3098
[mk-proof] #3591 quant-inst #3590
[mk-app] #3368 = #3590 #3595
[mk-proof] #3369 monotonicity #3594 #3368
[mk-app] #3376 = #3595 #3595
[mk-proof] #3127 rewrite #3376
[mk-proof] #3128 trans #3369 #3127 #3368
[mk-proof] #3121 mp #3591 #3128 #3595
[instance] 0x10686f3f0 #3591 ; 83
[attach-enode] #4762 83
[attach-enode] #4765 83
[attach-enode] #3991 83
[assign] #3991 justification -1: p50
[end-of-instance]
[eq-expl] #4762 root
[new-match] 0x10686f690 #1477 #1476 #4762 #1545 ; #4765
[eq-expl] #4743 lit #3991 ; #4765
[eq-expl] #4765 root
[new-match] 0x10686f6c8 #1522 #1506 #4762 #1545 ; #4744 (#4743 #4765)
[mk-app] #3122 = #3357 #3357
[mk-proof] #3129 refl #3122
[mk-app] #3130 or #1576 #3357
[mk-proof] #3513 quant-inst #3130
[instance] 0x10686f690 #3513 ; 84
[attach-enode] #4780 84
[attach-enode] #3357 84
[assign] #3357 justification -1: p49
[end-of-instance]
[mk-app] #3122 = #2947 #2947
[mk-proof] #3129 refl #3122
[mk-app] #4103 or #5060 #2947
[mk-proof] #4075 quant-inst #4103
[instance] 0x10686f6c8 #4075 ; 84
[attach-enode] #4782 84
[attach-enode] #4783 84
[attach-enode] #4786 84
[attach-enode] #3358 84
[attach-enode] #3361 84
[attach-enode] #2947 84
[mk-app] #4082 <= #3361 #1503
[mk-app] #4104 >= #3361 #1503
[assign] #2947 justification -1: p51
[end-of-instance]
[assign] #4082 clause p420 (not p419)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[assign] #4104 clause p421 (not p419)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[mk-app] #3122 = #4744 #4786
[attach-meaning] #176 arith (- 1)
[mk-app] #3129 + #4744 #3358
[mk-app] #4512 <= #3129 #36
[mk-app] #4513 >= #3129 #36
[assign] #3122 justification -1: p417
[attach-enode] #3122 0
[attach-enode] #3129 0
[assign] #4512 justification -1: p422
[assign] #4513 justification -1: p422
[new-match] 0x106870088 #1495 #1483 #4762 #1545 ; #4782 (#4765 #4765)
[mk-app] #4468 = #4782 #4804
[mk-app] #3421 = #3558 #4468
[mk-proof] #4458 monotonicity #4806 #3421
[mk-app] #4459 or #1563 #4468
[mk-app] #3422 or #1563 #3558
[mk-proof] #3443 quant-inst #3422
[mk-app] #3546 = #3422 #4459
[mk-proof] #3547 monotonicity #4458 #3546
[mk-app] #3540 = #4459 #4459
[mk-proof] #3541 rewrite #3540
[mk-proof] #3548 trans #3547 #3541 #3546
[mk-proof] #3549 mp #3443 #3548 #4459
[instance] 0x106870088 #3443 ; 85
[attach-enode] #4801 85
[attach-enode] #4804 85
[attach-enode] #4468 85
[assign] #4468 justification -1: p50
[end-of-instance]
[eq-expl] #4801 root
[new-match] 0x1068b1960 #1477 #1476 #4801 #1545 ; #4804
[eq-expl] #4782 lit #4468 ; #4804
[eq-expl] #4804 root
[new-match] 0x1068b1998 #1522 #1506 #4801 #1545 ; #4783 (#4782 #4804)
[mk-app] #3554 = #4015 #4015
[mk-proof] #2924 refl #3554
[mk-app] #2925 or #1576 #4015
[mk-proof] #2926 quant-inst #2925
[instance] 0x1068b1960 #2926 ; 86
[attach-enode] #4819 86
[attach-enode] #4015 86
[assign] #4015 justification -1: p49
[end-of-instance]
[mk-app] #3554 = #3374 #3374
[mk-proof] #2924 refl #3554
[mk-app] #2927 or #5060 #3374
[mk-proof] #3679 quant-inst #2927
[instance] 0x1068b1998 #3679 ; 86
[attach-enode] #4821 86
[attach-enode] #4822 86
[attach-enode] #4825 86
[attach-enode] #3635 86
[attach-enode] #3626 86
[attach-enode] #3374 86
[mk-app] #3680 <= #3626 #1503
[mk-app] #3450 >= #3626 #1503
[assign] #3374 justification -1: p51
[end-of-instance]
[assign] #3680 clause p428 (not p427)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[assign] #3450 clause p429 (not p427)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[mk-app] #3554 = #4783 #4825
[attach-meaning] #176 arith (- 1)
[mk-app] #2924 + #4783 #3635
[mk-app] #3589 <= #2924 #36
[mk-app] #3580 >= #2924 #36
[assign] #3554 justification -1: p425
[attach-enode] #3554 0
[attach-enode] #2924 0
[assign] #3589 justification -1: p430
[assign] #3580 justification -1: p430
[new-match] 0x1068b2358 #1495 #1483 #4801 #1545 ; #4821 (#4804 #4804)
[mk-app] #3583 = #4821 #4843
[mk-app] #4530 = #3828 #3583
[mk-proof] #4531 monotonicity #4845 #4530
[mk-app] #4402 or #1563 #3583
[mk-app] #4403 or #1563 #3828
[mk-proof] #4395 quant-inst #4403
[mk-app] #4396 = #4403 #4402
[mk-proof] #4404 monotonicity #4531 #4396
[mk-app] #4405 = #4402 #4402
[mk-proof] #4407 rewrite #4405
[mk-proof] #4419 trans #4404 #4407 #4396
[mk-proof] #4424 mp #4395 #4419 #4402
[instance] 0x1068b2358 #4395 ; 87
[attach-enode] #4840 87
[attach-enode] #4843 87
[attach-enode] #3583 87
[assign] #3583 justification -1: p50
[end-of-instance]
[eq-expl] #4840 root
[new-match] 0x1068b25f8 #1477 #1476 #4840 #1545 ; #4843
[eq-expl] #4821 lit #3583 ; #4843
[eq-expl] #4843 root
[new-match] 0x1068b2630 #1522 #1506 #4840 #1545 ; #4822 (#4821 #4843)
[mk-app] #3873 = #4090 #4090
[mk-proof] #4414 refl #3873
[mk-app] #4415 or #1576 #4090
[mk-proof] #4418 quant-inst #4415
[instance] 0x1068b25f8 #4418 ; 88
[attach-enode] #4858 88
[attach-enode] #4090 88
[assign] #4090 justification -1: p49
[end-of-instance]
[mk-app] #3873 = #3531 #3531
[mk-proof] #4414 refl #3873
[mk-app] #4425 or #5060 #3531
[mk-proof] #4039 quant-inst #4425
[instance] 0x1068b2630 #4039 ; 88
[attach-enode] #4860 88
[attach-enode] #4861 88
[attach-enode] #4864 88
[attach-enode] #4091 88
[attach-enode] #3534 88
[attach-enode] #3531 88
[mk-app] #4040 <= #3534 #1503
[mk-app] #4498 >= #3534 #1503
[assign] #3531 justification -1: p51
[end-of-instance]
[assign] #4040 clause p436 (not p435)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[assign] #4498 clause p437 (not p435)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[mk-app] #3873 = #4822 #4864
[attach-meaning] #176 arith (- 1)
[mk-app] #4414 + #4822 #4091
[mk-app] #4499 <= #4414 #36
[mk-app] #3301 >= #4414 #36
[assign] #3873 justification -1: p433
[attach-enode] #3873 0
[attach-enode] #4414 0
[assign] #4499 justification -1: p438
[assign] #3301 justification -1: p438
[new-match] 0x1068b2ff0 #1495 #1483 #4840 #1545 ; #4860 (#4843 #4843)
[mk-app] #3302 = #4860 #4882
[mk-app] #4207 = #3428 #3302
[mk-proof] #4208 monotonicity #4884 #4207
[mk-app] #4200 or #1563 #3302
[mk-app] #4203 or #1563 #3428
[mk-proof] #4209 quant-inst #4203
[mk-app] #4215 = #4203 #4200
[mk-proof] #4521 monotonicity #4208 #4215
[mk-app] #3177 = #4200 #4200
[mk-proof] #3178 rewrite #3177
[mk-proof] #3179 trans #4521 #3178 #4215
[mk-proof] #3182 mp #4209 #3179 #4200
[instance] 0x1068b2ff0 #4209 ; 89
[attach-enode] #4879 89
[attach-enode] #4882 89
[attach-enode] #3302 89
[assign] #3302 justification -1: p50
[end-of-instance]
[eq-expl] #4879 root
[new-match] 0x1068b3290 #1477 #1476 #4879 #1545 ; #4882
[eq-expl] #4860 lit #3302 ; #4882
[eq-expl] #4882 root
[new-match] 0x1068b32c8 #1522 #1506 #4879 #1545 ; #4861 (#4860 #4882)
[mk-app] #3186 = #4482 #4482
[mk-proof] #4515 refl #3186
[mk-app] #4505 or #1576 #4482
[mk-proof] #4113 quant-inst #4505
[instance] 0x1068b3290 #4113 ; 90
[attach-enode] #4897 90
[attach-enode] #4482 90
[assign] #4482 justification -1: p49
[end-of-instance]
[mk-app] #3186 = #2911 #2911
[mk-proof] #4515 refl #3186
[mk-app] #4122 or #5060 #2911
[mk-proof] #3665 quant-inst #4122
[instance] 0x1068b32c8 #3665 ; 90
[attach-enode] #4899 90
[attach-enode] #4900 90
[attach-enode] #4903 90
[attach-enode] #4554 90
[attach-enode] #4555 90
[attach-enode] #2911 90
[mk-app] #3655 <= #4555 #1503
[mk-app] #4622 >= #4555 #1503
[assign] #2911 justification -1: p51
[end-of-instance]
[assign] #3655 clause p444 (not p443)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[assign] #4622 clause p445 (not p443)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[mk-app] #3186 = #4861 #4903
[attach-meaning] #176 arith (- 1)
[mk-app] #4515 + #4861 #4554
[mk-app] #4623 <= #4515 #36
[mk-app] #4618 >= #4515 #36
[assign] #3186 justification -1: p441
[attach-enode] #3186 0
[attach-enode] #4515 0
[assign] #4623 justification -1: p446
[assign] #4618 justification -1: p446
[new-match] 0x1068baaa8 #1495 #1483 #4879 #1545 ; #4899 (#4882 #4882)
[mk-app] #4619 = #4899 #4921
[mk-app] #4628 = #3457 #4619
[mk-proof] #4629 monotonicity #4923 #4628
[mk-app] #4636 or #1563 #4619
[mk-app] #4696 or #1563 #3457
[mk-proof] #4697 quant-inst #4696
[mk-app] #4690 = #4696 #4636
[mk-proof] #4691 monotonicity #4629 #4690
[mk-app] #4698 = #4636 #4636
[mk-proof] #4699 rewrite #4698
[mk-proof] #4808 trans #4691 #4699 #4690
[mk-proof] #4809 mp #4697 #4808 #4636
[instance] 0x1068baaa8 #4697 ; 91
[attach-enode] #4918 91
[attach-enode] #4921 91
[attach-enode] #4619 91
[assign] #4619 justification -1: p50
[end-of-instance]
[eq-expl] #4918 root
[new-match] 0x1068bad48 #1477 #1476 #4918 #1545 ; #4921
[eq-expl] #4899 lit #4619 ; #4921
[eq-expl] #4921 root
[new-match] 0x1068bad80 #1522 #1506 #4918 #1545 ; #4900 (#4899 #4921)
[mk-app] #4810 = #3481 #3481
[mk-proof] #4813 refl #4810
[mk-app] #4814 or #1576 #3481
[mk-proof] #4815 quant-inst #4814
[instance] 0x1068bad48 #4815 ; 92
[attach-enode] #4936 92
[attach-enode] #3481 92
[assign] #3481 justification -1: p49
[end-of-instance]
[mk-app] #4810 = #3482 #3482
[mk-proof] #4813 refl #4810
[mk-app] #4816 or #5060 #3482
[mk-proof] #4890 quant-inst #4816
[instance] 0x1068bad80 #4890 ; 92
[attach-enode] #4938 92
[attach-enode] #4939 92
[attach-enode] #4942 92
[attach-enode] #3483 92
[attach-enode] #3477 92
[attach-enode] #3482 92
[mk-app] #4885 <= #3477 #1503
[mk-app] #4863 >= #3477 #1503
[assign] #3482 justification -1: p51
[end-of-instance]
[assign] #4885 clause p452 (not p451)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[assign] #4863 clause p453 (not p451)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[mk-app] #4810 = #4900 #4942
[attach-meaning] #176 arith (- 1)
[mk-app] #4813 + #4900 #3483
[mk-app] #4870 <= #4813 #36
[mk-app] #4886 >= #4813 #36
[assign] #4810 justification -1: p449
[attach-enode] #4810 0
[attach-enode] #4813 0
[assign] #4870 justification -1: p454
[assign] #4886 justification -1: p454
[new-match] 0x1068bb740 #1495 #1483 #4918 #1545 ; #4938 (#4921 #4921)
[mk-app] #4887 = #4938 #4960
[mk-app] #4940 = #4046 #4887
[mk-proof] #4941 monotonicity #4962 #4940
[mk-app] #4932 or #1563 #4887
[mk-app] #4933 or #1563 #4046
[mk-proof] #4948 quant-inst #4933
[mk-app] #4949 = #4933 #4932
[mk-proof] #5009 monotonicity #4941 #4949
[mk-app] #5010 = #4932 #4932
[mk-proof] #5003 rewrite #5010
[mk-proof] #5004 trans #5009 #5003 #4949
[mk-proof] #5011 mp #4948 #5004 #4932
[instance] 0x1068bb740 #4948 ; 93
[attach-enode] #4957 93
[attach-enode] #4960 93
[attach-enode] #4887 93
[assign] #4887 justification -1: p50
[end-of-instance]
[eq-expl] #4957 root
[new-match] 0x1068bb9e0 #1477 #1476 #4957 #1545 ; #4960
[eq-expl] #4938 lit #4887 ; #4960
[eq-expl] #4960 root
[new-match] 0x1068bba18 #1522 #1506 #4957 #1545 ; #4939 (#4938 #4960)
[mk-app] #5012 = #3877 #3877
[mk-proof] #5080 refl #5012
[mk-app] #5081 or #1576 #3877
[mk-proof] #5065 quant-inst #5081
[instance] 0x1068bb9e0 #5065 ; 94
[attach-enode] #4975 94
[attach-enode] #3877 94
[assign] #3877 justification -1: p49
[end-of-instance]
[mk-app] #5012 = #3970 #3970
[mk-proof] #5080 refl #5012
[mk-app] #5066 or #5060 #3970
[mk-proof] #5082 quant-inst #5066
[instance] 0x1068bba18 #5082 ; 94
[attach-enode] #4977 94
[attach-enode] #4978 94
[attach-enode] #4981 94
[attach-enode] #3878 94
[attach-enode] #3672 94
[attach-enode] #3970 94
[mk-app] #5083 <= #3672 #1503
[mk-app] #4068 >= #3672 #1503
[assign] #3970 justification -1: p51
[end-of-instance]
[assign] #5083 clause p460 (not p459)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[assign] #4068 clause p461 (not p459)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[mk-app] #5012 = #4939 #4981
[attach-meaning] #176 arith (- 1)
[mk-app] #5080 + #4939 #3878
[mk-app] #3062 <= #5080 #36
[mk-app] #3975 >= #5080 #36
[assign] #5012 justification -1: p457
[attach-enode] #5012 0
[attach-enode] #5080 0
[assign] #3062 justification -1: p462
[assign] #3975 justification -1: p462
[new-match] 0x1068bc3d8 #1495 #1483 #4957 #1545 ; #4977 (#4960 #4960)
[mk-app] #3272 = #4977 #4999
[mk-app] #4099 = #3206 #3272
[mk-proof] #3100 monotonicity #5001 #4099
[mk-app] #3852 or #1563 #3272
[mk-app] #4350 or #1563 #3206
[mk-proof] #3648 quant-inst #4350
[mk-app] #3649 = #4350 #3852
[mk-proof] #4357 monotonicity #3100 #3649
[mk-app] #4358 = #3852 #3852
[mk-proof] #2943 rewrite #4358
[mk-proof] #2944 trans #4357 #2943 #3649
[mk-proof] #3763 mp #3648 #2944 #3852
[instance] 0x1068bc3d8 #3648 ; 95
[attach-enode] #4996 95
[attach-enode] #4999 95
[attach-enode] #3272 95
[assign] #3272 justification -1: p50
[end-of-instance]
[eq-expl] #4996 root
[new-match] 0x1068cdc90 #1477 #1476 #4996 #1545 ; #4999
[eq-expl] #4977 lit #3272 ; #4999
[eq-expl] #4999 root
[new-match] 0x1068cdcc8 #1522 #1506 #4996 #1545 ; #4978 (#4977 #4999)
[mk-app] #2939 = #4601 #4601
[mk-proof] #2945 refl #2939
[mk-app] #3097 or #1576 #4601
[mk-proof] #2950 quant-inst #3097
[instance] 0x1068cdc90 #2950 ; 96
[attach-enode] #5014 96
[attach-enode] #4601 96
[assign] #4601 justification -1: p49
[end-of-instance]
[mk-app] #2939 = #4635 #4635
[mk-proof] #2945 refl #2939
[mk-app] #3564 or #5060 #4635
[mk-proof] #2948 quant-inst #3564
[instance] 0x1068cdcc8 #2948 ; 96
[attach-enode] #5016 96
[attach-enode] #5017 96
[attach-enode] #5020 96
[attach-enode] #4602 96
[attach-enode] #4638 96
[attach-enode] #4635 96
[mk-app] #4245 <= #4638 #1503
[mk-app] #3565 >= #4638 #1503
[assign] #4635 justification -1: p51
[end-of-instance]
[assign] #4245 clause p468 (not p467)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[assign] #3565 clause p469 (not p467)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[mk-app] #2939 = #4978 #5020
[attach-meaning] #176 arith (- 1)
[mk-app] #2945 + #4978 #4602
[mk-app] #3557 <= #2945 #36
[mk-app] #3826 >= #2945 #36
[assign] #2939 justification -1: p465
[attach-enode] #2939 0
[attach-enode] #2945 0
[assign] #3557 justification -1: p470
[assign] #3826 justification -1: p470
[new-match] 0x1068ce688 #1495 #1483 #4996 #1545 ; #5016 (#4999 #4999)
[mk-app] #3827 = #5016 #5038
[mk-app] #3375 = #4716 #3827
[mk-proof] #3380 monotonicity #5040 #3375
[mk-app] #4301 or #1563 #3827
[mk-app] #4552 or #1563 #4716
[mk-proof] #3424 quant-inst #4552
[mk-app] #4547 = #4552 #4301
[mk-proof] #3536 monotonicity #3380 #4547
[mk-app] #3537 = #4301 #4301
[mk-proof] #3420 rewrite #3537
[mk-proof] #3425 trans #3536 #3420 #4547
[mk-proof] #3934 mp #3424 #3425 #4301
[instance] 0x1068ce688 #3424 ; 97
[attach-enode] #5035 97
[attach-enode] #5038 97
[attach-enode] #3827 97
[assign] #3827 justification -1: p50
[end-of-instance]
[eq-expl] #5035 root
[new-match] 0x1068ce928 #1477 #1476 #5035 #1545 ; #5038
[eq-expl] #5016 lit #3827 ; #5038
[eq-expl] #5038 root
[new-match] 0x1068ce960 #1522 #1506 #5035 #1545 ; #5017 (#5016 #5038)
[mk-app] #3940 = #4795 #4795
[mk-proof] #2912 refl #3940
[mk-app] #3937 or #1576 #4795
[mk-proof] #3941 quant-inst #3937
[instance] 0x1068ce928 #3941 ; 98
[attach-enode] #5053 98
[attach-enode] #4795 98
[assign] #4795 justification -1: p49
[end-of-instance]
[mk-app] #3940 = #4833 #4833
[mk-proof] #2912 refl #3940
[mk-app] #3942 or #5060 #4833
[mk-proof] #3078 quant-inst #3942
[instance] 0x1068ce960 #3078 ; 98
[attach-enode] #5055 98
[attach-enode] #5056 98
[attach-enode] #5059 98
[attach-enode] #4790 98
[attach-enode] #4791 98
[attach-enode] #4833 98
[mk-app] #3079 <= #4791 #1503
[mk-app] #3074 >= #4791 #1503
[assign] #4833 justification -1: p51
[end-of-instance]
[assign] #3079 clause p476 (not p475)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[assign] #3074 clause p477 (not p475)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[mk-app] #3940 = #5017 #5059
[attach-meaning] #176 arith (- 1)
[mk-app] #2912 + #5017 #4790
[mk-app] #3076 <= #2912 #36
[mk-app] #3284 >= #2912 #36
[assign] #3940 justification -1: p473
[attach-enode] #3940 0
[attach-enode] #2912 0
[assign] #3076 justification -1: p478
[assign] #3284 justification -1: p478
[new-match] 0x1068cf320 #1495 #1483 #5035 #1545 ; #5055 (#5038 #5038)
[mk-app] #3285 = #5055 #5077
[mk-app] #3976 = #4869 #3285
[mk-proof] #3209 monotonicity #5079 #3976
[mk-app] #3971 or #1563 #3285
[mk-app] #3972 or #1563 #4869
[mk-proof] #3210 quant-inst #3972
[mk-app] #3204 = #3972 #3971
[mk-proof] #4673 monotonicity #3209 #3204
[mk-app] #4674 = #3971 #3971
[mk-proof] #4640 rewrite #4674
[mk-proof] #4641 trans #4673 #4640 #3204
[mk-proof] #4679 mp #3210 #4641 #3971
[instance] 0x1068cf320 #3210 ; 99
[attach-enode] #5074 99
[attach-enode] #5077 99
[attach-enode] #3285 99
[assign] #3285 justification -1: p50
[end-of-instance]
[eq-expl] #5074 root
[new-match] 0x1068cf5c0 #1477 #1476 #5074 #1545 ; #5077
[eq-expl] #5055 lit #3285 ; #5077
[eq-expl] #5077 root
[new-match] 0x1068cf5f8 #1522 #1506 #5074 #1545 ; #5056 (#5055 #5077)
[mk-app] #4680 = #4952 #4952
[mk-proof] #4836 refl #4680
[mk-app] #4872 or #1576 #4952
[mk-proof] #4834 quant-inst #4872
[instance] 0x1068cf5c0 #4834 ; 100
[attach-enode] #5092 100
[attach-enode] #4952 100
[assign] #4952 justification -1: p49
[end-of-instance]
[mk-app] #4680 = #4986 #4986
[mk-proof] #4836 refl #4680
[mk-app] #4829 or #5060 #4986
[mk-proof] #4873 quant-inst #4829
[instance] 0x1068cf5f8 #4873 ; 100
[attach-enode] #5094 100
[attach-enode] #5095 100
[attach-enode] #5098 100
[attach-enode] #4953 100
[attach-enode] #4989 100
[attach-enode] #4986 100
[mk-app] #4868 <= #4989 #1503
[mk-app] #5024 >= #4989 #1503
[assign] #4986 justification -1: p51
[end-of-instance]
[assign] #4868 clause p484 (not p483)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[assign] #5024 clause p485 (not p483)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[mk-app] #4680 = #5056 #5098
[attach-meaning] #176 arith (- 1)
[mk-app] #4836 + #5056 #4953
[mk-app] #5025 <= #4836 #36
[mk-app] #4991 >= #4836 #36
[assign] #4680 justification -1: p481
[attach-enode] #4680 0
[attach-enode] #4836 0
[assign] #5025 justification -1: p486
[assign] #4991 justification -1: p486
[new-match] 0x1068e2dd8 #1495 #1483 #5074 #1545 ; #5094 (#5077 #5077)
[push] 3
[mk-app] #4992 address<Int> #1569
[mk-app] #5030 mod #4992 #3950
[mk-app] #5031 = #5030 #36
[mk-app] #2189 not #5031
[mk-proof] #5130 asserted #2189
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[begin-check] 4
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #5031 #2
[mk-proof] #5116 iff-false #5130 #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #5031 #2
[mk-proof] #5116 iff-false #5130 #5115
[mk-app] #5115 ~ #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 rewrite #5115
[mk-proof] #5064 mp #5130 #5116 #2189
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[mk-app] #5115 = #2189 #2189
[mk-proof] #5116 refl #5115
[attach-enode] #4992 0
[attach-enode] #5030 0
[attach-enode] #5031 0
[mk-app] #5115 <= #5030 #36
[mk-app] #5116 >= #5030 #36
[assign] (not #5031) justification -1: 
[mk-app] #5064 div #4992 #3950
[mk-app] #5069 < #3950 #36
[mk-app] #5070 - #36 #3950
[mk-app] #5106 if #5069 #5070 #3950
[mk-app] #5107 - #5106 #151
[mk-app] #5102 <= #36 #3950
[mk-app] #5103 not #5102
[inst-discovered] theory-solving 0x0 arith# ; #5069
[mk-app] #5108 = #5069 #5103
[mk-proof] #5109 rewrite #5108
[instance] 0x0 #5108
[end-of-instance]
[inst-discovered] theory-solving 0x0 arith# ; #5102
[mk-app] #2190 = #5102 #1
[mk-proof] #5127 rewrite #2190
[instance] 0x0 #2190
[end-of-instance]
[mk-app] #5129 = #5103 #4435
[mk-proof] #5114 monotonicity #5127 #5129
[inst-discovered] theory-solving 0x0 basic# ; #4435
[instance] 0x0 #4438
[end-of-instance]
[mk-app] #5117 = #5103 #2
[mk-proof] #5118 trans #5114 #4441 #5117
[mk-app] #5119 = #5069 #2
[mk-proof] #5121 trans #5109 #5118 #5119
[attach-meaning] #176 arith (- 1)
[mk-app] #5122 * #176 #3950
[mk-app] #5123 + #36 #5122
[inst-discovered] theory-solving 0x0 arith# ; #5070
[mk-app] #5133 = #5070 #5123
[mk-proof] #5134 rewrite #5133
[instance] 0x0 #5133
[end-of-instance]
[mk-app] #5132 Int
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5122
[mk-app] #5135 = #5122 #5132
[mk-proof] #5136 rewrite #5135
[instance] 0x0 #5135
[end-of-instance]
[mk-app] #5150 + #36 #5132
[mk-app] #5181 = #5123 #5150
[mk-proof] #5171 monotonicity #5136 #5181
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5150
[mk-app] #5172 = #5150 #5132
[mk-proof] #5131 rewrite #5172
[instance] 0x0 #5172
[end-of-instance]
[mk-app] #5151 = #5123 #5132
[mk-proof] #5149 trans #5171 #5131 #5151
[mk-app] #5152 = #5070 #5132
[mk-proof] #5153 trans #5134 #5149 #5152
[mk-app] #5154 if #2 #5132 #3950
[mk-app] #5178 = #5106 #5154
[mk-proof] #5180 monotonicity #5121 #5153 #5178
[inst-discovered] theory-solving 0x0 arith# ; #5154
[mk-app] #5173 = #5154 #3950
[mk-proof] #5174 rewrite #5173
[instance] 0x0 #5173
[end-of-instance]
[mk-app] #5175 = #5106 #3950
[mk-proof] #5170 trans #5180 #5174 #5175
[mk-app] #5176 - #3950 #151
[mk-app] #5177 = #5107 #5176
[mk-proof] #5182 monotonicity #5170 #5177
[attach-meaning] #176 arith (- 1)
[mk-app] #5183 + #3950 #3102
[inst-discovered] theory-solving 0x0 arith# ; #5176
[mk-app] #5184 = #5176 #5183
[mk-proof] #5187 rewrite #5184
[instance] 0x0 #5184
[end-of-instance]
[mk-app] #5188 = #5107 #5183
[mk-proof] #5199 trans #5182 #5187 #5188
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3102
[instance] 0x0 #3064
[end-of-instance]
[mk-app] #5200 + #3950 #176
[mk-app] #5194 = #5183 #5200
[mk-proof] #5198 monotonicity #4028 #5194
[inst-discovered] theory-solving 0x0 arith# ; #5200
[mk-app] #5201 = #5200 #151
[mk-proof] #5202 rewrite #5201
[instance] 0x0 #5201
[end-of-instance]
[mk-app] #5204 = #5183 #151
[mk-proof] #5137 trans #5198 #5202 #5204
[mk-app] #5222 = #5107 #151
[mk-proof] #5257 trans #5199 #5137 #5222
[mk-app] #5221 = #3950 #36
[mk-app] #5265 * #3950 #5064
[mk-app] #5432 + #5265 #5030
[mk-app] #5269 = #5432 #4992
[mk-app] #5124 <= #5030 #151
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5221
[mk-app] #5069 = #5221 #2
[mk-proof] #5108 rewrite #5069
[instance] 0x0 #5069
[end-of-instance]
[attach-enode] #5064 0
[attach-enode] #5265 0
[attach-enode] #5432 0
[attach-enode] #5269 0
[mk-app] #5109 or #5221 #5269
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5109
[assign] #5269 justification -1: true
[end-of-instance]
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5221
[mk-app] #5069 = #5221 #2
[mk-proof] #5108 rewrite #5069
[instance] 0x0 #5069
[end-of-instance]
[attach-enode] #5116 0
[mk-app] #5109 or #5221 #5116
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5109
[assign] #5116 justification -1: true
[end-of-instance]
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5221
[mk-app] #5069 = #5221 #2
[mk-proof] #5108 rewrite #5069
[instance] 0x0 #5069
[end-of-instance]
[attach-enode] #5124 0
[mk-app] #5109 or #5221 #5124
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5109
[assign] #5124 justification -1: true
[end-of-instance]
[mk-app] #5109 = #5031 #2
[mk-proof] #5119 iff-false #5130 #5109
[assign] (not #5115) clause (not p490) p489 (not p491)
  (not (<= (mod (address<Int> idx_one@7@01) 2::Int) 0::Int)) 
  (= (mod (address<Int> idx_one@7@01) 2::Int) 0::Int) 
  (not (>= (mod (address<Int> idx_one@7@01) 2::Int) 0::Int)) 

[mk-app] #5267 = #3235 #5432
[attach-meaning] #176 arith (- 1)
[mk-app] #5268 * #176 #5432
[mk-app] #5263 + #3235 #5268
[mk-app] #5185 <= #5263 #36
[mk-app] #5186 >= #5263 #36
[assign] #5267 justification -1: p492 p56 p55
[attach-enode] #5267 0
[attach-enode] #5268 0
[attach-enode] #5263 0
[assign] #5185 justification -1: p494
[assign] #5186 justification -1: p494
[decide-and-or] #2170 #2177
[push] 4
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 5
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[new-match] 0x1068e3bf8 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e3c30 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e3c68 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e3ca8 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e3ce8 #124 #118 #1528 ; #3402
[new-match] 0x1068e3d18 #143 #118 #1528 ; #3402
[new-match] 0x1068e3d48 #237 #229 #3402 #36 ; #3403
[mk-app] #5179 * #176 #4347
[mk-app] #5128 + #3403 #5110 #5179
[mk-app] #5126 = #5128 #36
[mk-app] #5221 + #5110 #3403 #5179
[inst-discovered] theory-solving 0x0 arith# ; #5128
[mk-app] #5069 = #5128 #5221
[mk-proof] #5108 rewrite #5069
[instance] 0x0 #5069
[end-of-instance]
[mk-app] #5067 = #5221 #36
[mk-app] #5068 = #5126 #5067
[mk-proof] #5063 monotonicity #5108 #5068
[attach-meaning] #176 arith (- 1)
[mk-app] #5121 + #3402 #5120 #4347
[mk-app] #5070 = #5121 #36
[inst-discovered] theory-solving 0x0 arith# ; #5067
[mk-app] #5133 = #5067 #5070
[mk-proof] #5134 rewrite #5133
[instance] 0x0 #5133
[end-of-instance]
[mk-app] #5152 = #5126 #5070
[mk-proof] #5153 trans #5063 #5134 #5152
[mk-app] #5106 not #263
[mk-app] #5154 or #5106 #5070
[mk-app] #5178 or #5106 #5126
[mk-proof] #5180 quant-inst #5178
[mk-app] #5173 = #5178 #5154
[mk-proof] #5174 monotonicity #5153 #5173
[mk-app] #5175 = #5154 #5154
[mk-proof] #5170 rewrite #5175
[mk-proof] #5107 trans #5174 #5170 #5173
[mk-proof] #5176 mp #5180 #5107 #5154
[instance] 0x1068e3bf8 #5180 ; 3
[attach-enode] #5120 3
[attach-enode] #5121 3
[attach-enode] #5070 3
[mk-app] #5177 <= #5121 #36
[mk-app] #5182 >= #5121 #36
[assign] #5070 justification -1: p21
[end-of-instance]
[mk-app] #5184 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5184
[mk-app] #5187 = #5184 #5184
[mk-proof] #5188 rewrite #5187
[instance] 0x0 #5187
[end-of-instance]
[mk-app] #5199 or #4423 #5142 #5144 #5145
[mk-app] #5222 or #4423 #5184
[mk-proof] #5257 quant-inst #5222
[mk-app] #5125 = #5222 #5199
[mk-proof] #5203 rewrite #5125
[mk-proof] #5189 mp #5257 #5203 #5199
[instance] 0x1068e3c30 #5257 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5187 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5188 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5193 = #5187 #5188
[mk-proof] #5266 monotonicity #5169 #5193
[mk-app] #5253 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5188
[mk-app] #5433 = #5188 #5253
[mk-proof] #5434 rewrite #5433
[instance] 0x0 #5433
[end-of-instance]
[mk-app] #5435 = #5187 #5253
[mk-proof] #5436 trans #5266 #5434 #5435
[mk-app] #5437 not #1917
[mk-app] #5438 or #5437 #2172 #2353 #5144 #5148 #5165
[mk-app] #5439 or #5437 #5187
[mk-proof] #5440 quant-inst #5439
[mk-app] #5441 or #5437 #5253
[mk-app] #5442 = #5439 #5441
[mk-proof] #5443 monotonicity #5436 #5442
[mk-app] #5444 = #5441 #5438
[mk-proof] #5445 rewrite #5444
[mk-app] #5446 = #5439 #5438
[mk-proof] #5447 trans #5443 #5445 #5446
[mk-proof] #5448 mp #5440 #5447 #5438
[instance] 0x1068e3c68 #5440 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5449 >= #3402 #36
[mk-app] #5450 = #5449 #5449
[mk-proof] #5451 refl #5450
[mk-app] #5452 or #1546 #5449
[mk-proof] #5453 quant-inst #5452
[instance] 0x1068e3ce8 #5453 ; 3
[assign] #5449 justification -1: p13
[end-of-instance]
[mk-app] #5450 not #5191
[mk-app] #5451 or #5450 #2172
[mk-app] #5454 = #5451 #5451
[mk-proof] #5455 refl #5454
[mk-app] #5456 or #2307 #5450 #2172
[mk-app] #5457 or #2307 #5451
[mk-proof] #5458 quant-inst #5457
[mk-app] #5459 = #5457 #5456
[mk-proof] #5460 rewrite #5459
[mk-proof] #5461 mp #5458 #5460 #5456
[instance] 0x1068e3d18 #5458 ; 3
[attach-enode] #5191 3
[mk-app] #5462 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[instance] 0x1068e3d48 #5213 ; 3
[attach-enode] #5207 3
[assign] #5207 justification -1: p20
[end-of-instance]
[assign] #5177 clause p498 (not p497)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5182 clause p499 (not p497)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5462) clause (not p507) p506
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p504 (not p508)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5220 clause p509 (not p508)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5454 <= #4347 #36
[mk-app] #5455 >= #4347 #36
[assign] #5454 justification -1: p78
[assign] #5455 justification -1: p78
[assign] #5143 clause p501 (not p504) (not p505)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5199 #5142
[push] 6
[assign] #5142 decision axiom
[new-match] 0x1068e92e8 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e9320 #124 #118 #1529 ; #5139
[new-match] 0x1068e9350 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5232
[instance] 0x0 #5236
[end-of-instance]
[instance] 0x1068e92e8 #5243 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5463 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5464 >= #5139 #36
[mk-app] #5465 = #5464 #5464
[mk-proof] #5466 refl #5465
[mk-app] #5467 or #1546 #5464
[mk-proof] #5468 quant-inst #5467
[instance] 0x1068e9320 #5468 ; 4
[assign] #5464 justification -1: p13
[end-of-instance]
[mk-app] #5465 not #5255
[mk-app] #5466 or #5465 #5259
[mk-app] #5469 = #5466 #5466
[mk-proof] #5470 refl #5469
[mk-app] #5471 or #2307 #5465 #5259
[mk-app] #5472 or #2307 #5466
[mk-proof] #5473 quant-inst #5472
[mk-app] #5474 = #5472 #5471
[mk-proof] #5475 rewrite #5474
[mk-proof] #5476 mp #5473 #5475 #5471
[instance] 0x1068e9350 #5473 ; 4
[attach-enode] #5255 4
[mk-app] #5477 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5252 clause p513 (not p512)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5463 clause p514 (not p512)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5220)
[resolve-lit] 0 (not #5252)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5252)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[conflict] (not #5142) #2353 #2172
[pop] 1 7
[assign] (not #5142) clause (not p500) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p502 p500 (not p501)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068e92d0 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e9308 #124 #118 #1529 ; #5139
[new-match] 0x1068e9338 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5232
[instance] 0x0 #5236
[end-of-instance]
[instance] 0x1068e92d0 #5243 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5467 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5468 = #5464 #5464
[mk-proof] #5472 refl #5468
[mk-app] #5473 or #1546 #5464
[mk-proof] #5471 quant-inst #5473
[instance] 0x1068e9308 #5471 ; 4
[assign] #5464 justification -1: p13
[end-of-instance]
[mk-app] #5468 = #5466 #5466
[mk-proof] #5472 refl #5468
[mk-app] #5474 or #2307 #5465 #5259
[mk-app] #5475 or #2307 #5466
[mk-proof] #5476 quant-inst #5475
[mk-app] #5463 = #5475 #5474
[mk-proof] #5477 rewrite #5463
[mk-proof] #5469 mp #5476 #5477 #5474
[instance] 0x1068e9338 #5476 ; 4
[attach-enode] #5255 4
[mk-app] #5470 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5252 clause p513 (not p512)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5467 clause p514 (not p512)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #5470) clause (not p517) (not p504) (not p505) p500
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p516) p517
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #5468 >= #5064 #3950
[mk-app] #5472 not #5468
[mk-app] #5478 or #5468 #5472
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5478
[end-of-instance]
[push] 6
[assign] (not #5468) decision axiom
[mk-app] #5472 not #4210
[mk-app] #5478 or #5472 #4159
[mk-proof] #5479 th-lemma #5478
[mk-proof] #5480 unit-resolution #5479 #4158 #4159
[mk-app] #5481 or #2 #4063
[mk-proof] #5482 th-lemma #5481
[mk-proof] #5483 unit-resolution #5482 #8 #4063
[mk-app] #5484 or #2 #4722
[mk-proof] #5485 th-lemma #5484
[mk-proof] #5486 unit-resolution #5485 #8 #4722
[mk-app] #5487 = #4105 #4199
[mk-proof] #5488 monotonicity #1564 #5487
[mk-app] #5489 = #4199 #4742
[mk-proof] #5490 symm #5486 #5489
[mk-proof] #5491 trans* #5488 #5490 #4749
[mk-app] #5492 not #4749
[mk-app] #5493 or #5492 #5015
[mk-proof] #5494 th-lemma #5493
[mk-proof] #5495 unit-resolution #5494 #5491 #5015
[mk-app] #5496 or #5492 #4995
[mk-proof] #5497 th-lemma #5496
[mk-proof] #5498 unit-resolution #5497 #5491 #4995
[mk-app] #5499 or #2 #5124
[mk-proof] #5500 th-lemma #5499
[mk-proof] #5501 unit-resolution #5500 #8 #5124
[mk-app] #5502 or #2 #5116
[mk-proof] #5503 th-lemma #5502
[mk-proof] #5504 unit-resolution #5503 #8 #5116
[mk-app] #5505 not #5115
[mk-app] #5506 not #5116
[mk-app] #5507 or #5031 #5505 #5506
[mk-proof] #5508 th-lemma #5507
[mk-proof] #5509 unit-resolution #5508 #5130 #5504 #5505
[mk-proof] #5510 unit-resolution #4983 #1942 #5254
[mk-app] #5511 not #5254
[mk-app] #5512 or #5511 #5022
[mk-proof] #5513 th-lemma #5512
[mk-proof] #5514 unit-resolution #5513 #5510 #5022
[mk-app] #5515 or #5511 #5192
[mk-proof] #5516 th-lemma #5515
[mk-proof] #5517 unit-resolution #5516 #5510 #5192
[mk-app] #5518 = #1574 #1570
[mk-proof] #5519 monotonicity #1564 #5518
[mk-app] #5520 = #1570 #1574
[mk-proof] #5521 symm #5519 #5520
[mk-app] #5522 = #1569 #1574
[mk-proof] #5523 trans* #1573 #5521 #5522
[mk-app] #5524 or #2 #5269
[mk-proof] #5525 th-lemma #5524
[mk-proof] #5526 unit-resolution #5525 #8 #5269
[mk-app] #5527 = #4992 #3235
[mk-proof] #5528 monotonicity #5523 #5527
[mk-app] #5529 = #3235 #4992
[mk-proof] #5530 symm #5528 #5529
[mk-app] #5531 = #4992 #5432
[mk-proof] #5532 symm #5526 #5531
[mk-proof] #5533 trans* #5530 #5532 #5267
[mk-app] #5534 not #5267
[mk-app] #5535 or #5534 #5185
[mk-proof] #5536 th-lemma #5535
[mk-proof] #5537 unit-resolution #5536 #5533 #5185
[mk-app] #5538 or #5534 #5186
[mk-proof] #5539 th-lemma #5538
[mk-proof] #5540 unit-resolution #5539 #5533 #5186
[mk-proof] #5541 th-lemma #5540 #5537 #5517 #5514 #5509 #5501 #5498 #5495 #5483 #5480 #2
[pop] 3 7
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 4
[mk-proof] #5109 asserted #5031
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 ~ #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 rewrite #5119
[mk-proof] #5207 mp #5109 #5470 #5031
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[mk-app] #5119 = #5031 #5031
[mk-proof] #5470 refl #5119
[attach-enode] #4992 0
[attach-enode] #5030 0
[attach-enode] #5031 0
[assign] #5031 justification -1: 
[mk-app] #5119 < #3950 #36
[mk-app] #5470 - #36 #3950
[mk-app] #5207 if #5119 #5470 #3950
[mk-app] #5281 - #5207 #151
[inst-discovered] theory-solving 0x0 arith# ; #5119
[mk-app] #5220 = #5119 #5103
[mk-proof] #5282 rewrite #5220
[instance] 0x0 #5220
[end-of-instance]
[mk-app] #5283 = #5119 #2
[mk-proof] #5210 trans #5282 #5118 #5283
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5470
[mk-app] #5212 = #5470 #5123
[mk-proof] #5213 rewrite #5212
[instance] 0x0 #5212
[end-of-instance]
[mk-app] #5208 = #5470 #5132
[mk-proof] #5209 trans #5213 #5149 #5208
[mk-app] #5211 if #2 #5132 #3950
[mk-app] #5214 = #5207 #5211
[mk-proof] #5215 monotonicity #5210 #5209 #5214
[inst-discovered] theory-solving 0x0 arith# ; #5211
[mk-app] #5216 = #5211 #3950
[mk-proof] #5217 rewrite #5216
[instance] 0x0 #5216
[end-of-instance]
[mk-app] #5218 = #5207 #3950
[mk-proof] #5219 trans #5215 #5217 #5218
[mk-app] #5280 - #3950 #151
[mk-app] #5284 = #5281 #5280
[mk-proof] #5276 monotonicity #5219 #5284
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5280
[mk-app] #5277 = #5280 #5183
[mk-proof] #5278 rewrite #5277
[instance] 0x0 #5277
[end-of-instance]
[mk-app] #5279 = #5281 #5183
[mk-proof] #5272 trans #5276 #5278 #5279
[mk-app] #5252 = #5281 #151
[mk-proof] #5273 trans #5272 #5137 #5252
[mk-app] #5274 = #3950 #36
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5274
[mk-app] #5119 = #5274 #2
[mk-proof] #5220 rewrite #5119
[instance] 0x0 #5119
[end-of-instance]
[attach-enode] #5064 0
[attach-enode] #5265 0
[attach-enode] #5432 0
[attach-enode] #5269 0
[mk-app] #5282 or #5274 #5269
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5282
[assign] #5269 justification -1: true
[end-of-instance]
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5274
[mk-app] #5119 = #5274 #2
[mk-proof] #5220 rewrite #5119
[instance] 0x0 #5119
[end-of-instance]
[attach-enode] #5116 0
[mk-app] #5282 or #5274 #5116
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5282
[assign] #5116 justification -1: true
[end-of-instance]
[attach-meaning] #5132 arith (- 2)
[inst-discovered] theory-solving 0x0 arith# ; #5274
[mk-app] #5119 = #5274 #2
[mk-proof] #5220 rewrite #5119
[instance] 0x0 #5119
[end-of-instance]
[attach-enode] #5124 0
[mk-app] #5282 or #5274 #5124
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5282
[assign] #5124 justification -1: true
[end-of-instance]
[assign] #5115 clause p490 (not p489)
  (<= (mod (address<Int> idx_one@7@01) 2::Int) 0::Int) 
  (not (= (mod (address<Int> idx_one@7@01) 2::Int) 0::Int)) 

[attach-meaning] #176 arith (- 1)
[assign] #5267 justification -1: p492 p56 p55
[attach-enode] #5267 0
[attach-enode] #5268 0
[attach-enode] #5263 0
[assign] #5185 justification -1: p494
[assign] #5186 justification -1: p494
[push] 3
[mk-app] #5282 mod #4992 #1503
[mk-app] #5283 = #5282 #36
[mk-app] #5210 not #5283
[mk-proof] #5470 asserted #5210
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[begin-check] 4
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5283 #2
[mk-proof] #5213 iff-false #5470 #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5283 #2
[mk-proof] #5213 iff-false #5470 #5212
[mk-app] #5212 ~ #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 rewrite #5212
[mk-proof] #5208 mp #5470 #5213 #5210
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[mk-app] #5212 = #5210 #5210
[mk-proof] #5213 refl #5212
[attach-enode] #5282 0
[attach-enode] #5283 0
[mk-app] #5212 <= #5282 #36
[mk-app] #5213 >= #5282 #36
[assign] (not #5283) justification -1: 
[mk-app] #5208 div #4992 #1503
[mk-app] #5209 < #1503 #36
[mk-app] #5207 - #36 #1503
[mk-app] #5211 if #5209 #5207 #1503
[mk-app] #5214 - #5211 #151
[inst-discovered] theory-solving 0x0 arith# ; #5209
[mk-app] #5274 = #5209 #3233
[mk-proof] #5119 rewrite #5274
[instance] 0x0 #5274
[end-of-instance]
[mk-app] #5220 = #5209 #2
[mk-proof] #5215 trans #5119 #3190 #5220
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5207
[mk-app] #5216 = #5207 #3205
[mk-proof] #5217 rewrite #5216
[instance] 0x0 #5216
[end-of-instance]
[mk-app] #5218 = #5207 #4108
[mk-proof] #5219 trans #5217 #3152 #5218
[mk-app] #5281 if #2 #4108 #1503
[mk-app] #5280 = #5211 #5281
[mk-proof] #5284 monotonicity #5215 #5219 #5280
[inst-discovered] theory-solving 0x0 arith# ; #5281
[mk-app] #5276 = #5281 #1503
[mk-proof] #5277 rewrite #5276
[instance] 0x0 #5276
[end-of-instance]
[mk-app] #5278 = #5211 #1503
[mk-proof] #5279 trans #5284 #5277 #5278
[mk-app] #5272 - #1503 #151
[mk-app] #5252 = #5214 #5272
[mk-proof] #5273 monotonicity #5279 #5252
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5272
[mk-app] #5240 = #5272 #4048
[mk-proof] #5242 rewrite #5240
[instance] 0x0 #5240
[end-of-instance]
[mk-app] #5243 = #5214 #4048
[mk-proof] #5232 trans #5273 #5242 #5243
[mk-app] #5233 = #5214 #4037
[mk-proof] #5234 trans #5232 #4000 #5233
[mk-app] #5235 = #1503 #36
[mk-app] #5236 * #1503 #5208
[mk-app] #5237 + #5236 #5282
[mk-app] #5238 = #5237 #4992
[mk-app] #5239 <= #5282 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5235
[mk-app] #5209 = #5235 #2
[mk-proof] #5274 rewrite #5209
[instance] 0x0 #5209
[end-of-instance]
[attach-enode] #5208 0
[attach-enode] #5236 0
[attach-enode] #5237 0
[attach-enode] #5238 0
[mk-app] #5119 = #4992 #5237
[attach-meaning] #176 arith (- 1)
[mk-app] #5220 * #176 #5237
[mk-app] #5215 + #4992 #5220
[mk-app] #5207 <= #5215 #36
[mk-app] #5216 >= #5215 #36
[attach-enode] #5119 0
[attach-enode] #5220 0
[attach-enode] #5215 0
[mk-app] #5217 or #5235 #5238
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5217
[assign] #5238 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5235
[mk-app] #5209 = #5235 #2
[mk-proof] #5274 rewrite #5209
[instance] 0x0 #5209
[end-of-instance]
[attach-enode] #5213 0
[mk-app] #5217 or #5235 #5213
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5217
[assign] #5213 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5235
[mk-app] #5209 = #5235 #2
[mk-proof] #5274 rewrite #5209
[instance] 0x0 #5209
[end-of-instance]
[attach-enode] #5239 0
[mk-app] #5217 or #5235 #5239
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5217
[assign] #5239 justification -1: true
[end-of-instance]
[mk-app] #5217 = #5283 #2
[mk-proof] #5218 iff-false #5470 #5217
[assign] (not #5212) clause (not p498) p497 (not p499)
  (not (<= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int)) 
  (= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int) 
  (not (>= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int)) 

[assign] #5119 justification -1: p500
[attach-meaning] #176 arith (- 1)
[mk-app] #5465 + #4992 #5268
[mk-app] #5466 <= #5465 #36
[mk-app] #5464 >= #5465 #36
[assign] #5531 justification -1: p492
[attach-enode] #5531 0
[attach-enode] #5465 0
[assign] #5466 justification -1: p505
[assign] #5464 justification -1: p505
[assign] #5207 clause p502 (not p501)
  (<= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[assign] #5216 clause p503 (not p501)
  (>= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[decide-and-or] #2170 #2177
[push] 4
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 5
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[new-match] 0x1068e90a8 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e90e0 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e9118 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e9158 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e9198 #124 #118 #1528 ; #3402
[new-match] 0x1068e91c8 #143 #118 #1528 ; #3402
[new-match] 0x1068e91f8 #237 #229 #3402 #36 ; #3403
[mk-app] #5225 * #176 #4347
[mk-app] #5197 + #3403 #5110 #5225
[mk-app] #5450 = #5197 #36
[mk-app] #5235 + #5110 #3403 #5225
[inst-discovered] theory-solving 0x0 arith# ; #5197
[mk-app] #5209 = #5197 #5235
[mk-proof] #5274 rewrite #5209
[instance] 0x0 #5209
[end-of-instance]
[mk-app] #5451 = #5235 #36
[mk-app] #5449 = #5450 #5451
[mk-proof] #5187 monotonicity #5274 #5449
[attach-meaning] #176 arith (- 1)
[mk-app] #5184 + #3402 #5120 #4347
[mk-app] #5179 = #5184 #36
[inst-discovered] theory-solving 0x0 arith# ; #5451
[mk-app] #5128 = #5451 #5179
[mk-proof] #5126 rewrite #5128
[instance] 0x0 #5128
[end-of-instance]
[mk-app] #5219 = #5450 #5179
[mk-proof] #5211 trans #5187 #5126 #5219
[mk-app] #5281 not #263
[mk-app] #5280 or #5281 #5179
[mk-app] #5284 or #5281 #5450
[mk-proof] #5276 quant-inst #5284
[mk-app] #5277 = #5284 #5280
[mk-proof] #5278 monotonicity #5211 #5277
[mk-app] #5279 = #5280 #5280
[mk-proof] #5214 rewrite #5279
[mk-proof] #5272 trans #5278 #5214 #5277
[mk-proof] #5252 mp #5276 #5272 #5280
[instance] 0x1068e90a8 #5276 ; 3
[attach-enode] #5120 3
[attach-enode] #5184 3
[attach-enode] #5179 3
[mk-app] #5273 <= #5184 #36
[mk-app] #5240 >= #5184 #36
[assign] #5179 justification -1: p21
[end-of-instance]
[mk-app] #5242 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5242
[mk-app] #5243 = #5242 #5242
[mk-proof] #5232 rewrite #5243
[instance] 0x0 #5243
[end-of-instance]
[mk-app] #5233 or #4423 #5142 #5144 #5145
[mk-app] #5234 or #4423 #5242
[mk-proof] #5244 quant-inst #5234
[mk-app] #5245 = #5234 #5233
[mk-proof] #5246 rewrite #5245
[mk-proof] #5241 mp #5244 #5246 #5233
[instance] 0x1068e90e0 #5244 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5243 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5232 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5247 = #5243 #5232
[mk-proof] #5248 monotonicity #5169 #5247
[mk-app] #5249 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5232
[mk-app] #5250 = #5232 #5249
[mk-proof] #5251 rewrite #5250
[instance] 0x0 #5250
[end-of-instance]
[mk-app] #5270 = #5243 #5249
[mk-proof] #5262 trans #5248 #5251 #5270
[mk-app] #5271 not #1917
[mk-app] #5275 or #5271 #2172 #2353 #5144 #5148 #5165
[mk-app] #5261 or #5271 #5243
[mk-proof] #5285 quant-inst #5261
[mk-app] #5286 or #5271 #5249
[mk-app] #5287 = #5261 #5286
[mk-proof] #5288 monotonicity #5262 #5287
[mk-app] #5106 = #5286 #5275
[mk-proof] #5178 rewrite #5106
[mk-app] #5180 = #5261 #5275
[mk-proof] #5221 trans #5288 #5178 #5180
[mk-proof] #5069 mp #5285 #5221 #5275
[instance] 0x1068e9118 #5285 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5108 >= #3402 #36
[mk-app] #5067 = #5108 #5108
[mk-proof] #5068 refl #5067
[mk-app] #5063 or #1546 #5108
[mk-proof] #5121 quant-inst #5063
[instance] 0x1068e9198 #5121 ; 3
[assign] #5108 justification -1: p13
[end-of-instance]
[mk-app] #5067 not #5191
[mk-app] #5068 or #5067 #2172
[mk-app] #5070 = #5068 #5068
[mk-proof] #5133 refl #5070
[mk-app] #5134 or #2307 #5067 #2172
[mk-app] #5152 or #2307 #5068
[mk-proof] #5153 quant-inst #5152
[mk-app] #5154 = #5152 #5134
[mk-proof] #5173 rewrite #5154
[mk-proof] #5174 mp #5153 #5173 #5134
[instance] 0x1068e91c8 #5153 ; 3
[attach-enode] #5191 3
[mk-app] #5175 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[mk-app] #5070 = #5196 #36
[mk-app] #5133 = #5164 #36
[mk-app] #5170 = #5070 #5133
[mk-proof] #5107 monotonicity #5206 #5170
[mk-app] #5176 not #237
[mk-app] #5222 or #5176 #5133
[mk-app] #5257 or #5176 #5070
[mk-proof] #5199 quant-inst #5257
[mk-app] #5125 = #5257 #5222
[mk-proof] #5203 monotonicity #5107 #5125
[mk-app] #5189 = #5222 #5222
[mk-proof] #5437 rewrite #5189
[mk-proof] #5439 trans #5203 #5437 #5125
[mk-proof] #5440 mp #5199 #5439 #5222
[instance] 0x1068e91f8 #5199 ; 3
[attach-enode] #5133 3
[mk-app] #5188 >= #5164 #36
[assign] #5133 justification -1: p20
[end-of-instance]
[assign] #5273 clause p509 (not p508)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5240 clause p510 (not p508)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5175) clause (not p518) p517
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p515 (not p519)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5188 clause p520 (not p519)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5193 <= #4347 #36
[mk-app] #5266 >= #4347 #36
[assign] #5193 justification -1: p78
[assign] #5266 justification -1: p78
[assign] #5143 clause p512 (not p515) (not p516)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5233 #5142
[push] 6
[assign] #5142 decision axiom
[new-match] 0x1068ea188 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068ea1c0 #124 #118 #1529 ; #5139
[new-match] 0x1068ea1f0 #143 #118 #1529 ; #5139
[mk-app] #5253 or #2353 #2172 #5224
[mk-app] #5433 or #2353 #2172 #5229
[mk-app] #5434 = #5253 #5433
[mk-proof] #5435 monotonicity #5231 #5434
[mk-app] #5436 or #2172 #2353 #5229
[inst-discovered] theory-solving 0x0 basic# ; #5433
[mk-app] #5441 = #5433 #5436
[mk-proof] #5442 rewrite #5441
[instance] 0x0 #5441
[end-of-instance]
[mk-app] #5443 = #5253 #5436
[mk-proof] #5438 trans #5435 #5442 #5443
[mk-app] #5444 not #2726
[mk-app] #5445 or #5444 #2172 #2353 #5229
[mk-app] #5446 or #5444 #5253
[mk-proof] #5447 quant-inst #5446
[mk-app] #5448 or #5444 #5436
[mk-app] #5452 = #5446 #5448
[mk-proof] #5453 monotonicity #5438 #5452
[mk-app] #5457 = #5448 #5445
[mk-proof] #5458 rewrite #5457
[mk-app] #5456 = #5446 #5445
[mk-proof] #5459 trans #5453 #5458 #5456
[mk-proof] #5460 mp #5447 #5459 #5445
[instance] 0x1068ea188 #5447 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5461 <= #5226 #36
[mk-app] #5473 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5471 >= #5139 #36
[mk-app] #5475 = #5471 #5471
[mk-proof] #5476 refl #5475
[mk-app] #5474 or #1546 #5471
[mk-proof] #5463 quant-inst #5474
[instance] 0x1068ea1c0 #5463 ; 4
[assign] #5471 justification -1: p13
[end-of-instance]
[mk-app] #5475 not #5255
[mk-app] #5476 or #5475 #5259
[mk-app] #5477 = #5476 #5476
[mk-proof] #5469 refl #5477
[mk-app] #5177 or #2307 #5475 #5259
[mk-app] #5182 or #2307 #5476
[mk-proof] #5462 quant-inst #5182
[mk-app] #5454 = #5182 #5177
[mk-proof] #5455 rewrite #5454
[mk-proof] #5467 mp #5462 #5455 #5177
[instance] 0x1068ea1f0 #5462 ; 4
[attach-enode] #5255 4
[mk-app] #5468 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5461 clause p524 (not p523)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5473 clause p525 (not p523)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5188)
[resolve-lit] 0 (not #5461)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5461)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[mk-proof] #5477 hypothesis #5142
[mk-proof] #5469 hypothesis #2294
[mk-proof] #5542 hypothesis #2177
[mk-proof] #5543 unit-resolution #5460 #2731 #5542 #5469 #5229
[mk-app] #5544 not #5229
[mk-app] #5545 or #5544 #5461
[mk-proof] #5546 th-lemma #5545
[mk-proof] #5547 unit-resolution #5546 #5543 #5461
[mk-app] #5548 not #2348
[mk-app] #5549 or #5548 #2136
[mk-proof] #5550 th-lemma #5549
[mk-proof] #5551 unit-resolution #5550 #2186 #2136
[mk-proof] #5552 unit-resolution #5440 #2853 #5133
[mk-app] #5553 not #5133
[mk-app] #5554 or #5553 #5188
[mk-proof] #5555 th-lemma #5554
[mk-proof] #5556 unit-resolution #5555 #5552 #5188
[mk-proof] #5557 th-lemma #5556 #5551 #5547 #5477 #2
[mk-app] #5558 not #5142
[mk-app] #5559 or #5558 #2353 #2172
[mk-proof] #5560 lemma #5557 #5559
[conflict] (not #5142) #2353 #2172
[pop] 1 7
[assign] (not #5142) clause (not p511) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p513 p511 (not p512)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068ea170 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068ea1a8 #124 #118 #1529 ; #5139
[new-match] 0x1068ea1d8 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5433
[instance] 0x0 #5441
[end-of-instance]
[instance] 0x1068ea170 #5447 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5474 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5463 = #5471 #5471
[mk-proof] #5182 refl #5463
[mk-app] #5462 or #1546 #5471
[mk-proof] #5177 quant-inst #5462
[instance] 0x1068ea1a8 #5177 ; 4
[assign] #5471 justification -1: p13
[end-of-instance]
[mk-app] #5463 = #5476 #5476
[mk-proof] #5182 refl #5463
[mk-app] #5454 or #2307 #5475 #5259
[mk-app] #5455 or #2307 #5476
[mk-proof] #5467 quant-inst #5455
[mk-app] #5473 = #5455 #5454
[mk-proof] #5468 rewrite #5473
[mk-proof] #5534 mp #5467 #5468 #5454
[instance] 0x1068ea1d8 #5467 ; 4
[attach-enode] #5255 4
[mk-app] #5538 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5461 clause p524 (not p523)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5474 clause p525 (not p523)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #5538) clause (not p528) (not p515) (not p516) p511
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p527) p528
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #5463 not #4210
[mk-app] #5182 or #5463 #4159
[mk-proof] #5539 th-lemma #5182
[mk-proof] #5518 unit-resolution #5539 #4158 #4159
[mk-app] #5519 or #2 #4063
[mk-proof] #5520 th-lemma #5519
[mk-proof] #5521 unit-resolution #5520 #8 #4063
[mk-app] #5522 or #2 #4722
[mk-proof] #5523 th-lemma #5522
[mk-proof] #5527 unit-resolution #5523 #8 #4722
[mk-app] #5528 = #4105 #4199
[mk-proof] #5529 monotonicity #1564 #5528
[mk-app] #5530 = #4199 #4742
[mk-proof] #5524 symm #5527 #5530
[mk-proof] #5525 trans* #5529 #5524 #4749
[mk-app] #5526 not #4749
[mk-app] #5532 or #5526 #5015
[mk-proof] #5533 th-lemma #5532
[mk-proof] #5540 unit-resolution #5533 #5525 #5015
[mk-app] #5535 or #5526 #4995
[mk-proof] #5536 th-lemma #5535
[mk-proof] #5537 unit-resolution #5536 #5525 #4995
[mk-proof] #5511 unit-resolution #4983 #1942 #5254
[mk-app] #5515 not #5254
[mk-app] #5516 or #5515 #5022
[mk-proof] #5510 th-lemma #5516
[mk-proof] #5517 unit-resolution #5510 #5511 #5022
[mk-app] #5512 or #5515 #5192
[mk-proof] #5513 th-lemma #5512
[mk-proof] #5514 unit-resolution #5513 #5511 #5192
[mk-app] #5505 = #1574 #1570
[mk-proof] #5506 monotonicity #1564 #5505
[mk-app] #5507 = #1570 #1574
[mk-proof] #5508 symm #5506 #5507
[mk-app] #2189 = #1569 #1574
[mk-proof] #5130 trans* #1573 #5508 #2189
[mk-app] #5502 or #2 #5269
[mk-proof] #5503 th-lemma #5502
[mk-proof] #5504 unit-resolution #5503 #8 #5269
[mk-app] #5509 = #4992 #3235
[mk-proof] #5499 monotonicity #5130 #5509
[mk-app] #5500 = #3235 #4992
[mk-proof] #5501 symm #5499 #5500
[mk-proof] #5492 symm #5504 #5531
[mk-proof] #5496 trans* #5501 #5492 #5267
[mk-app] #5497 not #5267
[mk-app] #5487 or #5497 #5185
[mk-proof] #5488 th-lemma #5487
[mk-proof] #5484 unit-resolution #5488 #5496 #5185
[mk-app] #5485 or #5497 #5186
[mk-proof] #5486 th-lemma #5485
[mk-proof] #5489 unit-resolution #5486 #5496 #5186
[mk-app] #5490 not #5531
[mk-app] #5491 or #5490 #5466
[mk-proof] #5498 th-lemma #5491
[mk-proof] #5493 unit-resolution #5498 #5492 #5466
[mk-app] #5494 or #5490 #5464
[mk-proof] #5495 th-lemma #5494
[mk-proof] #5481 unit-resolution #5495 #5492 #5464
[mk-app] #5482 or #2 #5238
[mk-proof] #5483 th-lemma #5482
[mk-proof] #5472 unit-resolution #5483 #8 #5238
[mk-app] #5478 = #5119 #5238
[mk-proof] #5479 commutativity #5478
[mk-app] #5480 = #5238 #1
[mk-proof] #5541 iff-true #5472 #5480
[mk-app] #5561 = #5119 #1
[mk-proof] #5562 trans* #5479 #5541 #5561
[mk-app] #5563 = #5561 #5119
[mk-proof] #5564 rewrite #5563
[mk-proof] #5565 mp #5562 #5564 #5119
[mk-app] #5566 not #5119
[mk-app] #5567 or #5566 #5207
[mk-proof] #5568 th-lemma #5567
[mk-proof] #5569 unit-resolution #5568 #5565 #5207
[mk-app] #5570 or #5566 #5216
[mk-proof] #5571 th-lemma #5570
[mk-proof] #5572 unit-resolution #5571 #5565 #5216
[mk-app] #5573 or #2 #5239
[mk-proof] #5574 th-lemma #5573
[mk-proof] #5575 unit-resolution #5574 #8 #5239
[mk-app] #5576 or #2 #5213
[mk-proof] #5577 th-lemma #5576
[mk-proof] #5578 unit-resolution #5577 #8 #5213
[mk-app] #5579 not #5212
[mk-app] #5580 not #5213
[mk-app] #5581 or #5283 #5579 #5580
[mk-proof] #5582 th-lemma #5581
[mk-proof] #5583 unit-resolution #5582 #5470 #5578 #5579
[mk-proof] #5584 th-lemma #5583 #5575 #5572 #5569 #5481 #5493 #5489 #5484 #5514 #5517 #5537 #5540 #5521 #5518 #2
[pop] 2 6
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 4
[push] 3
[mk-proof] #5217 asserted #5283
[mk-app] #5218 = #5283 #5283
[mk-proof] #5538 refl #5218
[pop] 1 4
[push] 3
[mk-app] #5217 not #5210
[mk-proof] #5218 asserted #5217
[inst-discovered] theory-solving 0x0 basic# ; #5217
[mk-app] #5538 = #5217 #5283
[mk-proof] #5133 rewrite #5538
[instance] 0x0 #5538
[end-of-instance]
[mk-proof] #5553 mp #5218 #5133 #5283
[begin-check] 4
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 ~ #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 rewrite #5188
[mk-proof] #5555 mp #5553 #5554 #5283
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[mk-app] #5188 = #5283 #5283
[mk-proof] #5554 refl #5188
[attach-enode] #5282 0
[attach-enode] #5283 0
[assign] #5283 justification -1: 
[mk-app] #5188 < #1503 #36
[mk-app] #5554 - #36 #1503
[mk-app] #5555 if #5188 #5554 #1503
[mk-app] #5176 - #5555 #151
[inst-discovered] theory-solving 0x0 arith# ; #5188
[mk-app] #5257 = #5188 #3233
[mk-proof] #5199 rewrite #5257
[instance] 0x0 #5257
[end-of-instance]
[mk-app] #5170 = #5188 #2
[mk-proof] #5107 trans #5199 #3190 #5170
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5554
[mk-app] #5222 = #5554 #3205
[mk-proof] #5125 rewrite #5222
[instance] 0x0 #5222
[end-of-instance]
[mk-app] #5203 = #5554 #4108
[mk-proof] #5189 trans #5125 #3152 #5203
[mk-app] #5437 if #2 #4108 #1503
[mk-app] #5439 = #5555 #5437
[mk-proof] #5440 monotonicity #5107 #5189 #5439
[inst-discovered] theory-solving 0x0 arith# ; #5437
[mk-app] #5552 = #5437 #1503
[mk-proof] #5556 rewrite #5552
[instance] 0x0 #5552
[end-of-instance]
[mk-app] #5548 = #5555 #1503
[mk-proof] #5549 trans #5440 #5556 #5548
[mk-app] #5550 - #1503 #151
[mk-app] #5551 = #5176 #5550
[mk-proof] #5544 monotonicity #5549 #5551
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5550
[mk-app] #5461 = #5550 #4048
[mk-proof] #5545 rewrite #5461
[instance] 0x0 #5461
[end-of-instance]
[mk-app] #5546 = #5176 #4048
[mk-proof] #5444 trans #5544 #5545 #5546
[mk-app] #5446 = #5176 #4037
[mk-proof] #5447 trans #5444 #4000 #5446
[mk-app] #5433 = #1503 #36
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5433
[mk-app] #5188 = #5433 #2
[mk-proof] #5257 rewrite #5188
[instance] 0x0 #5188
[end-of-instance]
[attach-enode] #5208 0
[attach-enode] #5236 0
[attach-enode] #5237 0
[attach-enode] #5238 0
[attach-meaning] #176 arith (- 1)
[attach-enode] #5119 0
[attach-enode] #5220 0
[attach-enode] #5215 0
[mk-app] #5199 or #5433 #5238
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5199
[assign] #5238 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5433
[mk-app] #5188 = #5433 #2
[mk-proof] #5257 rewrite #5188
[instance] 0x0 #5188
[end-of-instance]
[attach-enode] #5213 0
[mk-app] #5199 or #5433 #5213
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5199
[assign] #5213 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5433
[mk-app] #5188 = #5433 #2
[mk-proof] #5257 rewrite #5188
[instance] 0x0 #5188
[end-of-instance]
[attach-enode] #5239 0
[mk-app] #5199 or #5433 #5239
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5199
[assign] #5239 justification -1: true
[end-of-instance]
[assign] #5212 clause p498 (not p497)
  (<= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int) 
  (not (= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int)) 

[assign] #5119 justification -1: p500
[attach-meaning] #176 arith (- 1)
[assign] #5531 justification -1: p492
[attach-enode] #5531 0
[attach-enode] #5465 0
[assign] #5466 justification -1: p505
[assign] #5464 justification -1: p505
[assign] #5207 clause p502 (not p501)
  (<= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[assign] #5216 clause p503 (not p501)
  (>= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[decide-and-or] #2170 #2177
[push] 4
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 5
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[new-match] 0x1068e90d8 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e9110 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e9148 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e9188 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e91c8 #124 #118 #1528 ; #3402
[new-match] 0x1068e91f8 #143 #118 #1528 ; #3402
[new-match] 0x1068e9228 #237 #229 #3402 #36 ; #3403
[mk-app] #5475 * #176 #4347
[mk-app] #5476 + #3403 #5110 #5475
[mk-app] #5471 = #5476 #36
[mk-app] #5433 + #5110 #3403 #5475
[inst-discovered] theory-solving 0x0 arith# ; #5476
[mk-app] #5188 = #5476 #5433
[mk-proof] #5257 rewrite #5188
[instance] 0x0 #5188
[end-of-instance]
[mk-app] #5253 = #5433 #36
[mk-app] #5070 = #5471 #5253
[mk-proof] #5067 monotonicity #5257 #5070
[attach-meaning] #176 arith (- 1)
[mk-app] #5068 + #3402 #5120 #4347
[mk-app] #5108 = #5068 #36
[inst-discovered] theory-solving 0x0 arith# ; #5253
[mk-app] #5243 = #5253 #5108
[mk-proof] #5242 rewrite #5243
[instance] 0x0 #5243
[end-of-instance]
[mk-app] #5225 = #5471 #5108
[mk-proof] #5197 trans #5067 #5242 #5225
[mk-app] #5450 not #263
[mk-app] #5199 or #5450 #5108
[mk-app] #5170 or #5450 #5471
[mk-proof] #5107 quant-inst #5170
[mk-app] #5554 = #5170 #5199
[mk-proof] #5222 monotonicity #5197 #5554
[mk-app] #5125 = #5199 #5199
[mk-proof] #5203 rewrite #5125
[mk-proof] #5189 trans #5222 #5203 #5554
[mk-proof] #5555 mp #5107 #5189 #5199
[instance] 0x1068e90d8 #5107 ; 3
[attach-enode] #5120 3
[attach-enode] #5068 3
[attach-enode] #5108 3
[mk-app] #5437 <= #5068 #36
[mk-app] #5439 >= #5068 #36
[assign] #5108 justification -1: p21
[end-of-instance]
[mk-app] #5440 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5440
[mk-app] #5552 = #5440 #5440
[mk-proof] #5556 rewrite #5552
[instance] 0x0 #5552
[end-of-instance]
[mk-app] #5548 or #4423 #5142 #5144 #5145
[mk-app] #5549 or #4423 #5440
[mk-proof] #5176 quant-inst #5549
[mk-app] #5550 = #5549 #5548
[mk-proof] #5551 rewrite #5550
[mk-proof] #5544 mp #5176 #5551 #5548
[instance] 0x1068e9110 #5176 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5552 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5556 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5461 = #5552 #5556
[mk-proof] #5545 monotonicity #5169 #5461
[mk-app] #5546 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5556
[mk-app] #5444 = #5556 #5546
[mk-proof] #5446 rewrite #5444
[instance] 0x0 #5444
[end-of-instance]
[mk-app] #5447 = #5552 #5546
[mk-proof] #5434 trans #5545 #5446 #5447
[mk-app] #5435 not #1917
[mk-app] #5436 or #5435 #2172 #2353 #5144 #5148 #5165
[mk-app] #5441 or #5435 #5552
[mk-proof] #5442 quant-inst #5441
[mk-app] #5443 or #5435 #5546
[mk-app] #5438 = #5441 #5443
[mk-proof] #5448 monotonicity #5434 #5438
[mk-app] #5452 = #5443 #5436
[mk-proof] #5453 rewrite #5452
[mk-app] #5445 = #5441 #5436
[mk-proof] #5457 trans #5448 #5453 #5445
[mk-proof] #5458 mp #5442 #5457 #5436
[instance] 0x1068e9148 #5442 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5456 >= #3402 #36
[mk-app] #5459 = #5456 #5456
[mk-proof] #5460 refl #5459
[mk-app] #5542 or #1546 #5456
[mk-proof] #5469 quant-inst #5542
[instance] 0x1068e91c8 #5469 ; 3
[assign] #5456 justification -1: p13
[end-of-instance]
[mk-app] #5459 not #5191
[mk-app] #5460 or #5459 #2172
[mk-app] #5543 = #5460 #5460
[mk-proof] #5547 refl #5543
[mk-app] #5477 or #2307 #5459 #2172
[mk-app] #5557 or #2307 #5460
[mk-proof] #5558 quant-inst #5557
[mk-app] #5559 = #5557 #5477
[mk-proof] #5560 rewrite #5559
[mk-proof] #5281 mp #5558 #5560 #5477
[instance] 0x1068e91f8 #5558 ; 3
[attach-enode] #5191 3
[mk-app] #5284 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[mk-app] #5543 = #5196 #36
[mk-app] #5547 = #5164 #36
[mk-app] #5276 = #5543 #5547
[mk-proof] #5235 monotonicity #5206 #5276
[mk-app] #5209 not #237
[mk-app] #5274 or #5209 #5547
[mk-app] #5451 or #5209 #5543
[mk-proof] #5449 quant-inst #5451
[mk-app] #5187 = #5451 #5274
[mk-proof] #5184 monotonicity #5235 #5187
[mk-app] #5179 = #5274 #5274
[mk-proof] #5128 rewrite #5179
[mk-proof] #5126 trans #5184 #5128 #5187
[mk-proof] #5219 mp #5449 #5126 #5274
[instance] 0x1068e9228 #5449 ; 3
[attach-enode] #5547 3
[mk-app] #5211 >= #5164 #36
[assign] #5547 justification -1: p20
[end-of-instance]
[assign] #5437 clause p509 (not p508)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5439 clause p510 (not p508)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5284) clause (not p518) p517
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p515 (not p519)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5211 clause p520 (not p519)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5280 <= #4347 #36
[mk-app] #5277 >= #4347 #36
[assign] #5280 justification -1: p78
[assign] #5277 justification -1: p78
[assign] #5143 clause p512 (not p515) (not p516)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5548 #5142
[push] 6
[assign] #5142 decision axiom
[new-match] 0x1068ea1b8 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068ea1f0 #124 #118 #1529 ; #5139
[new-match] 0x1068ea220 #143 #118 #1529 ; #5139
[mk-app] #5278 or #2353 #2172 #5224
[mk-app] #5279 or #2353 #2172 #5229
[mk-app] #5214 = #5278 #5279
[mk-proof] #5272 monotonicity #5231 #5214
[mk-app] #5252 or #2172 #2353 #5229
[inst-discovered] theory-solving 0x0 basic# ; #5279
[mk-app] #5234 = #5279 #5252
[mk-proof] #5244 rewrite #5234
[instance] 0x0 #5234
[end-of-instance]
[mk-app] #5233 = #5278 #5252
[mk-proof] #5245 trans #5272 #5244 #5233
[mk-app] #5246 not #2726
[mk-app] #5241 or #5246 #2172 #2353 #5229
[mk-app] #5271 or #5246 #5278
[mk-proof] #5261 quant-inst #5271
[mk-app] #5285 or #5246 #5252
[mk-app] #5232 = #5271 #5285
[mk-proof] #5247 monotonicity #5245 #5232
[mk-app] #5248 = #5285 #5241
[mk-proof] #5249 rewrite #5248
[mk-app] #5250 = #5271 #5241
[mk-proof] #5251 trans #5247 #5249 #5250
[mk-proof] #5270 mp #5261 #5251 #5241
[instance] 0x1068ea1b8 #5261 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5262 <= #5226 #36
[mk-app] #5286 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5287 >= #5139 #36
[mk-app] #5288 = #5287 #5287
[mk-proof] #5275 refl #5288
[mk-app] #5106 or #1546 #5287
[mk-proof] #5178 quant-inst #5106
[instance] 0x1068ea1f0 #5178 ; 4
[assign] #5287 justification -1: p13
[end-of-instance]
[mk-app] #5288 not #5255
[mk-app] #5275 or #5288 #5259
[mk-app] #5180 = #5275 #5275
[mk-proof] #5221 refl #5180
[mk-app] #5069 or #2307 #5288 #5259
[mk-app] #5063 or #2307 #5275
[mk-proof] #5121 quant-inst #5063
[mk-app] #5152 = #5063 #5069
[mk-proof] #5153 rewrite #5152
[mk-proof] #5134 mp #5121 #5153 #5069
[instance] 0x1068ea220 #5121 ; 4
[attach-enode] #5255 4
[mk-app] #5154 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5262 clause p524 (not p523)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5286 clause p525 (not p523)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5211)
[resolve-lit] 0 (not #5262)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5262)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[mk-proof] #5180 hypothesis #5142
[mk-proof] #5221 hypothesis #2294
[mk-proof] #5173 hypothesis #2177
[mk-proof] #5174 unit-resolution #5270 #2731 #5173 #5221 #5229
[mk-app] #5462 not #5229
[mk-app] #5177 or #5462 #5262
[mk-proof] #5455 th-lemma #5177
[mk-proof] #5467 unit-resolution #5455 #5174 #5262
[mk-app] #5454 not #2348
[mk-app] #5473 or #5454 #2136
[mk-proof] #5468 th-lemma #5473
[mk-proof] #5534 unit-resolution #5468 #2186 #2136
[mk-proof] #5273 unit-resolution #5219 #2853 #5547
[mk-app] #5240 not #5547
[mk-app] #5175 or #5240 #5211
[mk-proof] #5193 th-lemma #5175
[mk-proof] #5266 unit-resolution #5193 #5273 #5211
[mk-proof] #5474 th-lemma #5266 #5534 #5467 #5180 #2
[mk-app] #5585 not #5142
[mk-app] #5586 or #5585 #2353 #2172
[mk-proof] #5587 lemma #5474 #5586
[conflict] (not #5142) #2353 #2172
[pop] 1 7
[assign] (not #5142) clause (not p511) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p513 p511 (not p512)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068ea1a0 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068ea1d8 #124 #118 #1529 ; #5139
[new-match] 0x1068ea208 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5279
[instance] 0x0 #5234
[end-of-instance]
[instance] 0x1068ea1a0 #5261 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5106 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5178 = #5287 #5287
[mk-proof] #5063 refl #5178
[mk-app] #5121 or #1546 #5287
[mk-proof] #5069 quant-inst #5121
[instance] 0x1068ea1d8 #5069 ; 4
[assign] #5287 justification -1: p13
[end-of-instance]
[mk-app] #5178 = #5275 #5275
[mk-proof] #5063 refl #5178
[mk-app] #5152 or #2307 #5288 #5259
[mk-app] #5153 or #2307 #5275
[mk-proof] #5134 quant-inst #5153
[mk-app] #5286 = #5153 #5152
[mk-proof] #5154 rewrite #5286
[mk-proof] #5579 mp #5134 #5154 #5152
[instance] 0x1068ea208 #5134 ; 4
[attach-enode] #5255 4
[mk-app] #5580 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5262 clause p524 (not p523)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5106 clause p525 (not p523)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #5580) clause (not p528) (not p515) (not p516) p511
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p527) p528
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #1555 Seq<Int>!val!0
[mk-app] #2290 $Ref!val!0
[mk-app] #1556 $Ref!val!1
[mk-app] #5431 Ptr32!val!0
[mk-app] #1557 Ptr32!val!1
[mk-app] #2300 Seq<Int>!val!1
[mk-app] #5264 Seq<Int>!val!2
[mk-app] #5138 Seq<Int>!val!3
[mk-app] #2343 Int
[attach-meaning] #2343 arith 2283
[attach-meaning] #4108 arith (- 4)
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #2292 Ptr32!val!2
[mk-app] #2321 Ptr32!val!3
[attach-meaning] #4108 arith (- 4)
[mk-app] #2288 Ptr32!val!4
[attach-meaning] #3722 arith 16
[mk-app] #2315 Ptr32!val!5
[attach-meaning] #3161 arith 20
[mk-app] #2316 Ptr32!val!6
[attach-meaning] #4382 arith 24
[mk-app] #2317 Ptr32!val!7
[attach-meaning] #4389 arith 28
[mk-app] #2193 Ptr32!val!8
[attach-meaning] #3291 arith 32
[mk-app] #2318 Ptr32!val!9
[attach-meaning] #3216 arith 36
[mk-app] #2188 Ptr32!val!10
[attach-meaning] #4684 arith 40
[mk-app] #2344 Ptr32!val!11
[attach-meaning] #4840 arith 44
[mk-app] #2356 Ptr32!val!12
[attach-meaning] #4996 arith 48
[mk-app] #2339 Ptr32!val!13
[mk-app] #2341 Int
[attach-meaning] #2341 arith 52
[mk-app] #2185 Ptr32!val!14
[mk-app] #5290 Int
[attach-meaning] #5290 arith 56
[mk-app] #5292 Ptr32!val!15
[mk-app] #5294 Int
[attach-meaning] #5294 arith 60
[attach-meaning] #3722 arith 16
[mk-app] #5296 Ptr32!val!16
[mk-app] #5298 Int
[attach-meaning] #5298 arith 64
[attach-meaning] #3632 arith 17
[mk-app] #5300 Ptr32!val!17
[mk-app] #5302 Int
[attach-meaning] #5302 arith 68
[attach-meaning] #3800 arith 18
[mk-app] #5304 Ptr32!val!18
[mk-app] #5306 Int
[attach-meaning] #5306 arith 72
[attach-meaning] #4573 arith 19
[mk-app] #5308 Ptr32!val!19
[mk-app] #5310 Int
[attach-meaning] #5310 arith 76
[attach-meaning] #3161 arith 20
[mk-app] #5312 Ptr32!val!20
[mk-app] #5314 Int
[attach-meaning] #5314 arith 80
[attach-meaning] #4096 arith 21
[mk-app] #5316 Ptr32!val!21
[mk-app] #5318 Int
[attach-meaning] #5318 arith 84
[attach-meaning] #3898 arith 22
[mk-app] #5320 Ptr32!val!22
[mk-app] #5322 Int
[attach-meaning] #5322 arith 88
[attach-meaning] #3432 arith 23
[mk-app] #5324 Ptr32!val!23
[mk-app] #5326 Int
[attach-meaning] #5326 arith 92
[attach-meaning] #4382 arith 24
[mk-app] #5328 Ptr32!val!24
[mk-app] #5330 Int
[attach-meaning] #5330 arith 96
[attach-meaning] #4548 arith 25
[mk-app] #5332 Ptr32!val!25
[mk-app] #5334 Int
[attach-meaning] #5334 arith 100
[attach-meaning] #2916 arith 26
[mk-app] #5336 Ptr32!val!26
[mk-app] #5338 Int
[attach-meaning] #5338 arith 104
[attach-meaning] #3947 arith 27
[mk-app] #5340 Ptr32!val!27
[mk-app] #5342 Int
[attach-meaning] #5342 arith 108
[attach-meaning] #4389 arith 28
[mk-app] #5344 Ptr32!val!28
[mk-app] #5346 Int
[attach-meaning] #5346 arith 112
[attach-meaning] #3887 arith 29
[mk-app] #5348 Ptr32!val!29
[mk-app] #5350 Int
[attach-meaning] #5350 arith 116
[attach-meaning] #3867 arith 30
[mk-app] #5352 Ptr32!val!30
[mk-app] #5354 Int
[attach-meaning] #5354 arith 120
[attach-meaning] #3730 arith 31
[mk-app] #5356 Ptr32!val!31
[mk-app] #5358 Int
[attach-meaning] #5358 arith 124
[attach-meaning] #3291 arith 32
[mk-app] #5359 Ptr32!val!32
[mk-app] #2291 Int
[attach-meaning] #2291 arith 128
[attach-meaning] #4187 arith 33
[mk-app] #2192 Ptr32!val!33
[mk-app] #2340 Int
[attach-meaning] #2340 arith 132
[attach-meaning] #3677 arith 34
[mk-app] #2342 Ptr32!val!34
[mk-app] #5289 Int
[attach-meaning] #5289 arith 136
[attach-meaning] #3981 arith 35
[mk-app] #5291 Ptr32!val!35
[mk-app] #5293 Int
[attach-meaning] #5293 arith 140
[attach-meaning] #3216 arith 36
[mk-app] #5295 Ptr32!val!36
[mk-app] #5297 Int
[attach-meaning] #5297 arith 144
[attach-meaning] #4506 arith 37
[mk-app] #5299 Ptr32!val!37
[mk-app] #5301 Int
[attach-meaning] #5301 arith 148
[attach-meaning] #4606 arith 38
[mk-app] #5303 Ptr32!val!38
[mk-app] #5305 Int
[attach-meaning] #5305 arith 152
[attach-meaning] #4645 arith 39
[mk-app] #5307 Ptr32!val!39
[mk-app] #5309 Int
[attach-meaning] #5309 arith 156
[attach-meaning] #4684 arith 40
[mk-app] #5311 Ptr32!val!40
[mk-app] #5313 Int
[attach-meaning] #5313 arith 160
[attach-meaning] #4723 arith 41
[mk-app] #5315 Ptr32!val!41
[mk-app] #5317 Int
[attach-meaning] #5317 arith 164
[attach-meaning] #4762 arith 42
[mk-app] #5319 Ptr32!val!42
[mk-app] #5321 Int
[attach-meaning] #5321 arith 168
[attach-meaning] #4801 arith 43
[mk-app] #5327 Ptr32!val!43
[mk-app] #5331 Int
[attach-meaning] #5331 arith 172
[attach-meaning] #4840 arith 44
[mk-app] #5335 Ptr32!val!44
[mk-app] #5339 Int
[attach-meaning] #5339 arith 176
[attach-meaning] #4879 arith 45
[mk-app] #5343 Ptr32!val!45
[mk-app] #5347 Int
[attach-meaning] #5347 arith 180
[attach-meaning] #4918 arith 46
[mk-app] #5351 Ptr32!val!46
[mk-app] #5355 Int
[attach-meaning] #5355 arith 184
[attach-meaning] #4957 arith 47
[mk-app] #5360 Ptr32!val!47
[mk-app] #5362 Int
[attach-meaning] #5362 arith 188
[attach-meaning] #4996 arith 48
[mk-app] #5364 Ptr32!val!48
[mk-app] #5366 Int
[attach-meaning] #5366 arith 192
[attach-meaning] #5035 arith 49
[mk-app] #5368 Ptr32!val!49
[mk-app] #5370 Int
[attach-meaning] #5370 arith 196
[attach-meaning] #5074 arith 50
[mk-app] #5372 Ptr32!val!50
[mk-app] #5374 Ptr32!val!51
[mk-app] #5376 Int
[attach-meaning] #5376 arith 200
[mk-app] #5378 Int
[attach-meaning] #5378 arith 2284
[attach-meaning] #3722 arith 16
[attach-meaning] #3632 arith 17
[attach-meaning] #3800 arith 18
[attach-meaning] #4573 arith 19
[attach-meaning] #3161 arith 20
[attach-meaning] #4096 arith 21
[attach-meaning] #3898 arith 22
[attach-meaning] #3432 arith 23
[attach-meaning] #4382 arith 24
[attach-meaning] #4548 arith 25
[attach-meaning] #2916 arith 26
[attach-meaning] #3947 arith 27
[attach-meaning] #4389 arith 28
[attach-meaning] #3887 arith 29
[attach-meaning] #3867 arith 30
[attach-meaning] #3730 arith 31
[attach-meaning] #3291 arith 32
[attach-meaning] #4187 arith 33
[attach-meaning] #3677 arith 34
[attach-meaning] #3981 arith 35
[attach-meaning] #3216 arith 36
[attach-meaning] #4506 arith 37
[attach-meaning] #4606 arith 38
[attach-meaning] #4645 arith 39
[attach-meaning] #4684 arith 40
[attach-meaning] #4723 arith 41
[attach-meaning] #4762 arith 42
[attach-meaning] #4801 arith 43
[attach-meaning] #4840 arith 44
[attach-meaning] #4879 arith 45
[attach-meaning] #4918 arith 46
[attach-meaning] #4957 arith 47
[attach-meaning] #4996 arith 48
[attach-meaning] #5035 arith 49
[attach-meaning] #5074 arith 50
[mk-app] #5380 Int
[attach-meaning] #5380 arith 51
[attach-meaning] #2341 arith 52
[mk-app] #5382 Int
[attach-meaning] #5382 arith 53
[mk-app] #5384 Int
[attach-meaning] #5384 arith 54
[mk-app] #5386 Int
[attach-meaning] #5386 arith 55
[attach-meaning] #5290 arith 56
[mk-app] #5388 Int
[attach-meaning] #5388 arith 57
[mk-app] #5390 Int
[attach-meaning] #5390 arith 58
[mk-app] #5392 Int
[attach-meaning] #5392 arith 59
[attach-meaning] #5294 arith 60
[mk-app] #5394 Int
[attach-meaning] #5394 arith 61
[mk-app] #5396 Int
[attach-meaning] #5396 arith 62
[mk-app] #5398 Int
[attach-meaning] #5398 arith 63
[attach-meaning] #5298 arith 64
[mk-app] #5400 Int
[attach-meaning] #5400 arith 65
[mk-app] #5402 Int
[attach-meaning] #5402 arith 66
[mk-app] #5404 Int
[attach-meaning] #5404 arith 67
[attach-meaning] #5302 arith 68
[mk-app] #5406 Int
[attach-meaning] #5406 arith 69
[mk-app] #5408 Int
[attach-meaning] #5408 arith 70
[mk-app] #5410 Int
[attach-meaning] #5410 arith 71
[attach-meaning] #5306 arith 72
[mk-app] #5412 Int
[attach-meaning] #5412 arith 73
[mk-app] #5414 Int
[attach-meaning] #5414 arith 74
[mk-app] #5416 Int
[attach-meaning] #5416 arith 75
[attach-meaning] #5310 arith 76
[mk-app] #5429 Int
[attach-meaning] #5429 arith 77
[mk-app] #5430 Int
[attach-meaning] #5430 arith 78
[mk-app] #5323 Int
[attach-meaning] #5323 arith 79
[attach-meaning] #5314 arith 80
[mk-app] #5325 Int
[attach-meaning] #5325 arith 81
[mk-app] #5329 Int
[attach-meaning] #5329 arith 82
[mk-app] #5333 Int
[attach-meaning] #5333 arith 83
[attach-meaning] #5318 arith 84
[mk-app] #5337 Int
[attach-meaning] #5337 arith 85
[mk-app] #5341 Int
[attach-meaning] #5341 arith 86
[mk-app] #5345 Int
[attach-meaning] #5345 arith 87
[attach-meaning] #5322 arith 88
[mk-app] #5349 Int
[attach-meaning] #5349 arith 89
[mk-app] #5353 Int
[attach-meaning] #5353 arith 90
[mk-app] #5357 Int
[attach-meaning] #5357 arith 91
[attach-meaning] #5326 arith 92
[mk-app] #5361 Int
[attach-meaning] #5361 arith 93
[mk-app] #5363 Int
[attach-meaning] #5363 arith 94
[mk-app] #5365 Int
[attach-meaning] #5365 arith 95
[attach-meaning] #5330 arith 96
[mk-app] #5367 Int
[attach-meaning] #5367 arith 97
[mk-app] #5369 Int
[attach-meaning] #5369 arith 98
[mk-app] #5371 Int
[attach-meaning] #5371 arith 99
[attach-meaning] #5334 arith 100
[mk-app] #5373 Int
[attach-meaning] #5373 arith 101
[mk-app] #5375 Int
[attach-meaning] #5375 arith 102
[mk-app] #5377 Int
[attach-meaning] #5377 arith 103
[attach-meaning] #5338 arith 104
[mk-app] #5379 Int
[attach-meaning] #5379 arith 105
[mk-app] #5381 Int
[attach-meaning] #5381 arith 106
[mk-app] #5383 Int
[attach-meaning] #5383 arith 107
[attach-meaning] #5342 arith 108
[mk-app] #5385 Int
[attach-meaning] #5385 arith 109
[mk-app] #5387 Int
[attach-meaning] #5387 arith 110
[mk-app] #5389 Int
[attach-meaning] #5389 arith 111
[attach-meaning] #5346 arith 112
[mk-app] #5391 Int
[attach-meaning] #5391 arith 113
[mk-app] #5393 Int
[attach-meaning] #5393 arith 114
[mk-app] #5395 Int
[attach-meaning] #5395 arith 115
[attach-meaning] #5350 arith 116
[mk-app] #5397 Int
[attach-meaning] #5397 arith 117
[mk-app] #5399 Int
[attach-meaning] #5399 arith 118
[mk-app] #5401 Int
[attach-meaning] #5401 arith 119
[attach-meaning] #5354 arith 120
[mk-app] #5403 Int
[attach-meaning] #5403 arith 121
[mk-app] #5405 Int
[attach-meaning] #5405 arith 122
[mk-app] #5407 Int
[attach-meaning] #5407 arith 123
[attach-meaning] #5358 arith 124
[mk-app] #5409 Int
[attach-meaning] #5409 arith 125
[mk-app] #5411 Int
[attach-meaning] #5411 arith 126
[mk-app] #5413 Int
[attach-meaning] #5413 arith 127
[attach-meaning] #2291 arith 128
[mk-app] #5415 Int
[attach-meaning] #5415 arith 129
[mk-app] #5417 Int
[attach-meaning] #5417 arith 130
[mk-app] #5418 Int
[attach-meaning] #5418 arith 131
[attach-meaning] #2340 arith 132
[mk-app] #5419 Int
[attach-meaning] #5419 arith 133
[mk-app] #5420 Int
[attach-meaning] #5420 arith 134
[mk-app] #5421 Int
[attach-meaning] #5421 arith 135
[attach-meaning] #5289 arith 136
[mk-app] #5422 Int
[attach-meaning] #5422 arith 137
[mk-app] #5423 Int
[attach-meaning] #5423 arith 138
[mk-app] #5424 Int
[attach-meaning] #5424 arith 139
[attach-meaning] #5293 arith 140
[mk-app] #5425 Int
[attach-meaning] #5425 arith 141
[mk-app] #5426 Int
[attach-meaning] #5426 arith 142
[mk-app] #5427 Int
[attach-meaning] #5427 arith 143
[attach-meaning] #5297 arith 144
[mk-app] #5428 Int
[attach-meaning] #5428 arith 145
[mk-app] #5258 Int
[attach-meaning] #5258 arith 146
[mk-app] #5178 Int
[attach-meaning] #5178 arith 147
[attach-meaning] #5301 arith 148
[mk-app] #5063 Int
[attach-meaning] #5063 arith 149
[mk-app] #5581 Int
[attach-meaning] #5581 arith 150
[pop] 2 6
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 4
[push] 3
[mk-app] #5283 = #5282 #36
[mk-app] #5210 not #5283
[mk-proof] #5217 asserted #5210
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[begin-check] 4
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5283 #2
[mk-proof] #5538 iff-false #5217 #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5283 #2
[mk-proof] #5538 iff-false #5217 #5218
[mk-app] #5218 ~ #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 rewrite #5218
[mk-proof] #5133 mp #5217 #5538 #5210
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[mk-app] #5218 = #5210 #5210
[mk-proof] #5538 refl #5218
[attach-enode] #5282 0
[attach-enode] #5283 0
[mk-app] #5218 <= #5282 #36
[mk-app] #5538 >= #5282 #36
[assign] (not #5283) justification -1: 
[mk-app] #5133 div #4992 #1503
[mk-app] #5553 < #1503 #36
[mk-app] #5212 - #36 #1503
[mk-app] #5213 if #5553 #5212 #1503
[mk-app] #5208 - #5213 #151
[inst-discovered] theory-solving 0x0 arith# ; #5553
[mk-app] #5236 = #5553 #3233
[mk-proof] #5237 rewrite #5236
[instance] 0x0 #5236
[end-of-instance]
[mk-app] #5238 = #5553 #2
[mk-proof] #5119 trans #5237 #3190 #5238
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5212
[mk-app] #5220 = #5212 #3205
[mk-proof] #5215 rewrite #5220
[instance] 0x0 #5220
[end-of-instance]
[mk-app] #5207 = #5212 #4108
[mk-proof] #5216 trans #5215 #3152 #5207
[mk-app] #5239 if #2 #4108 #1503
[mk-app] #5531 = #5213 #5239
[mk-proof] #5465 monotonicity #5119 #5216 #5531
[inst-discovered] theory-solving 0x0 arith# ; #5239
[mk-app] #5466 = #5239 #1503
[mk-proof] #5464 rewrite #5466
[instance] 0x0 #5466
[end-of-instance]
[mk-app] #5580 = #5213 #1503
[mk-proof] #5450 trans #5465 #5464 #5580
[mk-app] #5170 - #1503 #151
[mk-app] #5107 = #5208 #5170
[mk-proof] #5433 monotonicity #5450 #5107
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5170
[mk-app] #5188 = #5170 #4048
[mk-proof] #5257 rewrite #5188
[instance] 0x0 #5188
[end-of-instance]
[mk-app] #5253 = #5208 #4048
[mk-proof] #5070 trans #5433 #5257 #5253
[mk-app] #5067 = #5208 #4037
[mk-proof] #5068 trans #5070 #4000 #5067
[mk-app] #5108 = #1503 #36
[mk-app] #5243 * #1503 #5133
[mk-app] #5242 + #5243 #5282
[mk-app] #5225 = #5242 #4992
[mk-app] #5197 <= #5282 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5108
[mk-app] #5553 = #5108 #2
[mk-proof] #5236 rewrite #5553
[instance] 0x0 #5553
[end-of-instance]
[attach-enode] #5133 0
[attach-enode] #5243 0
[attach-enode] #5242 0
[attach-enode] #5225 0
[mk-app] #5237 = #4992 #5242
[attach-meaning] #176 arith (- 1)
[mk-app] #5238 * #176 #5242
[mk-app] #5119 + #4992 #5238
[mk-app] #5212 <= #5119 #36
[mk-app] #5220 >= #5119 #36
[attach-enode] #5237 0
[attach-enode] #5238 0
[attach-enode] #5119 0
[mk-app] #5215 or #5108 #5225
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5215
[assign] #5225 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5108
[mk-app] #5553 = #5108 #2
[mk-proof] #5236 rewrite #5553
[instance] 0x0 #5553
[end-of-instance]
[attach-enode] #5538 0
[mk-app] #5215 or #5108 #5538
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5215
[assign] #5538 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5108
[mk-app] #5553 = #5108 #2
[mk-proof] #5236 rewrite #5553
[instance] 0x0 #5553
[end-of-instance]
[attach-enode] #5197 0
[mk-app] #5215 or #5108 #5197
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5215
[assign] #5197 justification -1: true
[end-of-instance]
[mk-app] #5215 = #5283 #2
[mk-proof] #5207 iff-false #5217 #5215
[assign] (not #5218) clause (not p498) p497 (not p499)
  (not (<= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int)) 
  (= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int) 
  (not (>= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int)) 

[assign] #5237 justification -1: p500
[mk-app] #5288 = #4992 #5432
[attach-meaning] #176 arith (- 1)
[mk-app] #5275 + #4992 #5268
[mk-app] #5287 <= #5275 #36
[mk-app] #5459 >= #5275 #36
[assign] #5288 justification -1: p492
[attach-enode] #5288 0
[attach-enode] #5275 0
[assign] #5287 justification -1: p505
[assign] #5459 justification -1: p505
[assign] #5212 clause p502 (not p501)
  (<= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[assign] #5220 clause p503 (not p501)
  (>= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[decide-and-or] #2170 #2177
[push] 4
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 5
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[new-match] 0x1068e90a8 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e90e0 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e9118 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e9158 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e9198 #124 #118 #1528 ; #3402
[new-match] 0x1068e91c8 #143 #118 #1528 ; #3402
[new-match] 0x1068e91f8 #237 #229 #3402 #36 ; #3403
[mk-app] #5460 * #176 #4347
[mk-app] #5456 + #3403 #5110 #5460
[mk-app] #5552 = #5456 #36
[mk-app] #5108 + #5110 #3403 #5460
[inst-discovered] theory-solving 0x0 arith# ; #5456
[mk-app] #5553 = #5456 #5108
[mk-proof] #5236 rewrite #5553
[instance] 0x0 #5553
[end-of-instance]
[mk-app] #5440 = #5108 #36
[mk-app] #5475 = #5552 #5440
[mk-proof] #5476 monotonicity #5236 #5475
[attach-meaning] #176 arith (- 1)
[mk-app] #5471 + #3402 #5120 #4347
[mk-app] #5216 = #5471 #36
[inst-discovered] theory-solving 0x0 arith# ; #5440
[mk-app] #5213 = #5440 #5216
[mk-proof] #5239 rewrite #5213
[instance] 0x0 #5213
[end-of-instance]
[mk-app] #5531 = #5552 #5216
[mk-proof] #5465 trans #5476 #5239 #5531
[mk-app] #5466 not #263
[mk-app] #5464 or #5466 #5216
[mk-app] #5580 or #5466 #5552
[mk-proof] #5450 quant-inst #5580
[mk-app] #5208 = #5580 #5464
[mk-proof] #5170 monotonicity #5465 #5208
[mk-app] #5107 = #5464 #5464
[mk-proof] #5433 rewrite #5107
[mk-proof] #5188 trans #5170 #5433 #5208
[mk-proof] #5257 mp #5450 #5188 #5464
[instance] 0x1068e90a8 #5450 ; 3
[attach-enode] #5120 3
[attach-enode] #5471 3
[attach-enode] #5216 3
[mk-app] #5253 <= #5471 #36
[mk-app] #5070 >= #5471 #36
[assign] #5216 justification -1: p21
[end-of-instance]
[mk-app] #5067 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5067
[mk-app] #5068 = #5067 #5067
[mk-proof] #5199 rewrite #5068
[instance] 0x0 #5068
[end-of-instance]
[mk-app] #5554 or #4423 #5142 #5144 #5145
[mk-app] #5222 or #4423 #5067
[mk-proof] #5125 quant-inst #5222
[mk-app] #5203 = #5222 #5554
[mk-proof] #5189 rewrite #5203
[mk-proof] #5555 mp #5125 #5189 #5554
[instance] 0x1068e90e0 #5125 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5068 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5199 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5549 = #5068 #5199
[mk-proof] #5176 monotonicity #5169 #5549
[mk-app] #5548 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5199
[mk-app] #5550 = #5199 #5548
[mk-proof] #5551 rewrite #5550
[instance] 0x0 #5550
[end-of-instance]
[mk-app] #5544 = #5068 #5548
[mk-proof] #5435 trans #5176 #5551 #5544
[mk-app] #5441 not #1917
[mk-app] #5442 or #5441 #2172 #2353 #5144 #5148 #5165
[mk-app] #5556 or #5441 #5068
[mk-proof] #5461 quant-inst #5556
[mk-app] #5545 or #5441 #5548
[mk-app] #5546 = #5556 #5545
[mk-proof] #5444 monotonicity #5435 #5546
[mk-app] #5446 = #5545 #5442
[mk-proof] #5447 rewrite #5446
[mk-app] #5434 = #5556 #5442
[mk-proof] #5443 trans #5444 #5447 #5434
[mk-proof] #5438 mp #5461 #5443 #5442
[instance] 0x1068e9118 #5461 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5448 >= #3402 #36
[mk-app] #5436 = #5448 #5448
[mk-proof] #5452 refl #5436
[mk-app] #5453 or #1546 #5448
[mk-proof] #5445 quant-inst #5453
[instance] 0x1068e9198 #5445 ; 3
[assign] #5448 justification -1: p13
[end-of-instance]
[mk-app] #5436 not #5191
[mk-app] #5452 or #5436 #2172
[mk-app] #5457 = #5452 #5452
[mk-proof] #5458 refl #5457
[mk-app] #5542 or #2307 #5436 #2172
[mk-app] #5469 or #2307 #5452
[mk-proof] #5557 quant-inst #5469
[mk-app] #5558 = #5469 #5542
[mk-proof] #5477 rewrite #5558
[mk-proof] #5559 mp #5557 #5477 #5542
[instance] 0x1068e91c8 #5557 ; 3
[attach-enode] #5191 3
[mk-app] #5560 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[instance] 0x1068e91f8 #5449 ; 3
[attach-enode] #5547 3
[assign] #5547 justification -1: p20
[end-of-instance]
[assign] #5253 clause p509 (not p508)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5070 clause p510 (not p508)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5560) clause (not p518) p517
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p515 (not p519)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5211 clause p520 (not p519)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5457 <= #4347 #36
[mk-app] #5458 >= #4347 #36
[assign] #5457 justification -1: p78
[assign] #5458 justification -1: p78
[assign] #5143 clause p512 (not p515) (not p516)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5554 #5142
[push] 6
[assign] #5142 decision axiom
[new-match] 0x1068ea188 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068ea1c0 #124 #118 #1529 ; #5139
[new-match] 0x1068ea1f0 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5279
[instance] 0x0 #5234
[end-of-instance]
[instance] 0x1068ea188 #5261 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5281 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5121 >= #5139 #36
[mk-app] #5069 = #5121 #5121
[mk-proof] #5153 refl #5069
[mk-app] #5134 or #1546 #5121
[mk-proof] #5152 quant-inst #5134
[instance] 0x1068ea1c0 #5152 ; 4
[assign] #5121 justification -1: p13
[end-of-instance]
[mk-app] #5069 not #5255
[mk-app] #5153 or #5069 #5259
[mk-app] #5286 = #5153 #5153
[mk-proof] #5154 refl #5286
[mk-app] #5579 or #2307 #5069 #5259
[mk-app] #5437 or #2307 #5153
[mk-proof] #5439 quant-inst #5437
[mk-app] #5284 = #5437 #5579
[mk-proof] #5280 rewrite #5284
[mk-proof] #5277 mp #5439 #5280 #5579
[instance] 0x1068ea1f0 #5439 ; 4
[attach-enode] #5255 4
[mk-app] #5106 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5262 clause p524 (not p523)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5281 clause p525 (not p523)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5211)
[resolve-lit] 0 (not #5262)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5262)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[conflict] (not #5142) #2353 #2172
[pop] 1 7
[assign] (not #5142) clause (not p511) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p513 p511 (not p512)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068ea170 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068ea1a8 #124 #118 #1529 ; #5139
[new-match] 0x1068ea1d8 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5279
[instance] 0x0 #5234
[end-of-instance]
[instance] 0x1068ea170 #5261 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5134 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5152 = #5121 #5121
[mk-proof] #5437 refl #5152
[mk-app] #5439 or #1546 #5121
[mk-proof] #5579 quant-inst #5439
[instance] 0x1068ea1a8 #5579 ; 4
[assign] #5121 justification -1: p13
[end-of-instance]
[mk-app] #5152 = #5153 #5153
[mk-proof] #5437 refl #5152
[mk-app] #5284 or #2307 #5069 #5259
[mk-app] #5280 or #2307 #5153
[mk-proof] #5277 quant-inst #5280
[mk-app] #5281 = #5280 #5284
[mk-proof] #5106 rewrite #5281
[mk-proof] #5286 mp #5277 #5106 #5284
[instance] 0x1068ea1d8 #5277 ; 4
[attach-enode] #5255 4
[mk-app] #5154 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5262 clause p524 (not p523)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5134 clause p525 (not p523)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #5154) clause (not p528) (not p515) (not p516) p511
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p527) p528
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #5152 >= #5133 #36
[mk-app] #5437 not #5152
[mk-app] #5582 or #5152 #5437
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5582
[end-of-instance]
[push] 6
[assign] (not #5152) decision axiom
[mk-app] #5437 not #4210
[mk-app] #5582 or #5437 #4159
[mk-proof] #5470 th-lemma #5582
[mk-proof] #5576 unit-resolution #5470 #4158 #4159
[mk-app] #5577 or #2 #4063
[mk-proof] #5578 th-lemma #5577
[mk-proof] #5583 unit-resolution #5578 #8 #4063
[mk-app] #5573 or #2 #4722
[mk-proof] #5574 th-lemma #5573
[mk-proof] #5575 unit-resolution #5574 #8 #4722
[mk-app] #5566 = #4105 #4199
[mk-proof] #5570 monotonicity #1564 #5566
[mk-app] #5571 = #4199 #4742
[mk-proof] #5478 symm #5575 #5571
[mk-proof] #5479 trans* #5570 #5478 #4749
[mk-app] #5482 not #4749
[mk-app] #5483 or #5482 #5015
[mk-proof] #5472 th-lemma #5483
[mk-proof] #5480 unit-resolution #5472 #5479 #5015
[mk-app] #5541 or #5482 #4995
[mk-proof] #5561 th-lemma #5541
[mk-proof] #5562 unit-resolution #5561 #5479 #4995
[mk-proof] #5563 unit-resolution #4983 #1942 #5254
[mk-app] #5564 not #5254
[mk-app] #5565 or #5564 #5022
[mk-proof] #5572 th-lemma #5565
[mk-proof] #5567 unit-resolution #5572 #5563 #5022
[mk-app] #5568 or #5564 #5192
[mk-proof] #5569 th-lemma #5568
[mk-proof] #5490 unit-resolution #5569 #5563 #5192
[mk-app] #5494 = #1574 #1570
[mk-proof] #5495 monotonicity #1564 #5494
[mk-app] #5502 = #1570 #1574
[mk-proof] #5503 symm #5495 #5502
[mk-app] #5504 = #1569 #1574
[mk-proof] #5492 trans* #1573 #5503 #5504
[mk-app] #5481 or #2 #5269
[mk-proof] #5491 th-lemma #5481
[mk-proof] #5498 unit-resolution #5491 #8 #5269
[mk-app] #5493 = #4992 #3235
[mk-proof] #5497 monotonicity #5492 #5493
[mk-app] #5485 = #3235 #4992
[mk-proof] #5486 symm #5497 #5485
[mk-proof] #5505 symm #5498 #5288
[mk-proof] #5506 trans* #5486 #5505 #5267
[mk-app] #5507 not #5267
[mk-app] #5508 or #5507 #5185
[mk-proof] #2189 th-lemma #5508
[mk-proof] #5130 unit-resolution #2189 #5506 #5185
[mk-app] #5509 or #5507 #5186
[mk-proof] #5499 th-lemma #5509
[mk-proof] #5500 unit-resolution #5499 #5506 #5186
[mk-app] #5501 not #5288
[mk-app] #5496 or #5501 #5287
[mk-proof] #5489 th-lemma #5496
[mk-proof] #5487 unit-resolution #5489 #5505 #5287
[mk-app] #5488 or #5501 #5459
[mk-proof] #5484 th-lemma #5488
[mk-proof] #5515 unit-resolution #5484 #5505 #5459
[mk-app] #5512 or #2 #5225
[mk-proof] #5513 th-lemma #5512
[mk-proof] #5511 unit-resolution #5513 #8 #5225
[mk-app] #5514 = #5237 #5225
[mk-proof] #5516 commutativity #5514
[mk-app] #5510 = #5225 #1
[mk-proof] #5517 iff-true #5511 #5510
[mk-app] #5526 = #5237 #1
[mk-proof] #5535 trans* #5516 #5517 #5526
[mk-app] #5536 = #5526 #5237
[mk-proof] #5528 rewrite #5536
[mk-proof] #5529 mp #5535 #5528 #5237
[mk-app] #5522 not #5237
[mk-app] #5523 or #5522 #5212
[mk-proof] #5527 th-lemma #5523
[mk-proof] #5530 unit-resolution #5527 #5529 #5212
[mk-app] #5524 or #5522 #5220
[mk-proof] #5525 th-lemma #5524
[mk-proof] #5537 unit-resolution #5525 #5529 #5220
[mk-app] #5532 or #2 #5197
[mk-proof] #5533 th-lemma #5532
[mk-proof] #5540 unit-resolution #5533 #8 #5197
[mk-app] #5519 or #2 #5538
[mk-proof] #5520 th-lemma #5519
[mk-proof] #5521 unit-resolution #5520 #8 #5538
[mk-app] #5463 not #5218
[mk-app] #5182 not #5538
[mk-app] #5539 or #5283 #5463 #5182
[mk-proof] #5518 th-lemma #5539
[mk-proof] #5584 unit-resolution #5518 #5217 #5521 #5463
[mk-proof] #5588 th-lemma #5584 #5540 #5537 #5530 #5515 #5487 #5500 #5130 #5490 #5567 #5562 #5480 #5583 #5576 #2
[pop] 3 7
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 4
[push] 3
[mk-proof] #5215 asserted #5283
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 ~ #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 rewrite #5207
[mk-proof] #5547 mp #5215 #5154 #5283
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[mk-app] #5207 = #5283 #5283
[mk-proof] #5154 refl #5207
[attach-enode] #5282 0
[attach-enode] #5283 0
[assign] #5283 justification -1: 
[mk-app] #5207 < #1503 #36
[mk-app] #5154 - #36 #1503
[mk-app] #5547 if #5207 #5154 #1503
[mk-app] #5240 - #5547 #151
[inst-discovered] theory-solving 0x0 arith# ; #5207
[mk-app] #5211 = #5207 #3233
[mk-proof] #5175 rewrite #5211
[instance] 0x0 #5211
[end-of-instance]
[mk-app] #5193 = #5207 #2
[mk-proof] #5209 trans #5175 #3190 #5193
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5154
[mk-app] #5451 = #5154 #3205
[mk-proof] #5449 rewrite #5451
[instance] 0x0 #5451
[end-of-instance]
[mk-app] #5276 = #5154 #4108
[mk-proof] #5235 trans #5449 #3152 #5276
[mk-app] #5274 if #2 #4108 #1503
[mk-app] #5187 = #5547 #5274
[mk-proof] #5184 monotonicity #5209 #5235 #5187
[inst-discovered] theory-solving 0x0 arith# ; #5274
[mk-app] #5179 = #5274 #1503
[mk-proof] #5128 rewrite #5179
[instance] 0x0 #5179
[end-of-instance]
[mk-app] #5126 = #5547 #1503
[mk-proof] #5219 trans #5184 #5128 #5126
[mk-app] #5273 - #1503 #151
[mk-app] #5266 = #5240 #5273
[mk-proof] #5454 monotonicity #5219 #5266
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5273
[mk-app] #5473 = #5273 #4048
[mk-proof] #5468 rewrite #5473
[instance] 0x0 #5473
[end-of-instance]
[mk-app] #5534 = #5240 #4048
[mk-proof] #5462 trans #5454 #5468 #5534
[mk-app] #5262 = #5240 #4037
[mk-proof] #5177 trans #5462 #4000 #5262
[mk-app] #5455 = #1503 #36
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5455
[mk-app] #5207 = #5455 #2
[mk-proof] #5211 rewrite #5207
[instance] 0x0 #5207
[end-of-instance]
[attach-enode] #5133 0
[attach-enode] #5243 0
[attach-enode] #5242 0
[attach-enode] #5225 0
[attach-meaning] #176 arith (- 1)
[attach-enode] #5237 0
[attach-enode] #5238 0
[attach-enode] #5119 0
[mk-app] #5175 or #5455 #5225
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5175
[assign] #5225 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5455
[mk-app] #5207 = #5455 #2
[mk-proof] #5211 rewrite #5207
[instance] 0x0 #5207
[end-of-instance]
[attach-enode] #5538 0
[mk-app] #5175 or #5455 #5538
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5175
[assign] #5538 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #5455
[mk-app] #5207 = #5455 #2
[mk-proof] #5211 rewrite #5207
[instance] 0x0 #5207
[end-of-instance]
[attach-enode] #5197 0
[mk-app] #5175 or #5455 #5197
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5175
[assign] #5197 justification -1: true
[end-of-instance]
[assign] #5218 clause p498 (not p497)
  (<= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int) 
  (not (= (mod (address<Int> idx_one@7@01) 4::Int) 0::Int)) 

[assign] #5237 justification -1: p500
[attach-meaning] #176 arith (- 1)
[assign] #5288 justification -1: p492
[attach-enode] #5288 0
[attach-enode] #5275 0
[assign] #5287 justification -1: p505
[assign] #5459 justification -1: p505
[assign] #5212 clause p502 (not p501)
  (<= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[assign] #5220 clause p503 (not p501)
  (>= (+ (address<Int> idx_one@7@01) (* -1::Int (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 0::Int) 
  (not (= (address<Int> idx_one@7@01) (+ (* 4::Int (div (address<Int> idx_one@7@01) 4::Int)) (mod (address<Int> idx_one@7@01) 4::Int)))) 

[push] 4
[mk-app] #5175 Seq_length #2187
[mk-app] #5193 + #3402 #151
[mk-app] #5209 = #5175 #5193
[mk-app] #5154 not #5209
[mk-proof] #5451 asserted #5154
[mk-app] #5449 + #151 #3402
[inst-discovered] theory-solving 0x0 arith# ; #5193
[mk-app] #5276 = #5193 #5449
[mk-proof] #5235 rewrite #5276
[instance] 0x0 #5276
[end-of-instance]
[mk-app] #5547 = #5175 #5449
[mk-app] #5274 = #5209 #5547
[mk-proof] #5187 monotonicity #5235 #5274
[attach-meaning] #176 arith (- 1)
[mk-app] #5184 + #5110 #5175
[attach-meaning] #176 arith (- 1)
[mk-app] #5179 * #176 #5175
[mk-app] #5128 + #3402 #5179
[attach-meaning] #176 arith (- 1)
[mk-app] #5184 = #5128 #176
[inst-discovered] theory-solving 0x0 arith# ; #5547
[mk-app] #5126 = #5547 #5184
[mk-proof] #5219 rewrite #5126
[instance] 0x0 #5126
[end-of-instance]
[mk-app] #5240 = #5209 #5184
[mk-proof] #5273 trans #5187 #5219 #5240
[mk-app] #5266 not #5184
[mk-app] #5454 = #5154 #5266
[mk-proof] #5473 monotonicity #5273 #5454
[mk-proof] #5468 mp #5451 #5473 #5266
[begin-check] 5
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5184 #2
[mk-proof] #5462 iff-false #5468 #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5184 #2
[mk-proof] #5462 iff-false #5468 #5534
[mk-app] #5534 ~ #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 rewrite #5534
[mk-proof] #5262 mp #5468 #5462 #5266
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[mk-app] #5534 = #5266 #5266
[mk-proof] #5462 refl #5534
[attach-enode] #5175 0
[attach-enode] #5179 0
[attach-enode] #5128 0
[attach-enode] #5184 0
[mk-app] #5534 <= #5128 #176
[mk-app] #5462 >= #5128 #176
[assign] (not #5184) justification -1: 
[mk-app] #5262 = #5184 #2
[mk-proof] #5177 iff-false #5468 #5262
[new-match] 0x1068e9398 #124 #118 #1528 ; #3402
[new-match] 0x1068e93c8 #143 #118 #1528 ; #3402
[eq-expl] #2187 lit #1530 ; #1529
[new-match] 0x1068e93f8 #2726 #167 #2191 #1528 ; #5175 (#2187 #1529)
[new-match] 0x1068e9430 #124 #118 #2187 ; #5175
[new-match] 0x1068e9460 #143 #118 #2187 ; #5175
[mk-app] #5069 >= #3402 #36
[mk-app] #5455 = #5069 #5069
[mk-proof] #5207 refl #5455
[mk-app] #5211 or #1546 #5069
[mk-proof] #5153 quant-inst #5211
[instance] 0x1068e9398 #5153 ; 3
[assign] #5069 justification -1: p13
[end-of-instance]
[mk-app] #5455 not #5191
[mk-app] #5207 or #5455 #2172
[mk-app] #5121 = #5207 #5207
[mk-proof] #5278 refl #5121
[mk-app] #5543 or #2307 #5455 #2172
[mk-app] #5436 or #2307 #5207
[mk-proof] #5452 quant-inst #5436
[mk-app] #5448 = #5436 #5543
[mk-proof] #5068 rewrite #5448
[mk-proof] #5067 mp #5452 #5068 #5543
[instance] 0x1068e93c8 #5452 ; 3
[attach-enode] #5191 3
[mk-app] #5460 <= #3402 #36
[end-of-instance]
[mk-app] #5121 or #2353 #2172 #5224
[mk-app] #5278 or #2353 #2172 #5229
[mk-app] #5456 = #5121 #5278
[mk-proof] #5552 monotonicity #5231 #5456
[mk-app] #5246 or #2172 #2353 #5229
[inst-discovered] theory-solving 0x0 basic# ; #5278
[mk-app] #5271 = #5278 #5246
[mk-proof] #5261 rewrite #5271
[instance] 0x0 #5271
[end-of-instance]
[mk-app] #5279 = #5121 #5246
[mk-proof] #5214 trans #5552 #5261 #5279
[mk-app] #5272 not #2726
[mk-app] #5252 or #5272 #2172 #2353 #5229
[mk-app] #5234 or #5272 #5121
[mk-proof] #5244 quant-inst #5234
[mk-app] #5233 or #5272 #5246
[mk-app] #5245 = #5234 #5233
[mk-proof] #5285 monotonicity #5214 #5245
[mk-app] #5232 = #5233 #5252
[mk-proof] #5247 rewrite #5232
[mk-app] #5241 = #5234 #5252
[mk-proof] #5248 trans #5285 #5247 #5241
[mk-proof] #5249 mp #5244 #5248 #5252
[instance] 0x1068e93f8 #5244 ; 1
[attach-enode] #5139 1
[attach-enode] #5140 1
[attach-enode] #5226 1
[attach-enode] #5229 1
[mk-app] #5250 <= #5226 #36
[mk-app] #5251 >= #5226 #36
[end-of-instance]
[mk-app] #5270 >= #5139 #36
[mk-app] #5173 = #5270 #5270
[mk-proof] #5221 refl #5173
[mk-app] #5174 or #1546 #5270
[mk-proof] #5467 quant-inst #5174
[instance] 0x1068e9430 #5467 ; 1
[assign] #5270 justification -1: p13
[end-of-instance]
[mk-app] #5173 not #5255
[mk-app] #5221 or #5173 #5259
[mk-app] #5180 = #5221 #5221
[mk-proof] #5474 refl #5180
[mk-app] #5585 or #2307 #5173 #5259
[mk-app] #5586 or #2307 #5221
[mk-proof] #5587 quant-inst #5586
[mk-app] #5466 = #5586 #5585
[mk-proof] #5580 rewrite #5466
[mk-proof] #5450 mp #5587 #5580 #5585
[instance] 0x1068e9460 #5587 ; 1
[attach-enode] #5255 1
[mk-app] #5108 <= #5139 #36
[attach-enode] #5259 1
[end-of-instance]
[mk-app] #5180 = #5139 #5175
[attach-meaning] #176 arith (- 1)
[mk-app] #5474 + #5139 #5179
[mk-app] #5553 <= #5474 #36
[mk-app] #5236 >= #5474 #36
[assign] #5180 justification -1: p62
[attach-enode] #5180 0
[attach-enode] #5474 0
[assign] #5553 justification -1: p521
[assign] #5236 justification -1: p521
[decide-and-or] #2170 #2177
[push] 5
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 6
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] (not #5191) clause (not p512) p68
  (not (= (Seq_length $t@2@01) 0::Int)) 
  (= $t@2@01 Seq_empty) 

[assign] #5229 clause p514 p68 p66
  (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] (not #5460) clause (not p513) p512
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5250 clause p515 (not p514)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5251 clause p516 (not p514)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5462 clause p510 (not p516) (not p74) (not p523)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_length seq@8@01))) -1::Int) 
  (not (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (not (<= (Seq_length (Seq_singleton 0::Int)) 1::Int)) 
  (not (>= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 

[assign] #5534 clause p509 (not p515) (not p75) (not p522)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_length seq@8@01))) -1::Int) 
  (not (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (not (>= (Seq_length (Seq_singleton 0::Int)) 1::Int)) 
  (not (<= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 

[assign] (not #5108) clause (not p519) p513 (not p515) (not p63)
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length $t@2@01) 0::Int) 
  (not (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (not (>= (Seq_length (Seq_singleton 0::Int)) 0::Int)) 

[eq-expl] #3403 root
[new-match] 0x1068ea2c8 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068ea300 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068ea338 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068ea378 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068ea3b8 #237 #229 #3402 #36 ; #3403
[mk-app] #5440 * #176 #4347
[mk-app] #5475 + #3403 #5110 #5440
[mk-app] #5476 = #5475 #36
[mk-app] #5471 + #5110 #3403 #5440
[inst-discovered] theory-solving 0x0 arith# ; #5475
[mk-app] #5216 = #5475 #5471
[mk-proof] #5213 rewrite #5216
[instance] 0x0 #5216
[end-of-instance]
[mk-app] #5239 = #5471 #36
[mk-app] #5531 = #5476 #5239
[mk-proof] #5465 monotonicity #5213 #5531
[attach-meaning] #176 arith (- 1)
[mk-app] #5464 + #3402 #5120 #4347
[mk-app] #5208 = #5464 #36
[inst-discovered] theory-solving 0x0 arith# ; #5239
[mk-app] #5170 = #5239 #5208
[mk-proof] #5107 rewrite #5170
[instance] 0x0 #5170
[end-of-instance]
[mk-app] #5433 = #5476 #5208
[mk-proof] #5188 trans #5465 #5107 #5433
[mk-app] #5257 not #263
[mk-app] #5222 or #5257 #5208
[mk-app] #5125 or #5257 #5476
[mk-proof] #5554 quant-inst #5125
[mk-app] #5203 = #5125 #5222
[mk-proof] #5189 monotonicity #5188 #5203
[mk-app] #5555 = #5222 #5222
[mk-proof] #5441 rewrite #5555
[mk-proof] #5556 trans #5189 #5441 #5203
[mk-proof] #5461 mp #5554 #5556 #5222
[instance] 0x1068ea2c8 #5554 ; 3
[attach-enode] #5120 3
[attach-enode] #5464 3
[attach-enode] #5208 3
[mk-app] #5199 <= #5464 #36
[mk-app] #5549 >= #5464 #36
[assign] #5208 justification -1: p21
[end-of-instance]
[mk-app] #5176 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5176
[mk-app] #5548 = #5176 #5176
[mk-proof] #5550 rewrite #5548
[instance] 0x0 #5548
[end-of-instance]
[mk-app] #5551 or #4423 #5142 #5144 #5145
[mk-app] #5544 or #4423 #5176
[mk-proof] #5435 quant-inst #5544
[mk-app] #5545 = #5544 #5551
[mk-proof] #5546 rewrite #5545
[mk-proof] #5444 mp #5435 #5546 #5551
[instance] 0x1068ea300 #5435 ; 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5548 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5550 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5442 = #5548 #5550
[mk-proof] #5446 monotonicity #5169 #5442
[mk-app] #5447 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5550
[mk-app] #5434 = #5550 #5447
[mk-proof] #5443 rewrite #5434
[instance] 0x0 #5434
[end-of-instance]
[mk-app] #5438 = #5548 #5447
[mk-proof] #5453 trans #5446 #5443 #5438
[mk-app] #5445 not #1917
[mk-app] #5469 or #5445 #2172 #2353 #5144 #5148 #5165
[mk-app] #5557 or #5445 #5548
[mk-proof] #5542 quant-inst #5557
[mk-app] #5558 or #5445 #5447
[mk-app] #5477 = #5557 #5558
[mk-proof] #5559 monotonicity #5453 #5477
[mk-app] #5439 = #5558 #5469
[mk-proof] #5579 rewrite #5439
[mk-app] #5280 = #5557 #5469
[mk-proof] #5277 trans #5559 #5579 #5280
[mk-proof] #5284 mp #5542 #5277 #5469
[instance] 0x1068ea338 #5542 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5281 = #5196 #36
[mk-app] #5106 = #5164 #36
[mk-app] #5286 = #5281 #5106
[mk-proof] #5253 monotonicity #5206 #5286
[mk-app] #5070 not #237
[mk-app] #5560 or #5070 #5106
[mk-app] #5457 or #5070 #5281
[mk-proof] #5458 quant-inst #5457
[mk-app] #5134 = #5457 #5560
[mk-proof] #5152 monotonicity #5253 #5134
[mk-app] #5589 = #5560 #5560
[mk-proof] #5590 rewrite #5589
[mk-proof] #5591 trans #5152 #5590 #5134
[mk-proof] #5592 mp #5458 #5591 #5560
[instance] 0x1068ea3b8 #5458 ; 3
[attach-enode] #5106 3
[mk-app] #5593 >= #5164 #36
[assign] #5106 justification -1: p20
[end-of-instance]
[resolve-process] true
[resolve-lit] 0 (not #5534)
[resolve-lit] 0 (not #5462)
[resolve-process] (not #5534)
[resolve-lit] 0 (not #5250)
[resolve-process] (not #5462)
[resolve-lit] 0 (not #5251)
[resolve-process] (not #5251)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5250)
[mk-proof] #5594 monotonicity #1535 #5180
[mk-app] #5595 not #5180
[mk-app] #5596 or #5595 #5236
[mk-proof] #5597 th-lemma #5596
[mk-proof] #5598 unit-resolution #5597 #5594 #5236
[mk-app] #5599 not #2348
[mk-app] #5600 or #5599 #2135
[mk-proof] #5601 th-lemma #5600
[mk-proof] #5602 unit-resolution #5601 #2186 #2135
[mk-proof] #5603 hypothesis #5229
[mk-app] #5604 not #5229
[mk-app] #5605 or #5604 #5251
[mk-proof] #5606 th-lemma #5605
[mk-proof] #5607 unit-resolution #5606 #5603 #5251
[mk-app] #5608 not #5236
[mk-app] #5609 not #2135
[mk-app] #5610 not #5251
[mk-app] #5611 or #5462 #5608 #5609 #5610
[mk-proof] #5612 th-lemma #5611
[mk-proof] #5613 unit-resolution #5612 #5607 #5602 #5598 #5462
[mk-app] #5614 or #5595 #5553
[mk-proof] #5615 th-lemma #5614
[mk-proof] #5616 unit-resolution #5615 #5594 #5553
[mk-app] #5617 or #5599 #2136
[mk-proof] #5618 th-lemma #5617
[mk-proof] #5619 unit-resolution #5618 #2186 #2136
[mk-app] #5620 or #5604 #5250
[mk-proof] #5621 th-lemma #5620
[mk-proof] #5622 unit-resolution #5621 #5603 #5250
[mk-app] #5623 not #5553
[mk-app] #5624 not #2136
[mk-app] #5625 not #5250
[mk-app] #5626 or #5534 #5623 #5624 #5625
[mk-proof] #5627 th-lemma #5626
[mk-proof] #5628 unit-resolution #5627 #5622 #5619 #5616 #5534
[mk-app] #5629 not #5534
[mk-app] #5630 not #5462
[mk-app] #5631 or #5184 #5629 #5630
[mk-proof] #5632 th-lemma #5631
[mk-app] #5633 or #5629 #5630
[mk-proof] #5634 unit-resolution #5632 #5468 #5633
[mk-proof] #5635 unit-resolution #5634 #5628 #5613 #2
[mk-proof] #5636 lemma #5635 #5604
[conflict] (not #5229)
[pop] 2 7
[assign] (not #5229) justification -1: 
[decide-and-or] #2170 #2177
[push] 5
[assign] (not #2353) decision axiom
[assign] #2172 clause p68 p66 p514
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 
  (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] #2167 clause p69 (not p68) (not p70)
  (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int)) 
  (not (= $t@2@01 Seq_empty)) 
  (not (or (not (= $t@2@01 Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int)))) 

[assign] #5191 justification -1: p14 p68
[assign] (not #5259) justification -1: (not p66) p69
[assign] (not #2178) justification -1: (not p66) p69 p68
[assign] (not #5255) justification -1: (not p64) p62 p69 p62
[mk-app] #5257 = #131 #3402
[attach-meaning] #176 arith (- 1)
[mk-app] #5125 + #131 #5110
[mk-app] #5554 <= #5125 #36
[mk-app] #5471 >= #5125 #36
[assign] #5257 justification -1: p68
[attach-enode] #5257 0
[attach-enode] #5110 0
[attach-enode] #5125 0
[assign] #5554 justification -1: p524
[assign] #5471 justification -1: p524
[mk-app] #5216 = #2347 #5175
[attach-meaning] #176 arith (- 1)
[mk-app] #5213 + #2347 #5179
[mk-app] #5239 <= #5213 #36
[mk-app] #5531 >= #5213 #36
[assign] #5216 justification -1: p62 p69
[attach-enode] #5216 0
[attach-enode] #5213 0
[assign] #5239 justification -1: p527
[assign] #5531 justification -1: p527
[eq-expl] #1528 lit #2172 ; #130
[eq-expl] #2191 lit #2167 ; #1529
[new-match] 0x1068ea958 #1917 #283 #36 #2191 #1528 ; #2304 (#2191 #1529)
[new-match] 0x1068ea998 #1854 #283 #36 #2191 #1528 ; #2304 (#2191 #1529)
[assign] #5460 clause p513 (not p512)
  (<= (Seq_length $t@2@01) 0::Int) 
  (not (= (Seq_length $t@2@01) 0::Int)) 

[assign] (not #5108) clause (not p519) p518
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[assign] #5250 clause p515 (not p513) (not p523) (not p528)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (not (>= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 
  (not (<= (+ (Seq_length (Seq_singleton 0::Int)) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 

[assign] #5251 clause p516 (not p529) (not p522) (not p511)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (+ (Seq_length (Seq_singleton 0::Int)) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 
  (not (<= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[resolve-process] true
[resolve-lit] 0 (not #5251)
[resolve-lit] 0 (not #5250)
[resolve-process] (not #5251)
[resolve-lit] 0 (not #5531)
[resolve-process] (not #5250)
[resolve-lit] 0 (not #5460)
[resolve-lit] 0 (not #5239)
[resolve-process] (not #5460)
[resolve-lit] 0 (not #5191)
[resolve-process] (not #5531)
[resolve-lit] 0 (not #5216)
[resolve-process] (not #5239)
[resolve-process] (not #5216)
[resolve-lit] 0 (not #2167)
[resolve-process] (not #5191)
[resolve-lit] 0 (not #2172)
[resolve-process] (not #2167)
[mk-proof] #5465 unit-resolution #2335 #2246 #2163
[mk-proof] #5464 unit-resolution #2142 #5465 #2168
[mk-proof] #5208 hypothesis #2172
[mk-proof] #5170 unit-resolution #2151 #5208 #5464 #2167
[mk-app] #5107 = #2191 #1529
[mk-proof] #5433 symm #5170 #5107
[mk-app] #5188 = #2187 #2191
[mk-proof] #5222 trans* #1532 #5170 #5188
[mk-app] #5203 = #5175 #2347
[mk-proof] #5189 monotonicity #5222 #5203
[mk-proof] #5555 symm #5189 #5216
[mk-app] #5441 not #5216
[mk-app] #5556 or #5441 #5239
[mk-proof] #5461 th-lemma #5556
[mk-proof] #5544 unit-resolution #5461 #5555 #5239
[mk-app] #5435 = #3402 #131
[mk-proof] #5551 monotonicity #5208 #5435
[mk-proof] #5545 trans* #5551 #133 #5191
[mk-app] #5546 or #5455 #5460
[mk-proof] #5444 th-lemma #5546
[mk-proof] #5445 unit-resolution #5444 #5545 #5460
[mk-app] #5557 not #5239
[mk-app] #5542 not #5460
[mk-app] #5550 or #5250 #5557 #5608 #5542
[mk-proof] #5442 th-lemma #5550
[mk-proof] #5446 unit-resolution #5442 #5445 #5598 #5544 #5250
[mk-proof] #5447 unit-resolution #5153 #2880 #5069
[mk-app] #5434 or #5441 #5531
[mk-proof] #5443 th-lemma #5434
[mk-proof] #5438 unit-resolution #5443 #5555 #5531
[mk-app] #5453 not #5531
[mk-app] #5558 not #5069
[mk-app] #5477 or #5251 #5453 #5623 #5558
[mk-proof] #5559 th-lemma #5477
[mk-proof] #5469 unit-resolution #5559 #5438 #5616 #5447 #5251
[mk-app] #5439 or #5229 #5625 #5610
[mk-proof] #5579 th-lemma #5439
[mk-proof] #5280 unit-resolution #5579 #5469 #5446 #5636 #2
[mk-proof] #5277 lemma #5280 #2294
[conflict] (not #2172)
[pop] 1 6
[attach-enode] #5213 0
[assign] (not #2172) justification -1: 
[assign] (not #5191) clause (not p512) p68
  (not (= (Seq_length $t@2@01) 0::Int)) 
  (= $t@2@01 Seq_empty) 

[assign] #2353 clause p66 p68 p514
  (= (Seq_singleton 0::Int) Seq_empty) 
  (= $t@2@01 Seq_empty) 
  (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5460) clause (not p513) p512
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #2178 clause p71 (not p66) (not p72)
  (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01) 
  (not (= (Seq_singleton 0::Int) Seq_empty)) 
  (not (or (not (= (Seq_singleton 0::Int) Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01))) 

[mk-proof] #5257 unit-resolution #5249 #2731 #5246
[mk-proof] #5125 unit-resolution #5257 #5277 #5636 #2353
[mk-app] #5554 = #151 #2347
[mk-proof] #5471 symm #2186 #5554
[mk-app] #5107 = #2347 #131
[mk-proof] #5433 monotonicity #5125 #5107
[mk-app] #5284 = #151 #36
[mk-proof] #5070 trans* #5471 #5433 #133 #5284
[mk-app] #5457 = #5284 #2
[mk-proof] #5458 rewrite #5457
[mk-proof] #5106 mp #5070 #5458 #2
[pop] 1 5
[mk-proof] #5262 asserted #5209
[inst-discovered] theory-solving 0x0 arith# ; #5193
[instance] 0x0 #5276
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #5177 + #5110 #5175
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5547
[instance] 0x0 #5126
[end-of-instance]
[mk-proof] #5177 mp #5262 #5273 #5184
[pop] 1 4
[pop] 1 3
[push] 2
[mk-app] #5031 address<Int> #1558
[mk-app] #4199 mod #5031 #1503
[mk-app] #4205 = #4199 #36
[mk-app] #4210 not #4205
[mk-proof] #5109 asserted #4210
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[pop] 1 3
[push] 2
[mk-app] #5031 address<Int> #1558
[mk-app] #4199 mod #5031 #1503
[mk-app] #4205 = #4199 #36
[mk-app] #4210 not #4205
[mk-proof] #5109 asserted #4210
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[begin-check] 3
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4205 #2
[mk-proof] #5060 iff-false #5109 #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4205 #2
[mk-proof] #5060 iff-false #5109 #4158
[mk-app] #4158 ~ #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 rewrite #4158
[mk-proof] #5256 mp #5109 #5060 #4210
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[mk-app] #4158 = #4210 #4210
[mk-proof] #5060 refl #4158
[attach-enode] #5031 0
[attach-enode] #1503 0
[attach-enode] #4199 0
[attach-enode] #4205 0
[mk-app] #4158 <= #4199 #36
[mk-app] #5060 >= #4199 #36
[assign] (not #4205) justification -1: 
[mk-app] #5256 div #5031 #1503
[mk-app] #5260 < #1503 #36
[mk-app] #5254 - #36 #1503
[mk-app] #4982 if #5260 #5254 #1503
[mk-app] #4983 - #4982 #151
[inst-discovered] theory-solving 0x0 arith# ; #5260
[mk-app] #5113 = #5260 #3233
[mk-proof] #5099 rewrite #5113
[instance] 0x0 #5113
[end-of-instance]
[mk-app] #5100 = #5260 #2
[mk-proof] #4976 trans #5099 #3190 #5100
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #5254
[mk-app] #4956 = #5254 #3205
[mk-proof] #5021 rewrite #4956
[instance] 0x0 #4956
[end-of-instance]
[mk-app] #4781 = #5254 #4108
[mk-proof] #4761 trans #5021 #3152 #4781
[mk-app] #4906 if #2 #4108 #1503
[mk-app] #5073 = #4982 #4906
[mk-proof] #4866 monotonicity #4976 #4761 #5073
[inst-discovered] theory-solving 0x0 arith# ; #4906
[mk-app] #4867 = #4906 #1503
[mk-proof] #4800 rewrite #4867
[instance] 0x0 #4867
[end-of-instance]
[mk-app] #4787 = #4982 #1503
[mk-proof] #4788 trans #4866 #4800 #4787
[mk-app] #4789 - #1503 #151
[mk-app] #4748 = #4983 #4789
[mk-proof] #4683 monotonicity #4788 #4748
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #4789
[mk-app] #4937 = #4789 #4048
[mk-proof] #4128 rewrite #4937
[instance] 0x0 #4937
[end-of-instance]
[mk-app] #4672 = #4983 #4048
[mk-proof] #4917 trans #4683 #4128 #4672
[mk-app] #4904 = #4983 #4037
[mk-proof] #4898 trans #4917 #4000 #4904
[mk-app] #4664 = #1503 #36
[mk-app] #4644 * #1503 #5256
[mk-app] #4820 + #4644 #4199
[mk-app] #3664 = #4820 #5031
[mk-app] #4126 <= #4199 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4664
[mk-app] #5260 = #4664 #2
[mk-proof] #5113 rewrite #5260
[instance] 0x0 #5260
[end-of-instance]
[attach-enode] #5256 0
[attach-enode] #4644 0
[attach-enode] #4820 0
[attach-enode] #3664 0
[mk-app] #5099 or #4664 #3664
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5099
[assign] #3664 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4664
[mk-app] #5260 = #4664 #2
[mk-proof] #5113 rewrite #5260
[instance] 0x0 #5260
[end-of-instance]
[attach-enode] #5060 0
[mk-app] #5099 or #4664 #5060
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5099
[assign] #5060 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #4664
[mk-app] #5260 = #4664 #2
[mk-proof] #5113 rewrite #5260
[instance] 0x0 #5260
[end-of-instance]
[attach-enode] #4126 0
[mk-app] #5099 or #4664 #4126
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5099
[assign] #4126 justification -1: true
[end-of-instance]
[mk-app] #5099 = #4205 #2
[mk-proof] #5100 iff-false #5109 #5099
[assign] (not #4158) clause (not p81) p80 (not p82)
  (not (<= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 
  (= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int) 
  (not (>= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 

[new-match] 0x106809eb0 #1522 #1506 #36 #1545 ; #5031 (#1558 #1559)
[mk-app] #5281 * #176 #4105
[mk-app] #5548 + #3235 #5281
[mk-app] #5176 = #5548 #1503
[mk-app] #4664 = #5176 #5176
[mk-proof] #5260 refl #4664
[mk-app] #5113 not #1522
[mk-app] #5440 or #5113 #5176
[mk-proof] #5475 quant-inst #5440
[instance] 0x106809eb0 #5475 ; 1
[attach-enode] #3235 1
[attach-enode] #4105 1
[attach-enode] #176 1
[attach-enode] #5281 1
[attach-enode] #5548 1
[attach-enode] #5176 1
[mk-app] #5476 <= #5548 #1503
[mk-app] #5173 >= #5548 #1503
[assign] #5176 justification -1: p51
[end-of-instance]
[assign] #5476 clause p86 (not p85)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[assign] #5173 clause p87 (not p85)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[mk-app] #4664 = #4105 #4820
[attach-meaning] #176 arith (- 1)
[mk-app] #5260 * #176 #4820
[mk-app] #5221 + #4105 #5260
[mk-app] #5270 <= #5221 #36
[mk-app] #5207 >= #5221 #36
[assign] #4664 justification -1: p83 p55
[attach-enode] #4664 0
[attach-enode] #5260 0
[attach-enode] #5221 0
[assign] #5270 justification -1: p88
[assign] #5207 justification -1: p88
[new-match] 0x1068171a0 #1522 #1506 #151 #1545 ; #3235 (#1574 #2367)
[mk-app] #4976 * #176 #4087
[mk-app] #5254 + #4086 #4976
[mk-app] #4956 = #5254 #1503
[mk-app] #5021 = #4956 #4956
[mk-proof] #4781 refl #5021
[mk-app] #4761 or #5113 #4956
[mk-proof] #4982 quant-inst #4761
[instance] 0x1068171a0 #4982 ; 2
[attach-enode] #3162 2
[attach-enode] #4086 2
[attach-enode] #4087 2
[attach-enode] #4976 2
[attach-enode] #5254 2
[attach-enode] #4956 2
[mk-app] #4906 <= #5254 #1503
[mk-app] #5073 >= #5254 #1503
[assign] #4956 justification -1: p51
[end-of-instance]
[assign] #4906 clause p92 (not p91)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[assign] #5073 clause p93 (not p91)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[mk-app] #5021 = #3235 #4087
[attach-meaning] #176 arith (- 1)
[mk-app] #4781 + #3235 #4976
[mk-app] #4866 <= #4781 #36
[mk-app] #4867 >= #4781 #36
[assign] #5021 justification -1: p58
[attach-enode] #5021 0
[attach-enode] #4781 0
[assign] #4866 justification -1: p94
[assign] #4867 justification -1: p94
[new-match] 0x106817a08 #1495 #1483 #151 #1545 ; #3162 (#2367 #2367)
[mk-app] #4800 = #3162 #2941
[mk-app] #4787 = #3162 #3955
[mk-app] #4788 = #4800 #4787
[mk-proof] #4983 monotonicity #3943 #4788
[mk-app] #4789 or #1563 #4787
[mk-app] #4748 or #1563 #4800
[mk-proof] #4683 quant-inst #4748
[mk-app] #4937 = #4748 #4789
[mk-proof] #4128 monotonicity #4983 #4937
[mk-app] #4672 = #4789 #4789
[mk-proof] #4917 rewrite #4672
[mk-proof] #4904 trans #4128 #4917 #4937
[mk-proof] #4898 mp #4683 #4904 #4789
[instance] 0x106817a08 #4683 ; 3
[attach-enode] #3950 3
[attach-enode] #3955 3
[attach-enode] #4787 3
[assign] #4787 justification -1: p50
[end-of-instance]
[eq-expl] #3950 root
[new-match] 0x106817cc8 #1477 #1476 #3950 #1545 ; #3955
[eq-expl] #3162 lit #4787 ; #3955
[eq-expl] #3955 root
[new-match] 0x106817d00 #1522 #1506 #3950 #1545 ; #4086 (#3162 #3955)
[mk-app] #4584 = #3384 #3950
[mk-app] #4585 = #4584 #4584
[mk-proof] #4486 refl #4585
[mk-app] #4493 or #1576 #4584
[mk-proof] #4115 quant-inst #4493
[instance] 0x106817cc8 #4115 ; 4
[attach-enode] #3384 4
[attach-enode] #4584 4
[assign] #4584 justification -1: p49
[end-of-instance]
[mk-app] #4585 * #176 #3391
[mk-app] #4486 + #3387 #4585
[mk-app] #3215 = #4486 #1503
[mk-app] #3201 = #3215 #3215
[mk-proof] #3202 refl #3201
[mk-app] #3203 or #5113 #3215
[mk-proof] #3193 quant-inst #3203
[instance] 0x106817d00 #3193 ; 4
[attach-enode] #3386 4
[attach-enode] #3387 4
[attach-enode] #3391 4
[attach-enode] #4585 4
[attach-enode] #4486 4
[attach-enode] #3215 4
[mk-app] #4710 <= #4486 #1503
[mk-app] #3875 >= #4486 #1503
[assign] #3215 justification -1: p51
[end-of-instance]
[assign] #4710 clause p100 (not p99)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[assign] #3875 clause p101 (not p99)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[mk-app] #3201 = #3391 #4086
[attach-meaning] #176 arith (- 1)
[mk-app] #3202 * #176 #4086
[mk-app] #3876 + #3391 #3202
[mk-app] #4711 <= #3876 #36
[mk-app] #4703 >= #3876 #36
[assign] #3201 justification -1: p97
[attach-enode] #3201 0
[attach-enode] #3202 0
[attach-enode] #3876 0
[assign] #4711 justification -1: p102
[assign] #4703 justification -1: p102
[new-match] 0x106818748 #1495 #1483 #3950 #1545 ; #3386 (#3955 #3955)
[mk-app] #4671 = #3386 #4318
[mk-app] #3588 = #3386 #4322
[mk-app] #3582 = #4671 #3588
[mk-proof] #3320 monotonicity #4324 #3582
[mk-app] #3321 or #1563 #3588
[mk-app] #4212 or #1563 #4671
[mk-proof] #4186 quant-inst #4212
[mk-app] #3319 = #4212 #3321
[mk-proof] #3313 monotonicity #3320 #3319
[mk-app] #3290 = #3321 #3321
[mk-proof] #4043 rewrite #3290
[mk-proof] #4044 trans #3313 #4043 #3319
[mk-proof] #4045 mp #4186 #4044 #3321
[instance] 0x106818748 #4186 ; 5
[attach-enode] #4037 5
[attach-enode] #4322 5
[attach-enode] #3588 5
[assign] #3588 justification -1: p50
[end-of-instance]
[eq-expl] #4037 root
[new-match] 0x1068189e8 #1477 #1476 #4037 #1545 ; #4322
[eq-expl] #3386 lit #3588 ; #4322
[eq-expl] #4322 root
[new-match] 0x106818a20 #1522 #1506 #4037 #1545 ; #3387 (#3386 #4322)
[mk-app] #3608 = #4342 #4037
[mk-app] #3609 = #3608 #3608
[mk-proof] #3475 refl #3609
[mk-app] #3476 or #1576 #3608
[mk-proof] #4410 quant-inst #3476
[instance] 0x1068189e8 #4410 ; 6
[attach-enode] #4342 6
[attach-enode] #3608 6
[assign] #3608 justification -1: p49
[end-of-instance]
[mk-app] #3609 * #176 #3488
[mk-app] #3475 + #4345 #3609
[mk-app] #4388 = #3475 #1503
[mk-app] #3586 + #3609 #4345
[inst-discovered] theory-solving 0x0 arith# ; #3475
[mk-app] #3587 = #3475 #3586
[mk-proof] #3946 rewrite #3587
[instance] 0x0 #3587
[end-of-instance]
[mk-app] #3930 = #3586 #1503
[mk-app] #3874 = #4388 #3930
[mk-proof] #4470 monotonicity #3946 #3874
[attach-meaning] #176 arith (- 1)
[mk-app] #4471 * #176 #4345
[mk-app] #3551 + #3488 #4471
[attach-meaning] #4108 arith (- 4)
[mk-app] #4380 = #3551 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3930
[mk-app] #3897 = #3930 #4380
[mk-proof] #3527 rewrite #3897
[instance] 0x0 #3897
[end-of-instance]
[mk-app] #4546 = #4388 #4380
[mk-proof] #4463 trans #4470 #3527 #4546
[mk-app] #3528 or #5113 #4380
[mk-app] #3529 or #5113 #4388
[mk-proof] #3521 quant-inst #3529
[mk-app] #4095 = #3529 #3528
[mk-proof] #4035 monotonicity #4463 #4095
[mk-app] #3141 = #3528 #3528
[mk-proof] #3142 rewrite #3141
[mk-proof] #3729 trans #4035 #3142 #4095
[mk-proof] #3607 mp #3521 #3729 #3528
[instance] 0x106818a20 #3521 ; 6
[attach-enode] #3488 6
[attach-enode] #4344 6
[attach-enode] #4345 6
[attach-enode] #4471 6
[attach-enode] #3551 6
[attach-enode] #4108 6
[attach-enode] #4380 6
[mk-app] #4434 <= #3551 #4108
[mk-app] #4298 >= #3551 #4108
[assign] #4380 justification -1: p51
[end-of-instance]
[assign] #4434 clause p108 (not p107)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[assign] #4298 clause p109 (not p107)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[mk-app] #4299 = #3387 #3488
[attach-meaning] #176 arith (- 1)
[mk-app] #3794 + #3387 #3609
[mk-app] #3017 <= #3794 #36
[mk-app] #3031 >= #3794 #36
[assign] #4299 justification -1: p105
[attach-enode] #4299 0
[attach-enode] #3609 0
[attach-enode] #3794 0
[assign] #3017 justification -1: p110
[assign] #3031 justification -1: p110
[new-match] 0x10681c558 #1495 #1483 #4037 #1545 ; #4344 (#4322 #4322)
[mk-app] #4010 = #4344 #4442
[mk-app] #4012 = #4344 #4446
[mk-app] #3721 = #4010 #4012
[mk-proof] #3016 monotonicity #4545 #3721
[mk-app] #3010 or #1563 #4012
[mk-app] #3571 or #1563 #4010
[mk-proof] #3639 quant-inst #3571
[mk-app] #2953 = #3571 #3010
[mk-proof] #4234 monotonicity #3016 #2953
[mk-app] #3784 = #3010 #3010
[mk-proof] #4308 rewrite #3784
[mk-proof] #4058 trans #4234 #4308 #2953
[mk-proof] #4059 mp #3639 #4058 #3010
[instance] 0x10681c558 #3639 ; 7
[attach-enode] #4446 7
[attach-enode] #4012 7
[assign] #4012 justification -1: p50
[end-of-instance]
[eq-expl] #1503 root
[new-match] 0x10681c768 #1477 #1476 #1503 #1545 ; #4446
[eq-expl] #4344 lit #4012 ; #4446
[eq-expl] #4446 root
[new-match] 0x10681c7a0 #1522 #1506 #1503 #1545 ; #4345 (#4344 #4446)
[mk-app] #4309 = #2974 #1503
[mk-app] #4311 = #4309 #4309
[mk-proof] #3904 refl #4311
[mk-app] #4060 or #1576 #4309
[mk-proof] #4052 quant-inst #4060
[instance] 0x10681c768 #4052 ; 8
[attach-enode] #2974 8
[attach-enode] #4309 8
[assign] #4309 justification -1: p49
[end-of-instance]
[mk-app] #4311 * #176 #3710
[mk-app] #3904 + #3707 #4311
[mk-app] #3431 = #3904 #1503
[mk-app] #4155 = #3431 #3431
[mk-proof] #4516 refl #4155
[mk-app] #3619 or #5113 #3431
[mk-proof] #3620 quant-inst #3619
[instance] 0x10681c7a0 #3620 ; 8
[attach-enode] #2976 8
[attach-enode] #3707 8
[attach-enode] #3710 8
[attach-enode] #4311 8
[attach-enode] #3904 8
[attach-enode] #3431 8
[mk-app] #3273 <= #3904 #1503
[mk-app] #3274 >= #3904 #1503
[assign] #3431 justification -1: p51
[end-of-instance]
[assign] #3273 clause p116 (not p115)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[assign] #3274 clause p117 (not p115)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[mk-app] #4155 = #3710 #4345
[attach-meaning] #176 arith (- 1)
[mk-app] #4516 + #3710 #4471
[mk-app] #3851 <= #4516 #36
[mk-app] #3417 >= #4516 #36
[assign] #4155 justification -1: p113
[attach-enode] #4155 0
[attach-enode] #4516 0
[assign] #3851 justification -1: p118
[assign] #3417 justification -1: p118
[new-match] 0x10681d160 #1495 #1483 #1503 #1545 ; #2976 (#4446 #4446)
[mk-app] #3229 = #2976 #4502
[mk-app] #4578 = #2976 #3398
[mk-app] #3849 = #3229 #4578
[mk-proof] #3850 monotonicity #3400 #3849
[mk-app] #4079 or #1563 #4578
[mk-app] #3712 or #1563 #3229
[mk-proof] #3713 quant-inst #3712
[mk-app] #3746 = #3712 #4079
[mk-proof] #3160 monotonicity #3850 #3746
[mk-app] #3144 = #4079 #4079
[mk-proof] #2975 rewrite #3144
[mk-proof] #4443 trans #3160 #2975 #3746
[mk-proof] #3373 mp #3713 #4443 #4079
[instance] 0x10681d160 #3713 ; 9
[attach-enode] #3395 9
[attach-enode] #3398 9
[attach-enode] #4578 9
[assign] #4578 justification -1: p50
[end-of-instance]
[eq-expl] #3395 root
[new-match] 0x10681d400 #1477 #1476 #3395 #1545 ; #3398
[eq-expl] #2976 lit #4578 ; #3398
[eq-expl] #3398 root
[new-match] 0x10681d438 #1522 #1506 #3395 #1545 ; #3707 (#2976 #3398)
[mk-app] #4094 = #3414 #3395
[mk-app] #4174 = #4094 #4094
[mk-proof] #3393 refl #4174
[mk-app] #3385 or #1576 #4094
[mk-proof] #3949 quant-inst #3385
[instance] 0x10681d400 #3949 ; 10
[attach-enode] #3414 10
[attach-enode] #4094 10
[assign] #4094 justification -1: p49
[end-of-instance]
[mk-app] #4174 * #176 #3848
[mk-app] #3393 + #3419 #4174
[mk-app] #4088 = #3393 #1503
[mk-app] #3199 = #4088 #4088
[mk-proof] #4172 refl #3199
[mk-app] #4106 or #5113 #4088
[mk-proof] #3022 quant-inst #4106
[instance] 0x10681d438 #3022 ; 10
[attach-enode] #3418 10
[attach-enode] #3419 10
[attach-enode] #3848 10
[attach-enode] #4174 10
[attach-enode] #3393 10
[attach-enode] #4088 10
[mk-app] #3234 <= #3393 #1503
[mk-app] #4490 >= #3393 #1503
[assign] #4088 justification -1: p51
[end-of-instance]
[assign] #3234 clause p124 (not p123)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[assign] #4490 clause p125 (not p123)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[mk-app] #3199 = #3707 #3848
[attach-meaning] #176 arith (- 1)
[mk-app] #4172 + #3707 #4174
[mk-app] #4501 <= #4172 #36
[mk-app] #3023 >= #4172 #36
[assign] #3199 justification -1: p121
[attach-enode] #3199 0
[attach-enode] #4172 0
[assign] #4501 justification -1: p126
[assign] #3023 justification -1: p126
[new-match] 0x106822a08 #1495 #1483 #3395 #1545 ; #3418 (#3398 #3398)
[mk-app] #3027 = #3418 #4360
[mk-app] #3555 = #3418 #2979
[mk-app] #3556 = #3027 #3555
[mk-proof] #4242 monotonicity #2981 #3556
[mk-app] #3028 or #1563 #3555
[mk-app] #3029 or #1563 #3027
[mk-proof] #4073 quant-inst #3029
[mk-app] #4557 = #3029 #3028
[mk-proof] #3506 monotonicity #4242 #4557
[mk-app] #4325 = #3028 #3028
[mk-proof] #4326 rewrite #4325
[mk-proof] #4330 trans #3506 #4326 #4557
[mk-proof] #4556 mp #4073 #4330 #3028
[instance] 0x106822a08 #4073 ; 11
[attach-enode] #4579 11
[attach-enode] #2979 11
[attach-enode] #3555 11
[assign] #3555 justification -1: p50
[end-of-instance]
[eq-expl] #4579 root
[new-match] 0x106822ca8 #1477 #1476 #4579 #1545 ; #2979
[eq-expl] #3418 lit #3555 ; #2979
[eq-expl] #2979 root
[new-match] 0x106822ce0 #1522 #1506 #4579 #1545 ; #3419 (#3418 #2979)
[mk-app] #3507 = #3228 #4579
[mk-app] #3492 = #3507 #3507
[mk-proof] #3493 refl #3492
[mk-app] #3497 or #1576 #3507
[mk-proof] #3498 quant-inst #3497
[instance] 0x106822ca8 #3498 ; 12
[attach-enode] #3228 12
[attach-enode] #3507 12
[assign] #3507 justification -1: p49
[end-of-instance]
[mk-app] #3492 * #176 #3237
[mk-app] #3493 + #3231 #3492
[mk-app] #3502 = #3493 #1503
[mk-app] #3621 = #3502 #3502
[mk-proof] #2962 refl #3621
[mk-app] #3511 or #5113 #3502
[mk-proof] #4182 quant-inst #3511
[instance] 0x106822ce0 #4182 ; 12
[attach-enode] #3230 12
[attach-enode] #3231 12
[attach-enode] #3237 12
[attach-enode] #3492 12
[attach-enode] #3493 12
[attach-enode] #3502 12
[mk-app] #3766 <= #3493 #1503
[mk-app] #3275 >= #3493 #1503
[assign] #3502 justification -1: p51
[end-of-instance]
[assign] #3766 clause p132 (not p131)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[assign] #3275 clause p133 (not p131)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[mk-app] #3621 = #3237 #3419
[attach-meaning] #176 arith (- 1)
[mk-app] #2962 * #176 #3419
[mk-app] #3888 + #3237 #2962
[mk-app] #3889 <= #3888 #36
[mk-app] #3240 >= #3888 #36
[assign] #3621 justification -1: p129
[attach-enode] #3621 0
[attach-enode] #2962 0
[attach-enode] #3888 0
[assign] #3889 justification -1: p134
[assign] #3240 justification -1: p134
[new-match] 0x106823728 #1495 #1483 #4579 #1545 ; #3230 (#2979 #2979)
[mk-app] #3409 = #3230 #3758
[mk-app] #3404 = #3230 #4131
[mk-app] #2969 = #3409 #3404
[mk-proof] #2970 monotonicity #4133 #2969
[mk-app] #3708 or #1563 #3404
[mk-app] #3709 or #1563 #3409
[mk-proof] #3846 quant-inst #3709
[mk-app] #3847 = #3709 #3708
[mk-proof] #3412 monotonicity #2970 #3847
[mk-app] #3413 = #3708 #3708
[mk-proof] #3415 rewrite #3413
[mk-proof] #3416 trans #3412 #3415 #3847
[mk-proof] #3489 mp #3846 #3416 #3708
[instance] 0x106823728 #3846 ; 13
[attach-enode] #3760 13
[attach-enode] #4131 13
[attach-enode] #3404 13
[assign] #3404 justification -1: p50
[end-of-instance]
[eq-expl] #3760 root
[new-match] 0x1068239c8 #1477 #1476 #3760 #1545 ; #4131
[eq-expl] #3230 lit #3404 ; #4131
[eq-expl] #4131 root
[new-match] 0x106823a00 #1522 #1506 #3760 #1545 ; #3231 (#3230 #4131)
[mk-app] #2986 = #4147 #3760
[mk-app] #2987 = #2986 #2986
[mk-proof] #3490 refl #2987
[mk-app] #3491 or #1576 #2986
[mk-proof] #3389 quant-inst #3491
[instance] 0x1068239c8 #3389 ; 14
[attach-enode] #4147 14
[attach-enode] #2986 14
[assign] #2986 justification -1: p49
[end-of-instance]
[mk-app] #2987 * #176 #4154
[mk-app] #3490 + #4151 #2987
[mk-app] #4144 = #3490 #1503
[mk-app] #4146 = #4144 #4144
[mk-proof] #4351 refl #4146
[mk-app] #4353 or #5113 #4144
[mk-proof] #2982 quant-inst #4353
[instance] 0x106823a00 #2982 ; 14
[attach-enode] #4149 14
[attach-enode] #4151 14
[attach-enode] #4154 14
[attach-enode] #2987 14
[attach-enode] #3490 14
[attach-enode] #4144 14
[mk-app] #2983 <= #3490 #1503
[mk-app] #3223 >= #3490 #1503
[assign] #4144 justification -1: p51
[end-of-instance]
[assign] #2983 clause p140 (not p139)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[assign] #3223 clause p141 (not p139)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[mk-app] #4146 = #3231 #4154
[attach-meaning] #176 arith (- 1)
[mk-app] #4351 + #3231 #2987
[mk-app] #3224 <= #4351 #36
[mk-app] #3232 >= #4351 #36
[assign] #4146 justification -1: p137
[attach-enode] #4146 0
[attach-enode] #4351 0
[assign] #3224 justification -1: p142
[assign] #3232 justification -1: p142
[new-match] 0x1068243c0 #1495 #1483 #3760 #1545 ; #4149 (#4131 #4131)
[mk-app] #3236 = #4149 #3956
[mk-app] #4142 = #4149 #4562
[mk-app] #4143 = #3236 #4142
[mk-proof] #4136 monotonicity #3249 #4143
[mk-app] #4137 or #1563 #4142
[mk-app] #4140 or #1563 #3236
[mk-proof] #4141 quant-inst #4140
[mk-app] #4152 = #4140 #4137
[mk-proof] #4153 monotonicity #4136 #4152
[mk-app] #3688 = #4137 #4137
[mk-proof] #3689 rewrite #3688
[mk-proof] #3251 trans #4153 #3689 #4152
[mk-proof] #3252 mp #4141 #3251 #4137
[instance] 0x1068243c0 #4141 ; 15
[attach-enode] #3958 15
[attach-enode] #4562 15
[attach-enode] #4142 15
[assign] #4142 justification -1: p50
[end-of-instance]
[eq-expl] #3958 root
[new-match] 0x106824660 #1477 #1476 #3958 #1545 ; #4562
[eq-expl] #4149 lit #4142 ; #4562
[eq-expl] #4562 root
[new-match] 0x106824698 #1522 #1506 #3958 #1545 ; #4151 (#4149 #4562)
[mk-app] #4332 = #3262 #3958
[mk-app] #4175 = #4332 #4332
[mk-proof] #4176 refl #4175
[mk-app] #4169 or #1576 #4332
[mk-proof] #4163 quant-inst #4169
[instance] 0x106824660 #4163 ; 16
[attach-enode] #3262 16
[attach-enode] #4332 16
[assign] #4332 justification -1: p49
[end-of-instance]
[mk-app] #4175 * #176 #3271
[mk-app] #4176 + #3268 #4175
[mk-app] #4167 = #4176 #1503
[mk-app] #4170 = #4167 #4167
[mk-proof] #4177 refl #4170
[mk-app] #4178 or #5113 #4167
[mk-proof] #2928 quant-inst #4178
[instance] 0x106824698 #2928 ; 16
[attach-enode] #3264 16
[attach-enode] #3268 16
[attach-enode] #3271 16
[attach-enode] #4175 16
[attach-enode] #4176 16
[attach-enode] #4167 16
[mk-app] #2929 <= #4176 #1503
[mk-app] #4540 >= #4176 #1503
[assign] #4167 justification -1: p51
[end-of-instance]
[assign] #2929 clause p148 (not p147)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[assign] #4540 clause p149 (not p147)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[mk-app] #4170 = #3271 #4151
[attach-meaning] #176 arith (- 1)
[mk-app] #4177 * #176 #4151
[mk-app] #4541 + #3271 #4177
[mk-app] #3494 <= #4541 #36
[mk-app] #3837 >= #4541 #36
[assign] #4170 justification -1: p145
[attach-enode] #4170 0
[attach-enode] #4177 0
[attach-enode] #4541 0
[assign] #3494 justification -1: p150
[assign] #3837 justification -1: p150
[new-match] 0x10682c6f0 #1495 #1483 #3958 #1545 ; #3264 (#4562 #4562)
[mk-app] #3838 = #3264 #3765
[mk-app] #3495 = #3264 #4156
[mk-app] #3496 = #3838 #3495
[mk-proof] #3499 monotonicity #4162 #3496
[mk-app] #4508 or #1563 #3495
[mk-app] #4509 or #1563 #3838
[mk-proof] #3510 quant-inst #4509
[mk-app] #3081 = #4509 #4508
[mk-proof] #3082 monotonicity #3499 #3081
[mk-app] #3614 = #4508 #4508
[mk-proof] #3615 rewrite #3614
[mk-proof] #3613 trans #3082 #3615 #3081
[mk-proof] #3616 mp #3510 #3613 #4508
[instance] 0x10682c6f0 #3510 ; 17
[attach-enode] #3767 17
[attach-enode] #4156 17
[attach-enode] #3495 17
[assign] #3495 justification -1: p50
[end-of-instance]
[eq-expl] #3767 root
[new-match] 0x10682c990 #1477 #1476 #3767 #1545 ; #4156
[eq-expl] #3264 lit #3495 ; #4156
[eq-expl] #4156 root
[new-match] 0x10682c9c8 #1522 #1506 #3767 #1545 ; #3268 (#3264 #4156)
[mk-app] #3738 = #4181 #3767
[mk-app] #3739 = #3738 #3738
[mk-proof] #3113 refl #3739
[mk-app] #3114 or #1576 #3738
[mk-proof] #3115 quant-inst #3114
[instance] 0x10682c990 #3115 ; 18
[attach-enode] #4181 18
[attach-enode] #3738 18
[assign] #3738 justification -1: p49
[end-of-instance]
[mk-app] #3739 * #176 #3618
[mk-app] #3113 + #4184 #3739
[mk-app] #3735 = #3113 #1503
[mk-app] #2971 + #3739 #4184
[inst-discovered] theory-solving 0x0 arith# ; #3113
[mk-app] #4049 = #3113 #2971
[mk-proof] #4050 rewrite #4049
[instance] 0x0 #4049
[end-of-instance]
[mk-app] #2972 = #2971 #1503
[mk-app] #2973 = #3735 #2972
[mk-proof] #3644 monotonicity #4050 #2973
[attach-meaning] #176 arith (- 1)
[mk-app] #4055 * #176 #4184
[mk-app] #4056 + #3618 #4055
[attach-meaning] #4108 arith (- 4)
[mk-app] #3411 = #4056 #4108
[inst-discovered] theory-solving 0x0 arith# ; #2972
[mk-app] #3360 = #2972 #3411
[mk-proof] #4221 rewrite #3360
[instance] 0x0 #3360
[end-of-instance]
[mk-app] #4222 = #3735 #3411
[mk-proof] #4217 trans #3644 #4221 #4222
[mk-app] #3352 or #5113 #3411
[mk-app] #3359 or #5113 #3735
[mk-proof] #4218 quant-inst #3359
[mk-app] #4219 = #3359 #3352
[mk-proof] #4220 monotonicity #4217 #4219
[mk-app] #4223 = #3352 #3352
[mk-proof] #4224 rewrite #4223
[mk-proof] #4225 trans #4220 #4224 #4219
[mk-proof] #2984 mp #4218 #4225 #3352
[instance] 0x10682c9c8 #4218 ; 18
[attach-enode] #3618 18
[attach-enode] #4183 18
[attach-enode] #4184 18
[attach-enode] #4055 18
[attach-enode] #4056 18
[attach-enode] #3411 18
[mk-app] #3703 <= #4056 #4108
[mk-app] #2960 >= #4056 #4108
[assign] #3411 justification -1: p51
[end-of-instance]
[assign] #3703 clause p156 (not p155)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[assign] #2960 clause p157 (not p155)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[mk-app] #2985 = #3268 #3618
[attach-meaning] #176 arith (- 1)
[mk-app] #2988 + #3268 #3739
[mk-app] #3225 <= #2988 #36
[mk-app] #3643 >= #2988 #36
[assign] #2985 justification -1: p153
[attach-enode] #2985 0
[attach-enode] #3739 0
[attach-enode] #2988 0
[assign] #3225 justification -1: p158
[assign] #3643 justification -1: p158
[new-match] 0x10682d410 #1495 #1483 #3767 #1545 ; #4183 (#4156 #4156)
[mk-app] #3559 = #4183 #3693
[mk-app] #4135 = #4183 #3698
[mk-app] #3915 = #3559 #4135
[mk-proof] #3005 monotonicity #4564 #3915
[mk-app] #4559 or #1563 #4135
[mk-app] #3002 or #1563 #3559
[mk-proof] #3913 quant-inst #3002
[mk-app] #3914 = #3002 #4559
[mk-proof] #3006 monotonicity #3005 #3914
[mk-app] #3014 = #4559 #4559
[mk-proof] #3034 rewrite #3014
[mk-proof] #3994 trans #3006 #3034 #3914
[mk-proof] #3995 mp #3913 #3994 #4559
[instance] 0x10682d410 #3913 ; 19
[attach-enode] #3695 19
[attach-enode] #3698 19
[attach-enode] #4135 19
[assign] #4135 justification -1: p50
[end-of-instance]
[eq-expl] #3695 root
[new-match] 0x10682d6b0 #1477 #1476 #3695 #1545 ; #3698
[eq-expl] #4183 lit #4135 ; #3698
[eq-expl] #3698 root
[new-match] 0x10682d6e8 #1522 #1506 #3695 #1545 ; #4184 (#4183 #3698)
[mk-app] #3988 = #3083 #3695
[mk-app] #3254 = #3988 #3988
[mk-proof] #3993 refl #3254
[mk-app] #3996 or #1576 #3988
[mk-proof] #3255 quant-inst #3996
[instance] 0x10682d6b0 #3255 ; 20
[attach-enode] #3083 20
[attach-enode] #3988 20
[assign] #3988 justification -1: p49
[end-of-instance]
[mk-app] #3254 * #176 #3089
[mk-app] #3993 + #3086 #3254
[mk-app] #3250 = #3993 #1503
[mk-app] #3253 = #3250 #3250
[mk-proof] #4001 refl #3253
[mk-app] #4007 or #5113 #3250
[mk-proof] #3279 quant-inst #4007
[instance] 0x10682d6e8 #3279 ; 20
[attach-enode] #3085 20
[attach-enode] #3086 20
[attach-enode] #3089 20
[attach-enode] #3254 20
[attach-enode] #3993 20
[attach-enode] #3250 20
[mk-app] #4277 <= #3993 #1503
[mk-app] #4278 >= #3993 #1503
[assign] #3250 justification -1: p51
[end-of-instance]
[assign] #4277 clause p164 (not p163)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[assign] #4278 clause p165 (not p163)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[mk-app] #3253 = #3089 #4184
[attach-meaning] #176 arith (- 1)
[mk-app] #4001 + #3089 #4055
[mk-app] #3574 <= #4001 #36
[mk-app] #3592 >= #4001 #36
[assign] #3253 justification -1: p161
[attach-enode] #3253 0
[attach-enode] #4001 0
[assign] #3574 justification -1: p166
[assign] #3592 justification -1: p166
[new-match] 0x1068320d0 #1495 #1483 #3695 #1545 ; #3085 (#3698 #3698)
[mk-app] #3593 = #3085 #3105
[mk-app] #4276 = #3085 #3111
[mk-app] #4279 = #3593 #4276
[mk-proof] #4274 monotonicity #3110 #4279
[mk-app] #4275 or #1563 #4276
[mk-app] #4280 or #1563 #3593
[mk-proof] #4281 quant-inst #4280
[mk-app] #4282 = #4280 #4275
[mk-proof] #4180 monotonicity #4274 #4282
[mk-app] #4288 = #4275 #4275
[mk-proof] #3825 rewrite #4288
[mk-proof] #4588 trans #4180 #3825 #4282
[mk-proof] #4589 mp #4281 #4588 #4275
[instance] 0x1068320d0 #4281 ; 21
[attach-enode] #3107 21
[attach-enode] #3111 21
[attach-enode] #4276 21
[assign] #4276 justification -1: p50
[end-of-instance]
[eq-expl] #3107 root
[new-match] 0x106832370 #1477 #1476 #3107 #1545 ; #3111
[eq-expl] #3085 lit #4276 ; #3111
[eq-expl] #3111 root
[new-match] 0x1068323a8 #1522 #1506 #3107 #1545 ; #3086 (#3085 #3111)
[mk-app] #3622 = #4051 #3107
[mk-app] #3125 = #3622 #3622
[mk-proof] #3123 refl #3125
[mk-app] #3836 or #1576 #3622
[mk-proof] #3168 quant-inst #3836
[instance] 0x106832370 #3168 ; 22
[attach-enode] #4051 22
[attach-enode] #3622 22
[assign] #3622 justification -1: p49
[end-of-instance]
[mk-app] #3125 * #176 #4057
[mk-app] #3123 + #4054 #3125
[mk-app] #3169 = #3123 #1503
[mk-app] #3137 = #3169 #3169
[mk-proof] #3139 refl #3137
[mk-app] #3147 or #5113 #3169
[mk-proof] #3171 quant-inst #3147
[instance] 0x1068323a8 #3171 ; 22
[attach-enode] #4053 22
[attach-enode] #4054 22
[attach-enode] #4057 22
[attach-enode] #3125 22
[attach-enode] #3123 22
[attach-enode] #3169 22
[mk-app] #3170 <= #3123 #1503
[mk-app] #3172 >= #3123 #1503
[assign] #3169 justification -1: p51
[end-of-instance]
[assign] #3170 clause p172 (not p171)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[assign] #3172 clause p173 (not p171)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[mk-app] #3137 = #3086 #4057
[attach-meaning] #176 arith (- 1)
[mk-app] #3139 + #3086 #3125
[mk-app] #3174 <= #3139 #36
[mk-app] #3743 >= #3139 #36
[assign] #3137 justification -1: p169
[attach-enode] #3137 0
[attach-enode] #3139 0
[assign] #3174 justification -1: p174
[assign] #3743 justification -1: p174
[new-match] 0x106832d68 #1495 #1483 #3107 #1545 ; #4053 (#3111 #3111)
[mk-app] #3744 = #4053 #4072
[mk-app] #4083 = #4053 #3326
[mk-app] #4565 = #3744 #4083
[mk-proof] #3524 monotonicity #3328 #4565
[mk-app] #3515 or #1563 #4083
[mk-app] #3611 or #1563 #3744
[mk-proof] #3612 quant-inst #3611
[mk-app] #3617 = #3611 #3515
[mk-proof] #3516 monotonicity #3524 #3617
[mk-app] #3517 = #3515 #3515
[mk-proof] #3737 rewrite #3517
[mk-proof] #4460 trans #3516 #3737 #3617
[mk-proof] #4467 mp #3612 #4460 #3515
[instance] 0x106832d68 #3612 ; 23
[attach-enode] #4510 23
[attach-enode] #3326 23
[attach-enode] #4083 23
[assign] #4083 justification -1: p50
[end-of-instance]
[eq-expl] #4510 root
[new-match] 0x106833008 #1477 #1476 #4510 #1545 ; #3326
[eq-expl] #4053 lit #4083 ; #3326
[eq-expl] #3326 root
[new-match] 0x106833040 #1522 #1506 #4510 #1545 ; #4054 (#4053 #3326)
[mk-app] #4454 = #3344 #4510
[mk-app] #4449 = #4454 #4454
[mk-proof] #4455 refl #4449
[mk-app] #4456 or #1576 #4454
[mk-proof] #3444 quant-inst #4456
[instance] 0x106833008 #3444 ; 24
[attach-enode] #3344 24
[attach-enode] #4454 24
[assign] #4454 justification -1: p49
[end-of-instance]
[mk-app] #4449 * #176 #3353
[mk-app] #4455 + #3347 #4449
[mk-app] #3445 = #4455 #1503
[mk-app] #3438 = #3445 #3445
[mk-proof] #3439 refl #3438
[mk-app] #3440 or #5113 #3445
[mk-proof] #3442 quant-inst #3440
[instance] 0x106833040 #3442 ; 24
[attach-enode] #3346 24
[attach-enode] #3347 24
[attach-enode] #3353 24
[attach-enode] #4449 24
[attach-enode] #4455 24
[attach-enode] #3445 24
[mk-app] #4064 <= #4455 #1503
[mk-app] #3854 >= #4455 #1503
[assign] #3445 justification -1: p51
[end-of-instance]
[assign] #4064 clause p180 (not p179)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[assign] #3854 clause p181 (not p179)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[mk-app] #3438 = #3353 #4054
[attach-meaning] #176 arith (- 1)
[mk-app] #3439 * #176 #4054
[mk-app] #3855 + #3353 #3439
[mk-app] #4065 <= #3855 #36
[mk-app] #3333 >= #3855 #36
[assign] #3438 justification -1: p177
[attach-enode] #3438 0
[attach-enode] #3439 0
[attach-enode] #3855 0
[assign] #4065 justification -1: p182
[assign] #3333 justification -1: p182
[new-match] 0x106833a88 #1495 #1483 #4510 #1545 ; #3346 (#3326 #3326)
[mk-app] #3330 = #3346 #3783
[mk-app] #4362 = #3346 #3788
[mk-app] #4363 = #3330 #4362
[mk-proof] #3351 monotonicity #4216 #4363
[mk-app] #4248 or #1563 #4362
[mk-app] #4249 or #1563 #3330
[mk-proof] #3808 quant-inst #4249
[mk-app] #3809 = #4249 #4248
[mk-proof] #4475 monotonicity #3351 #3809
[mk-app] #4476 = #4248 #4248
[mk-proof] #3810 rewrite #4476
[mk-proof] #4247 trans #4475 #3810 #3809
[mk-proof] #4250 mp #3808 #4247 #4248
[instance] 0x106833a88 #3808 ; 25
[attach-enode] #3785 25
[attach-enode] #3788 25
[attach-enode] #4362 25
[assign] #4362 justification -1: p50
[end-of-instance]
[eq-expl] #3785 root
[new-match] 0x106833d28 #1477 #1476 #3785 #1545 ; #3788
[eq-expl] #3346 lit #4362 ; #3788
[eq-expl] #3788 root
[new-match] 0x106833d60 #1522 #1506 #3785 #1545 ; #3347 (#3346 #3788)
[mk-app] #4251 = #4233 #3785
[mk-app] #4252 = #4251 #4251
[mk-proof] #4253 refl #4252
[mk-app] #4226 or #1576 #4251
[mk-proof] #2922 quant-inst #4226
[instance] 0x106833d28 #2922 ; 26
[attach-enode] #4233 26
[attach-enode] #4251 26
[assign] #4251 justification -1: p49
[end-of-instance]
[mk-app] #4252 * #176 #4240
[mk-app] #4253 + #4237 #4252
[mk-app] #2923 = #4253 #1503
[mk-app] #4231 = #2923 #2923
[mk-proof] #4232 refl #4231
[mk-app] #4592 or #5113 #2923
[mk-proof] #3774 quant-inst #4592
[instance] 0x106833d60 #3774 ; 26
[attach-enode] #4235 26
[attach-enode] #4237 26
[attach-enode] #4240 26
[attach-enode] #4252 26
[attach-enode] #4253 26
[attach-enode] #2923 26
[mk-app] #3935 <= #4253 #1503
[mk-app] #3706 >= #4253 #1503
[assign] #2923 justification -1: p51
[end-of-instance]
[assign] #3935 clause p188 (not p187)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[assign] #3706 clause p189 (not p187)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[mk-app] #4231 = #3347 #4240
[attach-meaning] #176 arith (- 1)
[mk-app] #4232 + #3347 #4252
[mk-app] #3920 <= #4232 #36
[mk-app] #3577 >= #4232 #36
[assign] #4231 justification -1: p185
[attach-enode] #4231 0
[attach-enode] #4232 0
[assign] #3920 justification -1: p190
[assign] #3577 justification -1: p190
[new-match] 0x10683b398 #1495 #1483 #3785 #1545 ; #4235 (#3788 #3788)
[mk-app] #3922 = #4235 #2952
[mk-app] #4522 = #4235 #2957
[mk-app] #3918 = #3922 #4522
[mk-proof] #3919 monotonicity #2959 #3918
[mk-app] #3578 or #1563 #4522
[mk-app] #3584 or #1563 #3922
[mk-proof] #3449 quant-inst #3584
[mk-app] #3048 = #3584 #3578
[mk-proof] #3049 monotonicity #3919 #3048
[mk-app] #3044 = #3578 #3578
[mk-proof] #4558 rewrite #3044
[mk-proof] #3047 trans #3049 #4558 #3048
[mk-proof] #3050 mp #3449 #3047 #3578
[instance] 0x10683b398 #3449 ; 27
[attach-enode] #2954 27
[attach-enode] #2957 27
[attach-enode] #4522 27
[assign] #4522 justification -1: p50
[end-of-instance]
[eq-expl] #2954 root
[new-match] 0x10683b638 #1477 #1476 #2954 #1545 ; #2957
[eq-expl] #4235 lit #4522 ; #2957
[eq-expl] #2957 root
[new-match] 0x10683b670 #1522 #1506 #2954 #1545 ; #4237 (#4235 #2957)
[mk-app] #3003 = #3638 #2954
[mk-app] #3004 = #3003 #3003
[mk-proof] #3007 refl #3004
[mk-app] #3051 or #1576 #3003
[mk-proof] #3447 quant-inst #3051
[instance] 0x10683b638 #3447 ; 28
[attach-enode] #3638 28
[attach-enode] #3003 28
[assign] #3003 justification -1: p49
[end-of-instance]
[mk-app] #3004 * #176 #4500
[mk-app] #3007 + #3641 #3004
[mk-app] #3987 = #3007 #1503
[mk-app] #3796 = #3987 #3987
[mk-proof] #4583 refl #3796
[mk-app] #4399 or #5113 #3987
[mk-proof] #4397 quant-inst #4399
[instance] 0x10683b670 #4397 ; 28
[attach-enode] #3640 28
[attach-enode] #3641 28
[attach-enode] #4500 28
[attach-enode] #3004 28
[attach-enode] #3007 28
[attach-enode] #3987 28
[mk-app] #4398 <= #3007 #1503
[mk-app] #3795 >= #3007 #1503
[assign] #3987 justification -1: p51
[end-of-instance]
[assign] #4398 clause p196 (not p195)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[assign] #3795 clause p197 (not p195)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[mk-app] #3796 = #4237 #4500
[attach-meaning] #176 arith (- 1)
[mk-app] #4583 + #4237 #3004
[mk-app] #3790 <= #4583 #36
[mk-app] #4550 >= #4583 #36
[assign] #3796 justification -1: p193
[attach-enode] #3796 0
[attach-enode] #4583 0
[assign] #3790 justification -1: p198
[assign] #4550 justification -1: p198
[new-match] 0x10683c030 #1495 #1483 #2954 #1545 ; #3640 (#2957 #2957)
[mk-app] #4551 = #3640 #3570
[mk-app] #4258 = #3640 #3910
[mk-app] #4259 = #4551 #4258
[mk-proof] #4260 monotonicity #3912 #4259
[mk-app] #4526 or #1563 #4258
[mk-app] #4264 or #1563 #4551
[mk-proof] #4269 quant-inst #4264
[mk-app] #4527 = #4264 #4526
[mk-proof] #3628 monotonicity #4260 #4527
[mk-app] #3575 = #4526 #4526
[mk-proof] #4270 rewrite #3575
[mk-proof] #3460 trans #3628 #4270 #4527
[mk-proof] #3378 mp #4269 #3460 #4526
[instance] 0x10683c030 #4269 ; 29
[attach-enode] #3572 29
[attach-enode] #3910 29
[attach-enode] #4258 29
[assign] #4258 justification -1: p50
[end-of-instance]
[eq-expl] #3572 root
[new-match] 0x10683c2d0 #1477 #1476 #3572 #1545 ; #3910
[eq-expl] #3640 lit #4258 ; #3910
[eq-expl] #3910 root
[new-match] 0x10683c308 #1522 #1506 #3572 #1545 ; #3641 (#3640 #3910)
[mk-app] #3926 = #3009 #3572
[mk-app] #3927 = #3926 #3926
[mk-proof] #3843 refl #3927
[mk-app] #3844 or #1576 #3926
[mk-proof] #4594 quant-inst #3844
[instance] 0x10683c2d0 #4594 ; 30
[attach-enode] #3009 30
[attach-enode] #3926 30
[assign] #3926 justification -1: p49
[end-of-instance]
[mk-app] #3927 * #176 #3015
[mk-app] #3843 + #3012 #3927
[mk-app] #4595 = #3843 #1503
[mk-app] #3928 = #4595 #4595
[mk-proof] #3929 refl #3928
[mk-app] #3458 or #5113 #4595
[mk-proof] #3459 quant-inst #3458
[instance] 0x10683c308 #3459 ; 30
[attach-enode] #3011 30
[attach-enode] #3012 30
[attach-enode] #3015 30
[attach-enode] #3927 30
[attach-enode] #3843 30
[attach-enode] #4595 30
[mk-app] #3462 <= #3843 #1503
[mk-app] #3463 >= #3843 #1503
[assign] #4595 justification -1: p51
[end-of-instance]
[assign] #3462 clause p204 (not p203)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[assign] #3463 clause p205 (not p203)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[mk-app] #3928 = #3015 #3641
[attach-meaning] #176 arith (- 1)
[mk-app] #3929 * #176 #3641
[mk-app] #4294 + #3015 #3929
[mk-app] #3479 <= #4294 #36
[mk-app] #3480 >= #4294 #36
[assign] #3928 justification -1: p201
[attach-enode] #3928 0
[attach-enode] #3929 0
[attach-enode] #4294 0
[assign] #3479 justification -1: p206
[assign] #3480 justification -1: p206
[new-match] 0x106840f78 #1495 #1483 #3572 #1545 ; #3011 (#3910 #3910)
[mk-app] #4295 = #3011 #3042
[mk-app] #4553 = #3011 #3725
[mk-app] #3126 = #4295 #4553
[mk-proof] #3604 monotonicity #3727 #3126
[mk-app] #3605 or #1563 #4553
[mk-app] #3131 or #1563 #4295
[mk-proof] #4537 quant-inst #3131
[mk-app] #3052 = #3131 #3605
[mk-proof] #3066 monotonicity #3604 #3052
[mk-app] #3067 = #3605 #3605
[mk-proof] #3610 rewrite #3067
[mk-proof] #4536 trans #3066 #3610 #3052
[mk-proof] #3056 mp #4537 #4536 #3605
[instance] 0x106840f78 #4537 ; 31
[attach-enode] #3722 31
[attach-enode] #3725 31
[attach-enode] #4553 31
[assign] #4553 justification -1: p50
[end-of-instance]
[eq-expl] #3722 root
[new-match] 0x106841218 #1477 #1476 #3722 #1545 ; #3725
[eq-expl] #3011 lit #4553 ; #3725
[eq-expl] #3725 root
[new-match] 0x106841250 #1522 #1506 #3722 #1545 ; #3012 (#3011 #3725)
[mk-app] #3057 = #4002 #3722
[mk-app] #4020 = #3057 #3057
[mk-proof] #4021 refl #4020
[mk-app] #3059 or #1576 #3057
[mk-proof] #3060 quant-inst #3059
[instance] 0x106841218 #3060 ; 32
[attach-enode] #4002 32
[attach-enode] #3057 32
[assign] #3057 justification -1: p49
[end-of-instance]
[mk-app] #4020 * #176 #4009
[mk-app] #4021 + #4005 #4020
[mk-app] #3175 = #4021 #1503
[mk-app] #3068 = #3175 #3175
[mk-proof] #3069 refl #3068
[mk-app] #3176 or #5113 #3175
[mk-proof] #3742 quant-inst #3176
[instance] 0x106841250 #3742 ; 32
[attach-enode] #4004 32
[attach-enode] #4005 32
[attach-enode] #4009 32
[attach-enode] #4020 32
[attach-enode] #4021 32
[attach-enode] #3175 32
[mk-app] #4074 <= #4021 #1503
[mk-app] #3070 >= #4021 #1503
[assign] #3175 justification -1: p51
[end-of-instance]
[assign] #4074 clause p212 (not p211)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[assign] #3070 clause p213 (not p211)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[mk-app] #3068 = #3012 #4009
[attach-meaning] #176 arith (- 1)
[mk-app] #3069 + #3012 #4020
[mk-app] #3071 <= #3069 #36
[mk-app] #3514 >= #3069 #36
[assign] #3068 justification -1: p209
[attach-enode] #3068 0
[attach-enode] #3069 0
[assign] #3071 justification -1: p214
[assign] #3514 justification -1: p214
[new-match] 0x106841c10 #1495 #1483 #3722 #1545 ; #4004 (#3725 #3725)
[mk-app] #4027 = #4004 #3624
[mk-app] #4032 = #4004 #3633
[mk-app] #4019 = #4027 #4032
[mk-proof] #4024 monotonicity #3631 #4019
[mk-app] #4025 or #1563 #4032
[mk-app] #4026 or #1563 #4027
[mk-proof] #4033 quant-inst #4026
[mk-app] #3304 = #4026 #4025
[mk-proof] #3305 monotonicity #4024 #3304
[mk-app] #3298 = #4025 #4025
[mk-proof] #3299 rewrite #3298
[mk-proof] #3300 trans #3305 #3299 #3304
[mk-proof] #4450 mp #4033 #3300 #4025
[instance] 0x106841c10 #4033 ; 33
[attach-enode] #3632 33
[attach-enode] #3633 33
[attach-enode] #4032 33
[assign] #4032 justification -1: p50
[end-of-instance]
[eq-expl] #3632 root
[new-match] 0x106841eb0 #1477 #1476 #3632 #1545 ; #3633
[eq-expl] #4004 lit #4032 ; #3633
[eq-expl] #3633 root
[new-match] 0x106841ee8 #1522 #1506 #3632 #1545 ; #4005 (#4004 #3633)
[mk-app] #3310 = #3596 #3632
[mk-app] #3311 = #3310 #3310
[mk-proof] #4451 refl #3311
[mk-app] #4452 or #1576 #3310
[mk-proof] #4457 quant-inst #4452
[instance] 0x106841eb0 #4457 ; 34
[attach-enode] #3596 34
[attach-enode] #3310 34
[assign] #3310 justification -1: p49
[end-of-instance]
[mk-app] #3311 * #176 #3370
[mk-app] #4451 + #3367 #3311
[mk-app] #3316 = #4451 #1503
[mk-app] #3317 = #3316 #3316
[mk-proof] #3441 refl #3317
[mk-app] #3880 or #5113 #3316
[mk-proof] #3824 quant-inst #3880
[instance] 0x106841ee8 #3824 ; 34
[attach-enode] #4533 34
[attach-enode] #3367 34
[attach-enode] #3370 34
[attach-enode] #3311 34
[attach-enode] #4451 34
[attach-enode] #3316 34
[mk-app] #4206 <= #4451 #1503
[mk-app] #3820 >= #4451 #1503
[assign] #3316 justification -1: p51
[end-of-instance]
[assign] #4206 clause p220 (not p219)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[assign] #3820 clause p221 (not p219)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[mk-app] #3317 = #3370 #4005
[attach-meaning] #176 arith (- 1)
[mk-app] #3441 * #176 #4005
[mk-app] #3821 + #3370 #3441
[mk-app] #3879 <= #3821 #36
[mk-app] #4570 >= #3821 #36
[assign] #3317 justification -1: p217
[attach-enode] #3317 0
[attach-enode] #3441 0
[attach-enode] #3821 0
[assign] #3879 justification -1: p222
[assign] #4570 justification -1: p222
[new-match] 0x106842930 #1495 #1483 #3632 #1545 ; #4533 (#3633 #3633)
[mk-app] #3822 = #4533 #3798
[mk-app] #3823 = #4533 #3803
[mk-app] #4571 = #3822 #3823
[mk-proof] #3597 monotonicity #4273 #4571
[mk-app] #3598 or #1563 #3823
[mk-app] #4370 or #1563 #3822
[mk-proof] #3961 quant-inst #4370
[mk-app] #3963 = #4370 #3598
[mk-proof] #4371 monotonicity #3597 #3963
[mk-app] #3542 = #3598 #3598
[mk-proof] #3539 rewrite #3542
[mk-proof] #3964 trans #4371 #3539 #3963
[mk-proof] #2995 mp #3961 #3964 #3598
[instance] 0x106842930 #3961 ; 35
[attach-enode] #3800 35
[attach-enode] #3803 35
[attach-enode] #3823 35
[assign] #3823 justification -1: p50
[end-of-instance]
[eq-expl] #3800 root
[new-match] 0x106842bd0 #1477 #1476 #3800 #1545 ; #3803
[eq-expl] #4533 lit #3823 ; #3803
[eq-expl] #3803 root
[new-match] 0x106827e20 #1522 #1506 #3800 #1545 ; #3367 (#4533 #3803)
[mk-app] #3902 = #4289 #3800
[mk-app] #3717 = #3902 #3902
[mk-proof] #3718 refl #3717
[mk-app] #3001 or #1576 #3902
[mk-proof] #3714 quant-inst #3001
[instance] 0x106842bd0 #3714 ; 36
[attach-enode] #4289 36
[attach-enode] #3902 36
[assign] #3902 justification -1: p49
[end-of-instance]
[mk-app] #3717 * #176 #4297
[mk-app] #3718 + #4293 #3717
[mk-app] #3715 = #3718 #1503
[mk-app] #3716 = #3715 #3715
[mk-proof] #3719 refl #3716
[mk-app] #3720 or #5113 #3715
[mk-proof] #3965 quant-inst #3720
[instance] 0x106827e20 #3965 ; 36
[attach-enode] #4292 36
[attach-enode] #4293 36
[attach-enode] #4297 36
[attach-enode] #3717 36
[attach-enode] #3718 36
[attach-enode] #3715 36
[mk-app] #3966 <= #3718 #1503
[mk-app] #3967 >= #3718 #1503
[assign] #3715 justification -1: p51
[end-of-instance]
[assign] #3966 clause p228 (not p227)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[assign] #3967 clause p229 (not p227)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[mk-app] #3716 = #3367 #4297
[attach-meaning] #176 arith (- 1)
[mk-app] #3719 + #3367 #3717
[mk-app] #3968 <= #3719 #36
[mk-app] #4254 >= #3719 #36
[assign] #3716 justification -1: p225
[attach-enode] #3716 0
[attach-enode] #3719 0
[assign] #3968 justification -1: p230
[assign] #4254 justification -1: p230
[new-match] 0x1068287e0 #1495 #1483 #3800 #1545 ; #4292 (#3803 #3803)
[mk-app] #3197 = #4292 #3831
[mk-app] #3207 = #4292 #3118
[mk-app] #4255 = #3197 #3207
[mk-proof] #4304 monotonicity #3120 #4255
[mk-app] #4315 or #1563 #3207
[mk-app] #3188 or #1563 #3197
[mk-proof] #3189 quant-inst #3188
[mk-app] #3681 = #3188 #4315
[mk-proof] #4109 monotonicity #4304 #3681
[mk-app] #4110 = #4315 #4315
[mk-proof] #3753 rewrite #4110
[mk-proof] #3222 trans #4109 #3753 #3681
[mk-proof] #3749 mp #3189 #3222 #4315
[instance] 0x1068287e0 #3189 ; 37
[attach-enode] #4573 37
[attach-enode] #3118 37
[attach-enode] #3207 37
[assign] #3207 justification -1: p50
[end-of-instance]
[eq-expl] #4573 root
[new-match] 0x106828a80 #1477 #1476 #4573 #1545 ; #3118
[eq-expl] #4292 lit #3207 ; #3118
[eq-expl] #3118 root
[new-match] 0x106828ab8 #1522 #1506 #4573 #1545 ; #4293 (#4292 #3118)
[mk-app] #3750 = #3133 #4573
[mk-app] #4123 = #3750 #3750
[mk-proof] #4514 refl #4123
[mk-app] #3668 or #1576 #3750
[mk-proof] #3669 quant-inst #3668
[instance] 0x106828a80 #3669 ; 38
[attach-enode] #3133 38
[attach-enode] #3750 38
[assign] #3750 justification -1: p49
[end-of-instance]
[mk-app] #4123 * #176 #3140
[mk-app] #4514 + #3136 #4123
[mk-app] #3657 = #4514 #1503
[mk-app] #4504 = #3657 #3657
[mk-proof] #3921 refl #4504
[mk-app] #3670 or #5113 #3657
[mk-proof] #3671 quant-inst #3670
[instance] 0x106828ab8 #3671 ; 38
[attach-enode] #3135 38
[attach-enode] #3136 38
[attach-enode] #3140 38
[attach-enode] #4123 38
[attach-enode] #4514 38
[attach-enode] #3657 38
[mk-app] #4523 <= #4514 #1503
[mk-app] #3576 >= #4514 #1503
[assign] #3657 justification -1: p51
[end-of-instance]
[assign] #4523 clause p236 (not p235)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[assign] #3576 clause p237 (not p235)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[mk-app] #4504 = #3140 #4293
[attach-meaning] #176 arith (- 1)
[mk-app] #3921 * #176 #4293
[mk-app] #3579 + #3140 #3921
[mk-app] #4586 <= #3579 #36
[mk-app] #4587 >= #3579 #36
[assign] #4504 justification -1: p233
[attach-enode] #4504 0
[attach-enode] #3921 0
[attach-enode] #3579 0
[assign] #4586 justification -1: p238
[assign] #4587 justification -1: p238
[new-match] 0x106829500 #1495 #1483 #4573 #1545 ; #3135 (#3118 #3118)
[mk-app] #3043 = #3135 #3158
[mk-app] #4655 = #3135 #3165
[mk-app] #4656 = #3043 #4655
[mk-proof] #4620 monotonicity #3167 #4656
[mk-app] #4621 or #1563 #4655
[mk-app] #4653 or #1563 #3043
[mk-proof] #4654 quant-inst #4653
[mk-app] #4651 = #4653 #4621
[mk-proof] #4652 monotonicity #4620 #4651
[mk-app] #4657 = #4621 #4621
[mk-proof] #4658 rewrite #4657
[mk-proof] #4659 trans #4652 #4658 #4651
[mk-proof] #4660 mp #4654 #4659 #4621
[instance] 0x106829500 #4654 ; 39
[attach-enode] #3161 39
[attach-enode] #3165 39
[attach-enode] #4655 39
[assign] #4655 justification -1: p50
[end-of-instance]
[eq-expl] #3161 root
[new-match] 0x1068297a0 #1477 #1476 #3161 #1545 ; #3165
[eq-expl] #3135 lit #4655 ; #3165
[eq-expl] #3165 root
[new-match] 0x1068297d8 #1522 #1506 #3161 #1545 ; #3136 (#3135 #3165)
[mk-app] #3453 = #3745 #3161
[mk-app] #4676 = #3453 #3453
[mk-proof] #4694 refl #4676
[mk-app] #3454 or #1576 #3453
[mk-proof] #3455 quant-inst #3454
[instance] 0x1068297a0 #3455 ; 40
[attach-enode] #3745 40
[attach-enode] #3453 40
[assign] #3453 justification -1: p49
[end-of-instance]
[mk-app] #4676 * #176 #4076
[mk-app] #4694 + #3748 #4676
[mk-app] #4400 = #4694 #1503
[mk-app] #4692 = #4400 #4400
[mk-proof] #4693 refl #4692
[mk-app] #4408 or #5113 #4400
[mk-proof] #4731 quant-inst #4408
[instance] 0x1068297d8 #4731 ; 40
[attach-enode] #3747 40
[attach-enode] #3748 40
[attach-enode] #4076 40
[attach-enode] #4676 40
[attach-enode] #4694 40
[attach-enode] #4400 40
[mk-app] #4732 <= #4694 #1503
[mk-app] #4714 >= #4694 #1503
[assign] #4400 justification -1: p51
[end-of-instance]
[assign] #4732 clause p244 (not p243)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[assign] #4714 clause p245 (not p243)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[mk-app] #4692 = #3136 #4076
[attach-meaning] #176 arith (- 1)
[mk-app] #4693 + #3136 #4676
[mk-app] #4734 <= #4693 #36
[mk-app] #4729 >= #4693 #36
[assign] #4692 justification -1: p241
[attach-enode] #4692 0
[attach-enode] #4693 0
[assign] #4734 justification -1: p246
[assign] #4729 justification -1: p246
[new-match] 0x106859ba8 #1495 #1483 #3161 #1545 ; #3747 (#3165 #3165)
[mk-app] #4730 = #3747 #4093
[mk-app] #4735 = #3747 #4100
[mk-app] #4739 = #4730 #4735
[mk-proof] #4740 monotonicity #4102 #4739
[mk-app] #4779 or #1563 #4735
[mk-app] #4784 or #1563 #4730
[mk-proof] #4746 quant-inst #4784
[mk-app] #4265 = #4784 #4779
[mk-proof] #4772 monotonicity #4740 #4265
[mk-app] #4773 = #4779 #4779
[mk-proof] #4267 rewrite #4773
[mk-proof] #4268 trans #4772 #4267 #4265
[mk-proof] #4271 mp #4746 #4268 #4779
[instance] 0x106859ba8 #4746 ; 41
[attach-enode] #4096 41
[attach-enode] #4100 41
[attach-enode] #4735 41
[assign] #4735 justification -1: p50
[end-of-instance]
[eq-expl] #4096 root
[new-match] 0x106859e48 #1477 #1476 #4096 #1545 ; #4100
[eq-expl] #3747 lit #4735 ; #4100
[eq-expl] #4100 root
[new-match] 0x106859e80 #1522 #1506 #4096 #1545 ; #3748 (#3747 #4100)
[mk-app] #4811 = #3520 #4096
[mk-app] #4812 = #4811 #4811
[mk-proof] #4753 refl #4812
[mk-app] #4754 or #1576 #4811
[mk-proof] #4768 quant-inst #4754
[instance] 0x106859e48 #4768 ; 42
[attach-enode] #3520 42
[attach-enode] #4811 42
[assign] #4811 justification -1: p49
[end-of-instance]
[mk-app] #4812 * #176 #3526
[mk-app] #4753 + #3523 #4812
[mk-app] #4769 = #4753 #1503
[mk-app] #4770 = #4769 #4769
[mk-proof] #4771 refl #4770
[mk-app] #4774 or #5113 #4769
[mk-proof] #4775 quant-inst #4774
[instance] 0x106859e80 #4775 ; 42
[attach-enode] #3522 42
[attach-enode] #3523 42
[attach-enode] #3526 42
[attach-enode] #4812 42
[attach-enode] #4753 42
[attach-enode] #4769 42
[mk-app] #4776 <= #4753 #1503
[mk-app] #4777 >= #4753 #1503
[assign] #4769 justification -1: p51
[end-of-instance]
[assign] #4776 clause p252 (not p251)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[assign] #4777 clause p253 (not p251)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[mk-app] #4770 = #3526 #3748
[attach-meaning] #176 arith (- 1)
[mk-app] #4771 * #176 #3748
[mk-app] #4778 + #3526 #4771
[mk-app] #4785 <= #4778 #36
[mk-app] #4792 >= #4778 #36
[assign] #4770 justification -1: p249
[attach-enode] #4770 0
[attach-enode] #4771 0
[attach-enode] #4778 0
[assign] #4785 justification -1: p254
[assign] #4792 justification -1: p254
[new-match] 0x10685a8c8 #1495 #1483 #4096 #1545 ; #3522 (#4100 #4100)
[mk-app] #4793 = #3522 #3896
[mk-app] #4807 = #3522 #3901
[mk-app] #4832 = #4793 #4807
[mk-proof] #4850 monotonicity #4448 #4832
[mk-app] #4818 or #1563 #4807
[mk-app] #4823 or #1563 #4793
[mk-proof] #4824 quant-inst #4823
[mk-app] #4427 = #4823 #4818
[mk-proof] #4895 monotonicity #4850 #4427
[mk-app] #4896 = #4818 #4818
[mk-proof] #4856 rewrite #4896
[mk-proof] #4857 trans #4895 #4856 #4427
[mk-proof] #4871 mp #4824 #4857 #4818
[instance] 0x10685a8c8 #4824 ; 43
[attach-enode] #3898 43
[attach-enode] #3901 43
[attach-enode] #4807 43
[assign] #4807 justification -1: p50
[end-of-instance]
[eq-expl] #3898 root
[new-match] 0x10685ab68 #1477 #1476 #3898 #1545 ; #3901
[eq-expl] #3522 lit #4807 ; #3901
[eq-expl] #3901 root
[new-match] 0x10685aba0 #1522 #1506 #3898 #1545 ; #3523 (#3522 #3901)
[mk-app] #4889 = #4462 #3898
[mk-app] #4891 = #4889 #4889
[mk-proof] #4892 refl #4891
[mk-app] #4893 or #1576 #4889
[mk-proof] #4894 quant-inst #4893
[instance] 0x10685ab68 #4894 ; 44
[attach-enode] #4462 44
[attach-enode] #4889 44
[assign] #4889 justification -1: p49
[end-of-instance]
[mk-app] #4891 * #176 #4469
[mk-app] #4892 + #4465 #4891
[mk-app] #4901 = #4892 #1503
[mk-app] #4902 = #4901 #4901
[mk-proof] #3053 refl #4902
[mk-app] #4928 or #5113 #4901
[mk-proof] #4929 quant-inst #4928
[instance] 0x10685aba0 #4929 ; 44
[attach-enode] #4464 44
[attach-enode] #4465 44
[attach-enode] #4469 44
[attach-enode] #4891 44
[attach-enode] #4892 44
[attach-enode] #4901 44
[mk-app] #3054 <= #4892 #1503
[mk-app] #3055 >= #4892 #1503
[assign] #4901 justification -1: p51
[end-of-instance]
[assign] #3054 clause p260 (not p259)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[assign] #3055 clause p261 (not p259)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[mk-app] #4902 = #3523 #4469
[attach-meaning] #176 arith (- 1)
[mk-app] #3053 + #3523 #4891
[mk-app] #3058 <= #3053 #36
[mk-app] #4972 >= #3053 #36
[assign] #4902 justification -1: p257
[attach-enode] #4902 0
[attach-enode] #3053 0
[assign] #3058 justification -1: p262
[assign] #4972 justification -1: p262
[new-match] 0x10685b560 #1495 #1483 #3898 #1545 ; #4464 (#3901 #3901)
[mk-app] #4973 = #4464 #3430
[mk-app] #4909 = #4464 #3435
[mk-app] #4910 = #4973 #4909
[mk-proof] #4927 monotonicity #3437 #4910
[mk-app] #4930 or #1563 #4909
[mk-app] #4934 or #1563 #4973
[mk-proof] #4935 quant-inst #4934
[mk-app] #4966 = #4934 #4930
[mk-proof] #4969 monotonicity #4927 #4966
[mk-app] #4968 = #4930 #4930
[mk-proof] #4963 rewrite #4968
[mk-proof] #4964 trans #4969 #4963 #4966
[mk-proof] #4965 mp #4935 #4964 #4930
[instance] 0x10685b560 #4935 ; 45
[attach-enode] #3432 45
[attach-enode] #3435 45
[attach-enode] #4909 45
[assign] #4909 justification -1: p50
[end-of-instance]
[eq-expl] #3432 root
[new-match] 0x106862810 #1477 #1476 #3432 #1545 ; #3435
[eq-expl] #4464 lit #4909 ; #3435
[eq-expl] #3435 root
[new-match] 0x106862848 #1522 #1506 #3432 #1545 ; #4465 (#4464 #3435)
[mk-app] #4970 = #3856 #3432
[mk-app] #4971 = #4970 #4970
[mk-proof] #4974 refl #4971
[mk-app] #4979 or #1576 #4970
[mk-proof] #5006 quant-inst #4979
[instance] 0x106862810 #5006 ; 46
[attach-enode] #3856 46
[attach-enode] #4970 46
[assign] #4970 justification -1: p49
[end-of-instance]
[mk-app] #4971 * #176 #4364
[mk-app] #4974 + #3859 #4971
[mk-app] #5007 = #4974 #1503
[mk-app] #5005 = #5007 #5007
[mk-proof] #5008 refl #5005
[mk-app] #3297 or #5113 #5007
[mk-proof] #5047 quant-inst #3297
[instance] 0x106862848 #5047 ; 46
[attach-enode] #3858 46
[attach-enode] #3859 46
[attach-enode] #4364 46
[attach-enode] #4971 46
[attach-enode] #4974 46
[attach-enode] #5007 46
[mk-app] #5048 <= #4974 #1503
[mk-app] #5041 >= #4974 #1503
[assign] #5007 justification -1: p51
[end-of-instance]
[assign] #5048 clause p268 (not p267)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[assign] #5041 clause p269 (not p267)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[mk-app] #5005 = #4364 #4465
[attach-meaning] #176 arith (- 1)
[mk-app] #5008 * #176 #4465
[mk-app] #5042 + #4364 #5008
[mk-app] #5043 <= #5042 #36
[mk-app] #5044 >= #5042 #36
[assign] #5005 justification -1: p265
[attach-enode] #5005 0
[attach-enode] #5008 0
[attach-enode] #5042 0
[assign] #5043 justification -1: p270
[assign] #5044 justification -1: p270
[new-match] 0x106863290 #1495 #1483 #3432 #1545 ; #3858 (#3435 #3435)
[mk-app] #5052 = #3858 #4379
[mk-app] #5057 = #3858 #4385
[mk-app] #5084 = #5052 #5057
[mk-proof] #5085 monotonicity #4580 #5084
[mk-app] #5091 or #1563 #5057
[mk-app] #5096 or #1563 #5052
[mk-proof] #3776 quant-inst #5096
[mk-app] #5089 = #5096 #5091
[mk-proof] #5090 monotonicity #5085 #5089
[mk-app] #4201 = #5091 #5091
[mk-proof] #4202 rewrite #4201
[mk-proof] #4195 trans #5090 #4202 #5089
[mk-proof] #5097 mp #3776 #4195 #5091
[instance] 0x106863290 #3776 ; 47
[attach-enode] #4382 47
[attach-enode] #4385 47
[attach-enode] #5057 47
[assign] #5057 justification -1: p50
[end-of-instance]
[eq-expl] #4382 root
[new-match] 0x106863530 #1477 #1476 #4382 #1545 ; #4385
[eq-expl] #3858 lit #5057 ; #4385
[eq-expl] #4385 root
[new-match] 0x106863568 #1522 #1506 #4382 #1545 ; #3859 (#3858 #4385)
[mk-app] #5104 = #3550 #4382
[mk-app] #4590 = #5104 #5104
[mk-proof] #3811 refl #4590
[mk-app] #3816 or #1576 #5104
[mk-proof] #2936 quant-inst #3816
[instance] 0x106863530 #2936 ; 48
[attach-enode] #3550 48
[attach-enode] #5104 48
[assign] #5104 justification -1: p49
[end-of-instance]
[mk-app] #4590 * #176 #3903
[mk-app] #3811 + #3553 #4590
[mk-app] #3154 = #3811 #1503
[mk-app] #3159 = #3154 #3154
[mk-proof] #4085 refl #3159
[mk-app] #4006 or #5113 #3154
[mk-proof] #3814 quant-inst #4006
[instance] 0x106863568 #3814 ; 48
[attach-enode] #3552 48
[attach-enode] #3553 48
[attach-enode] #3903 48
[attach-enode] #4590 48
[attach-enode] #3811 48
[attach-enode] #3154 48
[mk-app] #3815 <= #3811 #1503
[mk-app] #3394 >= #3811 #1503
[assign] #3154 justification -1: p51
[end-of-instance]
[assign] #3815 clause p276 (not p275)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[assign] #3394 clause p277 (not p275)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[mk-app] #3159 = #3859 #3903
[attach-meaning] #176 arith (- 1)
[mk-app] #4085 + #3859 #4590
[mk-app] #3817 <= #4085 #36
[mk-app] #4316 >= #4085 #36
[assign] #3159 justification -1: p273
[attach-enode] #3159 0
[attach-enode] #4085 0
[assign] #3817 justification -1: p278
[assign] #4316 justification -1: p278
[new-match] 0x106863f28 #1495 #1483 #4382 #1545 ; #3552 (#4385 #4385)
[mk-app] #3600 = #3552 #4484
[mk-app] #3892 = #3552 #3805
[mk-app] #3893 = #3600 #3892
[mk-proof] #3601 monotonicity #3807 #3893
[mk-app] #2989 or #1563 #3892
[mk-app] #3962 or #1563 #3600
[mk-proof] #3686 quant-inst #3962
[mk-app] #3687 = #3962 #2989
[mk-proof] #3890 monotonicity #3601 #3687
[mk-app] #3891 = #2989 #2989
[mk-proof] #3647 rewrite #3891
[mk-proof] #4518 trans #3890 #3647 #3687
[mk-proof] #4354 mp #3686 #4518 #2989
[instance] 0x106863f28 #3686 ; 49
[attach-enode] #4548 49
[attach-enode] #3805 49
[attach-enode] #3892 49
[assign] #3892 justification -1: p50
[end-of-instance]
[eq-expl] #4548 root
[new-match] 0x1068641c8 #1477 #1476 #4548 #1545 ; #3805
[eq-expl] #3552 lit #3892 ; #3805
[eq-expl] #3805 root
[new-match] 0x106864200 #1522 #1506 #4548 #1545 ; #3553 (#3552 #3805)
[mk-app] #4356 = #4256 #4548
[mk-app] #3248 = #4356 #4356
[mk-proof] #3756 refl #3248
[mk-app] #3246 or #1576 #4356
[mk-proof] #3241 quant-inst #3246
[instance] 0x1068641c8 #3241 ; 50
[attach-enode] #4256 50
[attach-enode] #4356 50
[assign] #4356 justification -1: p49
[end-of-instance]
[mk-app] #3248 * #176 #4307
[mk-app] #3756 + #4303 #3248
[mk-app] #3242 = #3756 #1503
[mk-app] #3247 = #3242 #3242
[mk-proof] #3690 refl #3247
[mk-app] #3691 or #5113 #3242
[mk-proof] #3692 quant-inst #3691
[instance] 0x106864200 #3692 ; 50
[attach-enode] #4302 50
[attach-enode] #4303 50
[attach-enode] #4307 50
[attach-enode] #3248 50
[attach-enode] #3756 50
[attach-enode] #3242 50
[mk-app] #3953 <= #3756 #1503
[mk-app] #3277 >= #3756 #1503
[assign] #3242 justification -1: p51
[end-of-instance]
[assign] #3953 clause p284 (not p283)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[assign] #3277 clause p285 (not p283)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[mk-app] #3247 = #3553 #4307
[attach-meaning] #176 arith (- 1)
[mk-app] #3690 + #3553 #3248
[mk-app] #3282 <= #3690 #36
[mk-app] #2940 >= #3690 #36
[assign] #3247 justification -1: p281
[attach-enode] #3247 0
[attach-enode] #3690 0
[assign] #3282 justification -1: p286
[assign] #2940 justification -1: p286
[new-match] 0x1068675e8 #1495 #1483 #4548 #1545 ; #4302 (#3805 #3805)
[mk-app] #2942 = #4302 #2914
[mk-app] #3187 = #4302 #2919
[mk-app] #3362 = #2942 #3187
[mk-proof] #3363 monotonicity #2921 #3362
[mk-app] #4061 or #1563 #3187
[mk-app] #4062 or #1563 #2942
[mk-proof] #4069 quant-inst #4062
[mk-app] #4070 = #4062 #4061
[mk-proof] #3364 monotonicity #3363 #4070
[mk-app] #3365 = #4061 #4061
[mk-proof] #4246 rewrite #3365
[mk-proof] #2949 trans #3364 #4246 #4070
[mk-proof] #3032 mp #4069 #2949 #4061
[instance] 0x1068675e8 #4069 ; 51
[attach-enode] #2916 51
[attach-enode] #2919 51
[attach-enode] #3187 51
[assign] #3187 justification -1: p50
[end-of-instance]
[eq-expl] #2916 root
[new-match] 0x106867888 #1477 #1476 #2916 #1545 ; #2919
[eq-expl] #4302 lit #3187 ; #2919
[eq-expl] #2919 root
[new-match] 0x1068678c0 #1522 #1506 #2916 #1545 ; #4303 (#4302 #2919)
[mk-app] #3033 = #3685 #2916
[mk-app] #3751 = #3033 #3033
[mk-proof] #3036 refl #3751
[mk-app] #3038 or #1576 #3033
[mk-proof] #3754 quant-inst #3038
[instance] 0x106867888 #3754 ; 52
[attach-enode] #3685 52
[attach-enode] #3033 52
[assign] #3033 justification -1: p49
[end-of-instance]
[mk-app] #3751 * #176 #3775
[mk-app] #3036 + #3772 #3751
[mk-app] #3755 = #3036 #1503
[mk-app] #4112 = #3755 #3755
[mk-proof] #3039 refl #4112
[mk-app] #3037 or #5113 #3755
[mk-proof] #3656 quant-inst #3037
[instance] 0x1068678c0 #3656 ; 52
[attach-enode] #3771 52
[attach-enode] #3772 52
[attach-enode] #3775 52
[attach-enode] #3751 52
[attach-enode] #3036 52
[attach-enode] #3755 52
[mk-app] #3146 <= #3036 #1503
[mk-app] #3151 >= #3036 #1503
[assign] #3755 justification -1: p51
[end-of-instance]
[assign] #3146 clause p292 (not p291)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[assign] #3151 clause p293 (not p291)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[mk-app] #4112 = #3775 #4303
[attach-meaning] #176 arith (- 1)
[mk-app] #3039 * #176 #4303
[mk-app] #3379 + #3775 #3039
[mk-app] #3377 <= #3379 #36
[mk-app] #3381 >= #3379 #36
[assign] #4112 justification -1: p289
[attach-enode] #4112 0
[attach-enode] #3039 0
[attach-enode] #3379 0
[assign] #3377 justification -1: p294
[assign] #3381 justification -1: p294
[new-match] 0x106868308 #1495 #1483 #2916 #1545 ; #3771 (#2919 #2919)
[mk-app] #3382 = #3771 #3945
[mk-app] #3829 = #3771 #4561
[mk-app] #3149 = #3382 #3829
[mk-proof] #3150 monotonicity #3917 #3149
[mk-app] #3145 or #1563 #3829
[mk-app] #3155 or #1563 #3382
[mk-proof] #3156 quant-inst #3155
[mk-app] #4616 = #3155 #3145
[mk-proof] #4080 monotonicity #3150 #4616
[mk-app] #4081 = #3145 #3145
[mk-proof] #4617 rewrite #4081
[mk-proof] #4612 trans #4080 #4617 #4616
[mk-proof] #4615 mp #3156 #4612 #3145
[instance] 0x106868308 #3156 ; 53
[attach-enode] #3947 53
[attach-enode] #4561 53
[attach-enode] #3829 53
[assign] #3829 justification -1: p50
[end-of-instance]
[eq-expl] #3947 root
[new-match] 0x1068685a8 #1477 #1476 #3947 #1545 ; #4561
[eq-expl] #3771 lit #3829 ; #4561
[eq-expl] #4561 root
[new-match] 0x1068685e0 #1522 #1506 #3947 #1545 ; #3772 (#3771 #4561)
[mk-app] #3535 = #3581 #3947
[mk-app] #3530 = #3535 #3535
[mk-proof] #4637 refl #3530
[mk-app] #4478 or #1576 #3535
[mk-proof] #4479 quant-inst #4478
[instance] 0x1068685a8 #4479 ; 54
[attach-enode] #3581 54
[attach-enode] #3535 54
[assign] #3535 justification -1: p49
[end-of-instance]
[mk-app] #3530 * #176 #3585
[mk-app] #4637 + #4529 #3530
[mk-app] #4373 = #4637 #1503
[mk-app] #4368 + #3530 #4529
[inst-discovered] theory-solving 0x0 arith# ; #4637
[mk-app] #4369 = #4637 #4368
[mk-proof] #4377 rewrite #4369
[instance] 0x0 #4369
[end-of-instance]
[mk-app] #3907 = #4368 #1503
[mk-app] #3908 = #4373 #3907
[mk-proof] #4481 monotonicity #4377 #3908
[attach-meaning] #176 arith (- 1)
[mk-app] #4312 * #176 #4529
[mk-app] #4313 + #3585 #4312
[attach-meaning] #4108 arith (- 4)
[mk-app] #3939 = #4313 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3907
[mk-app] #4667 = #3907 #3939
[mk-proof] #3865 rewrite #4667
[instance] 0x0 #4667
[end-of-instance]
[mk-app] #3860 = #4373 #3939
[mk-proof] #4668 trans #4481 #3865 #3860
[mk-app] #4675 or #5113 #3939
[mk-app] #4695 or #5113 #4373
[mk-proof] #3861 quant-inst #4695
[mk-app] #3862 = #4695 #4675
[mk-proof] #4700 monotonicity #4668 #3862
[mk-app] #3484 = #4675 #4675
[mk-proof] #3077 rewrite #3484
[mk-proof] #3881 trans #4700 #3077 #3862
[mk-proof] #3882 mp #3861 #3881 #4675
[instance] 0x1068685e0 #3861 ; 54
[attach-enode] #3585 54
[attach-enode] #4528 54
[attach-enode] #4529 54
[attach-enode] #4312 54
[attach-enode] #4313 54
[attach-enode] #3939 54
[mk-app] #3883 <= #4313 #4108
[mk-app] #3478 >= #4313 #4108
[assign] #3939 justification -1: p51
[end-of-instance]
[assign] #3883 clause p300 (not p299)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[assign] #3478 clause p301 (not p299)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[mk-app] #3075 = #3585 #3772
[attach-meaning] #176 arith (- 1)
[mk-app] #3778 * #176 #3772
[mk-app] #3322 + #3585 #3778
[mk-app] #4047 <= #3322 #36
[mk-app] #3286 >= #3322 #36
[assign] #3075 justification -1: p297
[attach-enode] #3075 0
[attach-enode] #3778 0
[attach-enode] #3322 0
[assign] #4047 justification -1: p302
[assign] #3286 justification -1: p302
[new-match] 0x106869028 #1495 #1483 #3947 #1545 ; #4528 (#4561 #4561)
[mk-app] #3287 = #4528 #4387
[mk-app] #4736 = #4528 #4392
[mk-app] #3779 = #3287 #4736
[mk-proof] #3780 monotonicity #4394 #3779
[mk-app] #4737 or #1563 #4736
[mk-app] #4738 or #1563 #3287
[mk-proof] #4745 quant-inst #4738
[mk-app] #3659 = #4738 #4737
[mk-proof] #3660 monotonicity #3780 #3659
[mk-app] #3777 = #4737 #4737
[mk-proof] #3323 rewrite #3777
[mk-proof] #3781 trans #3660 #3323 #3659
[mk-proof] #4576 mp #4745 #3781 #4737
[instance] 0x106869028 #4745 ; 55
[attach-enode] #4389 55
[attach-enode] #4392 55
[attach-enode] #4736 55
[assign] #4736 justification -1: p50
[end-of-instance]
[eq-expl] #4389 root
[new-match] 0x106847ad8 #1477 #1476 #4389 #1545 ; #4392
[eq-expl] #4528 lit #4736 ; #4392
[eq-expl] #4392 root
[new-match] 0x106847b10 #1522 #1506 #4389 #1545 ; #4529 (#4528 #4392)
[mk-app] #4577 = #4409 #4389
[mk-app] #3673 = #4577 #4577
[mk-proof] #3969 refl #3673
[mk-app] #3973 or #1576 #4577
[mk-proof] #3974 quant-inst #3973
[instance] 0x106847ad8 #3974 ; 56
[attach-enode] #4409 56
[attach-enode] #4577 56
[assign] #4577 justification -1: p49
[end-of-instance]
[mk-app] #3673 * #176 #3791
[mk-app] #3969 + #4582 #3673
[mk-app] #4129 = #3969 #1503
[mk-app] #4130 + #3673 #4582
[inst-discovered] theory-solving 0x0 arith# ; #3969
[mk-app] #3211 = #3969 #4130
[mk-proof] #3212 rewrite #3211
[instance] 0x0 #3211
[end-of-instance]
[mk-app] #3658 = #4130 #1503
[mk-app] #3661 = #4129 #3658
[mk-proof] #4599 monotonicity #3212 #3661
[attach-meaning] #176 arith (- 1)
[mk-app] #4600 * #176 #4582
[mk-app] #4487 + #3791 #4600
[attach-meaning] #4108 arith (- 4)
[mk-app] #4488 = #4487 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3658
[mk-app] #4639 = #3658 #4488
[mk-proof] #4817 rewrite #4639
[instance] 0x0 #4639
[end-of-instance]
[mk-app] #4752 = #4129 #4488
[mk-proof] #4757 trans #4599 #4817 #4752
[mk-app] #4713 or #5113 #4488
[mk-app] #4718 or #5113 #4129
[mk-proof] #4756 quant-inst #4718
[mk-app] #4751 = #4718 #4713
[mk-proof] #4758 monotonicity #4757 #4751
[mk-app] #4794 = #4713 #4713
[mk-proof] #4796 rewrite #4794
[mk-proof] #4797 trans #4758 #4796 #4751
[mk-proof] #4830 mp #4756 #4797 #4713
[instance] 0x106847b10 #4756 ; 56
[attach-enode] #3791 56
[attach-enode] #4411 56
[attach-enode] #4582 56
[attach-enode] #4600 56
[attach-enode] #4487 56
[attach-enode] #4488 56
[mk-app] #4835 <= #4487 #4108
[mk-app] #4853 >= #4487 #4108
[assign] #4488 justification -1: p51
[end-of-instance]
[assign] #4835 clause p308 (not p307)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[assign] #4853 clause p309 (not p307)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[mk-app] #4874 = #3791 #4529
[attach-meaning] #176 arith (- 1)
[mk-app] #4875 + #3791 #4312
[mk-app] #4854 <= #4875 #36
[mk-app] #4855 >= #4875 #36
[assign] #4874 justification -1: p305
[attach-enode] #4874 0
[attach-enode] #4875 0
[assign] #4854 justification -1: p310
[assign] #4855 justification -1: p310
[new-match] 0x1068484d0 #1495 #1483 #4389 #1545 ; #4411 (#4392 #4392)
[mk-app] #4862 = #4411 #3885
[mk-app] #4911 = #4411 #3923
[mk-app] #4912 = #4862 #4911
[mk-proof] #4888 monotonicity #3925 #4912
[mk-app] #5028 or #1563 #4911
[mk-app] #5029 or #1563 #4862
[mk-proof] #4946 quant-inst #5029
[mk-app] #4947 = #5029 #5028
[mk-proof] #4990 monotonicity #4888 #4947
[mk-app] #4985 = #5028 #5028
[mk-proof] #4160 rewrite #4985
[mk-proof] #4161 trans #4990 #4160 #4947
[mk-proof] #4165 mp #4946 #4161 #5028
[instance] 0x1068484d0 #4946 ; 57
[attach-enode] #3887 57
[attach-enode] #3923 57
[attach-enode] #4911 57
[assign] #4911 justification -1: p50
[end-of-instance]
[eq-expl] #3887 root
[new-match] 0x106848770 #1477 #1476 #3887 #1545 ; #3923
[eq-expl] #4411 lit #4911 ; #3923
[eq-expl] #3923 root
[new-match] 0x1068487a8 #1522 #1506 #3887 #1545 ; #4582 (#4411 #3923)
[mk-app] #4336 = #3466 #3887
[mk-app] #4337 = #4336 #4336
[mk-proof] #4338 refl #4337
[mk-app] #4924 or #1576 #4336
[mk-proof] #5157 quant-inst #4924
[instance] 0x106848770 #5157 ; 58
[attach-enode] #3466 58
[attach-enode] #4336 58
[assign] #4336 justification -1: p49
[end-of-instance]
[mk-app] #4337 * #176 #3473
[mk-app] #4338 + #3469 #4337
[mk-app] #4334 = #4338 #1503
[mk-app] #4925 = #4334 #4334
[mk-proof] #4926 refl #4925
[mk-app] #4931 or #5113 #4334
[mk-proof] #4171 quant-inst #4931
[instance] 0x1068487a8 #4171 ; 58
[attach-enode] #3468 58
[attach-enode] #3469 58
[attach-enode] #3473 58
[attach-enode] #4337 58
[attach-enode] #4338 58
[attach-enode] #4334 58
[mk-app] #5146 <= #4338 #1503
[mk-app] #4967 >= #4338 #1503
[assign] #4334 justification -1: p51
[end-of-instance]
[assign] #5146 clause p316 (not p315)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[assign] #4967 clause p317 (not p315)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[mk-app] #4925 = #3473 #4582
[attach-meaning] #176 arith (- 1)
[mk-app] #4926 + #3473 #4600
[mk-app] #4859 <= #4926 #36
[mk-app] #4839 >= #4926 #36
[assign] #4925 justification -1: p313
[attach-enode] #4925 0
[attach-enode] #4926 0
[assign] #4859 justification -1: p318
[assign] #4839 justification -1: p318
[new-match] 0x106849168 #1495 #1483 #3887 #1545 ; #3468 (#3923 #3923)
[mk-app] #5101 = #3468 #3486
[mk-app] #5093 = #3468 #3870
[mk-app] #5054 = #5101 #5093
[mk-proof] #5034 monotonicity #3872 #5054
[mk-app] #4878 or #1563 #5093
[mk-app] #4865 or #1563 #5101
[mk-proof] #4826 quant-inst #4865
[mk-app] #4827 = #4865 #4878
[mk-proof] #4828 monotonicity #5034 #4827
[mk-app] #3979 = #4878 #4878
[mk-proof] #4980 rewrite #3979
[mk-proof] #2994 trans #4828 #4980 #4827
[mk-proof] #3603 mp #4826 #2994 #4878
[instance] 0x106849168 #4826 ; 59
[attach-enode] #3867 59
[attach-enode] #3870 59
[attach-enode] #5093 59
[assign] #5093 justification -1: p50
[end-of-instance]
[eq-expl] #3867 root
[new-match] 0x106849408 #1477 #1476 #3867 #1545 ; #3870
[eq-expl] #3468 lit #5093 ; #3870
[eq-expl] #3870 root
[new-match] 0x106849440 #1522 #1506 #3867 #1545 ; #3469 (#3468 #3870)
[mk-app] #4987 = #4433 #3867
[mk-app] #4988 = #4987 #4987
[mk-proof] #5002 refl #4988
[mk-app] #3676 or #1576 #4987
[mk-proof] #3467 quant-inst #3676
[instance] 0x106849408 #3467 ; 60
[attach-enode] #4433 60
[attach-enode] #4987 60
[assign] #4987 justification -1: p49
[end-of-instance]
[mk-app] #4988 * #176 #3606
[mk-app] #5002 + #4575 #4988
[mk-app] #5013 = #5002 #1503
[mk-app] #3906 + #4988 #4575
[inst-discovered] theory-solving 0x0 arith# ; #5002
[mk-app] #4367 = #5002 #3906
[mk-proof] #3793 rewrite #4367
[instance] 0x0 #4367
[end-of-instance]
[mk-app] #4365 = #3906 #1503
[mk-app] #4366 = #5013 #4365
[mk-proof] #3905 monotonicity #3793 #4366
[attach-meaning] #176 arith (- 1)
[mk-app] #3857 * #176 #4575
[mk-app] #4300 + #3606 #3857
[attach-meaning] #4108 arith (- 4)
[mk-app] #4290 = #4300 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4365
[mk-app] #3134 = #4365 #4290
[mk-proof] #4572 rewrite #3134
[instance] 0x0 #3134
[end-of-instance]
[mk-app] #3799 = #5013 #4290
[mk-proof] #5049 trans #3905 #4572 #3799
[mk-app] #3354 or #5113 #4290
[mk-app] #3355 or #5113 #5013
[mk-proof] #5050 quant-inst #3355
[mk-app] #5051 = #3355 #3354
[mk-proof] #5058 monotonicity #5049 #5051
[mk-app] #4243 = #3354 #3354
[mk-proof] #4244 rewrite #4243
[mk-proof] #5086 trans #5058 #4244 #5051
[mk-proof] #3239 mp #5050 #5086 #3354
[instance] 0x106849440 #5050 ; 60
[attach-enode] #3606 60
[attach-enode] #4574 60
[attach-enode] #4575 60
[attach-enode] #3857 60
[attach-enode] #4300 60
[attach-enode] #4290 60
[mk-app] #3383 <= #4300 #4108
[mk-app] #3263 >= #4300 #4108
[assign] #4290 justification -1: p51
[end-of-instance]
[assign] #3383 clause p324 (not p323)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[assign] #3263 clause p325 (not p323)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[mk-app] #3957 = #3469 #3606
[attach-meaning] #176 arith (- 1)
[mk-app] #3759 + #3469 #4988
[mk-app] #3238 <= #3759 #36
[mk-app] #3388 >= #3759 #36
[assign] #3957 justification -1: p321
[attach-enode] #3957 0
[attach-enode] #4988 0
[attach-enode] #3759 0
[assign] #3238 justification -1: p326
[assign] #3388 justification -1: p326
[new-match] 0x106887e98 #1495 #1483 #3867 #1545 ; #4574 (#3870 #3870)
[mk-app] #3153 = #4574 #3728
[mk-app] #3390 = #4574 #3733
[mk-app] #3812 = #3153 #3390
[mk-proof] #3813 monotonicity #4017 #3812
[mk-app] #3504 or #1563 #3390
[mk-app] #3980 or #1563 #3153
[mk-proof] #3501 quant-inst #3980
[mk-app] #3508 = #3980 #3504
[mk-proof] #2934 monotonicity #3813 #3508
[mk-app] #2935 = #3504 #3504
[mk-proof] #4173 rewrite #2935
[mk-proof] #3509 trans #2934 #4173 #3508
[mk-proof] #3405 mp #3501 #3509 #3504
[instance] 0x106887e98 #3501 ; 61
[attach-enode] #3730 61
[attach-enode] #3733 61
[attach-enode] #3390 61
[assign] #3390 justification -1: p50
[end-of-instance]
[eq-expl] #3730 root
[new-match] 0x106888138 #1477 #1476 #3730 #1545 ; #3733
[eq-expl] #4574 lit #3390 ; #3733
[eq-expl] #3733 root
[new-match] 0x106888170 #1522 #1506 #3730 #1545 ; #4575 (#4574 #3733)
[mk-app] #3063 = #4034 #3730
[mk-app] #3227 = #3063 #3063
[mk-proof] #4138 refl #3227
[mk-app] #3410 or #1576 #3063
[mk-proof] #3244 quant-inst #3410
[instance] 0x106888138 #3244 ; 62
[attach-enode] #4034 62
[attach-enode] #3063 62
[assign] #3063 justification -1: p49
[end-of-instance]
[mk-app] #3227 * #176 #4041
[mk-app] #4138 + #4038 #3227
[mk-app] #3245 = #4138 #1503
[mk-app] #3226 = #3245 #3245
[mk-proof] #4139 refl #3226
[mk-app] #4134 or #5113 #3245
[mk-proof] #3260 quant-inst #4134
[instance] 0x106888170 #3260 ; 62
[attach-enode] #4036 62
[attach-enode] #4038 62
[attach-enode] #4041 62
[attach-enode] #3227 62
[attach-enode] #4138 62
[attach-enode] #3245 62
[mk-app] #3261 <= #4138 #1503
[mk-app] #3256 >= #4138 #1503
[assign] #3245 justification -1: p51
[end-of-instance]
[assign] #3261 clause p332 (not p331)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[assign] #3256 clause p333 (not p331)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[mk-app] #3226 = #4041 #4575
[attach-meaning] #176 arith (- 1)
[mk-app] #4139 + #4041 #3857
[mk-app] #3257 <= #4139 #36
[mk-app] #3894 >= #4139 #36
[assign] #3226 justification -1: p329
[attach-enode] #3226 0
[attach-enode] #4139 0
[assign] #3257 justification -1: p334
[assign] #3894 justification -1: p334
[new-match] 0x106888b30 #1495 #1483 #3730 #1545 ; #4036 (#3733 #3733)
[mk-app] #3832 = #4036 #3289
[mk-app] #3833 = #4036 #3294
[mk-app] #4439 = #3832 #3833
[mk-proof] #3646 monotonicity #3296 #4439
[mk-app] #4519 or #1563 #3833
[mk-app] #3623 or #1563 #3832
[mk-proof] #3636 quant-inst #3623
[mk-app] #3243 = #3623 #4519
[mk-proof] #3736 monotonicity #3646 #3243
[mk-app] #3340 = #4519 #4519
[mk-proof] #4538 rewrite #3340
[mk-proof] #4539 trans #3736 #4538 #3243
[mk-proof] #3095 mp #3636 #4539 #4519
[instance] 0x106888b30 #3636 ; 63
[attach-enode] #3291 63
[attach-enode] #3294 63
[attach-enode] #3833 63
[assign] #3833 justification -1: p50
[end-of-instance]
[eq-expl] #3291 root
[new-match] 0x106888dd0 #1477 #1476 #3291 #1545 ; #3294
[eq-expl] #4036 lit #3833 ; #3294
[eq-expl] #3294 root
[new-match] 0x106888e08 #1522 #1506 #3291 #1545 ; #4038 (#4036 #3294)
[mk-app] #3096 = #3312 #3291
[mk-app] #3341 = #3096 #3096
[mk-proof] #3331 refl #3341
[mk-app] #3332 or #1576 #3096
[mk-proof] #3342 quant-inst #3332
[instance] 0x106888dd0 #3342 ; 64
[attach-enode] #3312 64
[attach-enode] #3096 64
[assign] #3096 justification -1: p49
[end-of-instance]
[mk-app] #3341 * #176 #3318
[mk-app] #3331 + #3315 #3341
[mk-app] #3343 = #3331 #1503
[mk-app] #2961 = #3343 #3343
[mk-proof] #3278 refl #2961
[mk-app] #3702 or #5113 #3343
[mk-proof] #3701 quant-inst #3702
[instance] 0x106888e08 #3701 ; 64
[attach-enode] #3314 64
[attach-enode] #3315 64
[attach-enode] #3318 64
[attach-enode] #3341 64
[attach-enode] #3331 64
[attach-enode] #3343 64
[mk-app] #3281 <= #3331 #1503
[mk-app] #3276 >= #3331 #1503
[assign] #3343 justification -1: p51
[end-of-instance]
[assign] #3281 clause p340 (not p339)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[assign] #3276 clause p341 (not p339)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[mk-app] #2961 = #3318 #4038
[attach-meaning] #176 arith (- 1)
[mk-app] #3278 * #176 #4038
[mk-app] #3283 + #3318 #3278
[mk-app] #3704 <= #3283 #36
[mk-app] #3705 >= #3283 #36
[assign] #2961 justification -1: p337
[attach-enode] #2961 0
[attach-enode] #3278 0
[attach-enode] #3283 0
[assign] #3704 justification -1: p342
[assign] #3705 justification -1: p342
[new-match] 0x106889850 #1495 #1483 #3291 #1545 ; #3314 (#3294 #3294)
[mk-app] #3098 = #3314 #4185
[mk-app] #3590 = #3314 #4190
[mk-app] #3591 = #3098 #3590
[mk-proof] #3991 monotonicity #4192 #3591
[mk-app] #3986 or #1563 #3590
[mk-app] #3594 or #1563 #3098
[mk-proof] #3595 quant-inst #3594
[mk-app] #3368 = #3594 #3986
[mk-proof] #3369 monotonicity #3991 #3368
[mk-app] #3376 = #3986 #3986
[mk-proof] #3127 rewrite #3376
[mk-proof] #3128 trans #3369 #3127 #3368
[mk-proof] #3121 mp #3595 #3128 #3986
[instance] 0x106889850 #3595 ; 65
[attach-enode] #4187 65
[attach-enode] #4190 65
[attach-enode] #3590 65
[assign] #3590 justification -1: p50
[end-of-instance]
[eq-expl] #4187 root
[new-match] 0x106890760 #1477 #1476 #4187 #1545 ; #4190
[eq-expl] #3314 lit #3590 ; #4190
[eq-expl] #4190 root
[new-match] 0x106890798 #1522 #1506 #4187 #1545 ; #3315 (#3314 #4190)
[mk-app] #3357 = #4211 #4187
[mk-app] #3130 = #3357 #3357
[mk-proof] #3513 refl #3130
[mk-app] #3358 or #1576 #3357
[mk-proof] #3361 quant-inst #3358
[instance] 0x106890760 #3361 ; 66
[attach-enode] #4211 66
[attach-enode] #3357 66
[assign] #3357 justification -1: p49
[end-of-instance]
[mk-app] #3130 * #176 #4591
[mk-app] #3513 + #4214 #3130
[mk-app] #2947 = #3513 #1503
[mk-app] #4103 = #2947 #2947
[mk-proof] #4075 refl #4103
[mk-app] #3558 or #5113 #2947
[mk-proof] #3422 quant-inst #3558
[instance] 0x106890798 #3422 ; 66
[attach-enode] #4213 66
[attach-enode] #4214 66
[attach-enode] #4591 66
[attach-enode] #3130 66
[attach-enode] #3513 66
[attach-enode] #2947 66
[mk-app] #3443 <= #3513 #1503
[mk-app] #4468 >= #3513 #1503
[assign] #2947 justification -1: p51
[end-of-instance]
[assign] #3443 clause p348 (not p347)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[assign] #4468 clause p349 (not p347)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[mk-app] #4103 = #3315 #4591
[attach-meaning] #176 arith (- 1)
[mk-app] #4075 + #3315 #3130
[mk-app] #3421 <= #4075 #36
[mk-app] #4458 >= #4075 #36
[assign] #4103 justification -1: p345
[attach-enode] #4103 0
[attach-enode] #4075 0
[assign] #3421 justification -1: p350
[assign] #4458 justification -1: p350
[new-match] 0x106891158 #1495 #1483 #4187 #1545 ; #4213 (#4190 #4190)
[mk-app] #4459 = #4213 #3675
[mk-app] #3546 = #4213 #4495
[mk-app] #3547 = #4459 #3546
[mk-proof] #3540 monotonicity #3819 #3547
[mk-app] #3541 or #1563 #3546
[mk-app] #3548 or #1563 #4459
[mk-proof] #3549 quant-inst #3548
[mk-app] #4015 = #3548 #3541
[mk-proof] #2925 monotonicity #3540 #4015
[mk-app] #2926 = #3541 #3541
[mk-proof] #3635 rewrite #2926
[mk-proof] #3626 trans #2925 #3635 #4015
[mk-proof] #3374 mp #3549 #3626 #3541
[instance] 0x106891158 #3549 ; 67
[attach-enode] #3677 67
[attach-enode] #4495 67
[attach-enode] #3546 67
[assign] #3546 justification -1: p50
[end-of-instance]
[eq-expl] #3677 root
[new-match] 0x1068913f8 #1477 #1476 #3677 #1545 ; #4495
[eq-expl] #4213 lit #3546 ; #4495
[eq-expl] #4495 root
[new-match] 0x106891430 #1522 #1506 #3677 #1545 ; #4214 (#4213 #4495)
[mk-app] #2927 = #3602 #3677
[mk-app] #3679 = #2927 #2927
[mk-proof] #3828 refl #3679
[mk-app] #4403 or #1576 #2927
[mk-proof] #4395 quant-inst #4403
[instance] 0x1068913f8 #4395 ; 68
[attach-enode] #3602 68
[attach-enode] #2927 68
[assign] #2927 justification -1: p49
[end-of-instance]
[mk-app] #3679 * #176 #2991
[mk-app] #3828 + #4535 #3679
[mk-app] #3583 = #3828 #1503
[mk-app] #4530 + #3679 #4535
[inst-discovered] theory-solving 0x0 arith# ; #3828
[mk-app] #4531 = #3828 #4530
[mk-proof] #4402 rewrite #4531
[instance] 0x0 #4531
[end-of-instance]
[mk-app] #4396 = #4530 #1503
[mk-app] #4404 = #3583 #4396
[mk-proof] #4405 monotonicity #4402 #4404
[attach-meaning] #176 arith (- 1)
[mk-app] #4407 * #176 #4535
[mk-app] #4419 + #2991 #4407
[attach-meaning] #4108 arith (- 4)
[mk-app] #4424 = #4419 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4396
[mk-app] #4090 = #4396 #4424
[mk-proof] #4415 rewrite #4090
[instance] 0x0 #4090
[end-of-instance]
[mk-app] #4418 = #3583 #4424
[mk-proof] #4091 trans #4405 #4415 #4418
[mk-app] #3534 or #5113 #4424
[mk-app] #3531 or #5113 #3583
[mk-proof] #4425 quant-inst #3531
[mk-app] #4039 = #3531 #3534
[mk-proof] #3428 monotonicity #4091 #4039
[mk-app] #4203 = #3534 #3534
[mk-proof] #4209 rewrite #4203
[mk-proof] #3302 trans #3428 #4209 #4039
[mk-proof] #4207 mp #4425 #3302 #3534
[instance] 0x106891430 #4425 ; 68
[attach-enode] #2991 68
[attach-enode] #4534 68
[attach-enode] #4535 68
[attach-enode] #4407 68
[attach-enode] #4419 68
[attach-enode] #4424 68
[mk-app] #4208 <= #4419 #4108
[mk-app] #4200 >= #4419 #4108
[assign] #4424 justification -1: p51
[end-of-instance]
[assign] #4208 clause p356 (not p355)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[assign] #4200 clause p357 (not p355)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[mk-app] #4215 = #2991 #4214
[attach-meaning] #176 arith (- 1)
[mk-app] #4521 * #176 #4214
[mk-app] #3177 + #2991 #4521
[mk-app] #3178 <= #3177 #36
[mk-app] #3179 >= #3177 #36
[assign] #4215 justification -1: p353
[attach-enode] #4215 0
[attach-enode] #4521 0
[attach-enode] #3177 0
[assign] #3178 justification -1: p358
[assign] #3179 justification -1: p358
[new-match] 0x106891e78 #1495 #1483 #3677 #1545 ; #4534 (#4495 #4495)
[mk-app] #3182 = #4534 #3978
[mk-app] #4482 = #4534 #3984
[mk-app] #4505 = #3182 #4482
[mk-proof] #4113 monotonicity #4520 #4505
[mk-app] #4554 or #1563 #4482
[mk-app] #4555 or #1563 #3182
[mk-proof] #2911 quant-inst #4555
[mk-app] #4122 = #4555 #4554
[mk-proof] #3665 monotonicity #4113 #4122
[mk-app] #3457 = #4554 #4554
[mk-proof] #4696 rewrite #3457
[mk-proof] #4697 trans #3665 #4696 #4122
[mk-proof] #4619 mp #2911 #4697 #4554
[instance] 0x106891e78 #2911 ; 69
[attach-enode] #3981 69
[attach-enode] #3984 69
[attach-enode] #4482 69
[assign] #4482 justification -1: p50
[end-of-instance]
[eq-expl] #3981 root
[new-match] 0x106892118 #1477 #1476 #3981 #1545 ; #3984
[eq-expl] #4534 lit #4482 ; #3984
[eq-expl] #3984 root
[new-match] 0x106892150 #1522 #1506 #3981 #1545 ; #4535 (#4534 #3984)
[mk-app] #4628 = #3192 #3981
[mk-app] #4629 = #4628 #4628
[mk-proof] #4636 refl #4629
[mk-app] #4690 or #1576 #4628
[mk-proof] #4691 quant-inst #4690
[instance] 0x106892118 #4691 ; 70
[attach-enode] #3192 70
[attach-enode] #4628 70
[assign] #4628 justification -1: p49
[end-of-instance]
[mk-app] #4629 * #176 #3198
[mk-app] #4636 + #3195 #4629
[mk-app] #4698 = #4636 #1503
[mk-app] #4699 = #4698 #4698
[mk-proof] #4808 refl #4699
[mk-app] #4809 or #5113 #4698
[mk-proof] #3481 quant-inst #4809
[instance] 0x106892150 #3481 ; 70
[attach-enode] #3194 70
[attach-enode] #3195 70
[attach-enode] #3198 70
[attach-enode] #4629 70
[attach-enode] #4636 70
[attach-enode] #4698 70
[mk-app] #4814 <= #4636 #1503
[mk-app] #4815 >= #4636 #1503
[assign] #4698 justification -1: p51
[end-of-instance]
[assign] #4814 clause p364 (not p363)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[assign] #4815 clause p365 (not p363)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[mk-app] #4699 = #3198 #4535
[attach-meaning] #176 arith (- 1)
[mk-app] #4808 + #3198 #4407
[mk-app] #3483 <= #4808 #36
[mk-app] #3477 >= #4808 #36
[assign] #4699 justification -1: p361
[attach-enode] #4699 0
[attach-enode] #4808 0
[assign] #3483 justification -1: p366
[assign] #3477 justification -1: p366
[new-match] 0x10689a958 #1495 #1483 #3981 #1545 ; #3194 (#3984 #3984)
[mk-app] #3482 = #3194 #3214
[mk-app] #4816 = #3194 #3217
[mk-app] #4890 = #3482 #4816
[mk-proof] #4046 monotonicity #3221 #4890
[mk-app] #4933 or #1563 #4816
[mk-app] #4948 or #1563 #3482
[mk-proof] #4887 quant-inst #4948
[mk-app] #4940 = #4948 #4933
[mk-proof] #4941 monotonicity #4046 #4940
[mk-app] #4932 = #4933 #4933
[mk-proof] #4949 rewrite #4932
[mk-proof] #5009 trans #4941 #4949 #4940
[mk-proof] #5010 mp #4887 #5009 #4933
[instance] 0x10689a958 #4887 ; 71
[attach-enode] #3216 71
[attach-enode] #3217 71
[attach-enode] #4816 71
[assign] #4816 justification -1: p50
[end-of-instance]
[eq-expl] #3216 root
[new-match] 0x10689abf8 #1477 #1476 #3216 #1545 ; #3217
[eq-expl] #3194 lit #4816 ; #3217
[eq-expl] #3217 root
[new-match] 0x10689ac30 #1522 #1506 #3216 #1545 ; #3195 (#3194 #3217)
[mk-app] #5003 = #4114 #3216
[mk-app] #5004 = #5003 #5003
[mk-proof] #5011 refl #5004
[mk-app] #3877 or #1576 #5003
[mk-proof] #5081 quant-inst #3877
[instance] 0x10689abf8 #5081 ; 72
[attach-enode] #4114 72
[attach-enode] #5003 72
[assign] #5003 justification -1: p49
[end-of-instance]
[mk-app] #5004 * #176 #4124
[mk-app] #5011 + #4121 #5004
[mk-app] #5065 = #5011 #1503
[mk-app] #3878 = #5065 #5065
[mk-proof] #3672 refl #3878
[mk-app] #3970 or #5113 #5065
[mk-proof] #5066 quant-inst #3970
[instance] 0x10689ac30 #5066 ; 72
[attach-enode] #4116 72
[attach-enode] #4121 72
[attach-enode] #4124 72
[attach-enode] #5004 72
[attach-enode] #5011 72
[attach-enode] #5065 72
[mk-app] #5082 <= #5011 #1503
[mk-app] #3206 >= #5011 #1503
[assign] #5065 justification -1: p51
[end-of-instance]
[assign] #5082 clause p372 (not p371)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[assign] #3206 clause p373 (not p371)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[mk-app] #3878 = #3195 #4124
[attach-meaning] #176 arith (- 1)
[mk-app] #3672 + #3195 #5004
[mk-app] #4350 <= #3672 #36
[mk-app] #3648 >= #3672 #36
[assign] #3878 justification -1: p369
[attach-enode] #3878 0
[attach-enode] #3672 0
[assign] #4350 justification -1: p374
[assign] #3648 justification -1: p374
[new-match] 0x10689b5f0 #1495 #1483 #3216 #1545 ; #4116 (#3217 #3217)
[mk-app] #3272 = #4116 #3663
[mk-app] #4099 = #4116 #3652
[mk-app] #3100 = #3272 #4099
[mk-proof] #3852 monotonicity #3654 #3100
[mk-app] #3649 or #1563 #4099
[mk-app] #4357 or #1563 #3272
[mk-proof] #4358 quant-inst #4357
[mk-app] #2943 = #4357 #3649
[mk-proof] #2944 monotonicity #3852 #2943
[mk-app] #3763 = #3649 #3649
[mk-proof] #4601 rewrite #3763
[mk-proof] #3097 trans #2944 #4601 #2943
[mk-proof] #2950 mp #4358 #3097 #3649
[instance] 0x10689b5f0 #4358 ; 73
[attach-enode] #4506 73
[attach-enode] #3652 73
[attach-enode] #4099 73
[assign] #4099 justification -1: p50
[end-of-instance]
[eq-expl] #4506 root
[new-match] 0x10689b890 #1477 #1476 #4506 #1545 ; #3652
[eq-expl] #4116 lit #4099 ; #3652
[eq-expl] #3652 root
[new-match] 0x10689b8c8 #1522 #1506 #4506 #1545 ; #4121 (#4116 #3652)
[mk-app] #4602 = #4492 #4506
[mk-app] #4638 = #4602 #4602
[mk-proof] #4635 refl #4638
[mk-app] #3564 or #1576 #4602
[mk-proof] #2948 quant-inst #3564
[instance] 0x10689b890 #2948 ; 74
[attach-enode] #4492 74
[attach-enode] #4602 74
[assign] #4602 justification -1: p49
[end-of-instance]
[mk-app] #4638 * #176 #4597
[mk-app] #4635 + #4596 #4638
[mk-app] #4716 = #4635 #1503
[mk-app] #4552 = #4716 #4716
[mk-proof] #3424 refl #4552
[mk-app] #3827 or #5113 #4716
[mk-proof] #3375 quant-inst #3827
[instance] 0x10689b8c8 #3375 ; 74
[attach-enode] #4491 74
[attach-enode] #4596 74
[attach-enode] #4597 74
[attach-enode] #4638 74
[attach-enode] #4635 74
[attach-enode] #4716 74
[mk-app] #3380 <= #4635 #1503
[mk-app] #4301 >= #4635 #1503
[assign] #4716 justification -1: p51
[end-of-instance]
[assign] #3380 clause p380 (not p379)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[assign] #4301 clause p381 (not p379)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[mk-app] #4552 = #4121 #4597
[attach-meaning] #176 arith (- 1)
[mk-app] #3424 + #4121 #4638
[mk-app] #4547 <= #3424 #36
[mk-app] #3536 >= #3424 #36
[assign] #4552 justification -1: p377
[attach-enode] #4552 0
[attach-enode] #3424 0
[assign] #4547 justification -1: p382
[assign] #3536 justification -1: p382
[new-match] 0x10689c288 #1495 #1483 #4506 #1545 ; #4491 (#3652 #3652)
[mk-app] #3537 = #4491 #4604
[mk-app] #3420 = #4491 #4609
[mk-app] #3425 = #3537 #3420
[mk-proof] #3934 monotonicity #4611 #3425
[mk-app] #4795 or #1563 #3420
[mk-app] #3937 or #1563 #3537
[mk-proof] #3941 quant-inst #3937
[mk-app] #4790 = #3937 #4795
[mk-proof] #4791 monotonicity #3934 #4790
[mk-app] #4833 = #4795 #4795
[mk-proof] #3942 rewrite #4833
[mk-proof] #3078 trans #4791 #3942 #4790
[mk-proof] #4869 mp #3941 #3078 #4795
[instance] 0x10689c288 #3941 ; 75
[attach-enode] #4606 75
[attach-enode] #4609 75
[attach-enode] #3420 75
[assign] #3420 justification -1: p50
[end-of-instance]
[eq-expl] #4606 root
[new-match] 0x10684f560 #1477 #1476 #4606 #1545 ; #4609
[eq-expl] #4491 lit #3420 ; #4609
[eq-expl] #4609 root
[new-match] 0x10684f598 #1522 #1506 #4606 #1545 ; #4596 (#4491 #4609)
[mk-app] #3972 = #4624 #4606
[mk-app] #3210 = #3972 #3972
[mk-proof] #3285 refl #3210
[mk-app] #3976 or #1576 #3972
[mk-proof] #3209 quant-inst #3976
[instance] 0x10684f560 #3209 ; 76
[attach-enode] #4624 76
[attach-enode] #3972 76
[assign] #3972 justification -1: p49
[end-of-instance]
[mk-app] #3210 * #176 #4630
[mk-app] #3285 + #4627 #3210
[mk-app] #3971 = #3285 #1503
[mk-app] #3204 = #3971 #3971
[mk-proof] #4673 refl #3204
[mk-app] #4674 or #5113 #3971
[mk-proof] #4640 quant-inst #4674
[instance] 0x10684f598 #4640 ; 76
[attach-enode] #4626 76
[attach-enode] #4627 76
[attach-enode] #4630 76
[attach-enode] #3210 76
[attach-enode] #3285 76
[attach-enode] #3971 76
[mk-app] #4641 <= #3285 #1503
[mk-app] #4679 >= #3285 #1503
[assign] #3971 justification -1: p51
[end-of-instance]
[assign] #4641 clause p388 (not p387)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[assign] #4679 clause p389 (not p387)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[mk-app] #3204 = #4596 #4630
[attach-meaning] #176 arith (- 1)
[mk-app] #4673 + #4596 #3210
[mk-app] #4952 <= #4673 #36
[mk-app] #4872 >= #4673 #36
[assign] #3204 justification -1: p385
[attach-enode] #3204 0
[attach-enode] #4673 0
[assign] #4952 justification -1: p390
[assign] #4872 justification -1: p390
[new-match] 0x10684ff58 #1495 #1483 #4606 #1545 ; #4626 (#4609 #4609)
[mk-app] #4834 = #4626 #4643
[mk-app] #4953 = #4626 #4648
[mk-app] #4989 = #4834 #4953
[mk-proof] #4986 monotonicity #4650 #4989
[mk-app] #4829 or #1563 #4953
[mk-app] #4873 or #1563 #4834
[mk-proof] #4159 quant-inst #4873
[mk-app] #4063 = #4873 #4829
[mk-proof] #3021 monotonicity #4986 #4063
[mk-app] #4750 = #4829 #4829
[mk-proof] #4742 rewrite #4750
[mk-proof] #4722 trans #3021 #4742 #4063
[mk-proof] #4709 mp #4159 #4722 #4829
[instance] 0x10684ff58 #4159 ; 77
[attach-enode] #4645 77
[attach-enode] #4648 77
[attach-enode] #4953 77
[assign] #4953 justification -1: p50
[end-of-instance]
[eq-expl] #4645 root
[new-match] 0x1068501f8 #1477 #1476 #4645 #1545 ; #4648
[eq-expl] #4626 lit #4953 ; #4648
[eq-expl] #4648 root
[new-match] 0x106850230 #1522 #1506 #4645 #1545 ; #4627 (#4626 #4648)
[mk-app] #5022 = #4663 #4645
[mk-app] #5192 = #5022 #5022
[mk-proof] #4749 refl #5192
[mk-app] #3101 or #1576 #5022
[mk-proof] #5023 quant-inst #3101
[instance] 0x1068501f8 #5023 ; 78
[attach-enode] #4663 78
[attach-enode] #5022 78
[assign] #5022 justification -1: p49
[end-of-instance]
[mk-app] #5192 * #176 #4669
[mk-app] #4749 + #4666 #5192
[mk-app] #5015 = #4749 #1503
[mk-app] #4995 = #5015 #5015
[mk-proof] #4943 refl #4995
[mk-app] #4944 or #5113 #5015
[mk-proof] #4984 quant-inst #4944
[instance] 0x106850230 #4984 ; 78
[attach-enode] #4665 78
[attach-enode] #4666 78
[attach-enode] #4669 78
[attach-enode] #5192 78
[attach-enode] #4749 78
[attach-enode] #5015 78
[mk-app] #5195 <= #4749 #1503
[mk-app] #4945 >= #4749 #1503
[assign] #5015 justification -1: p51
[end-of-instance]
[assign] #5195 clause p396 (not p395)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[assign] #4945 clause p397 (not p395)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[mk-app] #4995 = #4627 #4669
[attach-meaning] #176 arith (- 1)
[mk-app] #4943 + #4627 #5192
[mk-app] #4905 <= #4943 #36
[mk-app] #4631 >= #4943 #36
[assign] #4995 justification -1: p393
[attach-enode] #4995 0
[attach-enode] #4943 0
[assign] #4905 justification -1: p398
[assign] #4631 justification -1: p398
[new-match] 0x106850bf0 #1495 #1483 #4645 #1545 ; #4665 (#4648 #4648)
[mk-app] #4632 = #4665 #4682
[mk-app] #4670 = #4665 #4687
[mk-app] #4127 = #4632 #4670
[mk-proof] #4633 monotonicity #4689 #4127
[mk-app] #4625 or #1563 #4670
[mk-app] #4605 or #1563 #4632
[mk-proof] #3931 quant-inst #4605
[mk-app] #3932 = #4605 #4625
[mk-proof] #3770 monotonicity #4633 #3932
[mk-app] #2915 = #4625 #4625
[mk-proof] #4257 rewrite #2915
[mk-proof] #4485 trans #3770 #4257 #3932
[mk-proof] #4013 mp #3931 #4485 #4625
[instance] 0x106850bf0 #3931 ; 79
[attach-enode] #4684 79
[attach-enode] #4687 79
[attach-enode] #4670 79
[assign] #4670 justification -1: p50
[end-of-instance]
[eq-expl] #4684 root
[new-match] 0x106850e90 #1477 #1476 #4684 #1545 ; #4687
[eq-expl] #4665 lit #4670 ; #4687
[eq-expl] #4687 root
[new-match] 0x106850ec8 #1522 #1506 #4684 #1545 ; #4666 (#4665 #4687)
[mk-app] #4003 = #4702 #4684
[mk-app] #4077 = #4003 #4003
[mk-proof] #4078 refl #4077
[mk-app] #4532 or #1576 #4003
[mk-proof] #3625 quant-inst #4532
[instance] 0x106850e90 #3625 ; 80
[attach-enode] #4702 80
[attach-enode] #4003 80
[assign] #4003 justification -1: p49
[end-of-instance]
[mk-app] #4077 * #176 #4708
[mk-app] #4078 + #4705 #4077
[mk-app] #3091 = #4078 #1503
[mk-app] #3092 = #3091 #3091
[mk-proof] #3106 refl #3092
[mk-app] #3090 or #5113 #3091
[mk-proof] #3084 quant-inst #3090
[instance] 0x106850ec8 #3084 ; 80
[attach-enode] #4704 80
[attach-enode] #4705 80
[attach-enode] #4708 80
[attach-enode] #4077 80
[attach-enode] #4078 80
[attach-enode] #3091 80
[mk-app] #3694 <= #4078 #1503
[mk-app] #4343 >= #4078 #1503
[assign] #3091 justification -1: p51
[end-of-instance]
[assign] #3694 clause p404 (not p403)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[assign] #4343 clause p405 (not p403)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[mk-app] #3092 = #4666 #4708
[attach-meaning] #176 arith (- 1)
[mk-app] #3106 + #4666 #4077
[mk-app] #4319 <= #3106 #36
[mk-app] #4503 >= #3106 #36
[assign] #3092 justification -1: p401
[attach-enode] #3092 0
[attach-enode] #3106 0
[assign] #4319 justification -1: p406
[assign] #4503 justification -1: p406
[new-match] 0x10686e6a8 #1495 #1483 #4684 #1545 ; #4704 (#4687 #4687)
[mk-app] #3711 = #4704 #4721
[mk-app] #3019 = #4704 #4726
[mk-app] #3020 = #3711 #3019
[mk-proof] #3392 monotonicity #4728 #3020
[mk-app] #3030 or #1563 #3019
[mk-app] #4331 or #1563 #3711
[mk-proof] #3018 quant-inst #4331
[mk-app] #4107 = #4331 #3030
[mk-proof] #4341 monotonicity #3392 #4107
[mk-app] #4333 = #3030 #3030
[mk-proof] #2966 rewrite #4333
[mk-proof] #2963 trans #4341 #2966 #4107
[mk-proof] #3503 mp #3018 #2963 #3030
[instance] 0x10686e6a8 #3018 ; 81
[attach-enode] #4723 81
[attach-enode] #4726 81
[attach-enode] #3019 81
[assign] #3019 justification -1: p50
[end-of-instance]
[eq-expl] #4723 root
[new-match] 0x10686e948 #1477 #1476 #4723 #1545 ; #4726
[eq-expl] #4704 lit #3019 ; #4726
[eq-expl] #4726 root
[new-match] 0x10686e980 #1522 #1506 #4723 #1545 ; #4705 (#4704 #4726)
[mk-app] #2967 = #4741 #4723
[mk-app] #2964 = #2967 #2967
[mk-proof] #2965 refl #2964
[mk-app] #2968 or #1576 #2967
[mk-proof] #3258 quant-inst #2968
[instance] 0x10686e948 #3258 ; 82
[attach-enode] #4741 82
[attach-enode] #2967 82
[assign] #2967 justification -1: p49
[end-of-instance]
[mk-app] #2964 * #176 #4747
[mk-app] #2965 + #4744 #2964
[mk-app] #3259 = #2965 #1503
[mk-app] #4164 = #3259 #3259
[mk-proof] #4166 refl #4164
[mk-app] #3280 or #5113 #3259
[mk-proof] #4168 quant-inst #3280
[instance] 0x10686e980 #4168 ; 82
[attach-enode] #4743 82
[attach-enode] #4744 82
[attach-enode] #4747 82
[attach-enode] #2964 82
[attach-enode] #2965 82
[attach-enode] #3259 82
[mk-app] #2932 <= #2965 #1503
[mk-app] #2933 >= #2965 #1503
[assign] #3259 justification -1: p51
[end-of-instance]
[assign] #2932 clause p412 (not p411)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[assign] #2933 clause p413 (not p411)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[mk-app] #4164 = #4705 #4747
[attach-meaning] #176 arith (- 1)
[mk-app] #4166 + #4705 #2964
[mk-app] #2930 <= #4166 #36
[mk-app] #2931 >= #4166 #36
[assign] #4164 justification -1: p409
[attach-enode] #4164 0
[attach-enode] #4166 0
[assign] #2930 justification -1: p414
[assign] #2931 justification -1: p414
[new-match] 0x10686f340 #1495 #1483 #4723 #1545 ; #4743 (#4726 #4726)
[mk-app] #2937 = #4743 #4760
[mk-app] #2938 = #4743 #4765
[mk-app] #3334 = #2937 #2938
[mk-proof] #3329 monotonicity #4767 #3334
[mk-app] #3740 or #1563 #2938
[mk-app] #3741 or #1563 #2937
[mk-proof] #3338 quant-inst #3741
[mk-app] #3339 = #3741 #3740
[mk-proof] #4566 monotonicity #3329 #3339
[mk-app] #4567 = #3740 #3740
[mk-proof] #4238 rewrite #4567
[mk-proof] #4239 trans #4566 #4238 #3339
[mk-proof] #3637 mp #3338 #4239 #3740
[instance] 0x10686f340 #3338 ; 83
[attach-enode] #4762 83
[attach-enode] #4765 83
[attach-enode] #2938 83
[assign] #2938 justification -1: p50
[end-of-instance]
[eq-expl] #4762 root
[new-match] 0x10686f5e0 #1477 #1476 #4762 #1545 ; #4765
[eq-expl] #4743 lit #2938 ; #4765
[eq-expl] #4765 root
[new-match] 0x10686f618 #1522 #1506 #4762 #1545 ; #4744 (#4743 #4765)
[mk-app] #3642 = #4780 #4762
[mk-app] #3560 = #3642 #3642
[mk-proof] #4008 refl #3560
[mk-app] #4016 or #1576 #3642
[mk-proof] #3989 quant-inst #4016
[instance] 0x10686f5e0 #3989 ; 84
[attach-enode] #4780 84
[attach-enode] #3642 84
[assign] #3642 justification -1: p49
[end-of-instance]
[mk-app] #3560 * #176 #4786
[mk-app] #4008 + #4783 #3560
[mk-app] #3992 = #4008 #1503
[mk-app] #4496 = #3992 #3992
[mk-proof] #3629 refl #4496
[mk-app] #3124 or #5113 #3992
[mk-proof] #3148 quant-inst #3124
[instance] 0x10686f618 #3148 ; 84
[attach-enode] #4782 84
[attach-enode] #4783 84
[attach-enode] #4786 84
[attach-enode] #3560 84
[attach-enode] #4008 84
[attach-enode] #3992 84
[mk-app] #4286 <= #4008 #1503
[mk-app] #4287 >= #4008 #1503
[assign] #3992 justification -1: p51
[end-of-instance]
[assign] #4286 clause p420 (not p419)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[assign] #4287 clause p421 (not p419)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[mk-app] #4496 = #4744 #4786
[attach-meaning] #176 arith (- 1)
[mk-app] #3629 + #4744 #3560
[mk-app] #3173 <= #3629 #36
[mk-app] #3132 >= #3629 #36
[assign] #4496 justification -1: p417
[attach-enode] #4496 0
[attach-enode] #3629 0
[assign] #3173 justification -1: p422
[assign] #3132 justification -1: p422
[new-match] 0x10686ffd8 #1495 #1483 #4762 #1545 ; #4782 (#4765 #4765)
[mk-app] #3518 = #4782 #4799
[mk-app] #3525 = #4782 #4804
[mk-app] #3512 = #3518 #3525
[mk-proof] #3519 monotonicity #4806 #3512
[mk-app] #3532 or #1563 #3525
[mk-app] #3533 or #1563 #3518
[mk-proof] #4453 quant-inst #3533
[mk-app] #3543 = #3533 #3532
[mk-proof] #4581 monotonicity #3519 #3543
[mk-app] #3446 = #3532 #3532
[mk-proof] #3853 rewrite #3446
[mk-proof] #3544 trans #4581 #3853 #3543
[mk-proof] #3545 mp #4453 #3544 #3532
[instance] 0x10686ffd8 #4453 ; 85
[attach-enode] #4801 85
[attach-enode] #4804 85
[attach-enode] #3525 85
[assign] #3525 justification -1: p50
[end-of-instance]
[eq-expl] #4801 root
[new-match] 0x1068b1890 #1477 #1476 #4801 #1545 ; #4804
[eq-expl] #4782 lit #3525 ; #4804
[eq-expl] #4804 root
[new-match] 0x1068b18c8 #1522 #1506 #4801 #1545 ; #4783 (#4782 #4804)
[mk-app] #3682 = #4819 #4801
[mk-app] #3683 = #3682 #3682
[mk-proof] #4306 refl #3683
[mk-app] #4314 or #1576 #3682
[mk-proof] #3684 quant-inst #4314
[instance] 0x1068b1890 #3684 ; 86
[attach-enode] #4819 86
[attach-enode] #3682 86
[assign] #3682 justification -1: p49
[end-of-instance]
[mk-app] #3683 * #176 #4825
[mk-app] #4306 + #4822 #3683
[mk-app] #3773 = #4306 #1503
[mk-app] #3936 = #3773 #3773
[mk-proof] #3448 refl #3936
[mk-app] #3451 or #5113 #3773
[mk-proof] #3045 quant-inst #3451
[instance] 0x1068b18c8 #3045 ; 86
[attach-enode] #4821 86
[attach-enode] #4822 86
[attach-enode] #4825 86
[attach-enode] #3683 86
[attach-enode] #4306 86
[attach-enode] #3773 86
[mk-app] #3046 <= #4306 #1503
[mk-app] #3452 >= #4306 #1503
[assign] #3773 justification -1: p51
[end-of-instance]
[assign] #3046 clause p428 (not p427)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[assign] #3452 clause p429 (not p427)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[mk-app] #3936 = #4783 #4825
[attach-meaning] #176 arith (- 1)
[mk-app] #3448 + #4783 #3683
[mk-app] #3456 <= #3448 #36
[mk-app] #3461 >= #3448 #36
[assign] #3936 justification -1: p425
[attach-enode] #3936 0
[attach-enode] #3448 0
[assign] #3456 justification -1: p430
[assign] #3461 justification -1: p430
[new-match] 0x1068b2288 #1495 #1483 #4801 #1545 ; #4821 (#4804 #4804)
[mk-app] #3839 = #4821 #4838
[mk-app] #4262 = #4821 #4843
[mk-app] #4263 = #3839 #4262
[mk-proof] #3840 monotonicity #4845 #4263
[mk-app] #3841 or #1563 #4262
[mk-app] #3842 or #1563 #3839
[mk-proof] #4428 quant-inst #3842
[mk-app] #4430 = #3842 #3841
[mk-proof] #3471 monotonicity #3840 #4430
[mk-app] #3472 = #3841 #3841
[mk-proof] #4431 rewrite #3472
[mk-proof] #4432 trans #3471 #4431 #4430
[mk-proof] #3072 mp #4428 #4432 #3841
[instance] 0x1068b2288 #4428 ; 87
[attach-enode] #4840 87
[attach-enode] #4843 87
[attach-enode] #4262 87
[assign] #4262 justification -1: p50
[end-of-instance]
[eq-expl] #4840 root
[new-match] 0x1068b2528 #1477 #1476 #4840 #1545 ; #4843
[eq-expl] #4821 lit #4262 ; #4843
[eq-expl] #4843 root
[new-match] 0x1068b2560 #1522 #1506 #4840 #1545 ; #4822 (#4821 #4843)
[mk-app] #3073 = #4858 #4840
[mk-app] #3061 = #3073 #3073
[mk-proof] #3065 refl #3061
[mk-app] #4022 or #1576 #3073
[mk-proof] #4023 quant-inst #4022
[instance] 0x1068b2528 #4023 ; 88
[attach-enode] #4858 88
[attach-enode] #3073 88
[assign] #3073 justification -1: p49
[end-of-instance]
[mk-app] #3061 * #176 #4864
[mk-app] #3065 + #4861 #3061
[mk-app] #4018 = #3065 #1503
[mk-app] #3324 = #4018 #4018
[mk-proof] #4193 refl #3324
[mk-app] #3303 or #5113 #4018
[mk-proof] #3309 quant-inst #3303
[instance] 0x1068b2560 #3309 ; 88
[attach-enode] #4860 88
[attach-enode] #4861 88
[attach-enode] #4864 88
[attach-enode] #3061 88
[attach-enode] #3065 88
[attach-enode] #4018 88
[mk-app] #4194 <= #3065 #1503
[mk-app] #4204 >= #3065 #1503
[assign] #4018 justification -1: p51
[end-of-instance]
[assign] #4194 clause p436 (not p435)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[assign] #4204 clause p437 (not p435)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[mk-app] #3324 = #4822 #4864
[attach-meaning] #176 arith (- 1)
[mk-app] #4193 + #4822 #3061
[mk-app] #2997 <= #4193 #36
[mk-app] #2998 >= #4193 #36
[assign] #3324 justification -1: p433
[attach-enode] #3324 0
[attach-enode] #4193 0
[assign] #2997 justification -1: p438
[assign] #2998 justification -1: p438
[new-match] 0x1068b2f20 #1495 #1483 #4840 #1545 ; #4860 (#4843 #4843)
[mk-app] #3599 = #4860 #4877
[mk-app] #2990 = #4860 #4882
[mk-app] #2996 = #3599 #2990
[mk-proof] #2999 monotonicity #4884 #2996
[mk-app] #3000 or #1563 #2990
[mk-app] #3191 or #1563 #3599
[mk-proof] #3196 quant-inst #3191
[mk-app] #3180 = #3191 #3000
[mk-proof] #3181 monotonicity #2999 #3180
[mk-app] #3208 = #3000 #3000
[mk-proof] #3752 rewrite #3208
[mk-proof] #4489 trans #3181 #3752 #3180
[mk-proof] #4598 mp #3196 #4489 #3000
[instance] 0x1068b2f20 #3196 ; 89
[attach-enode] #4879 89
[attach-enode] #4882 89
[attach-enode] #2990 89
[assign] #2990 justification -1: p50
[end-of-instance]
[eq-expl] #4879 root
[new-match] 0x1068b31c0 #1477 #1476 #4879 #1545 ; #4882
[eq-expl] #4860 lit #2990 ; #4882
[eq-expl] #4882 root
[new-match] 0x1068b31f8 #1522 #1506 #4879 #1545 ; #4861 (#4860 #4882)
[mk-app] #3666 = #4897 #4879
[mk-app] #3667 = #3666 #3666
[mk-proof] #4613 refl #3667
[mk-app] #4614 or #1576 #3666
[mk-proof] #4715 quant-inst #4614
[instance] 0x1068b31c0 #4715 ; 90
[attach-enode] #4897 90
[attach-enode] #3666 90
[assign] #3666 justification -1: p49
[end-of-instance]
[mk-app] #3667 * #176 #4903
[mk-app] #4613 + #4900 #3667
[mk-app] #4733 = #4613 #1503
[mk-app] #4661 = #4733 #4733
[mk-proof] #4662 refl #4661
[mk-app] #4701 or #5113 #4733
[mk-proof] #4706 quant-inst #4701
[instance] 0x1068b31f8 #4706 ; 90
[attach-enode] #4899 90
[attach-enode] #4900 90
[attach-enode] #4903 90
[attach-enode] #3667 90
[attach-enode] #4613 90
[attach-enode] #4733 90
[mk-app] #4707 <= #4613 #1503
[mk-app] #4831 >= #4613 #1503
[assign] #4733 justification -1: p51
[end-of-instance]
[assign] #4707 clause p444 (not p443)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[assign] #4831 clause p445 (not p443)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[mk-app] #4661 = #4861 #4903
[attach-meaning] #176 arith (- 1)
[mk-app] #4662 + #4861 #3667
[mk-app] #4851 <= #4662 #36
[mk-app] #4846 >= #4662 #36
[assign] #4661 justification -1: p441
[attach-enode] #4661 0
[attach-enode] #4662 0
[assign] #4851 justification -1: p446
[assign] #4846 justification -1: p446
[new-match] 0x1068ba9e8 #1495 #1483 #4879 #1545 ; #4899 (#4882 #4882)
[mk-app] #4847 = #4899 #4916
[mk-app] #4848 = #4899 #4921
[mk-app] #4849 = #4847 #4848
[mk-proof] #4852 monotonicity #4923 #4849
[mk-app] #5045 or #1563 #4848
[mk-app] #5046 or #1563 #4847
[mk-proof] #5018 quant-inst #5046
[mk-app] #5019 = #5046 #5045
[mk-proof] #5026 monotonicity #4852 #5019
[mk-app] #5027 = #5045 #5045
[mk-proof] #5105 rewrite #5027
[mk-proof] #3265 trans #5026 #5105 #5019
[mk-proof] #5087 mp #5018 #3265 #5045
[instance] 0x1068ba9e8 #5018 ; 91
[attach-enode] #4918 91
[attach-enode] #4921 91
[attach-enode] #4848 91
[assign] #4848 justification -1: p50
[end-of-instance]
[eq-expl] #4918 root
[new-match] 0x1068bac88 #1477 #1476 #4918 #1545 ; #4921
[eq-expl] #4899 lit #4848 ; #4921
[eq-expl] #4921 root
[new-match] 0x1068bacc0 #1522 #1506 #4918 #1545 ; #4900 (#4899 #4921)
[mk-app] #5088 = #4936 #4918
[mk-app] #3266 = #5088 #5088
[mk-proof] #3267 refl #3266
[mk-app] #4066 or #1576 #5088
[mk-proof] #4067 quant-inst #4066
[instance] 0x1068bac88 #4067 ; 92
[attach-enode] #4936 92
[attach-enode] #5088 92
[assign] #5088 justification -1: p49
[end-of-instance]
[mk-app] #3266 * #176 #4942
[mk-app] #3267 + #4939 #3266
[mk-app] #3093 = #3267 #1503
[mk-app] #3094 = #3093 #3093
[mk-proof] #3099 refl #3094
[mk-app] #3103 or #5113 #3093
[mk-proof] #3040 quant-inst #3103
[instance] 0x1068bacc0 #3040 ; 92
[attach-enode] #4938 92
[attach-enode] #4939 92
[attach-enode] #4942 92
[attach-enode] #3266 92
[attach-enode] #3267 92
[attach-enode] #3093 92
[mk-app] #4497 <= #3267 #1503
[mk-app] #3566 >= #3267 #1503
[assign] #3093 justification -1: p51
[end-of-instance]
[assign] #4497 clause p452 (not p451)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[assign] #3566 clause p453 (not p451)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[mk-app] #3094 = #4900 #4942
[attach-meaning] #176 arith (- 1)
[mk-app] #3099 + #4900 #3266
[mk-app] #3567 <= #3099 #36
[mk-app] #3634 >= #3099 #36
[assign] #3094 justification -1: p449
[attach-enode] #3094 0
[attach-enode] #3099 0
[assign] #3567 justification -1: p454
[assign] #3634 justification -1: p454
[new-match] 0x1068bb680 #1495 #1483 #4918 #1545 ; #4938 (#4921 #4921)
[mk-app] #4014 = #4938 #4955
[mk-app] #3538 = #4938 #4960
[mk-app] #3423 = #4014 #3538
[mk-proof] #4084 monotonicity #4962 #3423
[mk-app] #4089 or #1563 #3538
[mk-app] #4374 or #1563 #4014
[mk-proof] #4375 quant-inst #4374
[mk-app] #4372 = #4374 #4089
[mk-proof] #3863 monotonicity #4084 #4372
[mk-app] #3845 = #4089 #4089
[mk-proof] #3933 rewrite #3845
[mk-proof] #3864 trans #3863 #3933 #4372
[mk-proof] #4568 mp #4375 #3864 #4089
[instance] 0x1068bb680 #4375 ; 93
[attach-enode] #4957 93
[attach-enode] #4960 93
[attach-enode] #3538 93
[assign] #3538 justification -1: p50
[end-of-instance]
[eq-expl] #4957 root
[new-match] 0x1068bb920 #1477 #1476 #4957 #1545 ; #4960
[eq-expl] #4938 lit #3538 ; #4960
[eq-expl] #4960 root
[new-match] 0x1068bb958 #1522 #1506 #4957 #1545 ; #4939 (#4938 #4960)
[mk-app] #4569 = #4975 #4957
[mk-app] #4634 = #4569 #4569
[mk-proof] #4677 refl #4634
[mk-app] #4678 or #1576 #4569
[mk-proof] #4719 quant-inst #4678
[instance] 0x1068bb920 #4719 ; 94
[attach-enode] #4975 94
[attach-enode] #4569 94
[assign] #4569 justification -1: p49
[end-of-instance]
[mk-app] #4634 * #176 #4981
[mk-app] #4677 + #4978 #4634
[mk-app] #4755 = #4677 #1503
[mk-app] #4717 = #4755 #4755
[mk-proof] #4712 refl #4717
[mk-app] #4913 or #5113 #4755
[mk-proof] #4914 quant-inst #4913
[instance] 0x1068bb958 #4914 ; 94
[attach-enode] #4977 94
[attach-enode] #4978 94
[attach-enode] #4981 94
[attach-enode] #4634 94
[attach-enode] #4677 94
[attach-enode] #4755 94
[mk-app] #4907 <= #4677 #1503
[mk-app] #4908 >= #4677 #1503
[assign] #4755 justification -1: p51
[end-of-instance]
[assign] #4907 clause p460 (not p459)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[assign] #4908 clause p461 (not p459)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[mk-app] #4717 = #4939 #4981
[attach-meaning] #176 arith (- 1)
[mk-app] #4712 + #4939 #4634
[mk-app] #4950 <= #4712 #36
[mk-app] #4951 >= #4712 #36
[assign] #4717 justification -1: p457
[attach-enode] #4717 0
[attach-enode] #4712 0
[assign] #4950 justification -1: p462
[assign] #4951 justification -1: p462
[new-match] 0x1068bc318 #1495 #1483 #4957 #1545 ; #4977 (#4960 #4960)
[mk-app] #5111 = #4977 #4994
[mk-app] #5112 = #4977 #4999
[mk-app] #4339 = #5111 #5112
[mk-proof] #5190 monotonicity #5001 #4339
[mk-app] #5061 or #1563 #5112
[mk-app] #5062 or #1563 #5111
[mk-proof] #3886 quant-inst #5062
[mk-app] #3487 = #5062 #5061
[mk-proof] #2992 monotonicity #5190 #3487
[mk-app] #2993 = #5061 #5061
[mk-proof] #3474 rewrite #2993
[mk-proof] #3792 trans #2992 #3474 #3487
[mk-proof] #3356 mp #3886 #3792 #5061
[instance] 0x1068bc318 #3886 ; 95
[attach-enode] #4996 95
[attach-enode] #4999 95
[attach-enode] #5112 95
[assign] #5112 justification -1: p50
[end-of-instance]
[eq-expl] #4996 root
[new-match] 0x1068bc5b8 #1477 #1476 #4996 #1545 ; #4999
[eq-expl] #4977 lit #5112 ; #4999
[eq-expl] #4999 root
[new-match] 0x1068cdc10 #1522 #1506 #4996 #1545 ; #4978 (#4977 #4999)
[mk-app] #3345 = #5014 #4996
[mk-app] #3371 = #3345 #3345
[mk-proof] #3372 refl #3371
[mk-app] #4517 or #1576 #3345
[mk-proof] #4148 quant-inst #4517
[instance] 0x1068bc5b8 #4148 ; 96
[attach-enode] #5014 96
[attach-enode] #3345 96
[assign] #3345 justification -1: p49
[end-of-instance]
[mk-app] #3371 * #176 #5020
[mk-app] #3372 + #5017 #3371
[mk-app] #3406 = #3372 #1503
[mk-app] #3645 = #3406 #3406
[mk-proof] #3505 refl #3645
[mk-app] #3500 or #5113 #3406
[mk-proof] #3408 quant-inst #3500
[instance] 0x1068cdc10 #3408 ; 96
[attach-enode] #5016 96
[attach-enode] #5017 96
[attach-enode] #5020 96
[attach-enode] #3371 96
[attach-enode] #3372 96
[attach-enode] #3406 96
[mk-app] #3407 <= #3372 #1503
[mk-app] #3834 >= #3372 #1503
[assign] #3406 justification -1: p51
[end-of-instance]
[assign] #3407 clause p468 (not p467)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[assign] #3834 clause p469 (not p467)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[mk-app] #3645 = #4978 #5020
[attach-meaning] #176 arith (- 1)
[mk-app] #3505 + #4978 #3371
[mk-app] #3835 <= #3505 #36
[mk-app] #3269 >= #3505 #36
[assign] #3645 justification -1: p465
[attach-enode] #3645 0
[attach-enode] #3505 0
[assign] #3835 justification -1: p470
[assign] #3269 justification -1: p470
[new-match] 0x1068ce5d0 #1495 #1483 #4996 #1545 ; #5016 (#4999 #4999)
[mk-app] #3270 = #5016 #5033
[mk-app] #3087 = #5016 #5038
[mk-app] #3088 = #3270 #3087
[mk-proof] #3035 monotonicity #5040 #3088
[mk-app] #3990 or #1563 #3087
[mk-app] #3700 or #1563 #3270
[mk-proof] #4593 quant-inst #3700
[mk-app] #3008 = #3700 #3990
[mk-proof] #3013 monotonicity #3035 #3008
[mk-app] #4082 = #3990 #3990
[mk-proof] #4104 rewrite #4082
[mk-proof] #3122 trans #3013 #4104 #3008
[mk-proof] #3129 mp #4593 #3122 #3990
[instance] 0x1068ce5d0 #4593 ; 97
[attach-enode] #5035 97
[attach-enode] #5038 97
[attach-enode] #3087 97
[assign] #3087 justification -1: p50
[end-of-instance]
[eq-expl] #5035 root
[new-match] 0x1068ce870 #1477 #1476 #5035 #1545 ; #5038
[eq-expl] #5016 lit #3087 ; #5038
[eq-expl] #5038 root
[new-match] 0x1068ce8a8 #1522 #1506 #5035 #1545 ; #5017 (#5016 #5038)
[mk-app] #4512 = #5053 #5035
[mk-app] #4513 = #4512 #4512
[mk-proof] #3680 refl #4513
[mk-app] #3450 or #1576 #4512
[mk-proof] #3554 quant-inst #3450
[instance] 0x1068ce870 #3554 ; 98
[attach-enode] #5053 98
[attach-enode] #4512 98
[assign] #4512 justification -1: p49
[end-of-instance]
[mk-app] #4513 * #176 #5059
[mk-app] #3680 + #5056 #4513
[mk-app] #2924 = #3680 #1503
[mk-app] #3589 = #2924 #2924
[mk-proof] #3580 refl #3589
[mk-app] #4040 or #5113 #2924
[mk-proof] #4498 quant-inst #4040
[instance] 0x1068ce8a8 #4498 ; 98
[attach-enode] #5055 98
[attach-enode] #5056 98
[attach-enode] #5059 98
[attach-enode] #4513 98
[attach-enode] #3680 98
[attach-enode] #2924 98
[mk-app] #3873 <= #3680 #1503
[mk-app] #4414 >= #3680 #1503
[assign] #2924 justification -1: p51
[end-of-instance]
[assign] #3873 clause p476 (not p475)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[assign] #4414 clause p477 (not p475)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[mk-app] #3589 = #5017 #5059
[attach-meaning] #176 arith (- 1)
[mk-app] #3580 + #5017 #4513
[mk-app] #4499 <= #3580 #36
[mk-app] #3301 >= #3580 #36
[assign] #3589 justification -1: p473
[attach-enode] #3589 0
[attach-enode] #3580 0
[assign] #4499 justification -1: p478
[assign] #3301 justification -1: p478
[new-match] 0x1068cf268 #1495 #1483 #5035 #1545 ; #5055 (#5038 #5038)
[mk-app] #3655 = #5055 #5072
[mk-app] #4622 = #5055 #5077
[mk-app] #3186 = #3655 #4622
[mk-proof] #4515 monotonicity #5079 #3186
[mk-app] #4623 or #1563 #4622
[mk-app] #4618 or #1563 #3655
[mk-proof] #4885 quant-inst #4618
[mk-app] #4863 = #4618 #4623
[mk-proof] #4810 monotonicity #4515 #4863
[mk-app] #4813 = #4623 #4623
[mk-proof] #4870 rewrite #4813
[mk-proof] #4886 trans #4810 #4870 #4863
[mk-proof] #5083 mp #4885 #4886 #4623
[instance] 0x1068cf268 #4885 ; 99
[attach-enode] #5074 99
[attach-enode] #5077 99
[attach-enode] #4622 99
[assign] #4622 justification -1: p50
[end-of-instance]
[eq-expl] #5074 root
[new-match] 0x1068cf508 #1477 #1476 #5074 #1545 ; #5077
[eq-expl] #5055 lit #4622 ; #5077
[eq-expl] #5077 root
[new-match] 0x1068cf540 #1522 #1506 #5074 #1545 ; #5056 (#5055 #5077)
[mk-app] #4068 = #5092 #5074
[mk-app] #5012 = #4068 #4068
[mk-proof] #5080 refl #5012
[mk-app] #3062 or #1576 #4068
[mk-proof] #3975 quant-inst #3062
[instance] 0x1068cf508 #3975 ; 100
[attach-enode] #5092 100
[attach-enode] #4068 100
[assign] #4068 justification -1: p49
[end-of-instance]
[mk-app] #5012 * #176 #5098
[mk-app] #5080 + #5095 #5012
[mk-app] #4245 = #5080 #1503
[mk-app] #3565 = #4245 #4245
[mk-proof] #2939 refl #3565
[mk-app] #2945 or #5113 #4245
[mk-proof] #3557 quant-inst #2945
[instance] 0x1068cf540 #3557 ; 100
[attach-enode] #5094 100
[attach-enode] #5095 100
[attach-enode] #5098 100
[attach-enode] #5012 100
[attach-enode] #5080 100
[attach-enode] #4245 100
[mk-app] #3826 <= #5080 #1503
[mk-app] #3079 >= #5080 #1503
[assign] #4245 justification -1: p51
[end-of-instance]
[assign] #3826 clause p484 (not p483)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[assign] #3079 clause p485 (not p483)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[mk-app] #3565 = #5056 #5098
[attach-meaning] #176 arith (- 1)
[mk-app] #2939 + #5056 #5012
[mk-app] #3074 <= #2939 #36
[mk-app] #3940 >= #2939 #36
[assign] #3565 justification -1: p481
[attach-enode] #3565 0
[attach-enode] #2939 0
[assign] #3074 justification -1: p486
[assign] #3940 justification -1: p486
[new-match] 0x1068e2d10 #1495 #1483 #5074 #1545 ; #5094 (#5077 #5077)
[decide-and-or] #2170 #2177
[push] 3
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 4
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3402 root
[new-match] 0x1068e4178 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e41b0 #1674 #1173 #3403 #1529 ; #4352
[eq-expl] #1528 root
[eq-expl] #2191 root
[new-match] 0x1068e41e8 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4228 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4268 #124 #118 #1528 ; #3402
[new-match] 0x1068e4298 #143 #118 #1528 ; #3402
[new-match] 0x1068e42c8 #237 #229 #3402 #36 ; #3403
[mk-app] #2912 * #176 #4347
[mk-app] #3076 + #3403 #5110 #2912
[mk-app] #3284 = #3076 #36
[mk-app] #4868 + #5110 #3403 #2912
[inst-discovered] theory-solving 0x0 arith# ; #3076
[mk-app] #5024 = #3076 #4868
[mk-proof] #4680 rewrite #5024
[instance] 0x0 #5024
[end-of-instance]
[mk-app] #4836 = #4868 #36
[mk-app] #5025 = #3284 #4836
[mk-proof] #4991 monotonicity #4680 #5025
[attach-meaning] #176 arith (- 1)
[mk-app] #5115 + #3402 #5120 #4347
[mk-app] #5116 = #5115 #36
[inst-discovered] theory-solving 0x0 arith# ; #4836
[mk-app] #5064 = #4836 #5116
[mk-proof] #5265 rewrite #5064
[instance] 0x0 #5064
[end-of-instance]
[mk-app] #5432 = #3284 #5116
[mk-proof] #5269 trans #4991 #5265 #5432
[mk-app] #5124 not #263
[mk-app] #5267 or #5124 #5116
[mk-app] #5268 or #5124 #3284
[mk-proof] #5263 quant-inst #5268
[mk-app] #5185 = #5268 #5267
[mk-proof] #5186 monotonicity #5269 #5185
[mk-app] #5283 = #5267 #5267
[mk-proof] #5262 rewrite #5283
[mk-proof] #5177 trans #5186 #5262 #5185
[mk-proof] #5215 mp #5263 #5177 #5267
[instance] 0x1068e4178 #5263 ; 3
[attach-enode] #5120 3
[attach-enode] #5115 3
[attach-enode] #5116 3
[mk-app] #5218 <= #5115 #36
[mk-app] #5538 >= #5115 #36
[assign] #5116 justification -1: p21
[end-of-instance]
[mk-app] #5133 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5133
[mk-app] #5243 = #5133 #5133
[mk-proof] #5242 rewrite #5243
[instance] 0x0 #5243
[end-of-instance]
[mk-app] #5225 or #4423 #5142 #5144 #5145
[mk-app] #5237 or #4423 #5133
[mk-proof] #5238 quant-inst #5237
[mk-app] #5119 = #5237 #5225
[mk-proof] #5212 rewrite #5119
[mk-proof] #5220 mp #5238 #5212 #5225
[instance] 0x1068e41b0 #5238 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5243 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5242 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5197 = #5243 #5242
[mk-proof] #5288 monotonicity #5169 #5197
[mk-app] #5275 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5242
[mk-app] #5287 = #5242 #5275
[mk-proof] #5459 rewrite #5287
[instance] 0x0 #5287
[end-of-instance]
[mk-app] #5436 = #5243 #5275
[mk-proof] #5452 trans #5288 #5459 #5436
[mk-app] #5543 not #1917
[mk-app] #5448 or #5543 #2172 #2353 #5144 #5148 #5165
[mk-app] #5068 or #5543 #5243
[mk-proof] #5067 quant-inst #5068
[mk-app] #5174 or #5543 #5275
[mk-app] #5467 = #5068 #5174
[mk-proof] #5586 monotonicity #5452 #5467
[mk-app] #5587 = #5174 #5448
[mk-proof] #5585 rewrite #5587
[mk-app] #5466 = #5068 #5448
[mk-proof] #5580 trans #5586 #5585 #5466
[mk-proof] #5450 mp #5067 #5580 #5448
[instance] 0x1068e41e8 #5067 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5108 = #5069 #5069
[mk-proof] #5286 refl #5108
[instance] 0x1068e4268 #5153 ; 3
[assign] #5069 justification -1: p13
[end-of-instance]
[mk-app] #5108 or #5455 #2172
[mk-app] #5286 = #5108 #5108
[mk-proof] #5253 refl #5286
[mk-app] #5560 or #2307 #5455 #2172
[mk-app] #5134 or #2307 #5108
[mk-proof] #5152 quant-inst #5134
[mk-app] #5589 = #5134 #5560
[mk-proof] #5590 rewrite #5589
[mk-proof] #5591 mp #5152 #5590 #5560
[instance] 0x1068e4298 #5152 ; 3
[attach-enode] #5191 3
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[mk-app] #5286 = #5196 #36
[mk-app] #5253 = #5164 #36
[mk-app] #5592 = #5286 #5253
[mk-proof] #5199 monotonicity #5206 #5592
[mk-app] #5549 not #237
[mk-app] #5593 or #5549 #5253
[mk-app] #5463 or #5549 #5286
[mk-proof] #5182 quant-inst #5463
[mk-app] #5539 = #5463 #5593
[mk-proof] #5518 monotonicity #5199 #5539
[mk-app] #5210 = #5593 #5593
[mk-proof] #5217 rewrite #5210
[mk-proof] #5519 trans #5518 #5217 #5539
[mk-proof] #5520 mp #5182 #5519 #5593
[instance] 0x1068e42c8 #5182 ; 3
[attach-enode] #5253 3
[mk-app] #5521 >= #5164 #36
[assign] #5253 justification -1: p20
[end-of-instance]
[assign] #5218 clause p490 (not p489)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5538 clause p491 (not p489)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5460) clause (not p499) p498
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p496 (not p500)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5521 clause p501 (not p500)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5584 <= #4347 #36
[mk-app] #5532 >= #4347 #36
[assign] #5584 justification -1: p78
[assign] #5532 justification -1: p78
[assign] #5143 clause p493 (not p496) (not p497)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5225 #5142
[push] 5
[assign] #5142 decision axiom
[new-match] 0x1068e9890 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98c8 #124 #118 #1529 ; #5139
[new-match] 0x1068e98f8 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5278
[instance] 0x0 #5271
[end-of-instance]
[instance] 0x1068e9890 #5244 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5533 >= #5139 #36
[mk-app] #5540 = #5533 #5533
[mk-proof] #5522 refl #5540
[mk-app] #5524 or #1546 #5533
[mk-proof] #5525 quant-inst #5524
[instance] 0x1068e98c8 #5525 ; 4
[assign] #5533 justification -1: p13
[end-of-instance]
[mk-app] #5540 not #5255
[mk-app] #5522 or #5540 #5259
[mk-app] #5514 = #5522 #5522
[mk-proof] #5516 refl #5514
[mk-app] #5512 or #2307 #5540 #5259
[mk-app] #5513 or #2307 #5522
[mk-proof] #5511 quant-inst #5513
[mk-app] #5510 = #5513 #5512
[mk-proof] #5517 rewrite #5510
[mk-proof] #5526 mp #5511 #5517 #5512
[instance] 0x1068e98f8 #5511 ; 4
[attach-enode] #5255 4
[mk-app] #5535 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5250 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5251 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5521)
[resolve-lit] 0 (not #5250)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5250)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[mk-proof] #5514 hypothesis #5142
[mk-proof] #5516 hypothesis #2294
[mk-proof] #5536 hypothesis #2177
[mk-proof] #5528 unit-resolution #5249 #2731 #5536 #5516 #5229
[mk-proof] #5529 unit-resolution #5621 #5528 #5250
[mk-proof] #5537 unit-resolution #5520 #2853 #5253
[mk-app] #5523 not #5253
[mk-app] #5527 or #5523 #5521
[mk-proof] #5530 th-lemma #5527
[mk-proof] #5501 unit-resolution #5530 #5537 #5521
[mk-proof] #5488 th-lemma #5501 #5619 #5529 #5514 #2
[mk-app] #5484 not #5142
[mk-app] #5481 or #5484 #2353 #2172
[mk-proof] #5491 lemma #5488 #5481
[conflict] (not #5142) #2353 #2172
[pop] 1 6
[assign] (not #5142) clause (not p492) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p494 p492 (not p493)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068e9878 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98b0 #124 #118 #1529 ; #5139
[new-match] 0x1068e98e0 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5278
[instance] 0x0 #5271
[end-of-instance]
[instance] 0x1068e9878 #5244 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5524 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5525 = #5533 #5533
[mk-proof] #5513 refl #5525
[mk-app] #5511 or #1546 #5533
[mk-proof] #5512 quant-inst #5511
[instance] 0x1068e98b0 #5512 ; 4
[assign] #5533 justification -1: p13
[end-of-instance]
[mk-app] #5525 = #5522 #5522
[mk-proof] #5513 refl #5525
[mk-app] #5510 or #2307 #5540 #5259
[mk-app] #5517 or #2307 #5522
[mk-proof] #5526 quant-inst #5517
[mk-app] #5251 = #5517 #5510
[mk-proof] #5535 rewrite #5251
[mk-proof] #5554 mp #5526 #5535 #5510
[instance] 0x1068e98e0 #5526 ; 4
[attach-enode] #5255 4
[mk-app] #5471 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5250 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5524 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #5471) clause (not p509) (not p496) (not p497) p492
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p508) p509
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #5525 >= #5256 #36
[mk-app] #5513 not #5525
[mk-app] #5257 or #5525 #5513
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #5257
[end-of-instance]
[push] 5
[assign] (not #5525) decision axiom
[mk-app] #1555 Seq<Int>!val!0
[mk-app] #1557 $Ref!val!0
[mk-app] #1556 $Ref!val!1
[mk-app] #5138 Ptr32!val!0
[mk-app] #5264 Ptr32!val!1
[mk-app] #5431 Seq<Int>!val!1
[mk-app] #2290 Seq<Int>!val!2
[mk-app] #5581 Seq<Int>!val!3
[mk-app] #5063 Int
[attach-meaning] #5063 arith 8099
[mk-app] #5178 Int
[attach-meaning] #5178 arith (- 3)
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[mk-app] #5258 Ptr32!val!2
[mk-app] #5428 Ptr32!val!3
[attach-meaning] #4108 arith (- 4)
[mk-app] #5427 Ptr32!val!4
[attach-meaning] #3632 arith 17
[mk-app] #5426 Ptr32!val!5
[attach-meaning] #4096 arith 21
[mk-app] #5425 Ptr32!val!6
[attach-meaning] #4548 arith 25
[mk-app] #5424 Ptr32!val!7
[attach-meaning] #3887 arith 29
[mk-app] #5423 Ptr32!val!8
[attach-meaning] #4187 arith 33
[mk-app] #5422 Ptr32!val!9
[attach-meaning] #4506 arith 37
[mk-app] #5421 Ptr32!val!10
[attach-meaning] #4723 arith 41
[mk-app] #5420 Ptr32!val!11
[attach-meaning] #4879 arith 45
[mk-app] #5419 Ptr32!val!12
[attach-meaning] #5035 arith 49
[mk-app] #5418 Ptr32!val!13
[mk-app] #5417 Int
[attach-meaning] #5417 arith 53
[mk-app] #5415 Ptr32!val!14
[mk-app] #5413 Int
[attach-meaning] #5413 arith 57
[mk-app] #5411 Ptr32!val!15
[mk-app] #5409 Int
[attach-meaning] #5409 arith 61
[attach-meaning] #3722 arith 16
[mk-app] #5407 Ptr32!val!16
[mk-app] #5405 Int
[attach-meaning] #5405 arith 65
[attach-meaning] #3632 arith 17
[mk-app] #5403 Ptr32!val!17
[mk-app] #5401 Int
[attach-meaning] #5401 arith 69
[attach-meaning] #3800 arith 18
[mk-app] #5399 Ptr32!val!18
[mk-app] #5397 Int
[attach-meaning] #5397 arith 73
[attach-meaning] #4573 arith 19
[mk-app] #5395 Ptr32!val!19
[mk-app] #5393 Int
[attach-meaning] #5393 arith 77
[attach-meaning] #3161 arith 20
[mk-app] #5391 Ptr32!val!20
[mk-app] #5389 Int
[attach-meaning] #5389 arith 81
[attach-meaning] #4096 arith 21
[mk-app] #5387 Ptr32!val!21
[mk-app] #5385 Int
[attach-meaning] #5385 arith 85
[attach-meaning] #3898 arith 22
[mk-app] #5383 Ptr32!val!22
[mk-app] #5381 Int
[attach-meaning] #5381 arith 89
[attach-meaning] #3432 arith 23
[mk-app] #5379 Ptr32!val!23
[mk-app] #5377 Int
[attach-meaning] #5377 arith 93
[attach-meaning] #4382 arith 24
[mk-app] #5375 Ptr32!val!24
[mk-app] #5373 Int
[attach-meaning] #5373 arith 97
[attach-meaning] #4548 arith 25
[mk-app] #5371 Ptr32!val!25
[mk-app] #5369 Int
[attach-meaning] #5369 arith 101
[attach-meaning] #2916 arith 26
[mk-app] #5367 Ptr32!val!26
[mk-app] #5365 Int
[attach-meaning] #5365 arith 105
[attach-meaning] #3947 arith 27
[mk-app] #5363 Ptr32!val!27
[mk-app] #5361 Int
[attach-meaning] #5361 arith 109
[attach-meaning] #4389 arith 28
[mk-app] #5357 Ptr32!val!28
[mk-app] #5353 Int
[attach-meaning] #5353 arith 113
[attach-meaning] #3887 arith 29
[mk-app] #5349 Ptr32!val!29
[mk-app] #5345 Int
[attach-meaning] #5345 arith 117
[attach-meaning] #3867 arith 30
[mk-app] #5341 Ptr32!val!30
[mk-app] #5337 Int
[attach-meaning] #5337 arith 121
[attach-meaning] #3730 arith 31
[mk-app] #5333 Ptr32!val!31
[mk-app] #5329 Int
[attach-meaning] #5329 arith 125
[attach-meaning] #3291 arith 32
[mk-app] #5325 Ptr32!val!32
[mk-app] #5323 Int
[attach-meaning] #5323 arith 129
[attach-meaning] #4187 arith 33
[mk-app] #5430 Ptr32!val!33
[mk-app] #5429 Int
[attach-meaning] #5429 arith 133
[attach-meaning] #3677 arith 34
[mk-app] #5416 Ptr32!val!34
[mk-app] #5414 Int
[attach-meaning] #5414 arith 137
[attach-meaning] #3981 arith 35
[mk-app] #5412 Ptr32!val!35
[mk-app] #5410 Int
[attach-meaning] #5410 arith 141
[attach-meaning] #3216 arith 36
[mk-app] #5408 Ptr32!val!36
[mk-app] #5406 Int
[attach-meaning] #5406 arith 145
[attach-meaning] #4506 arith 37
[mk-app] #5404 Ptr32!val!37
[mk-app] #5402 Int
[attach-meaning] #5402 arith 149
[attach-meaning] #4606 arith 38
[mk-app] #5400 Ptr32!val!38
[mk-app] #5398 Int
[attach-meaning] #5398 arith 153
[attach-meaning] #4645 arith 39
[mk-app] #5396 Ptr32!val!39
[mk-app] #5394 Int
[attach-meaning] #5394 arith 157
[attach-meaning] #4684 arith 40
[mk-app] #5392 Ptr32!val!40
[mk-app] #5390 Int
[attach-meaning] #5390 arith 161
[attach-meaning] #4723 arith 41
[mk-app] #5388 Ptr32!val!41
[mk-app] #5386 Int
[attach-meaning] #5386 arith 165
[attach-meaning] #4762 arith 42
[mk-app] #5384 Ptr32!val!42
[mk-app] #5382 Int
[attach-meaning] #5382 arith 169
[attach-meaning] #4801 arith 43
[mk-app] #5380 Ptr32!val!43
[mk-app] #5378 Int
[attach-meaning] #5378 arith 173
[attach-meaning] #4840 arith 44
[mk-app] #5376 Ptr32!val!44
[mk-app] #5370 Int
[attach-meaning] #5370 arith 177
[attach-meaning] #4879 arith 45
[mk-app] #5366 Ptr32!val!45
[mk-app] #5362 Int
[attach-meaning] #5362 arith 181
[attach-meaning] #4918 arith 46
[mk-app] #5355 Ptr32!val!46
[mk-app] #5347 Int
[attach-meaning] #5347 arith 185
[attach-meaning] #4957 arith 47
[mk-app] #5339 Ptr32!val!47
[mk-app] #5331 Int
[attach-meaning] #5331 arith 189
[attach-meaning] #4996 arith 48
[mk-app] #5321 Ptr32!val!48
[mk-app] #5317 Int
[attach-meaning] #5317 arith 193
[attach-meaning] #5035 arith 49
[mk-app] #5313 Ptr32!val!49
[mk-app] #5309 Int
[attach-meaning] #5309 arith 197
[attach-meaning] #5074 arith 50
[mk-app] #5305 Ptr32!val!50
[mk-app] #5301 Ptr32!val!51
[mk-app] #5297 Int
[attach-meaning] #5297 arith 201
[mk-app] #5293 Int
[attach-meaning] #5293 arith 8100
[attach-meaning] #3722 arith 16
[attach-meaning] #3632 arith 17
[attach-meaning] #3800 arith 18
[attach-meaning] #4573 arith 19
[attach-meaning] #3161 arith 20
[attach-meaning] #4096 arith 21
[attach-meaning] #3898 arith 22
[attach-meaning] #3432 arith 23
[attach-meaning] #4382 arith 24
[attach-meaning] #4548 arith 25
[attach-meaning] #2916 arith 26
[attach-meaning] #3947 arith 27
[attach-meaning] #4389 arith 28
[attach-meaning] #3887 arith 29
[attach-meaning] #3867 arith 30
[attach-meaning] #3730 arith 31
[attach-meaning] #3291 arith 32
[attach-meaning] #4187 arith 33
[attach-meaning] #3677 arith 34
[attach-meaning] #3981 arith 35
[attach-meaning] #3216 arith 36
[attach-meaning] #4506 arith 37
[attach-meaning] #4606 arith 38
[attach-meaning] #4645 arith 39
[attach-meaning] #4684 arith 40
[attach-meaning] #4723 arith 41
[attach-meaning] #4762 arith 42
[attach-meaning] #4801 arith 43
[attach-meaning] #4840 arith 44
[attach-meaning] #4879 arith 45
[attach-meaning] #4918 arith 46
[attach-meaning] #4957 arith 47
[attach-meaning] #4996 arith 48
[attach-meaning] #5035 arith 49
[attach-meaning] #5074 arith 50
[mk-app] #5289 Int
[attach-meaning] #5289 arith 51
[mk-app] #2340 Int
[attach-meaning] #2340 arith 52
[attach-meaning] #5417 arith 53
[mk-app] #2291 Int
[attach-meaning] #2291 arith 54
[mk-app] #5358 Int
[attach-meaning] #5358 arith 55
[mk-app] #5354 Int
[attach-meaning] #5354 arith 56
[attach-meaning] #5413 arith 57
[mk-app] #5350 Int
[attach-meaning] #5350 arith 58
[mk-app] #5346 Int
[attach-meaning] #5346 arith 59
[mk-app] #5342 Int
[attach-meaning] #5342 arith 60
[attach-meaning] #5409 arith 61
[mk-app] #5338 Int
[attach-meaning] #5338 arith 62
[mk-app] #5334 Int
[attach-meaning] #5334 arith 63
[mk-app] #5330 Int
[attach-meaning] #5330 arith 64
[attach-meaning] #5405 arith 65
[mk-app] #5326 Int
[attach-meaning] #5326 arith 66
[mk-app] #5322 Int
[attach-meaning] #5322 arith 67
[mk-app] #5318 Int
[attach-meaning] #5318 arith 68
[attach-meaning] #5401 arith 69
[mk-app] #5314 Int
[attach-meaning] #5314 arith 70
[mk-app] #5310 Int
[attach-meaning] #5310 arith 71
[mk-app] #5306 Int
[attach-meaning] #5306 arith 72
[attach-meaning] #5397 arith 73
[mk-app] #5302 Int
[attach-meaning] #5302 arith 74
[mk-app] #5298 Int
[attach-meaning] #5298 arith 75
[mk-app] #5294 Int
[attach-meaning] #5294 arith 76
[attach-meaning] #5393 arith 77
[mk-app] #5290 Int
[attach-meaning] #5290 arith 78
[mk-app] #2341 Int
[attach-meaning] #2341 arith 79
[mk-app] #2343 Int
[attach-meaning] #2343 arith 80
[attach-meaning] #5389 arith 81
[mk-app] #5374 Int
[attach-meaning] #5374 arith 82
[mk-app] #5372 Int
[attach-meaning] #5372 arith 83
[mk-app] #5368 Int
[attach-meaning] #5368 arith 84
[attach-meaning] #5385 arith 85
[mk-app] #5364 Int
[attach-meaning] #5364 arith 86
[mk-app] #5360 Int
[attach-meaning] #5360 arith 87
[mk-app] #5351 Int
[attach-meaning] #5351 arith 88
[attach-meaning] #5381 arith 89
[mk-app] #5343 Int
[attach-meaning] #5343 arith 90
[mk-app] #5335 Int
[attach-meaning] #5335 arith 91
[mk-app] #5327 Int
[attach-meaning] #5327 arith 92
[attach-meaning] #5377 arith 93
[mk-app] #5319 Int
[attach-meaning] #5319 arith 94
[mk-app] #5315 Int
[attach-meaning] #5315 arith 95
[mk-app] #5311 Int
[attach-meaning] #5311 arith 96
[attach-meaning] #5373 arith 97
[mk-app] #5307 Int
[attach-meaning] #5307 arith 98
[mk-app] #5303 Int
[attach-meaning] #5303 arith 99
[mk-app] #5299 Int
[attach-meaning] #5299 arith 100
[attach-meaning] #5369 arith 101
[mk-app] #5295 Int
[attach-meaning] #5295 arith 102
[mk-app] #5291 Int
[attach-meaning] #5291 arith 103
[mk-app] #2342 Int
[attach-meaning] #2342 arith 104
[attach-meaning] #5365 arith 105
[mk-app] #2192 Int
[attach-meaning] #2192 arith 106
[mk-app] #5359 Int
[attach-meaning] #5359 arith 107
[mk-app] #5356 Int
[attach-meaning] #5356 arith 108
[attach-meaning] #5361 arith 109
[mk-app] #5352 Int
[attach-meaning] #5352 arith 110
[mk-app] #5348 Int
[attach-meaning] #5348 arith 111
[mk-app] #5344 Int
[attach-meaning] #5344 arith 112
[attach-meaning] #5353 arith 113
[mk-app] #5340 Int
[attach-meaning] #5340 arith 114
[mk-app] #5336 Int
[attach-meaning] #5336 arith 115
[mk-app] #5332 Int
[attach-meaning] #5332 arith 116
[attach-meaning] #5345 arith 117
[mk-app] #5328 Int
[attach-meaning] #5328 arith 118
[mk-app] #5324 Int
[attach-meaning] #5324 arith 119
[mk-app] #5320 Int
[attach-meaning] #5320 arith 120
[attach-meaning] #5337 arith 121
[mk-app] #5316 Int
[attach-meaning] #5316 arith 122
[mk-app] #5312 Int
[attach-meaning] #5312 arith 123
[mk-app] #5308 Int
[attach-meaning] #5308 arith 124
[attach-meaning] #5329 arith 125
[mk-app] #5304 Int
[attach-meaning] #5304 arith 126
[mk-app] #5300 Int
[attach-meaning] #5300 arith 127
[mk-app] #5296 Int
[attach-meaning] #5296 arith 128
[attach-meaning] #5323 arith 129
[mk-app] #5292 Int
[attach-meaning] #5292 arith 130
[mk-app] #2185 Int
[attach-meaning] #2185 arith 131
[mk-app] #2339 Int
[attach-meaning] #2339 arith 132
[attach-meaning] #5429 arith 133
[mk-app] #2356 Int
[attach-meaning] #2356 arith 134
[mk-app] #2344 Int
[attach-meaning] #2344 arith 135
[mk-app] #2188 Int
[attach-meaning] #2188 arith 136
[attach-meaning] #5414 arith 137
[mk-app] #2318 Int
[attach-meaning] #2318 arith 138
[mk-app] #2193 Int
[attach-meaning] #2193 arith 139
[mk-app] #2317 Int
[attach-meaning] #2317 arith 140
[attach-meaning] #5410 arith 141
[mk-app] #2316 Int
[attach-meaning] #2316 arith 142
[mk-app] #2315 Int
[attach-meaning] #2315 arith 143
[mk-app] #2288 Int
[attach-meaning] #2288 arith 144
[pop] 3 6
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 3
[push] 2
[mk-app] #5031 address<Int> #1558
[mk-app] #4199 mod #5031 #1503
[mk-app] #4205 = #4199 #36
[mk-app] #4210 not #4205
[mk-app] #5109 not #4210
[mk-proof] #5099 asserted #5109
[inst-discovered] theory-solving 0x0 basic# ; #5109
[mk-app] #5100 = #5109 #4205
[mk-proof] #5113 rewrite #5100
[instance] 0x0 #5100
[end-of-instance]
[mk-proof] #5440 mp #5099 #5113 #4205
[begin-check] 3
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 ~ #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 rewrite #5475
[mk-proof] #4982 mp #5440 #4761 #4205
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[mk-app] #5475 = #4205 #4205
[mk-proof] #4761 refl #5475
[attach-enode] #5031 0
[attach-enode] #1503 0
[attach-enode] #4199 0
[attach-enode] #4205 0
[mk-app] #5475 <= #4199 #36
[mk-app] #4761 >= #4199 #36
[assign] #4205 justification -1: 
[mk-app] #4982 div #5031 #1503
[mk-app] #4748 < #1503 #36
[mk-app] #4683 - #36 #1503
[mk-app] #4787 if #4748 #4683 #1503
[mk-app] #4788 - #4787 #151
[inst-discovered] theory-solving 0x0 arith# ; #4748
[mk-app] #4983 = #4748 #3233
[mk-proof] #4789 rewrite #4983
[instance] 0x0 #4983
[end-of-instance]
[mk-app] #4937 = #4748 #2
[mk-proof] #4128 trans #4789 #3190 #4937
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #4683
[mk-app] #4672 = #4683 #3205
[mk-proof] #4917 rewrite #4672
[instance] 0x0 #4672
[end-of-instance]
[mk-app] #4904 = #4683 #4108
[mk-proof] #4898 trans #4917 #3152 #4904
[mk-app] #4493 if #2 #4108 #1503
[mk-app] #4115 = #4787 #4493
[mk-proof] #3203 monotonicity #4128 #4898 #4115
[inst-discovered] theory-solving 0x0 arith# ; #4493
[mk-app] #3193 = #4493 #1503
[mk-proof] #4212 rewrite #3193
[instance] 0x0 #3193
[end-of-instance]
[mk-app] #4186 = #4787 #1503
[mk-proof] #3588 trans #3203 #4212 #4186
[mk-app] #3582 - #1503 #151
[mk-app] #3320 = #4788 #3582
[mk-proof] #3321 monotonicity #3588 #3320
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3582
[mk-app] #3319 = #3582 #4048
[mk-proof] #3313 rewrite #3319
[instance] 0x0 #3319
[end-of-instance]
[mk-app] #3290 = #4788 #4048
[mk-proof] #4043 trans #3321 #3313 #3290
[mk-app] #4044 = #4788 #4037
[mk-proof] #4045 trans #4043 #4000 #4044
[mk-app] #3476 = #1503 #36
[mk-app] #4410 * #1503 #4982
[mk-app] #3529 + #4410 #4199
[mk-app] #3521 = #3529 #5031
[mk-app] #3586 <= #4199 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3476
[mk-app] #4748 = #3476 #2
[mk-proof] #4983 rewrite #4748
[instance] 0x0 #4748
[end-of-instance]
[attach-enode] #4982 0
[attach-enode] #4410 0
[attach-enode] #3529 0
[attach-enode] #3521 0
[mk-app] #4789 or #3476 #3521
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4789
[assign] #3521 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3476
[mk-app] #4748 = #3476 #2
[mk-proof] #4983 rewrite #4748
[instance] 0x0 #4748
[end-of-instance]
[attach-enode] #4761 0
[mk-app] #4789 or #3476 #4761
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4789
[assign] #4761 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #3476
[mk-app] #4748 = #3476 #2
[mk-proof] #4983 rewrite #4748
[instance] 0x0 #4748
[end-of-instance]
[attach-enode] #3586 0
[mk-app] #4789 or #3476 #3586
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4789
[assign] #3586 justification -1: true
[end-of-instance]
[assign] #5475 clause p81 (not p80)
  (<= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int) 
  (not (= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 

[new-match] 0x106809ed0 #1522 #1506 #36 #1545 ; #5031 (#1558 #1559)
[mk-app] #5540 * #176 #4105
[mk-app] #5522 + #3235 #5540
[mk-app] #5533 = #5522 #1503
[mk-app] #3476 = #5533 #5533
[mk-proof] #4748 refl #3476
[mk-app] #4983 not #1522
[mk-app] #5108 or #4983 #5533
[mk-proof] #5069 quant-inst #5108
[instance] 0x106809ed0 #5069 ; 1
[attach-enode] #3235 1
[attach-enode] #4105 1
[attach-enode] #176 1
[attach-enode] #5540 1
[attach-enode] #5522 1
[attach-enode] #5533 1
[mk-app] #5243 <= #5522 #1503
[mk-app] #5133 >= #5522 #1503
[assign] #5533 justification -1: p51
[end-of-instance]
[assign] #5243 clause p86 (not p85)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[assign] #5133 clause p87 (not p85)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[mk-app] #3476 = #3529 #4105
[attach-meaning] #176 arith (- 1)
[mk-app] #4748 + #3529 #5540
[mk-app] #2912 <= #4748 #36
[mk-app] #3076 >= #4748 #36
[assign] #3476 justification -1: p83 p55
[attach-enode] #3476 0
[attach-enode] #4748 0
[assign] #2912 justification -1: p88
[assign] #3076 justification -1: p88
[new-match] 0x106817118 #1522 #1506 #151 #1545 ; #3235 (#1574 #2367)
[mk-app] #3284 * #176 #4087
[mk-app] #5012 + #4086 #3284
[mk-app] #5080 = #5012 #1503
[mk-app] #4245 = #5080 #5080
[mk-proof] #4068 refl #4245
[mk-app] #3655 or #4983 #5080
[mk-proof] #4513 quant-inst #3655
[instance] 0x106817118 #4513 ; 2
[attach-enode] #3162 2
[attach-enode] #4086 2
[attach-enode] #4087 2
[attach-enode] #3284 2
[attach-enode] #5012 2
[attach-enode] #5080 2
[mk-app] #3680 <= #5012 #1503
[mk-app] #2924 >= #5012 #1503
[assign] #5080 justification -1: p51
[end-of-instance]
[assign] #3680 clause p92 (not p91)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[assign] #2924 clause p93 (not p91)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[mk-app] #4245 = #3235 #4087
[attach-meaning] #176 arith (- 1)
[mk-app] #4068 + #3235 #3284
[mk-app] #4512 <= #4068 #36
[mk-app] #3270 >= #4068 #36
[assign] #4245 justification -1: p58
[attach-enode] #4245 0
[attach-enode] #4068 0
[assign] #4512 justification -1: p94
[assign] #3270 justification -1: p94
[new-match] 0x106817980 #1495 #1483 #151 #1545 ; #3162 (#2367 #2367)
[mk-app] #3371 = #3162 #2941
[mk-app] #3372 = #3162 #3955
[mk-app] #3406 = #3371 #3372
[mk-proof] #3345 monotonicity #3943 #3406
[mk-app] #5111 or #1563 #3372
[mk-app] #4634 or #1563 #3371
[mk-proof] #4677 quant-inst #4634
[mk-app] #4755 = #4634 #5111
[mk-proof] #4569 monotonicity #3345 #4755
[mk-app] #4014 = #5111 #5111
[mk-proof] #3266 rewrite #4014
[mk-proof] #3267 trans #4569 #3266 #4755
[mk-proof] #3093 mp #4677 #3267 #5111
[instance] 0x106817980 #4677 ; 3
[attach-enode] #3950 3
[attach-enode] #3955 3
[attach-enode] #3372 3
[assign] #3372 justification -1: p50
[end-of-instance]
[eq-expl] #3950 root
[new-match] 0x106817c40 #1477 #1476 #3950 #1545 ; #3955
[eq-expl] #3162 lit #3372 ; #3955
[eq-expl] #3955 root
[new-match] 0x106817c78 #1522 #1506 #3950 #1545 ; #4086 (#3162 #3955)
[mk-app] #5088 = #3384 #3950
[mk-app] #4847 = #5088 #5088
[mk-proof] #3667 refl #4847
[mk-app] #4613 or #1576 #5088
[mk-proof] #4733 quant-inst #4613
[instance] 0x106817c40 #4733 ; 4
[attach-enode] #3384 4
[attach-enode] #5088 4
[assign] #5088 justification -1: p49
[end-of-instance]
[mk-app] #4847 * #176 #3391
[mk-app] #3667 + #3387 #4847
[mk-app] #3666 = #3667 #1503
[mk-app] #3599 = #3666 #3666
[mk-proof] #3061 refl #3599
[mk-app] #3065 or #4983 #3666
[mk-proof] #4018 quant-inst #3065
[instance] 0x106817c78 #4018 ; 4
[attach-enode] #3386 4
[attach-enode] #3387 4
[attach-enode] #3391 4
[attach-enode] #4847 4
[attach-enode] #3667 4
[attach-enode] #3666 4
[mk-app] #3073 <= #3667 #1503
[mk-app] #3839 >= #3667 #1503
[assign] #3666 justification -1: p51
[end-of-instance]
[assign] #3073 clause p100 (not p99)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[assign] #3839 clause p101 (not p99)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[mk-app] #3599 = #3391 #4086
[attach-meaning] #176 arith (- 1)
[mk-app] #3061 * #176 #4086
[mk-app] #3683 + #3391 #3061
[mk-app] #4306 <= #3683 #36
[mk-app] #3773 >= #3683 #36
[assign] #3599 justification -1: p97
[attach-enode] #3599 0
[attach-enode] #3061 0
[attach-enode] #3683 0
[assign] #4306 justification -1: p102
[assign] #3773 justification -1: p102
[new-match] 0x1068186c0 #1495 #1483 #3950 #1545 ; #3386 (#3955 #3955)
[mk-app] #3682 = #3386 #4318
[mk-app] #3518 = #3386 #4322
[mk-app] #3560 = #3682 #3518
[mk-proof] #4008 monotonicity #4324 #3560
[mk-app] #3992 or #1563 #3518
[mk-app] #3642 or #1563 #3682
[mk-proof] #2937 quant-inst #3642
[mk-app] #2964 = #3642 #3992
[mk-proof] #2965 monotonicity #4008 #2964
[mk-app] #3259 = #3992 #3992
[mk-proof] #2967 rewrite #3259
[mk-proof] #3711 trans #2965 #2967 #2964
[mk-proof] #4077 mp #2937 #3711 #3992
[instance] 0x1068186c0 #2937 ; 5
[attach-enode] #4037 5
[attach-enode] #4322 5
[attach-enode] #3518 5
[assign] #3518 justification -1: p50
[end-of-instance]
[eq-expl] #4037 root
[new-match] 0x106818960 #1477 #1476 #4037 #1545 ; #4322
[eq-expl] #3386 lit #3518 ; #4322
[eq-expl] #4322 root
[new-match] 0x106818998 #1522 #1506 #4037 #1545 ; #3387 (#3386 #4322)
[mk-app] #4078 = #4342 #4037
[mk-app] #3091 = #4078 #4078
[mk-proof] #4003 refl #3091
[mk-app] #4632 or #1576 #4078
[mk-proof] #5192 quant-inst #4632
[instance] 0x106818960 #5192 ; 6
[attach-enode] #4342 6
[attach-enode] #4078 6
[assign] #4078 justification -1: p49
[end-of-instance]
[mk-app] #3091 * #176 #3488
[mk-app] #4003 + #4345 #3091
[mk-app] #4749 = #4003 #1503
[mk-app] #5015 + #3091 #4345
[inst-discovered] theory-solving 0x0 arith# ; #4003
[mk-app] #5022 = #4003 #5015
[mk-proof] #4834 rewrite #5022
[instance] 0x0 #5022
[end-of-instance]
[mk-app] #3210 = #5015 #1503
[mk-app] #3285 = #4749 #3210
[mk-proof] #3971 monotonicity #4834 #3285
[attach-meaning] #176 arith (- 1)
[mk-app] #3972 * #176 #4345
[mk-app] #3537 + #3488 #3972
[attach-meaning] #4108 arith (- 4)
[mk-app] #4638 = #3537 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3210
[mk-app] #4635 = #3210 #4638
[mk-proof] #4716 rewrite #4635
[instance] 0x0 #4635
[end-of-instance]
[mk-app] #4602 = #4749 #4638
[mk-proof] #3272 trans #3971 #4716 #4602
[mk-app] #5004 or #4983 #4638
[mk-app] #5011 or #4983 #4749
[mk-proof] #5065 quant-inst #5011
[mk-app] #5003 = #5011 #5004
[mk-proof] #3482 monotonicity #3272 #5003
[mk-app] #4629 = #5004 #5004
[mk-proof] #4636 rewrite #4629
[mk-proof] #4698 trans #3482 #4636 #5003
[mk-proof] #4628 mp #5065 #4698 #5004
[instance] 0x106818998 #5065 ; 6
[attach-enode] #3488 6
[attach-enode] #4344 6
[attach-enode] #4345 6
[attach-enode] #3972 6
[attach-enode] #3537 6
[attach-enode] #4108 6
[attach-enode] #4638 6
[mk-app] #3182 <= #3537 #4108
[mk-app] #3679 >= #3537 #4108
[assign] #4638 justification -1: p51
[end-of-instance]
[assign] #3182 clause p108 (not p107)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[assign] #3679 clause p109 (not p107)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[mk-app] #3828 = #3387 #3488
[attach-meaning] #176 arith (- 1)
[mk-app] #3583 + #3387 #3091
[mk-app] #2927 <= #3583 #36
[mk-app] #4459 >= #3583 #36
[assign] #3828 justification -1: p105
[attach-enode] #3828 0
[attach-enode] #3091 0
[attach-enode] #3583 0
[assign] #2927 justification -1: p110
[assign] #4459 justification -1: p110
[new-match] 0x10681c4c0 #1495 #1483 #4037 #1545 ; #4344 (#4322 #4322)
[mk-app] #3130 = #4344 #4442
[mk-app] #3513 = #4344 #4446
[mk-app] #2947 = #3130 #3513
[mk-proof] #3357 monotonicity #4545 #2947
[mk-app] #3098 or #1563 #3513
[mk-app] #3341 or #1563 #3130
[mk-proof] #3331 quant-inst #3341
[mk-app] #3343 = #3341 #3098
[mk-proof] #3096 monotonicity #3357 #3343
[mk-app] #3832 = #3098 #3098
[mk-proof] #3227 rewrite #3832
[mk-proof] #4138 trans #3096 #3227 #3343
[mk-proof] #3245 mp #3331 #4138 #3098
[instance] 0x10681c4c0 #3331 ; 7
[attach-enode] #4446 7
[attach-enode] #3513 7
[assign] #3513 justification -1: p50
[end-of-instance]
[eq-expl] #1503 root
[new-match] 0x10681c6d0 #1477 #1476 #1503 #1545 ; #4446
[eq-expl] #4344 lit #3513 ; #4446
[eq-expl] #4446 root
[new-match] 0x10681c708 #1522 #1506 #1503 #1545 ; #4345 (#4344 #4446)
[mk-app] #3063 = #2974 #1503
[mk-app] #3153 = #3063 #3063
[mk-proof] #4988 refl #3153
[mk-app] #5002 or #1576 #3063
[mk-proof] #5013 quant-inst #5002
[instance] 0x10681c6d0 #5013 ; 8
[attach-enode] #2974 8
[attach-enode] #3063 8
[assign] #3063 justification -1: p49
[end-of-instance]
[mk-app] #3153 * #176 #3710
[mk-app] #4988 + #3707 #3153
[mk-app] #4987 = #4988 #1503
[mk-app] #5101 = #4987 #4987
[mk-proof] #4337 refl #5101
[mk-app] #4338 or #4983 #4987
[mk-proof] #4334 quant-inst #4338
[instance] 0x10681c708 #4334 ; 8
[attach-enode] #2976 8
[attach-enode] #3707 8
[attach-enode] #3710 8
[attach-enode] #3153 8
[attach-enode] #4988 8
[attach-enode] #4987 8
[mk-app] #4336 <= #4988 #1503
[mk-app] #4862 >= #4988 #1503
[assign] #4987 justification -1: p51
[end-of-instance]
[assign] #4336 clause p116 (not p115)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[assign] #4862 clause p117 (not p115)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[mk-app] #5101 = #3710 #4345
[attach-meaning] #176 arith (- 1)
[mk-app] #4337 + #3710 #3972
[mk-app] #3673 <= #4337 #36
[mk-app] #3969 >= #4337 #36
[assign] #5101 justification -1: p113
[attach-enode] #5101 0
[attach-enode] #4337 0
[assign] #3673 justification -1: p118
[assign] #3969 justification -1: p118
[new-match] 0x10681d0c8 #1495 #1483 #1503 #1545 ; #2976 (#4446 #4446)
[mk-app] #4129 = #2976 #4502
[mk-app] #4577 = #2976 #3398
[mk-app] #3287 = #4129 #4577
[mk-proof] #3530 monotonicity #3400 #3287
[mk-app] #4637 or #1563 #4577
[mk-app] #4373 or #1563 #4129
[mk-proof] #3535 quant-inst #4373
[mk-app] #3382 = #4373 #4637
[mk-proof] #3751 monotonicity #3530 #3382
[mk-app] #3036 = #4637 #4637
[mk-proof] #3755 rewrite #3036
[mk-proof] #3033 trans #3751 #3755 #3382
[mk-proof] #2942 mp #3535 #3033 #4637
[instance] 0x10681d0c8 #3535 ; 9
[attach-enode] #3395 9
[attach-enode] #3398 9
[attach-enode] #4577 9
[assign] #4577 justification -1: p50
[end-of-instance]
[eq-expl] #3395 root
[new-match] 0x10681d368 #1477 #1476 #3395 #1545 ; #3398
[eq-expl] #2976 lit #4577 ; #3398
[eq-expl] #3398 root
[new-match] 0x10681d3a0 #1522 #1506 #3395 #1545 ; #3707 (#2976 #3398)
[mk-app] #3248 = #3414 #3395
[mk-app] #3756 = #3248 #3248
[mk-proof] #3242 refl #3756
[mk-app] #4356 or #1576 #3248
[mk-proof] #3600 quant-inst #4356
[instance] 0x10681d368 #3600 ; 10
[attach-enode] #3414 10
[attach-enode] #3248 10
[assign] #3248 justification -1: p49
[end-of-instance]
[mk-app] #3756 * #176 #3848
[mk-app] #3242 + #3419 #3756
[mk-app] #4590 = #3242 #1503
[mk-app] #3811 = #4590 #4590
[mk-proof] #3154 refl #3811
[mk-app] #5104 or #4983 #4590
[mk-proof] #5052 quant-inst #5104
[instance] 0x10681d3a0 #5052 ; 10
[attach-enode] #3418 10
[attach-enode] #3419 10
[attach-enode] #3848 10
[attach-enode] #3756 10
[attach-enode] #3242 10
[attach-enode] #4590 10
[mk-app] #4971 <= #3242 #1503
[mk-app] #4974 >= #3242 #1503
[assign] #4590 justification -1: p51
[end-of-instance]
[assign] #4971 clause p124 (not p123)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[assign] #4974 clause p125 (not p123)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[mk-app] #3811 = #3707 #3848
[attach-meaning] #176 arith (- 1)
[mk-app] #3154 + #3707 #3756
[mk-app] #5007 <= #3154 #36
[mk-app] #4970 >= #3154 #36
[assign] #3811 justification -1: p121
[attach-enode] #3811 0
[attach-enode] #3154 0
[assign] #5007 justification -1: p126
[assign] #4970 justification -1: p126
[new-match] 0x106822980 #1495 #1483 #3395 #1545 ; #3418 (#3398 #3398)
[mk-app] #4973 = #3418 #4360
[mk-app] #4891 = #3418 #2979
[mk-app] #4892 = #4973 #4891
[mk-proof] #4901 monotonicity #2981 #4892
[mk-app] #4889 or #1563 #4891
[mk-app] #4793 or #1563 #4973
[mk-proof] #4812 quant-inst #4793
[mk-app] #4753 = #4793 #4889
[mk-proof] #4769 monotonicity #4901 #4753
[mk-app] #4811 = #4889 #4889
[mk-proof] #4730 rewrite #4811
[mk-proof] #4676 trans #4769 #4730 #4753
[mk-proof] #4694 mp #4812 #4676 #4889
[instance] 0x106822980 #4812 ; 11
[attach-enode] #4579 11
[attach-enode] #2979 11
[attach-enode] #4891 11
[assign] #4891 justification -1: p50
[end-of-instance]
[eq-expl] #4579 root
[new-match] 0x106822c20 #1477 #1476 #4579 #1545 ; #2979
[eq-expl] #3418 lit #4891 ; #2979
[eq-expl] #2979 root
[new-match] 0x106822c58 #1522 #1506 #4579 #1545 ; #3419 (#3418 #2979)
[mk-app] #4400 = #3228 #4579
[mk-app] #3453 = #4400 #4400
[mk-proof] #3043 refl #3453
[mk-app] #4123 or #1576 #4400
[mk-proof] #4514 quant-inst #4123
[instance] 0x106822c20 #4514 ; 12
[attach-enode] #3228 12
[attach-enode] #4400 12
[assign] #4400 justification -1: p49
[end-of-instance]
[mk-app] #3453 * #176 #3237
[mk-app] #3043 + #3231 #3453
[mk-app] #3657 = #3043 #1503
[mk-app] #3750 = #3657 #3657
[mk-proof] #3197 refl #3750
[mk-app] #3717 or #4983 #3657
[mk-proof] #3718 quant-inst #3717
[instance] 0x106822c58 #3718 ; 12
[attach-enode] #3230 12
[attach-enode] #3231 12
[attach-enode] #3237 12
[attach-enode] #3453 12
[attach-enode] #3043 12
[attach-enode] #3657 12
[mk-app] #3715 <= #3043 #1503
[mk-app] #3902 >= #3043 #1503
[assign] #3657 justification -1: p51
[end-of-instance]
[assign] #3715 clause p132 (not p131)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[assign] #3902 clause p133 (not p131)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[mk-app] #3750 = #3237 #3419
[attach-meaning] #176 arith (- 1)
[mk-app] #3197 * #176 #3419
[mk-app] #3822 + #3237 #3197
[mk-app] #3311 <= #3822 #36
[mk-app] #4451 >= #3822 #36
[assign] #3750 justification -1: p129
[attach-enode] #3750 0
[attach-enode] #3197 0
[attach-enode] #3822 0
[assign] #3311 justification -1: p134
[assign] #4451 justification -1: p134
[new-match] 0x1068236a0 #1495 #1483 #4579 #1545 ; #3230 (#2979 #2979)
[mk-app] #3316 = #3230 #3758
[mk-app] #3310 = #3230 #4131
[mk-app] #4027 = #3316 #3310
[mk-proof] #4020 monotonicity #4133 #4027
[mk-app] #4021 or #1563 #3310
[mk-app] #3175 or #1563 #3316
[mk-proof] #3057 quant-inst #3175
[mk-app] #4295 = #3175 #4021
[mk-proof] #3927 monotonicity #4020 #4295
[mk-app] #3843 = #4021 #4021
[mk-proof] #4595 rewrite #3843
[mk-proof] #3926 trans #3927 #4595 #4295
[mk-proof] #4551 mp #3057 #3926 #4021
[instance] 0x1068236a0 #3057 ; 13
[attach-enode] #3760 13
[attach-enode] #4131 13
[attach-enode] #3310 13
[assign] #3310 justification -1: p50
[end-of-instance]
[eq-expl] #3760 root
[new-match] 0x106823940 #1477 #1476 #3760 #1545 ; #4131
[eq-expl] #3230 lit #3310 ; #4131
[eq-expl] #4131 root
[new-match] 0x106823978 #1522 #1506 #3760 #1545 ; #3231 (#3230 #4131)
[mk-app] #3004 = #4147 #3760
[mk-app] #3007 = #3004 #3004
[mk-proof] #3987 refl #3007
[mk-app] #3003 or #1576 #3004
[mk-proof] #3922 quant-inst #3003
[instance] 0x106823940 #3922 ; 14
[attach-enode] #4147 14
[attach-enode] #3004 14
[assign] #3004 justification -1: p49
[end-of-instance]
[mk-app] #3007 * #176 #4154
[mk-app] #3987 + #4151 #3007
[mk-app] #4252 = #3987 #1503
[mk-app] #4253 = #4252 #4252
[mk-proof] #2923 refl #4253
[mk-app] #4251 or #4983 #4252
[mk-proof] #3330 quant-inst #4251
[instance] 0x106823978 #3330 ; 14
[attach-enode] #4149 14
[attach-enode] #4151 14
[attach-enode] #4154 14
[attach-enode] #3007 14
[attach-enode] #3987 14
[attach-enode] #4252 14
[mk-app] #4449 <= #3987 #1503
[mk-app] #4455 >= #3987 #1503
[assign] #4252 justification -1: p51
[end-of-instance]
[assign] #4449 clause p140 (not p139)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[assign] #4455 clause p141 (not p139)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[mk-app] #4253 = #3231 #4154
[attach-meaning] #176 arith (- 1)
[mk-app] #2923 + #3231 #3007
[mk-app] #3445 <= #2923 #36
[mk-app] #4454 >= #2923 #36
[assign] #4253 justification -1: p137
[attach-enode] #4253 0
[attach-enode] #2923 0
[assign] #3445 justification -1: p142
[assign] #4454 justification -1: p142
[new-match] 0x106824338 #1495 #1483 #3760 #1545 ; #4149 (#4131 #4131)
[mk-app] #3744 = #4149 #3956
[mk-app] #3125 = #4149 #4562
[mk-app] #3123 = #3744 #3125
[mk-proof] #3169 monotonicity #3249 #3123
[mk-app] #3622 or #1563 #3125
[mk-app] #3593 or #1563 #3744
[mk-proof] #3254 quant-inst #3593
[mk-app] #3993 = #3593 #3622
[mk-proof] #3250 monotonicity #3169 #3993
[mk-app] #3988 = #3622 #3622
[mk-proof] #3559 rewrite #3988
[mk-proof] #3739 trans #3250 #3559 #3993
[mk-proof] #3113 mp #3254 #3739 #3622
[instance] 0x106824338 #3254 ; 15
[attach-enode] #3958 15
[attach-enode] #4562 15
[attach-enode] #3125 15
[assign] #3125 justification -1: p50
[end-of-instance]
[eq-expl] #3958 root
[new-match] 0x1068245d8 #1477 #1476 #3958 #1545 ; #4562
[eq-expl] #4149 lit #3125 ; #4562
[eq-expl] #4562 root
[new-match] 0x106824610 #1522 #1506 #3958 #1545 ; #4151 (#4149 #4562)
[mk-app] #3735 = #3262 #3958
[mk-app] #3738 = #3735 #3735
[mk-proof] #3838 refl #3738
[mk-app] #4175 or #1576 #3735
[mk-proof] #4176 quant-inst #4175
[instance] 0x1068245d8 #4176 ; 16
[attach-enode] #3262 16
[attach-enode] #3735 16
[assign] #3735 justification -1: p49
[end-of-instance]
[mk-app] #3738 * #176 #3271
[mk-app] #3838 + #3268 #3738
[mk-app] #4167 = #3838 #1503
[mk-app] #4332 = #4167 #4167
[mk-proof] #3236 refl #4332
[mk-app] #2987 or #4983 #4167
[mk-proof] #3490 quant-inst #2987
[instance] 0x106824610 #3490 ; 16
[attach-enode] #3264 16
[attach-enode] #3268 16
[attach-enode] #3271 16
[attach-enode] #3738 16
[attach-enode] #3838 16
[attach-enode] #4167 16
[mk-app] #4144 <= #3838 #1503
[mk-app] #2986 >= #3838 #1503
[assign] #4167 justification -1: p51
[end-of-instance]
[assign] #4144 clause p148 (not p147)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[assign] #2986 clause p149 (not p147)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[mk-app] #4332 = #3271 #4151
[attach-meaning] #176 arith (- 1)
[mk-app] #3236 * #176 #4151
[mk-app] #3409 + #3271 #3236
[mk-app] #3492 <= #3409 #36
[mk-app] #3493 >= #3409 #36
[assign] #4332 justification -1: p145
[attach-enode] #4332 0
[attach-enode] #3236 0
[attach-enode] #3409 0
[assign] #3492 justification -1: p150
[assign] #3493 justification -1: p150
[new-match] 0x10682c6b8 #1495 #1483 #3958 #1545 ; #3264 (#4562 #4562)
[mk-app] #3502 = #3264 #3765
[mk-app] #3507 = #3264 #4156
[mk-app] #3027 = #3502 #3507
[mk-proof] #4174 monotonicity #4162 #3027
[mk-app] #3393 or #1563 #3507
[mk-app] #4088 or #1563 #3502
[mk-proof] #4094 quant-inst #4088
[mk-app] #3229 = #4088 #3393
[mk-proof] #4311 monotonicity #4174 #3229
[mk-app] #3904 = #3393 #3393
[mk-proof] #3431 rewrite #3904
[mk-proof] #4309 trans #4311 #3431 #3229
[mk-proof] #4010 mp #4094 #4309 #3393
[instance] 0x10682c6b8 #4094 ; 17
[attach-enode] #3767 17
[attach-enode] #4156 17
[attach-enode] #3507 17
[assign] #3507 justification -1: p50
[end-of-instance]
[eq-expl] #3767 root
[new-match] 0x10682c958 #1477 #1476 #3767 #1545 ; #4156
[eq-expl] #3264 lit #3507 ; #4156
[eq-expl] #4156 root
[new-match] 0x10682c990 #1522 #1506 #3767 #1545 ; #3268 (#3264 #4156)
[mk-app] #3609 = #4181 #3767
[mk-app] #3475 = #3609 #3609
[mk-proof] #4388 refl #3475
[mk-app] #3608 or #1576 #3609
[mk-proof] #4671 quant-inst #3608
[instance] 0x10682c958 #4671 ; 18
[attach-enode] #4181 18
[attach-enode] #3609 18
[assign] #3609 justification -1: p49
[end-of-instance]
[mk-app] #3475 * #176 #3618
[mk-app] #4388 + #4184 #3475
[mk-app] #4585 = #4388 #1503
[mk-app] #4486 + #3475 #4184
[inst-discovered] theory-solving 0x0 arith# ; #4388
[mk-app] #3215 = #4388 #4486
[mk-proof] #4584 rewrite #3215
[instance] 0x0 #3215
[end-of-instance]
[mk-app] #4800 = #4486 #1503
[mk-app] #4976 = #4585 #4800
[mk-proof] #5254 monotonicity #4584 #4976
[attach-meaning] #176 arith (- 1)
[mk-app] #4956 * #176 #4184
[mk-app] #5281 + #3618 #4956
[attach-meaning] #4108 arith (- 4)
[mk-app] #5548 = #5281 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4800
[mk-app] #5176 = #4800 #5548
[mk-proof] #4789 rewrite #5176
[instance] 0x0 #5176
[end-of-instance]
[mk-app] #4937 = #4585 #5548
[mk-proof] #4128 trans #5254 #4789 #4937
[mk-app] #4683 or #4983 #5548
[mk-app] #4672 or #4983 #4585
[mk-proof] #4917 quant-inst #4672
[mk-app] #4904 = #4672 #4683
[mk-proof] #4898 monotonicity #4128 #4904
[mk-app] #4787 = #4683 #4683
[mk-proof] #4493 rewrite #4787
[mk-proof] #4115 trans #4898 #4493 #4904
[mk-proof] #3203 mp #4917 #4115 #4683
[instance] 0x10682c990 #4917 ; 18
[attach-enode] #3618 18
[attach-enode] #4183 18
[attach-enode] #4184 18
[attach-enode] #4956 18
[attach-enode] #5281 18
[attach-enode] #5548 18
[mk-app] #3193 <= #5281 #4108
[mk-app] #4212 >= #5281 #4108
[assign] #5548 justification -1: p51
[end-of-instance]
[assign] #3193 clause p156 (not p155)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[assign] #4212 clause p157 (not p155)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[mk-app] #4186 = #3268 #3618
[attach-meaning] #176 arith (- 1)
[mk-app] #3588 + #3268 #3475
[mk-app] #4788 <= #3588 #36
[mk-app] #3582 >= #3588 #36
[assign] #4186 justification -1: p153
[attach-enode] #4186 0
[attach-enode] #3475 0
[attach-enode] #3588 0
[assign] #4788 justification -1: p158
[assign] #3582 justification -1: p158
[new-match] 0x10682d3d8 #1495 #1483 #3767 #1545 ; #4183 (#4156 #4156)
[mk-app] #3320 = #4183 #3693
[mk-app] #3321 = #4183 #3698
[mk-app] #3319 = #3320 #3321
[mk-proof] #3313 monotonicity #4564 #3319
[mk-app] #3290 or #1563 #3321
[mk-app] #4043 or #1563 #3320
[mk-proof] #4044 quant-inst #4043
[mk-app] #4045 = #4043 #3290
[mk-proof] #3587 monotonicity #3313 #4045
[mk-app] #3946 = #3290 #3290
[mk-proof] #3930 rewrite #3946
[mk-proof] #3874 trans #3587 #3930 #4045
[mk-proof] #4470 mp #4044 #3874 #3290
[instance] 0x10682d3d8 #4044 ; 19
[attach-enode] #3695 19
[attach-enode] #3698 19
[attach-enode] #3321 19
[assign] #3321 justification -1: p50
[end-of-instance]
[eq-expl] #3695 root
[new-match] 0x10682d678 #1477 #1476 #3695 #1545 ; #3698
[eq-expl] #4183 lit #3321 ; #3698
[eq-expl] #3698 root
[new-match] 0x10682d6b0 #1522 #1506 #3695 #1545 ; #4184 (#4183 #3698)
[mk-app] #4471 = #3083 #3695
[mk-app] #3551 = #4471 #4471
[mk-proof] #4380 refl #3551
[mk-app] #3897 or #1576 #4471
[mk-proof] #3527 quant-inst #3897
[instance] 0x10682d678 #3527 ; 20
[attach-enode] #3083 20
[attach-enode] #4471 20
[assign] #4471 justification -1: p49
[end-of-instance]
[mk-app] #3551 * #176 #3089
[mk-app] #4380 + #3086 #3551
[mk-app] #4546 = #4380 #1503
[mk-app] #4463 = #4546 #4546
[mk-proof] #3528 refl #4463
[mk-app] #4095 or #4983 #4546
[mk-proof] #4035 quant-inst #4095
[instance] 0x10682d6b0 #4035 ; 20
[attach-enode] #3085 20
[attach-enode] #3086 20
[attach-enode] #3089 20
[attach-enode] #3551 20
[attach-enode] #4380 20
[attach-enode] #4546 20
[mk-app] #3141 <= #4380 #1503
[mk-app] #3142 >= #4380 #1503
[assign] #4546 justification -1: p51
[end-of-instance]
[assign] #3141 clause p164 (not p163)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[assign] #3142 clause p165 (not p163)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[mk-app] #4463 = #3089 #4184
[attach-meaning] #176 arith (- 1)
[mk-app] #3528 + #3089 #4956
[mk-app] #3729 <= #3528 #36
[mk-app] #3607 >= #3528 #36
[assign] #4463 justification -1: p161
[attach-enode] #4463 0
[attach-enode] #3528 0
[assign] #3729 justification -1: p166
[assign] #3607 justification -1: p166
[new-match] 0x1068320b0 #1495 #1483 #3695 #1545 ; #3085 (#3698 #3698)
[mk-app] #3571 = #3085 #3105
[mk-app] #3639 = #3085 #3111
[mk-app] #4012 = #3571 #3639
[mk-proof] #3721 monotonicity #3110 #4012
[mk-app] #3016 or #1563 #3639
[mk-app] #3010 or #1563 #3571
[mk-proof] #2953 quant-inst #3010
[mk-app] #4234 = #3010 #3016
[mk-proof] #3784 monotonicity #3721 #4234
[mk-app] #4308 = #3016 #3016
[mk-proof] #4058 rewrite #4308
[mk-proof] #4059 trans #3784 #4058 #4234
[mk-proof] #4060 mp #2953 #4059 #3016
[instance] 0x1068320b0 #2953 ; 21
[attach-enode] #3107 21
[attach-enode] #3111 21
[attach-enode] #3639 21
[assign] #3639 justification -1: p50
[end-of-instance]
[eq-expl] #3107 root
[new-match] 0x106832350 #1477 #1476 #3107 #1545 ; #3111
[eq-expl] #3085 lit #3639 ; #3111
[eq-expl] #3111 root
[new-match] 0x106832388 #1522 #1506 #3107 #1545 ; #3086 (#3085 #3111)
[mk-app] #4052 = #4051 #3107
[mk-app] #3619 = #4052 #4052
[mk-proof] #3620 refl #3619
[mk-app] #3712 or #1576 #4052
[mk-proof] #3713 quant-inst #3712
[instance] 0x106832350 #3713 ; 22
[attach-enode] #4051 22
[attach-enode] #4052 22
[assign] #4052 justification -1: p49
[end-of-instance]
[mk-app] #3619 * #176 #4057
[mk-app] #3620 + #4054 #3619
[mk-app] #4578 = #3620 #1503
[mk-app] #3849 = #4578 #4578
[mk-proof] #3850 refl #3849
[mk-app] #4079 or #4983 #4578
[mk-proof] #3746 quant-inst #4079
[instance] 0x106832388 #3746 ; 22
[attach-enode] #4053 22
[attach-enode] #4054 22
[attach-enode] #4057 22
[attach-enode] #3619 22
[attach-enode] #3620 22
[attach-enode] #4578 22
[mk-app] #3160 <= #3620 #1503
[mk-app] #3144 >= #3620 #1503
[assign] #4578 justification -1: p51
[end-of-instance]
[assign] #3160 clause p172 (not p171)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[assign] #3144 clause p173 (not p171)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[mk-app] #3849 = #3086 #4057
[attach-meaning] #176 arith (- 1)
[mk-app] #3850 + #3086 #3619
[mk-app] #2975 <= #3850 #36
[mk-app] #4443 >= #3850 #36
[assign] #3849 justification -1: p169
[attach-enode] #3849 0
[attach-enode] #3850 0
[assign] #2975 justification -1: p174
[assign] #4443 justification -1: p174
[new-match] 0x106832d48 #1495 #1483 #3107 #1545 ; #4053 (#3111 #3111)
[mk-app] #3373 = #4053 #4072
[mk-app] #3385 = #4053 #3326
[mk-app] #3949 = #3373 #3385
[mk-proof] #4106 monotonicity #3328 #3949
[mk-app] #3022 or #1563 #3385
[mk-app] #3029 or #1563 #3373
[mk-proof] #4073 quant-inst #3029
[mk-app] #3555 = #3029 #3022
[mk-proof] #3556 monotonicity #4106 #3555
[mk-app] #4242 = #3022 #3022
[mk-proof] #3028 rewrite #4242
[mk-proof] #4557 trans #3556 #3028 #3555
[mk-proof] #3506 mp #4073 #4557 #3022
[instance] 0x106832d48 #4073 ; 23
[attach-enode] #4510 23
[attach-enode] #3326 23
[attach-enode] #3385 23
[assign] #3385 justification -1: p50
[end-of-instance]
[eq-expl] #4510 root
[new-match] 0x106832fe8 #1477 #1476 #4510 #1545 ; #3326
[eq-expl] #4053 lit #3385 ; #3326
[eq-expl] #3326 root
[new-match] 0x106833020 #1522 #1506 #4510 #1545 ; #4054 (#4053 #3326)
[mk-app] #4325 = #3344 #4510
[mk-app] #4326 = #4325 #4325
[mk-proof] #4330 refl #4326
[mk-app] #4556 or #1576 #4325
[mk-proof] #3497 quant-inst #4556
[instance] 0x106832fe8 #3497 ; 24
[attach-enode] #3344 24
[attach-enode] #4325 24
[assign] #4325 justification -1: p49
[end-of-instance]
[mk-app] #4326 * #176 #3353
[mk-app] #4330 + #3347 #4326
[mk-app] #3498 = #4330 #1503
[mk-app] #3511 = #3498 #3498
[mk-proof] #4182 refl #3511
[mk-app] #3709 or #4983 #3498
[mk-proof] #3846 quant-inst #3709
[instance] 0x106833020 #3846 ; 24
[attach-enode] #3346 24
[attach-enode] #3347 24
[attach-enode] #3353 24
[attach-enode] #4326 24
[attach-enode] #4330 24
[attach-enode] #3498 24
[mk-app] #3404 <= #4330 #1503
[mk-app] #2969 >= #4330 #1503
[assign] #3498 justification -1: p51
[end-of-instance]
[assign] #3404 clause p180 (not p179)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[assign] #2969 clause p181 (not p179)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[mk-app] #3511 = #3353 #4054
[attach-meaning] #176 arith (- 1)
[mk-app] #4182 * #176 #4054
[mk-app] #2970 + #3353 #4182
[mk-app] #3708 <= #2970 #36
[mk-app] #3847 >= #2970 #36
[assign] #3511 justification -1: p177
[attach-enode] #3511 0
[attach-enode] #4182 0
[attach-enode] #2970 0
[assign] #3708 justification -1: p182
[assign] #3847 justification -1: p182
[new-match] 0x106833a68 #1495 #1483 #4510 #1545 ; #3346 (#3326 #3326)
[mk-app] #3412 = #3346 #3783
[mk-app] #3413 = #3346 #3788
[mk-app] #3415 = #3412 #3413
[mk-proof] #3416 monotonicity #4216 #3415
[mk-app] #3489 or #1563 #3413
[mk-app] #3491 or #1563 #3412
[mk-proof] #3389 quant-inst #3491
[mk-app] #4353 = #3491 #3489
[mk-proof] #2982 monotonicity #3416 #4353
[mk-app] #4140 = #3489 #3489
[mk-proof] #4141 rewrite #4140
[mk-proof] #4142 trans #2982 #4141 #4353
[mk-proof] #4143 mp #3389 #4142 #3489
[instance] 0x106833a68 #3389 ; 25
[attach-enode] #3785 25
[attach-enode] #3788 25
[attach-enode] #3413 25
[assign] #3413 justification -1: p50
[end-of-instance]
[eq-expl] #3785 root
[new-match] 0x106833d08 #1477 #1476 #3785 #1545 ; #3788
[eq-expl] #3346 lit #3413 ; #3788
[eq-expl] #3788 root
[new-match] 0x106833d40 #1522 #1506 #3785 #1545 ; #3347 (#3346 #3788)
[mk-app] #4136 = #4233 #3785
[mk-app] #4137 = #4136 #4136
[mk-proof] #4152 refl #4137
[mk-app] #4153 or #1576 #4136
[mk-proof] #3688 quant-inst #4153
[instance] 0x106833d08 #3688 ; 26
[attach-enode] #4233 26
[attach-enode] #4136 26
[assign] #4136 justification -1: p49
[end-of-instance]
[mk-app] #4137 * #176 #4240
[mk-app] #4152 + #4237 #4137
[mk-app] #3689 = #4152 #1503
[mk-app] #3251 = #3689 #3689
[mk-proof] #3252 refl #3251
[mk-app] #4169 or #4983 #3689
[mk-proof] #4163 quant-inst #4169
[instance] 0x106833d40 #4163 ; 26
[attach-enode] #4235 26
[attach-enode] #4237 26
[attach-enode] #4240 26
[attach-enode] #4137 26
[attach-enode] #4152 26
[attach-enode] #3689 26
[mk-app] #4178 <= #4152 #1503
[mk-app] #2928 >= #4152 #1503
[assign] #3689 justification -1: p51
[end-of-instance]
[assign] #4178 clause p188 (not p187)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[assign] #2928 clause p189 (not p187)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[mk-app] #3251 = #3347 #4240
[attach-meaning] #176 arith (- 1)
[mk-app] #3252 + #3347 #4137
[mk-app] #4509 <= #3252 #36
[mk-app] #3510 >= #3252 #36
[assign] #3251 justification -1: p185
[attach-enode] #3251 0
[attach-enode] #3252 0
[assign] #4509 justification -1: p190
[assign] #3510 justification -1: p190
[new-match] 0x10683b310 #1495 #1483 #3785 #1545 ; #4235 (#3788 #3788)
[mk-app] #3495 = #4235 #2952
[mk-app] #3496 = #4235 #2957
[mk-app] #3499 = #3495 #3496
[mk-proof] #4508 monotonicity #2959 #3499
[mk-app] #3081 or #1563 #3496
[mk-app] #3082 or #1563 #3495
[mk-proof] #3614 quant-inst #3082
[mk-app] #3615 = #3082 #3081
[mk-proof] #3613 monotonicity #4508 #3615
[mk-app] #3616 = #3081 #3081
[mk-proof] #3114 rewrite #3616
[mk-proof] #3115 trans #3613 #3114 #3615
[mk-proof] #3359 mp #3614 #3115 #3081
[instance] 0x10683b310 #3614 ; 27
[attach-enode] #2954 27
[attach-enode] #2957 27
[attach-enode] #3496 27
[assign] #3496 justification -1: p50
[end-of-instance]
[eq-expl] #2954 root
[new-match] 0x10683b5b0 #1477 #1476 #2954 #1545 ; #2957
[eq-expl] #4235 lit #3496 ; #2957
[eq-expl] #2957 root
[new-match] 0x10683b5e8 #1522 #1506 #2954 #1545 ; #4237 (#4235 #2957)
[mk-app] #4218 = #3638 #2954
[mk-app] #2971 = #4218 #4218
[mk-proof] #4049 refl #2971
[mk-app] #4050 or #1576 #4218
[mk-proof] #2972 quant-inst #4050
[instance] 0x10683b5b0 #2972 ; 28
[attach-enode] #3638 28
[attach-enode] #4218 28
[assign] #4218 justification -1: p49
[end-of-instance]
[mk-app] #2971 * #176 #4500
[mk-app] #4049 + #3641 #2971
[mk-app] #2973 = #4049 #1503
[mk-app] #3644 = #2973 #2973
[mk-proof] #4055 refl #3644
[mk-app] #4056 or #4983 #2973
[mk-proof] #3411 quant-inst #4056
[instance] 0x10683b5e8 #3411 ; 28
[attach-enode] #3640 28
[attach-enode] #3641 28
[attach-enode] #4500 28
[attach-enode] #2971 28
[attach-enode] #4049 28
[attach-enode] #2973 28
[mk-app] #3360 <= #4049 #1503
[mk-app] #4221 >= #4049 #1503
[assign] #2973 justification -1: p51
[end-of-instance]
[assign] #3360 clause p196 (not p195)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[assign] #4221 clause p197 (not p195)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[mk-app] #3644 = #4237 #4500
[attach-meaning] #176 arith (- 1)
[mk-app] #4055 + #4237 #2971
[mk-app] #4222 <= #4055 #36
[mk-app] #4217 >= #4055 #36
[assign] #3644 justification -1: p193
[attach-enode] #3644 0
[attach-enode] #4055 0
[assign] #4222 justification -1: p198
[assign] #4217 justification -1: p198
[new-match] 0x10683bfa8 #1495 #1483 #2954 #1545 ; #3640 (#2957 #2957)
[mk-app] #3352 = #3640 #3570
[mk-app] #4219 = #3640 #3910
[mk-app] #4220 = #3352 #4219
[mk-proof] #4223 monotonicity #3912 #4220
[mk-app] #4224 or #1563 #4219
[mk-app] #4225 or #1563 #3352
[mk-proof] #2984 quant-inst #4225
[mk-app] #3002 = #4225 #4224
[mk-proof] #3913 monotonicity #4223 #3002
[mk-app] #4135 = #4224 #4224
[mk-proof] #3915 rewrite #4135
[mk-proof] #3005 trans #3913 #3915 #3002
[mk-proof] #4559 mp #2984 #3005 #4224
[instance] 0x10683bfa8 #2984 ; 29
[attach-enode] #3572 29
[attach-enode] #3910 29
[attach-enode] #4219 29
[assign] #4219 justification -1: p50
[end-of-instance]
[eq-expl] #3572 root
[new-match] 0x10683c248 #1477 #1476 #3572 #1545 ; #3910
[eq-expl] #3640 lit #4219 ; #3910
[eq-expl] #3910 root
[new-match] 0x10683c280 #1522 #1506 #3572 #1545 ; #3641 (#3640 #3910)
[mk-app] #3914 = #3009 #3572
[mk-app] #3006 = #3914 #3914
[mk-proof] #3014 refl #3006
[mk-app] #3034 or #1576 #3914
[mk-proof] #3994 quant-inst #3034
[instance] 0x10683c248 #3994 ; 30
[attach-enode] #3009 30
[attach-enode] #3914 30
[assign] #3914 justification -1: p49
[end-of-instance]
[mk-app] #3006 * #176 #3015
[mk-app] #3014 + #3012 #3006
[mk-app] #3995 = #3014 #1503
[mk-app] #3996 = #3995 #3995
[mk-proof] #3255 refl #3996
[mk-app] #4007 or #4983 #3995
[mk-proof] #3279 quant-inst #4007
[instance] 0x10683c280 #3279 ; 30
[attach-enode] #3011 30
[attach-enode] #3012 30
[attach-enode] #3015 30
[attach-enode] #3006 30
[attach-enode] #3014 30
[attach-enode] #3995 30
[mk-app] #4280 <= #3014 #1503
[mk-app] #4281 >= #3014 #1503
[assign] #3995 justification -1: p51
[end-of-instance]
[assign] #4280 clause p204 (not p203)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[assign] #4281 clause p205 (not p203)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[mk-app] #3996 = #3015 #3641
[attach-meaning] #176 arith (- 1)
[mk-app] #3255 * #176 #3641
[mk-app] #4276 + #3015 #3255
[mk-app] #4279 <= #4276 #36
[mk-app] #4274 >= #4276 #36
[assign] #3996 justification -1: p201
[attach-enode] #3996 0
[attach-enode] #3255 0
[attach-enode] #4276 0
[assign] #4279 justification -1: p206
[assign] #4274 justification -1: p206
[new-match] 0x106840f38 #1495 #1483 #3572 #1545 ; #3011 (#3910 #3910)
[mk-app] #4275 = #3011 #3042
[mk-app] #4282 = #3011 #3725
[mk-app] #4180 = #4275 #4282
[mk-proof] #4288 monotonicity #3727 #4180
[mk-app] #3825 or #1563 #4282
[mk-app] #4588 or #1563 #4275
[mk-proof] #4589 quant-inst #4588
[mk-app] #3836 = #4588 #3825
[mk-proof] #3168 monotonicity #4288 #3836
[mk-app] #3147 = #3825 #3825
[mk-proof] #3171 rewrite #3147
[mk-proof] #3611 trans #3168 #3171 #3836
[mk-proof] #3612 mp #4589 #3611 #3825
[instance] 0x106840f38 #4589 ; 31
[attach-enode] #3722 31
[attach-enode] #3725 31
[attach-enode] #4282 31
[assign] #4282 justification -1: p50
[end-of-instance]
[eq-expl] #3722 root
[new-match] 0x1068411d8 #1477 #1476 #3722 #1545 ; #3725
[eq-expl] #3011 lit #4282 ; #3725
[eq-expl] #3725 root
[new-match] 0x106841210 #1522 #1506 #3722 #1545 ; #3012 (#3011 #3725)
[mk-app] #4083 = #4002 #3722
[mk-app] #4565 = #4083 #4083
[mk-proof] #3524 refl #4565
[mk-app] #3515 or #1576 #4083
[mk-proof] #3617 quant-inst #3515
[instance] 0x1068411d8 #3617 ; 32
[attach-enode] #4002 32
[attach-enode] #4083 32
[assign] #4083 justification -1: p49
[end-of-instance]
[mk-app] #4565 * #176 #4009
[mk-app] #3524 + #4005 #4565
[mk-app] #3516 = #3524 #1503
[mk-app] #3517 = #3516 #3516
[mk-proof] #3737 refl #3517
[mk-app] #4460 or #4983 #3516
[mk-proof] #4467 quant-inst #4460
[instance] 0x106841210 #4467 ; 32
[attach-enode] #4004 32
[attach-enode] #4005 32
[attach-enode] #4009 32
[attach-enode] #4565 32
[attach-enode] #3524 32
[attach-enode] #3516 32
[mk-app] #4456 <= #3524 #1503
[mk-app] #3444 >= #3524 #1503
[assign] #3516 justification -1: p51
[end-of-instance]
[assign] #4456 clause p212 (not p211)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[assign] #3444 clause p213 (not p211)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[mk-app] #3517 = #3012 #4009
[attach-meaning] #176 arith (- 1)
[mk-app] #3737 + #3012 #4565
[mk-app] #3440 <= #3737 #36
[mk-app] #3442 >= #3737 #36
[assign] #3517 justification -1: p209
[attach-enode] #3517 0
[attach-enode] #3737 0
[assign] #3440 justification -1: p214
[assign] #3442 justification -1: p214
[new-match] 0x106841bd0 #1495 #1483 #3722 #1545 ; #4004 (#3725 #3725)
[mk-app] #4249 = #4004 #3624
[mk-app] #3808 = #4004 #3633
[mk-app] #4362 = #4249 #3808
[mk-proof] #4363 monotonicity #3631 #4362
[mk-app] #3351 or #1563 #3808
[mk-app] #4248 or #1563 #4249
[mk-proof] #3809 quant-inst #4248
[mk-app] #4475 = #4248 #3351
[mk-proof] #4476 monotonicity #4363 #4475
[mk-app] #3810 = #3351 #3351
[mk-proof] #4247 rewrite #3810
[mk-proof] #4250 trans #4476 #4247 #4475
[mk-proof] #4226 mp #3809 #4250 #3351
[instance] 0x106841bd0 #3809 ; 33
[attach-enode] #3632 33
[attach-enode] #3633 33
[attach-enode] #3808 33
[assign] #3808 justification -1: p50
[end-of-instance]
[eq-expl] #3632 root
[new-match] 0x106841e70 #1477 #1476 #3632 #1545 ; #3633
[eq-expl] #4004 lit #3808 ; #3633
[eq-expl] #3633 root
[new-match] 0x106841ea8 #1522 #1506 #3632 #1545 ; #4005 (#4004 #3633)
[mk-app] #2922 = #3596 #3632
[mk-app] #4592 = #2922 #2922
[mk-proof] #3774 refl #4592
[mk-app] #3584 or #1576 #2922
[mk-proof] #3449 quant-inst #3584
[instance] 0x106841e70 #3449 ; 34
[attach-enode] #3596 34
[attach-enode] #2922 34
[assign] #2922 justification -1: p49
[end-of-instance]
[mk-app] #4592 * #176 #3370
[mk-app] #3774 + #3367 #4592
[mk-app] #4522 = #3774 #1503
[mk-app] #3918 = #4522 #4522
[mk-proof] #3919 refl #3918
[mk-app] #3578 or #4983 #4522
[mk-proof] #3048 quant-inst #3578
[instance] 0x106841ea8 #3048 ; 34
[attach-enode] #4533 34
[attach-enode] #3367 34
[attach-enode] #3370 34
[attach-enode] #4592 34
[attach-enode] #3774 34
[attach-enode] #4522 34
[mk-app] #3049 <= #3774 #1503
[mk-app] #3044 >= #3774 #1503
[assign] #4522 justification -1: p51
[end-of-instance]
[assign] #3049 clause p220 (not p219)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[assign] #3044 clause p221 (not p219)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[mk-app] #3918 = #3370 #4005
[attach-meaning] #176 arith (- 1)
[mk-app] #3919 * #176 #4005
[mk-app] #4558 + #3370 #3919
[mk-app] #3047 <= #4558 #36
[mk-app] #3050 >= #4558 #36
[assign] #3918 justification -1: p217
[attach-enode] #3918 0
[attach-enode] #3919 0
[attach-enode] #4558 0
[assign] #3047 justification -1: p222
[assign] #3050 justification -1: p222
[new-match] 0x1068428f0 #1495 #1483 #3632 #1545 ; #4533 (#3633 #3633)
[mk-app] #3051 = #4533 #3798
[mk-app] #3447 = #4533 #3803
[mk-app] #4399 = #3051 #3447
[mk-proof] #4397 monotonicity #4273 #4399
[mk-app] #4264 or #1563 #3447
[mk-app] #4269 or #1563 #3051
[mk-proof] #4258 quant-inst #4269
[mk-app] #4259 = #4269 #4264
[mk-proof] #4260 monotonicity #4397 #4259
[mk-app] #4526 = #4264 #4264
[mk-proof] #4527 rewrite #4526
[mk-proof] #3628 trans #4260 #4527 #4259
[mk-proof] #3575 mp #4258 #3628 #4264
[instance] 0x1068428f0 #4258 ; 35
[attach-enode] #3800 35
[attach-enode] #3803 35
[attach-enode] #3447 35
[assign] #3447 justification -1: p50
[end-of-instance]
[eq-expl] #3800 root
[new-match] 0x106842b90 #1477 #1476 #3800 #1545 ; #3803
[eq-expl] #4533 lit #3447 ; #3803
[eq-expl] #3803 root
[new-match] 0x106842bc8 #1522 #1506 #3800 #1545 ; #3367 (#4533 #3803)
[mk-app] #4270 = #4289 #3800
[mk-app] #3460 = #4270 #4270
[mk-proof] #3378 refl #3460
[mk-app] #3844 or #1576 #4270
[mk-proof] #4594 quant-inst #3844
[instance] 0x106842b90 #4594 ; 36
[attach-enode] #4289 36
[attach-enode] #4270 36
[assign] #4270 justification -1: p49
[end-of-instance]
[mk-app] #3460 * #176 #4297
[mk-app] #3378 + #4293 #3460
[mk-app] #3458 = #3378 #1503
[mk-app] #3459 = #3458 #3458
[mk-proof] #3131 refl #3459
[mk-app] #4537 or #4983 #3458
[mk-proof] #4553 quant-inst #4537
[instance] 0x106842bc8 #4553 ; 36
[attach-enode] #4292 36
[attach-enode] #4293 36
[attach-enode] #4297 36
[attach-enode] #3460 36
[attach-enode] #3378 36
[attach-enode] #3458 36
[mk-app] #3126 <= #3378 #1503
[mk-app] #3604 >= #3378 #1503
[assign] #3458 justification -1: p51
[end-of-instance]
[assign] #3126 clause p228 (not p227)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[assign] #3604 clause p229 (not p227)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[mk-app] #3459 = #3367 #4297
[attach-meaning] #176 arith (- 1)
[mk-app] #3131 + #3367 #3460
[mk-app] #3605 <= #3131 #36
[mk-app] #3052 >= #3131 #36
[assign] #3459 justification -1: p225
[attach-enode] #3459 0
[attach-enode] #3131 0
[assign] #3605 justification -1: p230
[assign] #3052 justification -1: p230
[new-match] 0x106828798 #1495 #1483 #3800 #1545 ; #4292 (#3803 #3803)
[mk-app] #3066 = #4292 #3831
[mk-app] #3067 = #4292 #3118
[mk-app] #3610 = #3066 #3067
[mk-proof] #4536 monotonicity #3120 #3610
[mk-app] #3056 or #1563 #3067
[mk-app] #3059 or #1563 #3066
[mk-proof] #3060 quant-inst #3059
[mk-app] #3176 = #3059 #3056
[mk-proof] #3742 monotonicity #4536 #3176
[mk-app] #4026 = #3056 #3056
[mk-proof] #4033 rewrite #4026
[mk-proof] #4032 trans #3742 #4033 #3176
[mk-proof] #4019 mp #3060 #4032 #3056
[instance] 0x106828798 #3060 ; 37
[attach-enode] #4573 37
[attach-enode] #3118 37
[attach-enode] #3067 37
[assign] #3067 justification -1: p50
[end-of-instance]
[eq-expl] #4573 root
[new-match] 0x106828a38 #1477 #1476 #4573 #1545 ; #3118
[eq-expl] #4292 lit #3067 ; #3118
[eq-expl] #3118 root
[new-match] 0x106828a70 #1522 #1506 #4573 #1545 ; #4293 (#4292 #3118)
[mk-app] #4024 = #3133 #4573
[mk-app] #4025 = #4024 #4024
[mk-proof] #3304 refl #4025
[mk-app] #3305 or #1576 #4024
[mk-proof] #3298 quant-inst #3305
[instance] 0x106828a38 #3298 ; 38
[attach-enode] #3133 38
[attach-enode] #4024 38
[assign] #4024 justification -1: p49
[end-of-instance]
[mk-app] #4025 * #176 #3140
[mk-app] #3304 + #3136 #4025
[mk-app] #3299 = #3304 #1503
[mk-app] #3300 = #3299 #3299
[mk-proof] #4450 refl #3300
[mk-app] #4452 or #4983 #3299
[mk-proof] #4457 quant-inst #4452
[instance] 0x106828a70 #4457 ; 38
[attach-enode] #3135 38
[attach-enode] #3136 38
[attach-enode] #3140 38
[attach-enode] #4025 38
[attach-enode] #3304 38
[attach-enode] #3299 38
[mk-app] #3880 <= #3304 #1503
[mk-app] #3824 >= #3304 #1503
[assign] #3299 justification -1: p51
[end-of-instance]
[assign] #3880 clause p236 (not p235)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[assign] #3824 clause p237 (not p235)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[mk-app] #3300 = #3140 #4293
[attach-meaning] #176 arith (- 1)
[mk-app] #4450 * #176 #4293
[mk-app] #4370 + #3140 #4450
[mk-app] #3961 <= #4370 #36
[mk-app] #3823 >= #4370 #36
[assign] #3300 justification -1: p233
[attach-enode] #3300 0
[attach-enode] #4450 0
[attach-enode] #4370 0
[assign] #3961 justification -1: p238
[assign] #3823 justification -1: p238
[new-match] 0x1068294b8 #1495 #1483 #4573 #1545 ; #3135 (#3118 #3118)
[mk-app] #4571 = #3135 #3158
[mk-app] #3597 = #3135 #3165
[mk-app] #3598 = #4571 #3597
[mk-proof] #3963 monotonicity #3167 #3598
[mk-app] #4371 or #1563 #3597
[mk-app] #3542 or #1563 #4571
[mk-proof] #3539 quant-inst #3542
[mk-app] #3964 = #3542 #4371
[mk-proof] #2995 monotonicity #3963 #3964
[mk-app] #3001 = #4371 #4371
[mk-proof] #3714 rewrite #3001
[mk-proof] #3720 trans #2995 #3714 #3964
[mk-proof] #3965 mp #3539 #3720 #4371
[instance] 0x1068294b8 #3539 ; 39
[attach-enode] #3161 39
[attach-enode] #3165 39
[attach-enode] #3597 39
[assign] #3597 justification -1: p50
[end-of-instance]
[eq-expl] #3161 root
[new-match] 0x106829758 #1477 #1476 #3161 #1545 ; #3165
[eq-expl] #3135 lit #3597 ; #3165
[eq-expl] #3165 root
[new-match] 0x106829790 #1522 #1506 #3161 #1545 ; #3136 (#3135 #3165)
[mk-app] #3188 = #3745 #3161
[mk-app] #3189 = #3188 #3188
[mk-proof] #3207 refl #3189
[mk-app] #4255 or #1576 #3188
[mk-proof] #4304 quant-inst #4255
[instance] 0x106829758 #4304 ; 40
[attach-enode] #3745 40
[attach-enode] #3188 40
[assign] #3188 justification -1: p49
[end-of-instance]
[mk-app] #3189 * #176 #4076
[mk-app] #3207 + #3748 #3189
[mk-app] #4315 = #3207 #1503
[mk-app] #3681 = #4315 #4315
[mk-proof] #4109 refl #3681
[mk-app] #4110 or #4983 #4315
[mk-proof] #3753 quant-inst #4110
[instance] 0x106829790 #3753 ; 40
[attach-enode] #3747 40
[attach-enode] #3748 40
[attach-enode] #4076 40
[attach-enode] #3189 40
[attach-enode] #3207 40
[attach-enode] #4315 40
[mk-app] #3222 <= #3207 #1503
[mk-app] #3749 >= #3207 #1503
[assign] #4315 justification -1: p51
[end-of-instance]
[assign] #3222 clause p244 (not p243)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[assign] #3749 clause p245 (not p243)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[mk-app] #3681 = #3136 #4076
[attach-meaning] #176 arith (- 1)
[mk-app] #4109 + #3136 #3189
[mk-app] #3668 <= #4109 #36
[mk-app] #3669 >= #4109 #36
[assign] #3681 justification -1: p241
[attach-enode] #3681 0
[attach-enode] #4109 0
[assign] #3668 justification -1: p246
[assign] #3669 justification -1: p246
[new-match] 0x106859b60 #1495 #1483 #3161 #1545 ; #3747 (#3165 #3165)
[mk-app] #3670 = #3747 #4093
[mk-app] #3671 = #3747 #4100
[mk-app] #4653 = #3670 #3671
[mk-proof] #4654 monotonicity #4102 #4653
[mk-app] #4655 or #1563 #3671
[mk-app] #4656 or #1563 #3670
[mk-proof] #4620 quant-inst #4656
[mk-app] #4621 = #4656 #4655
[mk-proof] #4651 monotonicity #4654 #4621
[mk-app] #4652 = #4655 #4655
[mk-proof] #4657 rewrite #4652
[mk-proof] #4658 trans #4651 #4657 #4621
[mk-proof] #4659 mp #4620 #4658 #4655
[instance] 0x106859b60 #4620 ; 41
[attach-enode] #4096 41
[attach-enode] #4100 41
[attach-enode] #3671 41
[assign] #3671 justification -1: p50
[end-of-instance]
[eq-expl] #4096 root
[new-match] 0x106859e00 #1477 #1476 #4096 #1545 ; #4100
[eq-expl] #3747 lit #3671 ; #4100
[eq-expl] #4100 root
[new-match] 0x106859e38 #1522 #1506 #4096 #1545 ; #3748 (#3747 #4100)
[mk-app] #4660 = #3520 #4096
[mk-app] #3454 = #4660 #4660
[mk-proof] #3455 refl #3454
[mk-app] #4408 or #1576 #4660
[mk-proof] #4731 quant-inst #4408
[instance] 0x106859e00 #4731 ; 42
[attach-enode] #3520 42
[attach-enode] #4660 42
[assign] #4660 justification -1: p49
[end-of-instance]
[mk-app] #3454 * #176 #3526
[mk-app] #3455 + #3523 #3454
[mk-app] #4784 = #3455 #1503
[mk-app] #4746 = #4784 #4784
[mk-proof] #4735 refl #4746
[mk-app] #4739 or #4983 #4784
[mk-proof] #4740 quant-inst #4739
[instance] 0x106859e38 #4740 ; 42
[attach-enode] #3522 42
[attach-enode] #3523 42
[attach-enode] #3526 42
[attach-enode] #3454 42
[attach-enode] #3455 42
[attach-enode] #4784 42
[mk-app] #4779 <= #3455 #1503
[mk-app] #4265 >= #3455 #1503
[assign] #4784 justification -1: p51
[end-of-instance]
[assign] #4779 clause p252 (not p251)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[assign] #4265 clause p253 (not p251)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[mk-app] #4746 = #3526 #3748
[attach-meaning] #176 arith (- 1)
[mk-app] #4735 * #176 #3748
[mk-app] #4772 + #3526 #4735
[mk-app] #4773 <= #4772 #36
[mk-app] #4267 >= #4772 #36
[assign] #4746 justification -1: p249
[attach-enode] #4746 0
[attach-enode] #4735 0
[attach-enode] #4772 0
[assign] #4773 justification -1: p254
[assign] #4267 justification -1: p254
[new-match] 0x10685a880 #1495 #1483 #4096 #1545 ; #3522 (#4100 #4100)
[mk-app] #4268 = #3522 #3896
[mk-app] #4271 = #3522 #3901
[mk-app] #4754 = #4268 #4271
[mk-proof] #4768 monotonicity #4448 #4754
[mk-app] #4774 or #1563 #4271
[mk-app] #4775 or #1563 #4268
[mk-proof] #4823 quant-inst #4775
[mk-app] #4824 = #4775 #4774
[mk-proof] #4807 monotonicity #4768 #4824
[mk-app] #4832 = #4774 #4774
[mk-proof] #4850 rewrite #4832
[mk-proof] #4818 trans #4807 #4850 #4824
[mk-proof] #4427 mp #4823 #4818 #4774
[instance] 0x10685a880 #4823 ; 43
[attach-enode] #3898 43
[attach-enode] #3901 43
[attach-enode] #4271 43
[assign] #4271 justification -1: p50
[end-of-instance]
[eq-expl] #3898 root
[new-match] 0x10685ab20 #1477 #1476 #3898 #1545 ; #3901
[eq-expl] #3522 lit #4271 ; #3901
[eq-expl] #3901 root
[new-match] 0x10685ab58 #1522 #1506 #3898 #1545 ; #3523 (#3522 #3901)
[mk-app] #4895 = #4462 #3898
[mk-app] #4896 = #4895 #4895
[mk-proof] #4856 refl #4896
[mk-app] #4857 or #1576 #4895
[mk-proof] #4871 quant-inst #4857
[instance] 0x10685ab20 #4871 ; 44
[attach-enode] #4462 44
[attach-enode] #4895 44
[assign] #4895 justification -1: p49
[end-of-instance]
[mk-app] #4896 * #176 #4469
[mk-app] #4856 + #4465 #4896
[mk-app] #4893 = #4856 #1503
[mk-app] #4894 = #4893 #4893
[mk-proof] #4928 refl #4894
[mk-app] #4929 or #4983 #4893
[mk-proof] #4934 quant-inst #4929
[instance] 0x10685ab58 #4934 ; 44
[attach-enode] #4464 44
[attach-enode] #4465 44
[attach-enode] #4469 44
[attach-enode] #4896 44
[attach-enode] #4856 44
[attach-enode] #4893 44
[mk-app] #4935 <= #4856 #1503
[mk-app] #4909 >= #4856 #1503
[assign] #4893 justification -1: p51
[end-of-instance]
[assign] #4935 clause p260 (not p259)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[assign] #4909 clause p261 (not p259)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[mk-app] #4894 = #3523 #4469
[attach-meaning] #176 arith (- 1)
[mk-app] #4928 + #3523 #4896
[mk-app] #4910 <= #4928 #36
[mk-app] #4927 >= #4928 #36
[assign] #4894 justification -1: p257
[attach-enode] #4894 0
[attach-enode] #4928 0
[assign] #4910 justification -1: p262
[assign] #4927 justification -1: p262
[new-match] 0x10685b518 #1495 #1483 #3898 #1545 ; #4464 (#3901 #3901)
[mk-app] #4930 = #4464 #3430
[mk-app] #4966 = #4464 #3435
[mk-app] #4969 = #4930 #4966
[mk-proof] #4968 monotonicity #3437 #4969
[mk-app] #4963 or #1563 #4966
[mk-app] #4964 or #1563 #4930
[mk-proof] #4965 quant-inst #4964
[mk-app] #4979 = #4964 #4963
[mk-proof] #5006 monotonicity #4968 #4979
[mk-app] #3297 = #4963 #4963
[mk-proof] #5047 rewrite #3297
[mk-proof] #5096 trans #5006 #5047 #4979
[mk-proof] #3776 mp #4965 #5096 #4963
[instance] 0x10685b518 #4965 ; 45
[attach-enode] #3432 45
[attach-enode] #3435 45
[attach-enode] #4966 45
[assign] #4966 justification -1: p50
[end-of-instance]
[eq-expl] #3432 root
[new-match] 0x10685b7b8 #1477 #1476 #3432 #1545 ; #3435
[eq-expl] #4464 lit #4966 ; #3435
[eq-expl] #3435 root
[new-match] 0x106862810 #1522 #1506 #3432 #1545 ; #4465 (#4464 #3435)
[mk-app] #5057 = #3856 #3432
[mk-app] #5084 = #5057 #5057
[mk-proof] #5085 refl #5084
[mk-app] #5091 or #1576 #5057
[mk-proof] #5089 quant-inst #5091
[instance] 0x10685b7b8 #5089 ; 46
[attach-enode] #3856 46
[attach-enode] #5057 46
[assign] #5057 justification -1: p49
[end-of-instance]
[mk-app] #5084 * #176 #4364
[mk-app] #5085 + #3859 #5084
[mk-app] #5090 = #5085 #1503
[mk-app] #4201 = #5090 #5090
[mk-proof] #4202 refl #4201
[mk-app] #4195 or #4983 #5090
[mk-proof] #5097 quant-inst #4195
[instance] 0x106862810 #5097 ; 46
[attach-enode] #3858 46
[attach-enode] #3859 46
[attach-enode] #4364 46
[attach-enode] #5084 46
[attach-enode] #5085 46
[attach-enode] #5090 46
[mk-app] #3816 <= #5085 #1503
[mk-app] #2936 >= #5085 #1503
[assign] #5090 justification -1: p51
[end-of-instance]
[assign] #3816 clause p268 (not p267)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[assign] #2936 clause p269 (not p267)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[mk-app] #4201 = #4364 #4465
[attach-meaning] #176 arith (- 1)
[mk-app] #4202 * #176 #4465
[mk-app] #4006 + #4364 #4202
[mk-app] #3814 <= #4006 #36
[mk-app] #3962 >= #4006 #36
[assign] #4201 justification -1: p265
[attach-enode] #4201 0
[attach-enode] #4202 0
[attach-enode] #4006 0
[assign] #3814 justification -1: p270
[assign] #3962 justification -1: p270
[new-match] 0x106863258 #1495 #1483 #3432 #1545 ; #3858 (#3435 #3435)
[mk-app] #3686 = #3858 #4379
[mk-app] #3892 = #3858 #4385
[mk-app] #3893 = #3686 #3892
[mk-proof] #3601 monotonicity #4580 #3893
[mk-app] #2989 or #1563 #3892
[mk-app] #3687 or #1563 #3686
[mk-proof] #3890 quant-inst #3687
[mk-app] #3891 = #3687 #2989
[mk-proof] #3647 monotonicity #3601 #3891
[mk-app] #4518 = #2989 #2989
[mk-proof] #4354 rewrite #4518
[mk-proof] #3246 trans #3647 #4354 #3891
[mk-proof] #3241 mp #3890 #3246 #2989
[instance] 0x106863258 #3890 ; 47
[attach-enode] #4382 47
[attach-enode] #4385 47
[attach-enode] #3892 47
[assign] #3892 justification -1: p50
[end-of-instance]
[eq-expl] #4382 root
[new-match] 0x1068634f8 #1477 #1476 #4382 #1545 ; #4385
[eq-expl] #3858 lit #3892 ; #4385
[eq-expl] #4385 root
[new-match] 0x106863530 #1522 #1506 #4382 #1545 ; #3859 (#3858 #4385)
[mk-app] #3691 = #3550 #4382
[mk-app] #3692 = #3691 #3691
[mk-proof] #4062 refl #3692
[mk-app] #4069 or #1576 #3691
[mk-proof] #3187 quant-inst #4069
[instance] 0x1068634f8 #3187 ; 48
[attach-enode] #3550 48
[attach-enode] #3691 48
[assign] #3691 justification -1: p49
[end-of-instance]
[mk-app] #3692 * #176 #3903
[mk-app] #4062 + #3553 #3692
[mk-app] #3362 = #4062 #1503
[mk-app] #3363 = #3362 #3362
[mk-proof] #4061 refl #3363
[mk-app] #4070 or #4983 #3362
[mk-proof] #3364 quant-inst #4070
[instance] 0x106863530 #3364 ; 48
[attach-enode] #3552 48
[attach-enode] #3553 48
[attach-enode] #3903 48
[attach-enode] #3692 48
[attach-enode] #4062 48
[attach-enode] #3362 48
[mk-app] #3365 <= #4062 #1503
[mk-app] #4246 >= #4062 #1503
[assign] #3362 justification -1: p51
[end-of-instance]
[assign] #3365 clause p276 (not p275)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[assign] #4246 clause p277 (not p275)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[mk-app] #3363 = #3859 #3903
[attach-meaning] #176 arith (- 1)
[mk-app] #4061 + #3859 #3692
[mk-app] #2949 <= #4061 #36
[mk-app] #3032 >= #4061 #36
[assign] #3363 justification -1: p273
[attach-enode] #3363 0
[attach-enode] #4061 0
[assign] #2949 justification -1: p278
[assign] #3032 justification -1: p278
[new-match] 0x106863ef0 #1495 #1483 #4382 #1545 ; #3552 (#4385 #4385)
[mk-app] #3038 = #3552 #4484
[mk-app] #3754 = #3552 #3805
[mk-app] #3037 = #3038 #3754
[mk-proof] #3656 monotonicity #3807 #3037
[mk-app] #3155 or #1563 #3754
[mk-app] #3156 or #1563 #3038
[mk-proof] #3829 quant-inst #3156
[mk-app] #3149 = #3156 #3155
[mk-proof] #3150 monotonicity #3656 #3149
[mk-app] #3145 = #3155 #3155
[mk-proof] #4616 rewrite #3145
[mk-proof] #4080 trans #3150 #4616 #3149
[mk-proof] #4081 mp #3829 #4080 #3155
[instance] 0x106863ef0 #3829 ; 49
[attach-enode] #4548 49
[attach-enode] #3805 49
[attach-enode] #3754 49
[assign] #3754 justification -1: p50
[end-of-instance]
[eq-expl] #4548 root
[new-match] 0x106864190 #1477 #1476 #4548 #1545 ; #3805
[eq-expl] #3552 lit #3754 ; #3805
[eq-expl] #3805 root
[new-match] 0x1068641c8 #1522 #1506 #4548 #1545 ; #3553 (#3552 #3805)
[mk-app] #4617 = #4256 #4548
[mk-app] #4612 = #4617 #4617
[mk-proof] #4615 refl #4612
[mk-app] #4478 or #1576 #4617
[mk-proof] #4479 quant-inst #4478
[instance] 0x106864190 #4479 ; 50
[attach-enode] #4256 50
[attach-enode] #4617 50
[assign] #4617 justification -1: p49
[end-of-instance]
[mk-app] #4612 * #176 #4307
[mk-app] #4615 + #4303 #4612
[mk-app] #4695 = #4615 #1503
[mk-app] #3861 = #4695 #4695
[mk-proof] #4368 refl #3861
[mk-app] #4369 or #4983 #4695
[mk-proof] #4377 quant-inst #4369
[instance] 0x1068641c8 #4377 ; 50
[attach-enode] #4302 50
[attach-enode] #4303 50
[attach-enode] #4307 50
[attach-enode] #4612 50
[attach-enode] #4615 50
[attach-enode] #4695 50
[mk-app] #3907 <= #4615 #1503
[mk-app] #3908 >= #4615 #1503
[assign] #4695 justification -1: p51
[end-of-instance]
[assign] #3907 clause p284 (not p283)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[assign] #3908 clause p285 (not p283)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[mk-app] #3861 = #3553 #4307
[attach-meaning] #176 arith (- 1)
[mk-app] #4368 + #3553 #4612
[mk-app] #4481 <= #4368 #36
[mk-app] #4312 >= #4368 #36
[assign] #3861 justification -1: p281
[attach-enode] #3861 0
[attach-enode] #4368 0
[assign] #4481 justification -1: p286
[assign] #4312 justification -1: p286
[new-match] 0x1068675a8 #1495 #1483 #4548 #1545 ; #4302 (#3805 #3805)
[mk-app] #4313 = #4302 #2914
[mk-app] #3939 = #4302 #2919
[mk-app] #4667 = #4313 #3939
[mk-proof] #3865 monotonicity #2921 #4667
[mk-app] #3860 or #1563 #3939
[mk-app] #4668 or #1563 #4313
[mk-proof] #4675 quant-inst #4668
[mk-app] #3862 = #4668 #3860
[mk-proof] #4700 monotonicity #3865 #3862
[mk-app] #3484 = #3860 #3860
[mk-proof] #3077 rewrite #3484
[mk-proof] #3881 trans #4700 #3077 #3862
[mk-proof] #3882 mp #4675 #3881 #3860
[instance] 0x1068675a8 #4675 ; 51
[attach-enode] #2916 51
[attach-enode] #2919 51
[attach-enode] #3939 51
[assign] #3939 justification -1: p50
[end-of-instance]
[eq-expl] #2916 root
[new-match] 0x106867848 #1477 #1476 #2916 #1545 ; #2919
[eq-expl] #4302 lit #3939 ; #2919
[eq-expl] #2919 root
[new-match] 0x106867880 #1522 #1506 #2916 #1545 ; #4303 (#4302 #2919)
[mk-app] #4738 = #3685 #2916
[mk-app] #4745 = #4738 #4738
[mk-proof] #4736 refl #4745
[mk-app] #3779 or #1576 #4738
[mk-proof] #3780 quant-inst #3779
[instance] 0x106867848 #3780 ; 52
[attach-enode] #3685 52
[attach-enode] #4738 52
[assign] #4738 justification -1: p49
[end-of-instance]
[mk-app] #4745 * #176 #3775
[mk-app] #4736 + #3772 #4745
[mk-app] #4737 = #4736 #1503
[mk-app] #3659 = #4737 #4737
[mk-proof] #3660 refl #3659
[mk-app] #3777 or #4983 #4737
[mk-proof] #3323 quant-inst #3777
[instance] 0x106867880 #3323 ; 52
[attach-enode] #3771 52
[attach-enode] #3772 52
[attach-enode] #3775 52
[attach-enode] #4745 52
[attach-enode] #4736 52
[attach-enode] #4737 52
[mk-app] #3781 <= #4736 #1503
[mk-app] #4576 >= #4736 #1503
[assign] #4737 justification -1: p51
[end-of-instance]
[assign] #3781 clause p292 (not p291)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[assign] #4576 clause p293 (not p291)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[mk-app] #3659 = #3775 #4303
[attach-meaning] #176 arith (- 1)
[mk-app] #3660 * #176 #4303
[mk-app] #3973 + #3775 #3660
[mk-app] #3974 <= #3973 #36
[mk-app] #4718 >= #3973 #36
[assign] #3659 justification -1: p289
[attach-enode] #3659 0
[attach-enode] #3660 0
[attach-enode] #3973 0
[assign] #3974 justification -1: p294
[assign] #4718 justification -1: p294
[new-match] 0x1068682c8 #1495 #1483 #2916 #1545 ; #3771 (#2919 #2919)
[mk-app] #4756 = #3771 #3945
[mk-app] #4130 = #3771 #4561
[mk-app] #3211 = #4756 #4130
[mk-proof] #3212 monotonicity #3917 #3211
[mk-app] #3658 or #1563 #4130
[mk-app] #3661 or #1563 #4756
[mk-proof] #4599 quant-inst #3661
[mk-app] #4600 = #3661 #3658
[mk-proof] #4487 monotonicity #3212 #4600
[mk-app] #4488 = #3658 #3658
[mk-proof] #4639 rewrite #4488
[mk-proof] #4817 trans #4487 #4639 #4600
[mk-proof] #4752 mp #4599 #4817 #3658
[instance] 0x1068682c8 #4599 ; 53
[attach-enode] #3947 53
[attach-enode] #4561 53
[attach-enode] #4130 53
[assign] #4130 justification -1: p50
[end-of-instance]
[eq-expl] #3947 root
[new-match] 0x106868568 #1477 #1476 #3947 #1545 ; #4561
[eq-expl] #3771 lit #4130 ; #4561
[eq-expl] #4561 root
[new-match] 0x1068685a0 #1522 #1506 #3947 #1545 ; #3772 (#3771 #4561)
[mk-app] #4757 = #3581 #3947
[mk-app] #4713 = #4757 #4757
[mk-proof] #4751 refl #4713
[mk-app] #4758 or #1576 #4757
[mk-proof] #4794 quant-inst #4758
[instance] 0x106868568 #4794 ; 54
[attach-enode] #3581 54
[attach-enode] #4757 54
[assign] #4757 justification -1: p49
[end-of-instance]
[mk-app] #4713 * #176 #3585
[mk-app] #4751 + #4529 #4713
[mk-app] #4796 = #4751 #1503
[mk-app] #4797 + #4713 #4529
[inst-discovered] theory-solving 0x0 arith# ; #4751
[mk-app] #4830 = #4751 #4797
[mk-proof] #5029 rewrite #4830
[instance] 0x0 #4830
[end-of-instance]
[mk-app] #4946 = #4797 #1503
[mk-app] #4911 = #4796 #4946
[mk-proof] #4912 monotonicity #5029 #4911
[attach-meaning] #176 arith (- 1)
[mk-app] #4888 * #176 #4529
[mk-app] #5028 + #3585 #4888
[attach-meaning] #4108 arith (- 4)
[mk-app] #4947 = #5028 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4946
[mk-app] #4990 = #4946 #4947
[mk-proof] #4985 rewrite #4990
[instance] 0x0 #4990
[end-of-instance]
[mk-app] #4160 = #4796 #4947
[mk-proof] #4161 trans #4912 #4985 #4160
[mk-app] #4165 or #4983 #4947
[mk-app] #4924 or #4983 #4796
[mk-proof] #5157 quant-inst #4924
[mk-app] #4931 = #4924 #4165
[mk-proof] #4171 monotonicity #4161 #4931
[mk-app] #4865 = #4165 #4165
[mk-proof] #4826 rewrite #4865
[mk-proof] #5093 trans #4171 #4826 #4931
[mk-proof] #5054 mp #5157 #5093 #4165
[instance] 0x1068685a0 #5157 ; 54
[attach-enode] #3585 54
[attach-enode] #4528 54
[attach-enode] #4529 54
[attach-enode] #4888 54
[attach-enode] #5028 54
[attach-enode] #4947 54
[mk-app] #5034 <= #5028 #4108
[mk-app] #4878 >= #5028 #4108
[assign] #4947 justification -1: p51
[end-of-instance]
[assign] #5034 clause p300 (not p299)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[assign] #4878 clause p301 (not p299)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[mk-app] #4827 = #3585 #3772
[attach-meaning] #176 arith (- 1)
[mk-app] #4828 * #176 #3772
[mk-app] #3979 + #3585 #4828
[mk-app] #4980 <= #3979 #36
[mk-app] #2994 >= #3979 #36
[assign] #4827 justification -1: p297
[attach-enode] #4827 0
[attach-enode] #4828 0
[attach-enode] #3979 0
[assign] #4980 justification -1: p302
[assign] #2994 justification -1: p302
[new-match] 0x106868fe8 #1495 #1483 #3947 #1545 ; #4528 (#4561 #4561)
[mk-app] #3603 = #4528 #4387
[mk-app] #3676 = #4528 #4392
[mk-app] #3467 = #3603 #3676
[mk-proof] #3355 monotonicity #4394 #3467
[mk-app] #5050 or #1563 #3676
[mk-app] #3906 or #1563 #3603
[mk-proof] #4367 quant-inst #3906
[mk-app] #3793 = #3906 #5050
[mk-proof] #4365 monotonicity #3355 #3793
[mk-app] #4366 = #5050 #5050
[mk-proof] #3905 rewrite #4366
[mk-proof] #3857 trans #4365 #3905 #3793
[mk-proof] #4300 mp #4367 #3857 #5050
[instance] 0x106868fe8 #4367 ; 55
[attach-enode] #4389 55
[attach-enode] #4392 55
[attach-enode] #3676 55
[assign] #3676 justification -1: p50
[end-of-instance]
[eq-expl] #4389 root
[new-match] 0x106847ab8 #1477 #1476 #4389 #1545 ; #4392
[eq-expl] #4528 lit #3676 ; #4392
[eq-expl] #4392 root
[new-match] 0x106847af0 #1522 #1506 #4389 #1545 ; #4529 (#4528 #4392)
[mk-app] #4290 = #4409 #4389
[mk-app] #3134 = #4290 #4290
[mk-proof] #4572 refl #3134
[mk-app] #3799 or #1576 #4290
[mk-proof] #5049 quant-inst #3799
[instance] 0x106847ab8 #5049 ; 56
[attach-enode] #4409 56
[attach-enode] #4290 56
[assign] #4290 justification -1: p49
[end-of-instance]
[mk-app] #3134 * #176 #3791
[mk-app] #4572 + #4582 #3134
[mk-app] #3354 = #4572 #1503
[mk-app] #5051 + #3134 #4582
[inst-discovered] theory-solving 0x0 arith# ; #4572
[mk-app] #5058 = #4572 #5051
[mk-proof] #4243 rewrite #5058
[instance] 0x0 #5058
[end-of-instance]
[mk-app] #4244 = #5051 #1503
[mk-app] #5086 = #3354 #4244
[mk-proof] #3239 monotonicity #4243 #5086
[attach-meaning] #176 arith (- 1)
[mk-app] #3980 * #176 #4582
[mk-app] #3501 + #3791 #3980
[attach-meaning] #4108 arith (- 4)
[mk-app] #3390 = #3501 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4244
[mk-app] #3812 = #4244 #3390
[mk-proof] #3813 rewrite #3812
[instance] 0x0 #3812
[end-of-instance]
[mk-app] #3504 = #3354 #3390
[mk-proof] #3508 trans #3239 #3813 #3504
[mk-app] #2934 or #4983 #3390
[mk-app] #2935 or #4983 #3354
[mk-proof] #4173 quant-inst #2935
[mk-app] #3509 = #2935 #2934
[mk-proof] #3405 monotonicity #3508 #3509
[mk-app] #3410 = #2934 #2934
[mk-proof] #3244 rewrite #3410
[mk-proof] #4134 trans #3405 #3244 #3509
[mk-proof] #3260 mp #4173 #4134 #2934
[instance] 0x106847af0 #4173 ; 56
[attach-enode] #3791 56
[attach-enode] #4411 56
[attach-enode] #4582 56
[attach-enode] #3980 56
[attach-enode] #3501 56
[attach-enode] #3390 56
[mk-app] #3623 <= #3501 #4108
[mk-app] #3636 >= #3501 #4108
[assign] #3390 justification -1: p51
[end-of-instance]
[assign] #3623 clause p308 (not p307)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[assign] #3636 clause p309 (not p307)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[mk-app] #3833 = #3791 #4529
[attach-meaning] #176 arith (- 1)
[mk-app] #4439 + #3791 #4888
[mk-app] #3646 <= #4439 #36
[mk-app] #4519 >= #4439 #36
[assign] #3833 justification -1: p305
[attach-enode] #3833 0
[attach-enode] #4439 0
[assign] #3646 justification -1: p310
[assign] #4519 justification -1: p310
[new-match] 0x1068484b0 #1495 #1483 #4389 #1545 ; #4411 (#4392 #4392)
[mk-app] #3243 = #4411 #3885
[mk-app] #3736 = #4411 #3923
[mk-app] #3340 = #3243 #3736
[mk-proof] #4538 monotonicity #3925 #3340
[mk-app] #4539 or #1563 #3736
[mk-app] #3095 or #1563 #3243
[mk-proof] #3332 quant-inst #3095
[mk-app] #3342 = #3095 #4539
[mk-proof] #3702 monotonicity #4538 #3342
[mk-app] #3701 = #4539 #4539
[mk-proof] #3594 rewrite #3701
[mk-proof] #3595 trans #3702 #3594 #3342
[mk-proof] #3590 mp #3332 #3595 #4539
[instance] 0x1068484b0 #3332 ; 57
[attach-enode] #3887 57
[attach-enode] #3923 57
[attach-enode] #3736 57
[assign] #3736 justification -1: p50
[end-of-instance]
[eq-expl] #3887 root
[new-match] 0x106848750 #1477 #1476 #3887 #1545 ; #3923
[eq-expl] #4411 lit #3736 ; #3923
[eq-expl] #3923 root
[new-match] 0x106848788 #1522 #1506 #3887 #1545 ; #4582 (#4411 #3923)
[mk-app] #3591 = #3466 #3887
[mk-app] #3991 = #3591 #3591
[mk-proof] #3986 refl #3991
[mk-app] #3368 or #1576 #3591
[mk-proof] #3369 quant-inst #3368
[instance] 0x106848750 #3369 ; 58
[attach-enode] #3466 58
[attach-enode] #3591 58
[assign] #3591 justification -1: p49
[end-of-instance]
[mk-app] #3991 * #176 #3473
[mk-app] #3986 + #3469 #3991
[mk-app] #3376 = #3986 #1503
[mk-app] #3127 = #3376 #3376
[mk-proof] #3128 refl #3127
[mk-app] #3121 or #4983 #3376
[mk-proof] #3358 quant-inst #3121
[instance] 0x106848788 #3358 ; 58
[attach-enode] #3468 58
[attach-enode] #3469 58
[attach-enode] #3473 58
[attach-enode] #3991 58
[attach-enode] #3986 58
[attach-enode] #3376 58
[mk-app] #3361 <= #3986 #1503
[mk-app] #3558 >= #3986 #1503
[assign] #3376 justification -1: p51
[end-of-instance]
[assign] #3361 clause p316 (not p315)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[assign] #3558 clause p317 (not p315)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[mk-app] #3127 = #3473 #4582
[attach-meaning] #176 arith (- 1)
[mk-app] #3128 + #3473 #3980
[mk-app] #3422 <= #3128 #36
[mk-app] #3548 >= #3128 #36
[assign] #3127 justification -1: p313
[attach-enode] #3127 0
[attach-enode] #3128 0
[assign] #3422 justification -1: p318
[assign] #3548 justification -1: p318
[new-match] 0x106849148 #1495 #1483 #3887 #1545 ; #3468 (#3923 #3923)
[mk-app] #3549 = #3468 #3486
[mk-app] #3546 = #3468 #3870
[mk-app] #3547 = #3549 #3546
[mk-proof] #3540 monotonicity #3872 #3547
[mk-app] #3541 or #1563 #3546
[mk-app] #4015 or #1563 #3549
[mk-proof] #2925 quant-inst #4015
[mk-app] #2926 = #4015 #3541
[mk-proof] #3635 monotonicity #3540 #2926
[mk-app] #3626 = #3541 #3541
[mk-proof] #3374 rewrite #3626
[mk-proof] #4403 trans #3635 #3374 #2926
[mk-proof] #4395 mp #2925 #4403 #3541
[instance] 0x106849148 #2925 ; 59
[attach-enode] #3867 59
[attach-enode] #3870 59
[attach-enode] #3546 59
[assign] #3546 justification -1: p50
[end-of-instance]
[eq-expl] #3867 root
[new-match] 0x1068493e8 #1477 #1476 #3867 #1545 ; #3870
[eq-expl] #3468 lit #3546 ; #3870
[eq-expl] #3870 root
[new-match] 0x106849420 #1522 #1506 #3867 #1545 ; #3469 (#3468 #3870)
[mk-app] #3531 = #4433 #3867
[mk-app] #4425 = #3531 #3531
[mk-proof] #4530 refl #4425
[mk-app] #4531 or #1576 #3531
[mk-proof] #4402 quant-inst #4531
[instance] 0x1068493e8 #4402 ; 60
[attach-enode] #4433 60
[attach-enode] #3531 60
[assign] #3531 justification -1: p49
[end-of-instance]
[mk-app] #4425 * #176 #3606
[mk-app] #4530 + #4575 #4425
[mk-app] #4396 = #4530 #1503
[mk-app] #4404 + #4425 #4575
[inst-discovered] theory-solving 0x0 arith# ; #4530
[mk-app] #4405 = #4530 #4404
[mk-proof] #4407 rewrite #4405
[instance] 0x0 #4405
[end-of-instance]
[mk-app] #4419 = #4404 #1503
[mk-app] #4424 = #4396 #4419
[mk-proof] #4090 monotonicity #4407 #4424
[attach-meaning] #176 arith (- 1)
[mk-app] #4415 * #176 #4575
[mk-app] #4418 + #3606 #4415
[attach-meaning] #4108 arith (- 4)
[mk-app] #4091 = #4418 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4419
[mk-app] #3534 = #4419 #4091
[mk-proof] #4039 rewrite #3534
[instance] 0x0 #3534
[end-of-instance]
[mk-app] #3428 = #4396 #4091
[mk-proof] #4203 trans #4090 #4039 #3428
[mk-app] #4209 or #4983 #4091
[mk-app] #3302 or #4983 #4396
[mk-proof] #4207 quant-inst #3302
[mk-app] #4555 = #3302 #4209
[mk-proof] #2911 monotonicity #4203 #4555
[mk-app] #4482 = #4209 #4209
[mk-proof] #4505 rewrite #4482
[mk-proof] #4113 trans #2911 #4505 #4555
[mk-proof] #4554 mp #4207 #4113 #4209
[instance] 0x106849420 #4207 ; 60
[attach-enode] #3606 60
[attach-enode] #4574 60
[attach-enode] #4575 60
[attach-enode] #4415 60
[attach-enode] #4418 60
[attach-enode] #4091 60
[mk-app] #4122 <= #4418 #4108
[mk-app] #3665 >= #4418 #4108
[assign] #4091 justification -1: p51
[end-of-instance]
[assign] #4122 clause p324 (not p323)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[assign] #3665 clause p325 (not p323)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[mk-app] #3457 = #3469 #3606
[attach-meaning] #176 arith (- 1)
[mk-app] #4696 + #3469 #4425
[mk-app] #4697 <= #4696 #36
[mk-app] #4619 >= #4696 #36
[assign] #3457 justification -1: p321
[attach-enode] #3457 0
[attach-enode] #4425 0
[attach-enode] #4696 0
[assign] #4697 justification -1: p326
[assign] #4619 justification -1: p326
[new-match] 0x106887e98 #1495 #1483 #3867 #1545 ; #4574 (#3870 #3870)
[mk-app] #4690 = #4574 #3728
[mk-app] #4691 = #4574 #3733
[mk-app] #4809 = #4690 #4691
[mk-proof] #3481 monotonicity #4017 #4809
[mk-app] #4948 or #1563 #4691
[mk-app] #4887 or #1563 #4690
[mk-proof] #4816 quant-inst #4887
[mk-app] #4890 = #4887 #4948
[mk-proof] #4046 monotonicity #3481 #4890
[mk-app] #4933 = #4948 #4948
[mk-proof] #4940 rewrite #4933
[mk-proof] #4941 trans #4046 #4940 #4890
[mk-proof] #4932 mp #4816 #4941 #4948
[instance] 0x106887e98 #4816 ; 61
[attach-enode] #3730 61
[attach-enode] #3733 61
[attach-enode] #4691 61
[assign] #4691 justification -1: p50
[end-of-instance]
[eq-expl] #3730 root
[new-match] 0x106888138 #1477 #1476 #3730 #1545 ; #3733
[eq-expl] #4574 lit #4691 ; #3733
[eq-expl] #3733 root
[new-match] 0x106888170 #1522 #1506 #3730 #1545 ; #4575 (#4574 #3733)
[mk-app] #4949 = #4034 #3730
[mk-app] #5009 = #4949 #4949
[mk-proof] #5010 refl #5009
[mk-app] #3877 or #1576 #4949
[mk-proof] #5081 quant-inst #3877
[instance] 0x106888138 #5081 ; 62
[attach-enode] #4034 62
[attach-enode] #4949 62
[assign] #4949 justification -1: p49
[end-of-instance]
[mk-app] #5009 * #176 #4041
[mk-app] #5010 + #4038 #5009
[mk-app] #3970 = #5010 #1503
[mk-app] #5066 = #3970 #3970
[mk-proof] #4357 refl #5066
[mk-app] #4358 or #4983 #3970
[mk-proof] #4099 quant-inst #4358
[instance] 0x106888170 #4099 ; 62
[attach-enode] #4036 62
[attach-enode] #4038 62
[attach-enode] #4041 62
[attach-enode] #5009 62
[attach-enode] #5010 62
[attach-enode] #3970 62
[mk-app] #3100 <= #5010 #1503
[mk-app] #3852 >= #5010 #1503
[assign] #3970 justification -1: p51
[end-of-instance]
[assign] #3100 clause p332 (not p331)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[assign] #3852 clause p333 (not p331)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[mk-app] #5066 = #4041 #4575
[attach-meaning] #176 arith (- 1)
[mk-app] #4357 + #4041 #4415
[mk-app] #3649 <= #4357 #36
[mk-app] #2943 >= #4357 #36
[assign] #5066 justification -1: p329
[attach-enode] #5066 0
[attach-enode] #4357 0
[assign] #3649 justification -1: p334
[assign] #2943 justification -1: p334
[new-match] 0x106888b30 #1495 #1483 #3730 #1545 ; #4036 (#3733 #3733)
[mk-app] #2944 = #4036 #3289
[mk-app] #3763 = #4036 #3294
[mk-app] #4601 = #2944 #3763
[mk-proof] #3097 monotonicity #3296 #4601
[mk-app] #2950 or #1563 #3763
[mk-app] #3564 or #1563 #2944
[mk-proof] #2948 quant-inst #3564
[mk-app] #3827 = #3564 #2950
[mk-proof] #3375 monotonicity #3097 #3827
[mk-app] #3937 = #2950 #2950
[mk-proof] #3941 rewrite #3937
[mk-proof] #3420 trans #3375 #3941 #3827
[mk-proof] #3425 mp #2948 #3420 #2950
[instance] 0x106888b30 #2948 ; 63
[attach-enode] #3291 63
[attach-enode] #3294 63
[attach-enode] #3763 63
[assign] #3763 justification -1: p50
[end-of-instance]
[eq-expl] #3291 root
[new-match] 0x106888dd0 #1477 #1476 #3291 #1545 ; #3294
[eq-expl] #4036 lit #3763 ; #3294
[eq-expl] #3294 root
[new-match] 0x106888e08 #1522 #1506 #3291 #1545 ; #4038 (#4036 #3294)
[mk-app] #3934 = #3312 #3291
[mk-app] #4795 = #3934 #3934
[mk-proof] #4790 refl #4795
[mk-app] #4791 or #1576 #3934
[mk-proof] #4833 quant-inst #4791
[instance] 0x106888dd0 #4833 ; 64
[attach-enode] #3312 64
[attach-enode] #3934 64
[assign] #3934 justification -1: p49
[end-of-instance]
[mk-app] #4795 * #176 #3318
[mk-app] #4790 + #3315 #4795
[mk-app] #3942 = #4790 #1503
[mk-app] #3078 = #3942 #3942
[mk-proof] #4869 refl #3078
[mk-app] #3976 or #4983 #3942
[mk-proof] #3209 quant-inst #3976
[instance] 0x106888e08 #3209 ; 64
[attach-enode] #3314 64
[attach-enode] #3315 64
[attach-enode] #3318 64
[attach-enode] #4795 64
[attach-enode] #4790 64
[attach-enode] #3942 64
[mk-app] #4674 <= #4790 #1503
[mk-app] #4640 >= #4790 #1503
[assign] #3942 justification -1: p51
[end-of-instance]
[assign] #4674 clause p340 (not p339)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[assign] #4640 clause p341 (not p339)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[mk-app] #3078 = #3318 #4038
[attach-meaning] #176 arith (- 1)
[mk-app] #4869 * #176 #4038
[mk-app] #4873 + #3318 #4869
[mk-app] #4159 <= #4873 #36
[mk-app] #4953 >= #4873 #36
[assign] #3078 justification -1: p337
[attach-enode] #3078 0
[attach-enode] #4869 0
[attach-enode] #4873 0
[assign] #4159 justification -1: p342
[assign] #4953 justification -1: p342
[new-match] 0x106889850 #1495 #1483 #3291 #1545 ; #3314 (#3294 #3294)
[mk-app] #4989 = #3314 #4185
[mk-app] #4986 = #3314 #4190
[mk-app] #4829 = #4989 #4986
[mk-proof] #4063 monotonicity #4192 #4829
[mk-app] #3021 or #1563 #4986
[mk-app] #4750 or #1563 #4989
[mk-proof] #4742 quant-inst #4750
[mk-app] #4722 = #4750 #3021
[mk-proof] #4709 monotonicity #4063 #4722
[mk-app] #3101 = #3021 #3021
[mk-proof] #5023 rewrite #3101
[mk-proof] #4944 trans #4709 #5023 #4722
[mk-proof] #4984 mp #4742 #4944 #3021
[instance] 0x106889850 #4742 ; 65
[attach-enode] #4187 65
[attach-enode] #4190 65
[attach-enode] #4986 65
[assign] #4986 justification -1: p50
[end-of-instance]
[eq-expl] #4187 root
[new-match] 0x106890760 #1477 #1476 #4187 #1545 ; #4190
[eq-expl] #3314 lit #4986 ; #4190
[eq-expl] #4190 root
[new-match] 0x106890798 #1522 #1506 #4187 #1545 ; #3315 (#3314 #4190)
[mk-app] #4605 = #4211 #4187
[mk-app] #3931 = #4605 #4605
[mk-proof] #4670 refl #3931
[mk-app] #4127 or #1576 #4605
[mk-proof] #4633 quant-inst #4127
[instance] 0x106890760 #4633 ; 66
[attach-enode] #4211 66
[attach-enode] #4605 66
[assign] #4605 justification -1: p49
[end-of-instance]
[mk-app] #3931 * #176 #4591
[mk-app] #4670 + #4214 #3931
[mk-app] #4625 = #4670 #1503
[mk-app] #3932 = #4625 #4625
[mk-proof] #3770 refl #3932
[mk-app] #2915 or #4983 #4625
[mk-proof] #4257 quant-inst #2915
[instance] 0x106890798 #4257 ; 66
[attach-enode] #4213 66
[attach-enode] #4214 66
[attach-enode] #4591 66
[attach-enode] #3931 66
[attach-enode] #4670 66
[attach-enode] #4625 66
[mk-app] #4485 <= #4670 #1503
[mk-app] #4013 >= #4670 #1503
[assign] #4625 justification -1: p51
[end-of-instance]
[assign] #4485 clause p348 (not p347)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[assign] #4013 clause p349 (not p347)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[mk-app] #3932 = #3315 #4591
[attach-meaning] #176 arith (- 1)
[mk-app] #3770 + #3315 #3931
[mk-app] #4532 <= #3770 #36
[mk-app] #3625 >= #3770 #36
[assign] #3932 justification -1: p345
[attach-enode] #3932 0
[attach-enode] #3770 0
[assign] #4532 justification -1: p350
[assign] #3625 justification -1: p350
[new-match] 0x106891158 #1495 #1483 #4187 #1545 ; #4213 (#4190 #4190)
[mk-app] #3090 = #4213 #3675
[mk-app] #3084 = #4213 #4495
[mk-app] #4331 = #3090 #3084
[mk-proof] #3018 monotonicity #3819 #4331
[mk-app] #3019 or #1563 #3084
[mk-app] #3020 or #1563 #3090
[mk-proof] #3392 quant-inst #3020
[mk-app] #3030 = #3020 #3019
[mk-proof] #4107 monotonicity #3018 #3030
[mk-app] #4341 = #3019 #3019
[mk-proof] #4333 rewrite #4341
[mk-proof] #2966 trans #4107 #4333 #3030
[mk-proof] #2963 mp #3392 #2966 #3019
[instance] 0x106891158 #3392 ; 67
[attach-enode] #3677 67
[attach-enode] #4495 67
[attach-enode] #3084 67
[assign] #3084 justification -1: p50
[end-of-instance]
[eq-expl] #3677 root
[new-match] 0x1068913f8 #1477 #1476 #3677 #1545 ; #4495
[eq-expl] #4213 lit #3084 ; #4495
[eq-expl] #4495 root
[new-match] 0x106891430 #1522 #1506 #3677 #1545 ; #4214 (#4213 #4495)
[mk-app] #3503 = #3602 #3677
[mk-app] #2968 = #3503 #3503
[mk-proof] #3258 refl #2968
[mk-app] #3280 or #1576 #3503
[mk-proof] #4168 quant-inst #3280
[instance] 0x1068913f8 #4168 ; 68
[attach-enode] #3602 68
[attach-enode] #3503 68
[assign] #3503 justification -1: p49
[end-of-instance]
[mk-app] #2968 * #176 #2991
[mk-app] #3258 + #4535 #2968
[mk-app] #3741 = #3258 #1503
[mk-app] #3338 + #2968 #4535
[inst-discovered] theory-solving 0x0 arith# ; #3258
[mk-app] #2938 = #3258 #3338
[mk-proof] #3334 rewrite #2938
[instance] 0x0 #2938
[end-of-instance]
[mk-app] #3329 = #3338 #1503
[mk-app] #3740 = #3741 #3329
[mk-proof] #3339 monotonicity #3334 #3740
[attach-meaning] #176 arith (- 1)
[mk-app] #4566 * #176 #4535
[mk-app] #4567 + #2991 #4566
[attach-meaning] #4108 arith (- 4)
[mk-app] #4238 = #4567 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3329
[mk-app] #4239 = #3329 #4238
[mk-proof] #3637 rewrite #4239
[instance] 0x0 #4239
[end-of-instance]
[mk-app] #4016 = #3741 #4238
[mk-proof] #3989 trans #3339 #3637 #4016
[mk-app] #3124 or #4983 #4238
[mk-app] #3148 or #4983 #3741
[mk-proof] #3533 quant-inst #3148
[mk-app] #4453 = #3148 #3124
[mk-proof] #3525 monotonicity #3989 #4453
[mk-app] #3512 = #3124 #3124
[mk-proof] #3519 rewrite #3512
[mk-proof] #3532 trans #3525 #3519 #4453
[mk-proof] #3543 mp #3533 #3532 #3124
[instance] 0x106891430 #3533 ; 68
[attach-enode] #2991 68
[attach-enode] #4534 68
[attach-enode] #4535 68
[attach-enode] #4566 68
[attach-enode] #4567 68
[attach-enode] #4238 68
[mk-app] #4581 <= #4567 #4108
[mk-app] #3446 >= #4567 #4108
[assign] #4238 justification -1: p51
[end-of-instance]
[assign] #4581 clause p356 (not p355)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[assign] #3446 clause p357 (not p355)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[mk-app] #3853 = #2991 #4214
[attach-meaning] #176 arith (- 1)
[mk-app] #3544 * #176 #4214
[mk-app] #3545 + #2991 #3544
[mk-app] #4314 <= #3545 #36
[mk-app] #3684 >= #3545 #36
[assign] #3853 justification -1: p353
[attach-enode] #3853 0
[attach-enode] #3544 0
[attach-enode] #3545 0
[assign] #4314 justification -1: p358
[assign] #3684 justification -1: p358
[new-match] 0x106891e78 #1495 #1483 #3677 #1545 ; #4534 (#4495 #4495)
[mk-app] #3451 = #4534 #3978
[mk-app] #3045 = #4534 #3984
[mk-app] #3842 = #3451 #3045
[mk-proof] #4428 monotonicity #4520 #3842
[mk-app] #4262 or #1563 #3045
[mk-app] #4263 or #1563 #3451
[mk-proof] #3840 quant-inst #4263
[mk-app] #3841 = #4263 #4262
[mk-proof] #4430 monotonicity #4428 #3841
[mk-app] #3471 = #4262 #4262
[mk-proof] #3472 rewrite #3471
[mk-proof] #4431 trans #4430 #3472 #3841
[mk-proof] #4432 mp #3840 #4431 #4262
[instance] 0x106891e78 #3840 ; 69
[attach-enode] #3981 69
[attach-enode] #3984 69
[attach-enode] #3045 69
[assign] #3045 justification -1: p50
[end-of-instance]
[eq-expl] #3981 root
[new-match] 0x106892118 #1477 #1476 #3981 #1545 ; #3984
[eq-expl] #4534 lit #3045 ; #3984
[eq-expl] #3984 root
[new-match] 0x106892150 #1522 #1506 #3981 #1545 ; #4535 (#4534 #3984)
[mk-app] #3072 = #3192 #3981
[mk-app] #4022 = #3072 #3072
[mk-proof] #4023 refl #4022
[mk-app] #3303 or #1576 #3072
[mk-proof] #3309 quant-inst #3303
[instance] 0x106892118 #3309 ; 70
[attach-enode] #3192 70
[attach-enode] #3072 70
[assign] #3072 justification -1: p49
[end-of-instance]
[mk-app] #4022 * #176 #3198
[mk-app] #4023 + #3195 #4022
[mk-app] #3191 = #4023 #1503
[mk-app] #3196 = #3191 #3191
[mk-proof] #2990 refl #3196
[mk-app] #2996 or #4983 #3191
[mk-proof] #2999 quant-inst #2996
[instance] 0x106892150 #2999 ; 70
[attach-enode] #3194 70
[attach-enode] #3195 70
[attach-enode] #3198 70
[attach-enode] #4022 70
[attach-enode] #4023 70
[attach-enode] #3191 70
[mk-app] #3000 <= #4023 #1503
[mk-app] #3180 >= #4023 #1503
[assign] #3191 justification -1: p51
[end-of-instance]
[assign] #3000 clause p364 (not p363)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[assign] #3180 clause p365 (not p363)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[mk-app] #3196 = #3198 #4535
[attach-meaning] #176 arith (- 1)
[mk-app] #2990 + #3198 #4566
[mk-app] #3181 <= #2990 #36
[mk-app] #3208 >= #2990 #36
[assign] #3196 justification -1: p361
[attach-enode] #3196 0
[attach-enode] #2990 0
[assign] #3181 justification -1: p366
[assign] #3208 justification -1: p366
[new-match] 0x10689a958 #1495 #1483 #3981 #1545 ; #3194 (#3984 #3984)
[mk-app] #3752 = #3194 #3214
[mk-app] #4489 = #3194 #3217
[mk-app] #4598 = #3752 #4489
[mk-proof] #4614 monotonicity #3221 #4598
[mk-app] #4715 or #1563 #4489
[mk-app] #4701 or #1563 #3752
[mk-proof] #4706 quant-inst #4701
[mk-app] #5046 = #4701 #4715
[mk-proof] #5018 monotonicity #4614 #5046
[mk-app] #4848 = #4715 #4715
[mk-proof] #4849 rewrite #4848
[mk-proof] #4852 trans #5018 #4849 #5046
[mk-proof] #5045 mp #4706 #4852 #4715
[instance] 0x10689a958 #4706 ; 71
[attach-enode] #3216 71
[attach-enode] #3217 71
[attach-enode] #4489 71
[assign] #4489 justification -1: p50
[end-of-instance]
[eq-expl] #3216 root
[new-match] 0x10689abf8 #1477 #1476 #3216 #1545 ; #3217
[eq-expl] #3194 lit #4489 ; #3217
[eq-expl] #3217 root
[new-match] 0x10689ac30 #1522 #1506 #3216 #1545 ; #3195 (#3194 #3217)
[mk-app] #5019 = #4114 #3216
[mk-app] #5026 = #5019 #5019
[mk-proof] #5027 refl #5026
[mk-app] #5105 or #1576 #5019
[mk-proof] #3265 quant-inst #5105
[instance] 0x10689abf8 #3265 ; 72
[attach-enode] #4114 72
[attach-enode] #5019 72
[assign] #5019 justification -1: p49
[end-of-instance]
[mk-app] #5026 * #176 #4124
[mk-app] #5027 + #4121 #5026
[mk-app] #5087 = #5027 #1503
[mk-app] #4066 = #5087 #5087
[mk-proof] #4067 refl #4066
[mk-app] #3103 or #4983 #5087
[mk-proof] #3040 quant-inst #3103
[instance] 0x10689ac30 #3040 ; 72
[attach-enode] #4116 72
[attach-enode] #4121 72
[attach-enode] #4124 72
[attach-enode] #5026 72
[attach-enode] #5027 72
[attach-enode] #5087 72
[mk-app] #4374 <= #5027 #1503
[mk-app] #4375 >= #5027 #1503
[assign] #5087 justification -1: p51
[end-of-instance]
[assign] #4374 clause p372 (not p371)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[assign] #4375 clause p373 (not p371)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[mk-app] #4066 = #3195 #4124
[attach-meaning] #176 arith (- 1)
[mk-app] #4067 + #3195 #5026
[mk-app] #3538 <= #4067 #36
[mk-app] #3423 >= #4067 #36
[assign] #4066 justification -1: p369
[attach-enode] #4066 0
[attach-enode] #4067 0
[assign] #3538 justification -1: p374
[assign] #3423 justification -1: p374
[new-match] 0x10689b5f0 #1495 #1483 #3216 #1545 ; #4116 (#3217 #3217)
[mk-app] #4084 = #4116 #3663
[mk-app] #4089 = #4116 #3652
[mk-app] #4372 = #4084 #4089
[mk-proof] #3863 monotonicity #3654 #4372
[mk-app] #3845 or #1563 #4089
[mk-app] #3933 or #1563 #4084
[mk-proof] #3864 quant-inst #3933
[mk-app] #4568 = #3933 #3845
[mk-proof] #4678 monotonicity #3863 #4568
[mk-app] #4719 = #3845 #3845
[mk-proof] #4913 rewrite #4719
[mk-proof] #4914 trans #4678 #4913 #4568
[mk-proof] #5062 mp #3864 #4914 #3845
[instance] 0x10689b5f0 #3864 ; 73
[attach-enode] #4506 73
[attach-enode] #3652 73
[attach-enode] #4089 73
[assign] #4089 justification -1: p50
[end-of-instance]
[eq-expl] #4506 root
[new-match] 0x10689b890 #1477 #1476 #4506 #1545 ; #3652
[eq-expl] #4116 lit #4089 ; #3652
[eq-expl] #3652 root
[new-match] 0x10689b8c8 #1522 #1506 #4506 #1545 ; #4121 (#4116 #3652)
[mk-app] #3886 = #4492 #4506
[mk-app] #5112 = #3886 #3886
[mk-proof] #4339 refl #5112
[mk-app] #5190 or #1576 #3886
[mk-proof] #5061 quant-inst #5190
[instance] 0x10689b890 #5061 ; 74
[attach-enode] #4492 74
[attach-enode] #3886 74
[assign] #3886 justification -1: p49
[end-of-instance]
[mk-app] #5112 * #176 #4597
[mk-app] #4339 + #4596 #5112
[mk-app] #3487 = #4339 #1503
[mk-app] #2992 = #3487 #3487
[mk-proof] #2993 refl #2992
[mk-app] #3474 or #4983 #3487
[mk-proof] #3792 quant-inst #3474
[instance] 0x10689b8c8 #3792 ; 74
[attach-enode] #4491 74
[attach-enode] #4596 74
[attach-enode] #4597 74
[attach-enode] #5112 74
[attach-enode] #4339 74
[attach-enode] #3487 74
[mk-app] #3356 <= #4339 #1503
[mk-app] #4517 >= #4339 #1503
[assign] #3487 justification -1: p51
[end-of-instance]
[assign] #3356 clause p380 (not p379)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[assign] #4517 clause p381 (not p379)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[mk-app] #2992 = #4121 #4597
[attach-meaning] #176 arith (- 1)
[mk-app] #2993 + #4121 #5112
[mk-app] #4148 <= #2993 #36
[mk-app] #3500 >= #2993 #36
[assign] #2992 justification -1: p377
[attach-enode] #2992 0
[attach-enode] #2993 0
[assign] #4148 justification -1: p382
[assign] #3500 justification -1: p382
[new-match] 0x10689c288 #1495 #1483 #4506 #1545 ; #4491 (#3652 #3652)
[mk-app] #3408 = #4491 #4604
[mk-app] #3700 = #4491 #4609
[mk-app] #4593 = #3408 #3700
[mk-proof] #3087 monotonicity #4611 #4593
[mk-app] #3088 or #1563 #3700
[mk-app] #3035 or #1563 #3408
[mk-proof] #3990 quant-inst #3035
[mk-app] #3008 = #3035 #3088
[mk-proof] #3013 monotonicity #3087 #3008
[mk-app] #4082 = #3088 #3088
[mk-proof] #4104 rewrite #4082
[mk-proof] #3122 trans #3013 #4104 #3008
[mk-proof] #3129 mp #3990 #3122 #3088
[instance] 0x10689c288 #3990 ; 75
[attach-enode] #4606 75
[attach-enode] #4609 75
[attach-enode] #3700 75
[assign] #3700 justification -1: p50
[end-of-instance]
[eq-expl] #4606 root
[new-match] 0x10684f560 #1477 #1476 #4606 #1545 ; #4609
[eq-expl] #4491 lit #3700 ; #4609
[eq-expl] #4609 root
[new-match] 0x10684f598 #1522 #1506 #4606 #1545 ; #4596 (#4491 #4609)
[mk-app] #3450 = #4624 #4606
[mk-app] #3554 = #3450 #3450
[mk-proof] #4040 refl #3554
[mk-app] #4498 or #1576 #3450
[mk-proof] #4618 quant-inst #4498
[instance] 0x10684f560 #4618 ; 76
[attach-enode] #4624 76
[attach-enode] #3450 76
[assign] #3450 justification -1: p49
[end-of-instance]
[mk-app] #3554 * #176 #4630
[mk-app] #4040 + #4627 #3554
[mk-app] #4885 = #4040 #1503
[mk-app] #4622 = #4885 #4885
[mk-proof] #3186 refl #4622
[mk-app] #4515 or #4983 #4885
[mk-proof] #4623 quant-inst #4515
[instance] 0x10684f598 #4623 ; 76
[attach-enode] #4626 76
[attach-enode] #4627 76
[attach-enode] #4630 76
[attach-enode] #3554 76
[attach-enode] #4040 76
[attach-enode] #4885 76
[mk-app] #4863 <= #4040 #1503
[mk-app] #4810 >= #4040 #1503
[assign] #4885 justification -1: p51
[end-of-instance]
[assign] #4863 clause p388 (not p387)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[assign] #4810 clause p389 (not p387)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[mk-app] #4622 = #4596 #4630
[attach-meaning] #176 arith (- 1)
[mk-app] #3186 + #4596 #3554
[mk-app] #4813 <= #3186 #36
[mk-app] #4870 >= #3186 #36
[assign] #4622 justification -1: p385
[attach-enode] #4622 0
[attach-enode] #3186 0
[assign] #4813 justification -1: p390
[assign] #4870 justification -1: p390
[new-match] 0x10684ff58 #1495 #1483 #4606 #1545 ; #4626 (#4609 #4609)
[mk-app] #4886 = #4626 #4643
[mk-app] #5083 = #4626 #4648
[mk-app] #3062 = #4886 #5083
[mk-proof] #3975 monotonicity #4650 #3062
[mk-app] #2945 or #1563 #5083
[mk-app] #3557 or #1563 #4886
[mk-proof] #4158 quant-inst #3557
[mk-app] #5060 = #3557 #2945
[mk-proof] #5256 monotonicity #3975 #5060
[mk-app] #4644 = #2945 #2945
[mk-proof] #4820 rewrite #4644
[mk-proof] #3664 trans #5256 #4820 #5060
[mk-proof] #4126 mp #4158 #3664 #2945
[instance] 0x10684ff58 #4158 ; 77
[attach-enode] #4645 77
[attach-enode] #4648 77
[attach-enode] #5083 77
[assign] #5083 justification -1: p50
[end-of-instance]
[eq-expl] #4645 root
[new-match] 0x1068501f8 #1477 #1476 #4645 #1545 ; #4648
[eq-expl] #4626 lit #5083 ; #4648
[eq-expl] #4648 root
[new-match] 0x106850230 #1522 #1506 #4645 #1545 ; #4627 (#4626 #4648)
[mk-app] #5476 = #4663 #4645
[mk-app] #5173 = #5476 #5476
[mk-proof] #4664 refl #5173
[mk-app] #5260 or #1576 #5476
[mk-proof] #5221 quant-inst #5260
[instance] 0x1068501f8 #5221 ; 78
[attach-enode] #4663 78
[attach-enode] #5476 78
[assign] #5476 justification -1: p49
[end-of-instance]
[mk-app] #5173 * #176 #4669
[mk-app] #4664 + #4666 #5173
[mk-app] #5270 = #4664 #1503
[mk-app] #5207 = #5270 #5270
[mk-proof] #4906 refl #5207
[mk-app] #5073 or #4983 #5270
[mk-proof] #5021 quant-inst #5073
[instance] 0x106850230 #5021 ; 78
[attach-enode] #4665 78
[attach-enode] #4666 78
[attach-enode] #4669 78
[attach-enode] #5173 78
[attach-enode] #4664 78
[attach-enode] #5270 78
[mk-app] #4781 <= #4664 #1503
[mk-app] #4866 >= #4664 #1503
[assign] #5270 justification -1: p51
[end-of-instance]
[assign] #4781 clause p396 (not p395)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[assign] #4866 clause p397 (not p395)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[mk-app] #5207 = #4627 #4669
[attach-meaning] #176 arith (- 1)
[mk-app] #4906 + #4627 #5173
[mk-app] #4867 <= #4906 #36
[mk-app] #4710 >= #4906 #36
[assign] #5207 justification -1: p393
[attach-enode] #5207 0
[attach-enode] #4906 0
[assign] #4867 justification -1: p398
[assign] #4710 justification -1: p398
[new-match] 0x106850bf0 #1495 #1483 #4645 #1545 ; #4665 (#4648 #4648)
[mk-app] #3875 = #4665 #4682
[mk-app] #3201 = #4665 #4687
[mk-app] #3202 = #3875 #3201
[mk-proof] #3876 monotonicity #4689 #3202
[mk-app] #4711 or #1563 #3201
[mk-app] #4703 or #1563 #3875
[mk-proof] #4434 quant-inst #4703
[mk-app] #4298 = #4703 #4711
[mk-proof] #4299 monotonicity #3876 #4298
[mk-app] #3794 = #4711 #4711
[mk-proof] #3017 rewrite #3794
[mk-proof] #3031 trans #4299 #3017 #4298
[mk-proof] #3273 mp #4434 #3031 #4711
[instance] 0x106850bf0 #4434 ; 79
[attach-enode] #4684 79
[attach-enode] #4687 79
[attach-enode] #3201 79
[assign] #3201 justification -1: p50
[end-of-instance]
[eq-expl] #4684 root
[new-match] 0x106850e90 #1477 #1476 #4684 #1545 ; #4687
[eq-expl] #4665 lit #3201 ; #4687
[eq-expl] #4687 root
[new-match] 0x106850ec8 #1522 #1506 #4684 #1545 ; #4666 (#4665 #4687)
[mk-app] #3274 = #4702 #4684
[mk-app] #4155 = #3274 #3274
[mk-proof] #4516 refl #4155
[mk-app] #3851 or #1576 #3274
[mk-proof] #3417 quant-inst #3851
[instance] 0x106850e90 #3417 ; 80
[attach-enode] #4702 80
[attach-enode] #3274 80
[assign] #3274 justification -1: p49
[end-of-instance]
[mk-app] #4155 * #176 #4708
[mk-app] #4516 + #4705 #4155
[mk-app] #3234 = #4516 #1503
[mk-app] #4490 = #3234 #3234
[mk-proof] #3199 refl #4490
[mk-app] #4172 or #4983 #3234
[mk-proof] #4501 quant-inst #4172
[instance] 0x106850ec8 #4501 ; 80
[attach-enode] #4704 80
[attach-enode] #4705 80
[attach-enode] #4708 80
[attach-enode] #4155 80
[attach-enode] #4516 80
[attach-enode] #3234 80
[mk-app] #3023 <= #4516 #1503
[mk-app] #3766 >= #4516 #1503
[assign] #3234 justification -1: p51
[end-of-instance]
[assign] #3023 clause p404 (not p403)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[assign] #3766 clause p405 (not p403)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[mk-app] #4490 = #4666 #4708
[attach-meaning] #176 arith (- 1)
[mk-app] #3199 + #4666 #4155
[mk-app] #3275 <= #3199 #36
[mk-app] #3621 >= #3199 #36
[assign] #4490 justification -1: p401
[attach-enode] #4490 0
[attach-enode] #3199 0
[assign] #3275 justification -1: p406
[assign] #3621 justification -1: p406
[new-match] 0x10686e6a8 #1495 #1483 #4684 #1545 ; #4704 (#4687 #4687)
[mk-app] #2962 = #4704 #4721
[mk-app] #3888 = #4704 #4726
[mk-app] #3889 = #2962 #3888
[mk-proof] #3240 monotonicity #4728 #3889
[mk-app] #2983 or #1563 #3888
[mk-app] #3223 or #1563 #2962
[mk-proof] #4146 quant-inst #3223
[mk-app] #4351 = #3223 #2983
[mk-proof] #3224 monotonicity #3240 #4351
[mk-app] #3232 = #2983 #2983
[mk-proof] #2929 rewrite #3232
[mk-proof] #4540 trans #3224 #2929 #4351
[mk-proof] #4170 mp #4146 #4540 #2983
[instance] 0x10686e6a8 #4146 ; 81
[attach-enode] #4723 81
[attach-enode] #4726 81
[attach-enode] #3888 81
[assign] #3888 justification -1: p50
[end-of-instance]
[eq-expl] #4723 root
[new-match] 0x10686e948 #1477 #1476 #4723 #1545 ; #4726
[eq-expl] #4704 lit #3888 ; #4726
[eq-expl] #4726 root
[new-match] 0x10686e980 #1522 #1506 #4723 #1545 ; #4705 (#4704 #4726)
[mk-app] #4177 = #4741 #4723
[mk-app] #4541 = #4177 #4177
[mk-proof] #3494 refl #4541
[mk-app] #3837 or #1576 #4177
[mk-proof] #3703 quant-inst #3837
[instance] 0x10686e948 #3703 ; 82
[attach-enode] #4741 82
[attach-enode] #4177 82
[assign] #4177 justification -1: p49
[end-of-instance]
[mk-app] #4541 * #176 #4747
[mk-app] #3494 + #4744 #4541
[mk-app] #2960 = #3494 #1503
[mk-app] #2985 = #2960 #2960
[mk-proof] #2988 refl #2985
[mk-app] #3225 or #4983 #2960
[mk-proof] #3643 quant-inst #3225
[instance] 0x10686e980 #3643 ; 82
[attach-enode] #4743 82
[attach-enode] #4744 82
[attach-enode] #4747 82
[attach-enode] #4541 82
[attach-enode] #3494 82
[attach-enode] #2960 82
[mk-app] #4277 <= #3494 #1503
[mk-app] #4278 >= #3494 #1503
[assign] #2960 justification -1: p51
[end-of-instance]
[assign] #4277 clause p412 (not p411)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[assign] #4278 clause p413 (not p411)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[mk-app] #2985 = #4705 #4747
[attach-meaning] #176 arith (- 1)
[mk-app] #2988 + #4705 #4541
[mk-app] #3253 <= #2988 #36
[mk-app] #4001 >= #2988 #36
[assign] #2985 justification -1: p409
[attach-enode] #2985 0
[attach-enode] #2988 0
[assign] #3253 justification -1: p414
[assign] #4001 justification -1: p414
[new-match] 0x10686f340 #1495 #1483 #4723 #1545 ; #4743 (#4726 #4726)
[mk-app] #3574 = #4743 #4760
[mk-app] #3592 = #4743 #4765
[mk-app] #3170 = #3574 #3592
[mk-proof] #3172 monotonicity #4767 #3170
[mk-app] #3137 or #1563 #3592
[mk-app] #3139 or #1563 #3574
[mk-proof] #3174 quant-inst #3139
[mk-app] #3743 = #3139 #3137
[mk-proof] #4064 monotonicity #3172 #3743
[mk-app] #3854 = #3137 #3137
[mk-proof] #3438 rewrite #3854
[mk-proof] #3439 trans #4064 #3438 #3743
[mk-proof] #3855 mp #3174 #3439 #3137
[instance] 0x10686f340 #3174 ; 83
[attach-enode] #4762 83
[attach-enode] #4765 83
[attach-enode] #3592 83
[assign] #3592 justification -1: p50
[end-of-instance]
[eq-expl] #4762 root
[new-match] 0x10686f5e0 #1477 #1476 #4762 #1545 ; #4765
[eq-expl] #4743 lit #3592 ; #4765
[eq-expl] #4765 root
[new-match] 0x10686f618 #1522 #1506 #4762 #1545 ; #4744 (#4743 #4765)
[mk-app] #4065 = #4780 #4762
[mk-app] #3333 = #4065 #4065
[mk-proof] #3935 refl #3333
[mk-app] #3706 or #1576 #4065
[mk-proof] #4231 quant-inst #3706
[instance] 0x10686f5e0 #4231 ; 84
[attach-enode] #4780 84
[attach-enode] #4065 84
[assign] #4065 justification -1: p49
[end-of-instance]
[mk-app] #3333 * #176 #4786
[mk-app] #3935 + #4783 #3333
[mk-app] #4232 = #3935 #1503
[mk-app] #3920 = #4232 #4232
[mk-proof] #3577 refl #3920
[mk-app] #4398 or #4983 #4232
[mk-proof] #3795 quant-inst #4398
[instance] 0x10686f618 #3795 ; 84
[attach-enode] #4782 84
[attach-enode] #4783 84
[attach-enode] #4786 84
[attach-enode] #3333 84
[attach-enode] #3935 84
[attach-enode] #4232 84
[mk-app] #3796 <= #3935 #1503
[mk-app] #4583 >= #3935 #1503
[assign] #4232 justification -1: p51
[end-of-instance]
[assign] #3796 clause p420 (not p419)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[assign] #4583 clause p421 (not p419)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[mk-app] #3920 = #4744 #4786
[attach-meaning] #176 arith (- 1)
[mk-app] #3577 + #4744 #3333
[mk-app] #3790 <= #3577 #36
[mk-app] #4550 >= #3577 #36
[assign] #3920 justification -1: p417
[attach-enode] #3920 0
[attach-enode] #3577 0
[assign] #3790 justification -1: p422
[assign] #4550 justification -1: p422
[new-match] 0x10686ffd8 #1495 #1483 #4762 #1545 ; #4782 (#4765 #4765)
[mk-app] #3462 = #4782 #4799
[mk-app] #3463 = #4782 #4804
[mk-app] #3928 = #3462 #3463
[mk-proof] #3929 monotonicity #4806 #3928
[mk-app] #4294 or #1563 #3463
[mk-app] #3479 or #1563 #3462
[mk-proof] #3480 quant-inst #3479
[mk-app] #4074 = #3479 #4294
[mk-proof] #3070 monotonicity #3929 #4074
[mk-app] #3068 = #4294 #4294
[mk-proof] #3069 rewrite #3068
[mk-proof] #3071 trans #3070 #3069 #4074
[mk-proof] #3514 mp #3480 #3071 #4294
[instance] 0x10686ffd8 #3480 ; 85
[attach-enode] #4801 85
[attach-enode] #4804 85
[attach-enode] #3463 85
[assign] #3463 justification -1: p50
[end-of-instance]
[eq-expl] #4801 root
[new-match] 0x1068b1890 #1477 #1476 #4801 #1545 ; #4804
[eq-expl] #4782 lit #3463 ; #4804
[eq-expl] #4804 root
[new-match] 0x1068b18c8 #1522 #1506 #4801 #1545 ; #4783 (#4782 #4804)
[mk-app] #4206 = #4819 #4801
[mk-app] #3820 = #4206 #4206
[mk-proof] #3317 refl #3820
[mk-app] #3441 or #1576 #4206
[mk-proof] #3821 quant-inst #3441
[instance] 0x1068b1890 #3821 ; 86
[attach-enode] #4819 86
[attach-enode] #4206 86
[assign] #4206 justification -1: p49
[end-of-instance]
[mk-app] #3820 * #176 #4825
[mk-app] #3317 + #4822 #3820
[mk-app] #3879 = #3317 #1503
[mk-app] #4570 = #3879 #3879
[mk-proof] #3966 refl #4570
[mk-app] #3967 or #4983 #3879
[mk-proof] #3716 quant-inst #3967
[instance] 0x1068b18c8 #3716 ; 86
[attach-enode] #4821 86
[attach-enode] #4822 86
[attach-enode] #4825 86
[attach-enode] #3820 86
[attach-enode] #3317 86
[attach-enode] #3879 86
[mk-app] #3719 <= #3317 #1503
[mk-app] #3968 >= #3317 #1503
[assign] #3879 justification -1: p51
[end-of-instance]
[assign] #3719 clause p428 (not p427)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[assign] #3968 clause p429 (not p427)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[mk-app] #4570 = #4783 #4825
[attach-meaning] #176 arith (- 1)
[mk-app] #3966 + #4783 #3820
[mk-app] #4254 <= #3966 #36
[mk-app] #4523 >= #3966 #36
[assign] #4570 justification -1: p425
[attach-enode] #4570 0
[attach-enode] #3966 0
[assign] #4254 justification -1: p430
[assign] #4523 justification -1: p430
[new-match] 0x1068b2288 #1495 #1483 #4801 #1545 ; #4821 (#4804 #4804)
[mk-app] #3576 = #4821 #4838
[mk-app] #4504 = #4821 #4843
[mk-app] #3921 = #3576 #4504
[mk-proof] #3579 monotonicity #4845 #3921
[mk-app] #4586 or #1563 #4504
[mk-app] #4587 or #1563 #3576
[mk-proof] #4732 quant-inst #4587
[mk-app] #4714 = #4587 #4586
[mk-proof] #4692 monotonicity #3579 #4714
[mk-app] #4693 = #4586 #4586
[mk-proof] #4734 rewrite #4693
[mk-proof] #4729 trans #4692 #4734 #4714
[mk-proof] #4776 mp #4732 #4729 #4586
[instance] 0x1068b2288 #4732 ; 87
[attach-enode] #4840 87
[attach-enode] #4843 87
[attach-enode] #4504 87
[assign] #4504 justification -1: p50
[end-of-instance]
[eq-expl] #4840 root
[new-match] 0x1068b2528 #1477 #1476 #4840 #1545 ; #4843
[eq-expl] #4821 lit #4504 ; #4843
[eq-expl] #4843 root
[new-match] 0x1068b2560 #1522 #1506 #4840 #1545 ; #4822 (#4821 #4843)
[mk-app] #4777 = #4858 #4840
[mk-app] #4770 = #4777 #4777
[mk-proof] #4771 refl #4770
[mk-app] #4778 or #1576 #4777
[mk-proof] #4785 quant-inst #4778
[instance] 0x1068b2528 #4785 ; 88
[attach-enode] #4858 88
[attach-enode] #4777 88
[assign] #4777 justification -1: p49
[end-of-instance]
[mk-app] #4770 * #176 #4864
[mk-app] #4771 + #4861 #4770
[mk-app] #4792 = #4771 #1503
[mk-app] #3054 = #4792 #4792
[mk-proof] #3055 refl #3054
[mk-app] #4902 or #4983 #4792
[mk-proof] #3053 quant-inst #4902
[instance] 0x1068b2560 #3053 ; 88
[attach-enode] #4860 88
[attach-enode] #4861 88
[attach-enode] #4864 88
[attach-enode] #4770 88
[attach-enode] #4771 88
[attach-enode] #4792 88
[mk-app] #3058 <= #4771 #1503
[mk-app] #4972 >= #4771 #1503
[assign] #4792 justification -1: p51
[end-of-instance]
[assign] #3058 clause p436 (not p435)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[assign] #4972 clause p437 (not p435)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[mk-app] #3054 = #4822 #4864
[attach-meaning] #176 arith (- 1)
[mk-app] #3055 + #4822 #4770
[mk-app] #5048 <= #3055 #36
[mk-app] #5041 >= #3055 #36
[assign] #3054 justification -1: p433
[attach-enode] #3054 0
[attach-enode] #3055 0
[assign] #5048 justification -1: p438
[assign] #5041 justification -1: p438
[new-match] 0x1068b2f20 #1495 #1483 #4840 #1545 ; #4860 (#4843 #4843)
[mk-app] #5005 = #4860 #4877
[mk-app] #5008 = #4860 #4882
[mk-app] #5042 = #5005 #5008
[mk-proof] #5043 monotonicity #4884 #5042
[mk-app] #5044 or #1563 #5008
[mk-app] #3815 or #1563 #5005
[mk-proof] #3394 quant-inst #3815
[mk-app] #3159 = #3815 #5044
[mk-proof] #4085 monotonicity #5043 #3159
[mk-app] #3817 = #5044 #5044
[mk-proof] #4316 rewrite #3817
[mk-proof] #3953 trans #4085 #4316 #3159
[mk-proof] #3277 mp #3394 #3953 #5044
[instance] 0x1068b2f20 #3394 ; 89
[attach-enode] #4879 89
[attach-enode] #4882 89
[attach-enode] #5008 89
[assign] #5008 justification -1: p50
[end-of-instance]
[eq-expl] #4879 root
[new-match] 0x1068b31c0 #1477 #1476 #4879 #1545 ; #4882
[eq-expl] #4860 lit #5008 ; #4882
[eq-expl] #4882 root
[new-match] 0x1068b31f8 #1522 #1506 #4879 #1545 ; #4861 (#4860 #4882)
[mk-app] #3247 = #4897 #4879
[mk-app] #3690 = #3247 #3247
[mk-proof] #3282 refl #3690
[mk-app] #2940 or #1576 #3247
[mk-proof] #3146 quant-inst #2940
[instance] 0x1068b31c0 #3146 ; 90
[attach-enode] #4897 90
[attach-enode] #3247 90
[assign] #3247 justification -1: p49
[end-of-instance]
[mk-app] #3690 * #176 #4903
[mk-app] #3282 + #4900 #3690
[mk-app] #3151 = #3282 #1503
[mk-app] #4112 = #3151 #3151
[mk-proof] #3039 refl #4112
[mk-app] #3379 or #4983 #3151
[mk-proof] #3377 quant-inst #3379
[instance] 0x1068b31f8 #3377 ; 90
[attach-enode] #4899 90
[attach-enode] #4900 90
[attach-enode] #4903 90
[attach-enode] #3690 90
[attach-enode] #3282 90
[attach-enode] #3151 90
[mk-app] #3381 <= #3282 #1503
[mk-app] #3883 >= #3282 #1503
[assign] #3151 justification -1: p51
[end-of-instance]
[assign] #3381 clause p444 (not p443)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[assign] #3883 clause p445 (not p443)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[mk-app] #4112 = #4861 #4903
[attach-meaning] #176 arith (- 1)
[mk-app] #3039 + #4861 #3690
[mk-app] #3478 <= #3039 #36
[mk-app] #3075 >= #3039 #36
[assign] #4112 justification -1: p441
[attach-enode] #4112 0
[attach-enode] #3039 0
[assign] #3478 justification -1: p446
[assign] #3075 justification -1: p446
[new-match] 0x1068ba9e8 #1495 #1483 #4879 #1545 ; #4899 (#4882 #4882)
[mk-app] #3778 = #4899 #4916
[mk-app] #3322 = #4899 #4921
[mk-app] #4047 = #3778 #3322
[mk-proof] #3286 monotonicity #4923 #4047
[mk-app] #4835 or #1563 #3322
[mk-app] #4853 or #1563 #3778
[mk-proof] #4874 quant-inst #4853
[mk-app] #4875 = #4853 #4835
[mk-proof] #4854 monotonicity #3286 #4875
[mk-app] #4855 = #4835 #4835
[mk-proof] #5146 rewrite #4855
[mk-proof] #4967 trans #4854 #5146 #4875
[mk-proof] #4925 mp #4874 #4967 #4835
[instance] 0x1068ba9e8 #4874 ; 91
[attach-enode] #4918 91
[attach-enode] #4921 91
[attach-enode] #3322 91
[assign] #3322 justification -1: p50
[end-of-instance]
[eq-expl] #4918 root
[new-match] 0x1068bac88 #1477 #1476 #4918 #1545 ; #4921
[eq-expl] #4899 lit #3322 ; #4921
[eq-expl] #4921 root
[new-match] 0x1068bacc0 #1522 #1506 #4918 #1545 ; #4900 (#4899 #4921)
[mk-app] #4926 = #4936 #4918
[mk-app] #4859 = #4926 #4926
[mk-proof] #4839 refl #4859
[mk-app] #3383 or #1576 #4926
[mk-proof] #3263 quant-inst #3383
[instance] 0x1068bac88 #3263 ; 92
[attach-enode] #4936 92
[attach-enode] #4926 92
[assign] #4926 justification -1: p49
[end-of-instance]
[mk-app] #4859 * #176 #4942
[mk-app] #4839 + #4939 #4859
[mk-app] #3957 = #4839 #1503
[mk-app] #3759 = #3957 #3957
[mk-proof] #3238 refl #3759
[mk-app] #3388 or #4983 #3957
[mk-proof] #3261 quant-inst #3388
[instance] 0x1068bacc0 #3261 ; 92
[attach-enode] #4938 92
[attach-enode] #4939 92
[attach-enode] #4942 92
[attach-enode] #4859 92
[attach-enode] #4839 92
[attach-enode] #3957 92
[mk-app] #3256 <= #4839 #1503
[mk-app] #3226 >= #4839 #1503
[assign] #3957 justification -1: p51
[end-of-instance]
[assign] #3256 clause p452 (not p451)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[assign] #3226 clause p453 (not p451)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[mk-app] #3759 = #4900 #4942
[attach-meaning] #176 arith (- 1)
[mk-app] #3238 + #4900 #4859
[mk-app] #4139 <= #3238 #36
[mk-app] #3257 >= #3238 #36
[assign] #3759 justification -1: p449
[attach-enode] #3759 0
[attach-enode] #3238 0
[assign] #4139 justification -1: p454
[assign] #3257 justification -1: p454
[new-match] 0x1068bb680 #1495 #1483 #4918 #1545 ; #4938 (#4921 #4921)
[mk-app] #3894 = #4938 #4955
[mk-app] #3281 = #4938 #4960
[mk-app] #3276 = #3894 #3281
[mk-proof] #2961 monotonicity #4962 #3276
[mk-app] #3278 or #1563 #3281
[mk-app] #3283 or #1563 #3894
[mk-proof] #3704 quant-inst #3283
[mk-app] #3705 = #3283 #3278
[mk-proof] #3443 monotonicity #2961 #3705
[mk-app] #4468 = #3278 #3278
[mk-proof] #4103 rewrite #4468
[mk-proof] #4075 trans #3443 #4103 #3705
[mk-proof] #3421 mp #3704 #4075 #3278
[instance] 0x1068bb680 #3704 ; 93
[attach-enode] #4957 93
[attach-enode] #4960 93
[attach-enode] #3281 93
[assign] #3281 justification -1: p50
[end-of-instance]
[eq-expl] #4957 root
[new-match] 0x1068bb920 #1477 #1476 #4957 #1545 ; #4960
[eq-expl] #4938 lit #3281 ; #4960
[eq-expl] #4960 root
[new-match] 0x1068bb958 #1522 #1506 #4957 #1545 ; #4939 (#4938 #4960)
[mk-app] #4458 = #4975 #4957
[mk-app] #4208 = #4458 #4458
[mk-proof] #4200 refl #4208
[mk-app] #4215 or #1576 #4458
[mk-proof] #4521 quant-inst #4215
[instance] 0x1068bb920 #4521 ; 94
[attach-enode] #4975 94
[attach-enode] #4458 94
[assign] #4458 justification -1: p49
[end-of-instance]
[mk-app] #4208 * #176 #4981
[mk-app] #4200 + #4978 #4208
[mk-app] #3177 = #4200 #1503
[mk-app] #3178 = #3177 #3177
[mk-proof] #3179 refl #3178
[mk-app] #4814 or #4983 #3177
[mk-proof] #4815 quant-inst #4814
[instance] 0x1068bb958 #4815 ; 94
[attach-enode] #4977 94
[attach-enode] #4978 94
[attach-enode] #4981 94
[attach-enode] #4208 94
[attach-enode] #4200 94
[attach-enode] #3177 94
[mk-app] #4699 <= #4200 #1503
[mk-app] #4808 >= #4200 #1503
[assign] #3177 justification -1: p51
[end-of-instance]
[assign] #4699 clause p460 (not p459)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[assign] #4808 clause p461 (not p459)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[mk-app] #3178 = #4939 #4981
[attach-meaning] #176 arith (- 1)
[mk-app] #3179 + #4939 #4208
[mk-app] #3483 <= #3179 #36
[mk-app] #3477 >= #3179 #36
[assign] #3178 justification -1: p457
[attach-enode] #3178 0
[attach-enode] #3179 0
[assign] #3483 justification -1: p462
[assign] #3477 justification -1: p462
[new-match] 0x1068bc318 #1495 #1483 #4957 #1545 ; #4977 (#4960 #4960)
[mk-app] #5082 = #4977 #4994
[mk-app] #3206 = #4977 #4999
[mk-app] #3878 = #5082 #3206
[mk-proof] #3672 monotonicity #5001 #3878
[mk-app] #4350 or #1563 #3206
[mk-app] #3648 or #1563 #5082
[mk-proof] #3380 quant-inst #3648
[mk-app] #4301 = #3648 #4350
[mk-proof] #4552 monotonicity #3672 #4301
[mk-app] #3424 = #4350 #4350
[mk-proof] #4547 rewrite #3424
[mk-proof] #3536 trans #4552 #4547 #4301
[mk-proof] #4641 mp #3380 #3536 #4350
[instance] 0x1068bc318 #3380 ; 95
[attach-enode] #4996 95
[attach-enode] #4999 95
[attach-enode] #3206 95
[assign] #3206 justification -1: p50
[end-of-instance]
[eq-expl] #4996 root
[new-match] 0x1068bc5b8 #1477 #1476 #4996 #1545 ; #4999
[eq-expl] #4977 lit #3206 ; #4999
[eq-expl] #4999 root
[new-match] 0x1068cdc10 #1522 #1506 #4996 #1545 ; #4978 (#4977 #4999)
[mk-app] #4679 = #5014 #4996
[mk-app] #3204 = #4679 #4679
[mk-proof] #4673 refl #3204
[mk-app] #4952 or #1576 #4679
[mk-proof] #4872 quant-inst #4952
[instance] 0x1068bc5b8 #4872 ; 96
[attach-enode] #5014 96
[attach-enode] #4679 96
[assign] #4679 justification -1: p49
[end-of-instance]
[mk-app] #3204 * #176 #5020
[mk-app] #4673 + #5017 #3204
[mk-app] #5195 = #4673 #1503
[mk-app] #4945 = #5195 #5195
[mk-proof] #4995 refl #4945
[mk-app] #4943 or #4983 #5195
[mk-proof] #4905 quant-inst #4943
[instance] 0x1068cdc10 #4905 ; 96
[attach-enode] #5016 96
[attach-enode] #5017 96
[attach-enode] #5020 96
[attach-enode] #3204 96
[attach-enode] #4673 96
[attach-enode] #5195 96
[mk-app] #4631 <= #4673 #1503
[mk-app] #3694 >= #4673 #1503
[assign] #5195 justification -1: p51
[end-of-instance]
[assign] #4631 clause p468 (not p467)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[assign] #3694 clause p469 (not p467)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[mk-app] #4945 = #4978 #5020
[attach-meaning] #176 arith (- 1)
[mk-app] #4995 + #4978 #3204
[mk-app] #4343 <= #4995 #36
[mk-app] #3092 >= #4995 #36
[assign] #4945 justification -1: p465
[attach-enode] #4945 0
[attach-enode] #4995 0
[assign] #4343 justification -1: p470
[assign] #3092 justification -1: p470
[new-match] 0x1068ce5d0 #1495 #1483 #4996 #1545 ; #5016 (#4999 #4999)
[mk-app] #3106 = #5016 #5033
[mk-app] #4319 = #5016 #5038
[mk-app] #4503 = #3106 #4319
[mk-proof] #2932 monotonicity #5040 #4503
[mk-app] #2933 or #1563 #4319
[mk-app] #4164 or #1563 #3106
[mk-proof] #4166 quant-inst #4164
[mk-app] #2930 = #4164 #2933
[mk-proof] #2931 monotonicity #2932 #2930
[mk-app] #4286 = #2933 #2933
[mk-proof] #4287 rewrite #4286
[mk-proof] #4496 trans #2931 #4287 #2930
[mk-proof] #3629 mp #4166 #4496 #2933
[instance] 0x1068ce5d0 #4166 ; 97
[attach-enode] #5035 97
[attach-enode] #5038 97
[attach-enode] #4319 97
[assign] #4319 justification -1: p50
[end-of-instance]
[eq-expl] #5035 root
[new-match] 0x1068ce870 #1477 #1476 #5035 #1545 ; #5038
[eq-expl] #5016 lit #4319 ; #5038
[eq-expl] #5038 root
[new-match] 0x1068ce8a8 #1522 #1506 #5035 #1545 ; #5017 (#5016 #5038)
[mk-app] #3173 = #5053 #5035
[mk-app] #3132 = #3173 #3173
[mk-proof] #3046 refl #3132
[mk-app] #3452 or #1576 #3173
[mk-proof] #3936 quant-inst #3452
[instance] 0x1068ce870 #3936 ; 98
[attach-enode] #5053 98
[attach-enode] #3173 98
[assign] #3173 justification -1: p49
[end-of-instance]
[mk-app] #3132 * #176 #5059
[mk-app] #3046 + #5056 #3132
[mk-app] #3448 = #3046 #1503
[mk-app] #3456 = #3448 #3448
[mk-proof] #3461 refl #3456
[mk-app] #4194 or #4983 #3448
[mk-proof] #4204 quant-inst #4194
[instance] 0x1068ce8a8 #4204 ; 98
[attach-enode] #5055 98
[attach-enode] #5056 98
[attach-enode] #5059 98
[attach-enode] #3132 98
[attach-enode] #3046 98
[attach-enode] #3448 98
[mk-app] #3324 <= #3046 #1503
[mk-app] #4193 >= #3046 #1503
[assign] #3448 justification -1: p51
[end-of-instance]
[assign] #3324 clause p476 (not p475)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[assign] #4193 clause p477 (not p475)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[mk-app] #3456 = #5017 #5059
[attach-meaning] #176 arith (- 1)
[mk-app] #3461 + #5017 #3132
[mk-app] #2997 <= #3461 #36
[mk-app] #2998 >= #3461 #36
[assign] #3456 justification -1: p473
[attach-enode] #3456 0
[attach-enode] #3461 0
[assign] #2997 justification -1: p478
[assign] #2998 justification -1: p478
[new-match] 0x1068cf268 #1495 #1483 #5035 #1545 ; #5055 (#5038 #5038)
[mk-app] #4707 = #5055 #5072
[mk-app] #4831 = #5055 #5077
[mk-app] #4661 = #4707 #4831
[mk-proof] #4662 monotonicity #5079 #4661
[mk-app] #4851 or #1563 #4831
[mk-app] #4846 or #1563 #4707
[mk-proof] #4497 quant-inst #4846
[mk-app] #3566 = #4846 #4851
[mk-proof] #3094 monotonicity #4662 #3566
[mk-app] #3099 = #4851 #4851
[mk-proof] #3567 rewrite #3099
[mk-proof] #3634 trans #3094 #3567 #3566
[mk-proof] #4907 mp #4497 #3634 #4851
[instance] 0x1068cf268 #4497 ; 99
[attach-enode] #5074 99
[attach-enode] #5077 99
[attach-enode] #4831 99
[assign] #4831 justification -1: p50
[end-of-instance]
[eq-expl] #5074 root
[new-match] 0x1068cf508 #1477 #1476 #5074 #1545 ; #5077
[eq-expl] #5055 lit #4831 ; #5077
[eq-expl] #5077 root
[new-match] 0x1068cf540 #1522 #1506 #5074 #1545 ; #5056 (#5055 #5077)
[mk-app] #4908 = #5092 #5074
[mk-app] #4717 = #4908 #4908
[mk-proof] #4712 refl #4717
[mk-app] #4950 or #1576 #4908
[mk-proof] #4951 quant-inst #4950
[instance] 0x1068cf508 #4951 ; 100
[attach-enode] #5092 100
[attach-enode] #4908 100
[assign] #4908 justification -1: p49
[end-of-instance]
[mk-app] #4717 * #176 #5098
[mk-app] #4712 + #5095 #4717
[mk-app] #3407 = #4712 #1503
[mk-app] #3834 = #3407 #3407
[mk-proof] #3645 refl #3834
[mk-app] #3505 or #4983 #3407
[mk-proof] #3835 quant-inst #3505
[instance] 0x1068cf540 #3835 ; 100
[attach-enode] #5094 100
[attach-enode] #5095 100
[attach-enode] #5098 100
[attach-enode] #4717 100
[attach-enode] #4712 100
[attach-enode] #3407 100
[mk-app] #3269 <= #4712 #1503
[mk-app] #3873 >= #4712 #1503
[assign] #3407 justification -1: p51
[end-of-instance]
[assign] #3269 clause p484 (not p483)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[assign] #3873 clause p485 (not p483)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[mk-app] #3834 = #5056 #5098
[attach-meaning] #176 arith (- 1)
[mk-app] #3645 + #5056 #4717
[mk-app] #4414 <= #3645 #36
[mk-app] #3589 >= #3645 #36
[assign] #3834 justification -1: p481
[attach-enode] #3834 0
[attach-enode] #3645 0
[assign] #4414 justification -1: p486
[assign] #3589 justification -1: p486
[new-match] 0x1068e2d10 #1495 #1483 #5074 #1545 ; #5094 (#5077 #5077)
[decide-and-or] #2170 #2177
[push] 3
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 4
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[eq-expl] #3403 root
[new-match] 0x1068e4178 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e41b0 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e41e8 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4228 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4268 #124 #118 #1528 ; #3402
[new-match] 0x1068e4298 #143 #118 #1528 ; #3402
[new-match] 0x1068e42c8 #237 #229 #3402 #36 ; #3403
[mk-app] #3580 * #176 #4347
[mk-app] #4499 + #3403 #5110 #3580
[mk-app] #3301 = #4499 #36
[mk-app] #3826 + #5110 #3403 #3580
[inst-discovered] theory-solving 0x0 arith# ; #4499
[mk-app] #3079 = #4499 #3826
[mk-proof] #3565 rewrite #3079
[instance] 0x0 #3079
[end-of-instance]
[mk-app] #2939 = #3826 #36
[mk-app] #3074 = #3301 #2939
[mk-proof] #3940 monotonicity #3565 #3074
[attach-meaning] #176 arith (- 1)
[mk-app] #5471 + #3402 #5120 #4347
[mk-app] #5124 = #5471 #36
[inst-discovered] theory-solving 0x0 arith# ; #2939
[mk-app] #5268 = #2939 #5124
[mk-proof] #5263 rewrite #5268
[instance] 0x0 #5268
[end-of-instance]
[mk-app] #4868 = #3301 #5124
[mk-proof] #5024 trans #3940 #5263 #4868
[mk-app] #4680 not #263
[mk-app] #4836 or #4680 #5124
[mk-app] #5025 or #4680 #3301
[mk-proof] #4991 quant-inst #5025
[mk-app] #5115 = #5025 #4836
[mk-proof] #5116 monotonicity #5024 #5115
[mk-app] #5064 = #4836 #4836
[mk-proof] #5265 rewrite #5064
[mk-proof] #5432 trans #5116 #5265 #5115
[mk-proof] #5269 mp #4991 #5432 #4836
[instance] 0x1068e4178 #4991 ; 3
[attach-enode] #5120 3
[attach-enode] #5471 3
[attach-enode] #5124 3
[mk-app] #5267 <= #5471 #36
[mk-app] #5185 >= #5471 #36
[assign] #5124 justification -1: p21
[end-of-instance]
[mk-app] #5186 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5186
[mk-app] #5283 = #5186 #5186
[mk-proof] #5262 rewrite #5283
[instance] 0x0 #5283
[end-of-instance]
[mk-app] #5177 or #4423 #5142 #5144 #5145
[mk-app] #5215 or #4423 #5186
[mk-proof] #5237 quant-inst #5215
[mk-app] #5238 = #5215 #5177
[mk-proof] #5225 rewrite #5238
[mk-proof] #5119 mp #5237 #5225 #5177
[instance] 0x1068e41b0 #5237 ; 3
[attach-enode] #5139 3
[attach-enode] #5140 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5283 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5262 or #2353 #2172 #5148 #5165 #5144
[mk-app] #5212 = #5283 #5262
[mk-proof] #5220 monotonicity #5169 #5212
[mk-app] #5543 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5262
[mk-app] #5068 = #5262 #5543
[mk-proof] #5067 rewrite #5068
[instance] 0x0 #5068
[end-of-instance]
[mk-app] #5242 = #5283 #5543
[mk-proof] #5197 trans #5220 #5067 #5242
[mk-app] #5288 not #1917
[mk-app] #5275 or #5288 #2172 #2353 #5144 #5148 #5165
[mk-app] #5287 or #5288 #5283
[mk-proof] #5459 quant-inst #5287
[mk-app] #5436 or #5288 #5543
[mk-app] #5452 = #5287 #5436
[mk-proof] #5174 monotonicity #5197 #5452
[mk-app] #5467 = #5436 #5275
[mk-proof] #5586 rewrite #5467
[mk-app] #5448 = #5287 #5275
[mk-proof] #5587 trans #5174 #5586 #5448
[mk-proof] #5585 mp #5459 #5587 #5275
[instance] 0x1068e41e8 #5459 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[mk-app] #5466 >= #3402 #36
[mk-app] #5580 = #5466 #5466
[mk-proof] #5450 refl #5580
[mk-app] #5211 or #1546 #5466
[mk-proof] #5153 quant-inst #5211
[instance] 0x1068e4268 #5153 ; 3
[assign] #5466 justification -1: p13
[end-of-instance]
[mk-app] #5580 or #5455 #2172
[mk-app] #5450 = #5580 #5580
[mk-proof] #5134 refl #5450
[mk-app] #5152 or #2307 #5455 #2172
[mk-app] #5560 or #2307 #5580
[mk-proof] #5589 quant-inst #5560
[mk-app] #5590 = #5560 #5152
[mk-proof] #5591 rewrite #5590
[mk-proof] #5511 mp #5589 #5591 #5152
[instance] 0x1068e4298 #5589 ; 3
[attach-enode] #5191 3
[mk-app] #5512 <= #3402 #36
[assign] (not #5191) justification -1: p15 (not p68)
[end-of-instance]
[instance] 0x1068e42c8 #5182 ; 3
[attach-enode] #5253 3
[assign] #5253 justification -1: p20
[end-of-instance]
[assign] #5267 clause p490 (not p489)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] #5185 clause p491 (not p489)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01))) 0::Int)) 

[assign] (not #5512) clause (not p499) p498
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5165 clause p496 (not p500)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[assign] #5521 clause p501 (not p500)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int) 
  (not (= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 

[mk-app] #5450 <= #4347 #36
[mk-app] #5134 >= #4347 #36
[assign] #5450 justification -1: p78
[assign] #5134 justification -1: p78
[assign] #5143 clause p493 (not p496) (not p497)
  (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[decide-and-or] #5177 #5142
[push] 5
[assign] #5142 decision axiom
[new-match] 0x1068e9890 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98c8 #124 #118 #1529 ; #5139
[new-match] 0x1068e98f8 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5278
[instance] 0x0 #5271
[end-of-instance]
[instance] 0x1068e9890 #5244 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5517 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5526 >= #5139 #36
[mk-app] #5510 = #5526 #5526
[mk-proof] #5251 refl #5510
[mk-app] #5535 or #1546 #5526
[mk-proof] #5554 quant-inst #5535
[instance] 0x1068e98c8 #5554 ; 4
[assign] #5526 justification -1: p13
[end-of-instance]
[mk-app] #5510 not #5255
[mk-app] #5251 or #5510 #5259
[mk-app] #5218 = #5251 #5251
[mk-proof] #5538 refl #5218
[mk-app] #5460 or #2307 #5510 #5259
[mk-app] #5584 or #2307 #5251
[mk-proof] #5532 quant-inst #5584
[mk-app] #5524 = #5584 #5460
[mk-proof] #5525 rewrite #5524
[mk-proof] #2321 mp #5532 #5525 #5460
[instance] 0x1068e98f8 #5532 ; 4
[attach-enode] #5255 4
[mk-app] #2292 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5250 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5517 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[resolve-process] true
[resolve-lit] 1 (not #5521)
[resolve-lit] 0 (not #5250)
[resolve-lit] 0 (not #5142)
[resolve-process] (not #5250)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5229)
[resolve-lit] 2 #2353
[resolve-lit] 1 #2172
[conflict] (not #5142) #2353 #2172
[pop] 1 6
[assign] (not #5142) clause (not p492) p68 p66
  (not (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #5145 clause p494 p492 (not p493)
  (Seq_contains_trigger (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01)))) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (Seq_add 0::Int (Seq_length $t@2@01)) 0::Int)) 

[new-match] 0x1068e9878 #2726 #167 #2191 #1528 ; #5139 (#1529 #1529)
[new-match] 0x1068e98b0 #124 #118 #1529 ; #5139
[new-match] 0x1068e98e0 #143 #118 #1529 ; #5139
[inst-discovered] theory-solving 0x0 basic# ; #5278
[instance] 0x0 #5271
[end-of-instance]
[instance] 0x1068e9878 #5244 ; 4
[attach-enode] #5226 4
[attach-enode] #5229 4
[mk-app] #5535 >= #5226 #36
[assign] #5229 justification -1: p17 (not p66) (not p68)
[end-of-instance]
[mk-app] #5554 = #5526 #5526
[mk-proof] #5584 refl #5554
[mk-app] #5532 or #1546 #5526
[mk-proof] #5460 quant-inst #5532
[instance] 0x1068e98b0 #5460 ; 4
[assign] #5526 justification -1: p13
[end-of-instance]
[mk-app] #5554 = #5251 #5251
[mk-proof] #5584 refl #5554
[mk-app] #5524 or #2307 #5510 #5259
[mk-app] #5525 or #2307 #5251
[mk-proof] #2321 quant-inst #5525
[mk-app] #5517 = #5525 #5524
[mk-proof] #2292 rewrite #5517
[mk-proof] #5218 mp #2321 #2292 #5524
[instance] 0x1068e98e0 #2321 ; 4
[attach-enode] #5255 4
[mk-app] #5538 <= #5139 #36
[attach-enode] #5259 4
[end-of-instance]
[assign] #5250 clause p505 (not p504)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5535 clause p506 (not p504)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] (not #5538) clause (not p509) (not p496) (not p497) p492
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (not (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_add 0::Int (Seq_length $t@2@01)))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 
  (>= (+ (Seq_add 0::Int (Seq_length $t@2@01)) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5255) clause (not p508) p509
  (not (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[mk-app] #1555 Seq<Int>!val!0
[mk-app] #5264 $Ref!val!0
[mk-app] #1556 $Ref!val!1
[mk-app] #5581 Ptr32!val!0
[mk-app] #2290 Ptr32!val!1
[mk-app] #5138 Seq<Int>!val!1
[mk-app] #1557 Seq<Int>!val!2
[mk-app] #2288 Seq<Int>!val!3
[mk-app] #2315 Int
[attach-meaning] #2315 arith 282
[attach-meaning] #176 arith (- 1)
[mk-app] #2316 Ptr32!val!2
[mk-app] #2317 Ptr32!val!3
[attach-meaning] #3722 arith 16
[attach-meaning] #4108 arith (- 4)
[mk-app] #2193 Ptr32!val!4
[attach-meaning] #3161 arith 20
[mk-app] #2318 Ptr32!val!5
[attach-meaning] #4382 arith 24
[mk-app] #2188 Ptr32!val!6
[attach-meaning] #4389 arith 28
[mk-app] #2344 Ptr32!val!7
[attach-meaning] #3291 arith 32
[mk-app] #2356 Ptr32!val!8
[attach-meaning] #3216 arith 36
[mk-app] #2339 Ptr32!val!9
[attach-meaning] #4684 arith 40
[mk-app] #2185 Ptr32!val!10
[attach-meaning] #4840 arith 44
[mk-app] #5292 Ptr32!val!11
[attach-meaning] #4996 arith 48
[mk-app] #5296 Ptr32!val!12
[mk-app] #5300 Int
[attach-meaning] #5300 arith 52
[mk-app] #5304 Ptr32!val!13
[mk-app] #5308 Int
[attach-meaning] #5308 arith 56
[mk-app] #5312 Ptr32!val!14
[mk-app] #5316 Int
[attach-meaning] #5316 arith 60
[mk-app] #5320 Ptr32!val!15
[mk-app] #5324 Int
[attach-meaning] #5324 arith 64
[attach-meaning] #3722 arith 16
[mk-app] #5328 Ptr32!val!16
[mk-app] #5332 Int
[attach-meaning] #5332 arith 68
[attach-meaning] #3632 arith 17
[mk-app] #5336 Ptr32!val!17
[mk-app] #5340 Int
[attach-meaning] #5340 arith 72
[attach-meaning] #3800 arith 18
[mk-app] #5344 Ptr32!val!18
[mk-app] #5348 Int
[attach-meaning] #5348 arith 76
[attach-meaning] #4573 arith 19
[mk-app] #5352 Ptr32!val!19
[mk-app] #5356 Int
[attach-meaning] #5356 arith 80
[attach-meaning] #3161 arith 20
[mk-app] #5359 Ptr32!val!20
[mk-app] #2192 Int
[attach-meaning] #2192 arith 84
[attach-meaning] #4096 arith 21
[mk-app] #2342 Ptr32!val!21
[mk-app] #5291 Int
[attach-meaning] #5291 arith 88
[attach-meaning] #3898 arith 22
[mk-app] #5295 Ptr32!val!22
[mk-app] #5299 Int
[attach-meaning] #5299 arith 92
[attach-meaning] #3432 arith 23
[mk-app] #5303 Ptr32!val!23
[mk-app] #5307 Int
[attach-meaning] #5307 arith 96
[attach-meaning] #4382 arith 24
[mk-app] #5311 Ptr32!val!24
[mk-app] #5315 Int
[attach-meaning] #5315 arith 100
[attach-meaning] #4548 arith 25
[mk-app] #5319 Ptr32!val!25
[mk-app] #5327 Int
[attach-meaning] #5327 arith 104
[attach-meaning] #2916 arith 26
[mk-app] #5335 Ptr32!val!26
[mk-app] #5343 Int
[attach-meaning] #5343 arith 108
[attach-meaning] #3947 arith 27
[mk-app] #5351 Ptr32!val!27
[mk-app] #5360 Int
[attach-meaning] #5360 arith 112
[attach-meaning] #4389 arith 28
[mk-app] #5364 Ptr32!val!28
[mk-app] #5368 Int
[attach-meaning] #5368 arith 116
[attach-meaning] #3887 arith 29
[mk-app] #5372 Ptr32!val!29
[mk-app] #5374 Int
[attach-meaning] #5374 arith 120
[attach-meaning] #3867 arith 30
[mk-app] #2343 Ptr32!val!30
[mk-app] #2341 Int
[attach-meaning] #2341 arith 124
[attach-meaning] #3730 arith 31
[mk-app] #5290 Ptr32!val!31
[mk-app] #5294 Int
[attach-meaning] #5294 arith 128
[attach-meaning] #3291 arith 32
[mk-app] #5298 Ptr32!val!32
[mk-app] #5302 Int
[attach-meaning] #5302 arith 132
[attach-meaning] #4187 arith 33
[mk-app] #5306 Ptr32!val!33
[mk-app] #5310 Int
[attach-meaning] #5310 arith 136
[attach-meaning] #3677 arith 34
[mk-app] #5314 Ptr32!val!34
[mk-app] #5318 Int
[attach-meaning] #5318 arith 140
[attach-meaning] #3981 arith 35
[mk-app] #5322 Ptr32!val!35
[mk-app] #5326 Int
[attach-meaning] #5326 arith 144
[attach-meaning] #3216 arith 36
[mk-app] #5330 Ptr32!val!36
[mk-app] #5334 Int
[attach-meaning] #5334 arith 148
[attach-meaning] #4506 arith 37
[mk-app] #5338 Ptr32!val!37
[mk-app] #5342 Int
[attach-meaning] #5342 arith 152
[attach-meaning] #4606 arith 38
[mk-app] #5346 Ptr32!val!38
[mk-app] #5350 Int
[attach-meaning] #5350 arith 156
[attach-meaning] #4645 arith 39
[mk-app] #5354 Ptr32!val!39
[mk-app] #5358 Int
[attach-meaning] #5358 arith 160
[attach-meaning] #4684 arith 40
[mk-app] #2291 Ptr32!val!40
[mk-app] #2340 Int
[attach-meaning] #2340 arith 164
[attach-meaning] #4723 arith 41
[mk-app] #5289 Ptr32!val!41
[mk-app] #5293 Int
[attach-meaning] #5293 arith 168
[attach-meaning] #4762 arith 42
[mk-app] #5297 Ptr32!val!42
[mk-app] #5309 Int
[attach-meaning] #5309 arith 172
[attach-meaning] #4801 arith 43
[mk-app] #5317 Ptr32!val!43
[mk-app] #5331 Int
[attach-meaning] #5331 arith 176
[attach-meaning] #4840 arith 44
[mk-app] #5347 Ptr32!val!44
[mk-app] #5362 Int
[attach-meaning] #5362 arith 180
[attach-meaning] #4879 arith 45
[mk-app] #5370 Ptr32!val!45
[mk-app] #5378 Int
[attach-meaning] #5378 arith 184
[attach-meaning] #4918 arith 46
[mk-app] #5382 Ptr32!val!46
[mk-app] #5386 Int
[attach-meaning] #5386 arith 188
[attach-meaning] #4957 arith 47
[mk-app] #5390 Ptr32!val!47
[mk-app] #5394 Int
[attach-meaning] #5394 arith 192
[attach-meaning] #4996 arith 48
[mk-app] #5398 Ptr32!val!48
[mk-app] #5402 Int
[attach-meaning] #5402 arith 196
[attach-meaning] #5035 arith 49
[mk-app] #5406 Ptr32!val!49
[mk-app] #5410 Int
[attach-meaning] #5410 arith 200
[attach-meaning] #5074 arith 50
[mk-app] #5414 Ptr32!val!50
[mk-app] #5429 Ptr32!val!51
[mk-app] #5323 Int
[attach-meaning] #5323 arith 204
[mk-app] #5329 Int
[attach-meaning] #5329 arith 283
[attach-meaning] #3722 arith 16
[attach-meaning] #3632 arith 17
[attach-meaning] #3800 arith 18
[attach-meaning] #4573 arith 19
[attach-meaning] #3161 arith 20
[attach-meaning] #4096 arith 21
[attach-meaning] #3898 arith 22
[attach-meaning] #3432 arith 23
[attach-meaning] #4382 arith 24
[attach-meaning] #4548 arith 25
[attach-meaning] #2916 arith 26
[attach-meaning] #3947 arith 27
[attach-meaning] #4389 arith 28
[attach-meaning] #3887 arith 29
[attach-meaning] #3867 arith 30
[attach-meaning] #3730 arith 31
[attach-meaning] #3291 arith 32
[attach-meaning] #4187 arith 33
[attach-meaning] #3677 arith 34
[attach-meaning] #3981 arith 35
[attach-meaning] #3216 arith 36
[attach-meaning] #4506 arith 37
[attach-meaning] #4606 arith 38
[attach-meaning] #4645 arith 39
[attach-meaning] #4684 arith 40
[attach-meaning] #4723 arith 41
[attach-meaning] #4762 arith 42
[attach-meaning] #4801 arith 43
[attach-meaning] #4840 arith 44
[attach-meaning] #4879 arith 45
[attach-meaning] #4918 arith 46
[attach-meaning] #4957 arith 47
[attach-meaning] #4996 arith 48
[attach-meaning] #5035 arith 49
[attach-meaning] #5074 arith 50
[mk-app] #5337 Int
[attach-meaning] #5337 arith 51
[attach-meaning] #5300 arith 52
[mk-app] #5345 Int
[attach-meaning] #5345 arith 53
[mk-app] #5353 Int
[attach-meaning] #5353 arith 54
[mk-app] #5361 Int
[attach-meaning] #5361 arith 55
[attach-meaning] #5308 arith 56
[mk-app] #5365 Int
[attach-meaning] #5365 arith 57
[mk-app] #5369 Int
[attach-meaning] #5369 arith 58
[mk-app] #5373 Int
[attach-meaning] #5373 arith 59
[attach-meaning] #5316 arith 60
[mk-app] #5377 Int
[attach-meaning] #5377 arith 61
[mk-app] #5381 Int
[attach-meaning] #5381 arith 62
[mk-app] #5385 Int
[attach-meaning] #5385 arith 63
[attach-meaning] #5324 arith 64
[mk-app] #5389 Int
[attach-meaning] #5389 arith 65
[mk-app] #5393 Int
[attach-meaning] #5393 arith 66
[mk-app] #5397 Int
[attach-meaning] #5397 arith 67
[attach-meaning] #5332 arith 68
[mk-app] #5401 Int
[attach-meaning] #5401 arith 69
[mk-app] #5405 Int
[attach-meaning] #5405 arith 70
[mk-app] #5409 Int
[attach-meaning] #5409 arith 71
[attach-meaning] #5340 arith 72
[mk-app] #5413 Int
[attach-meaning] #5413 arith 73
[mk-app] #5417 Int
[attach-meaning] #5417 arith 74
[mk-app] #5178 Int
[attach-meaning] #5178 arith 75
[attach-meaning] #5348 arith 76
[mk-app] #5063 Int
[attach-meaning] #5063 arith 77
[mk-app] #5301 Int
[attach-meaning] #5301 arith 78
[mk-app] #5305 Int
[attach-meaning] #5305 arith 79
[attach-meaning] #5356 arith 80
[mk-app] #5313 Int
[attach-meaning] #5313 arith 81
[mk-app] #5321 Int
[attach-meaning] #5321 arith 82
[mk-app] #5339 Int
[attach-meaning] #5339 arith 83
[attach-meaning] #2192 arith 84
[mk-app] #5355 Int
[attach-meaning] #5355 arith 85
[mk-app] #5366 Int
[attach-meaning] #5366 arith 86
[mk-app] #5376 Int
[attach-meaning] #5376 arith 87
[attach-meaning] #5291 arith 88
[mk-app] #5380 Int
[attach-meaning] #5380 arith 89
[mk-app] #5384 Int
[attach-meaning] #5384 arith 90
[mk-app] #5388 Int
[attach-meaning] #5388 arith 91
[attach-meaning] #5299 arith 92
[mk-app] #5392 Int
[attach-meaning] #5392 arith 93
[mk-app] #5396 Int
[attach-meaning] #5396 arith 94
[mk-app] #5400 Int
[attach-meaning] #5400 arith 95
[attach-meaning] #5307 arith 96
[mk-app] #5404 Int
[attach-meaning] #5404 arith 97
[mk-app] #5408 Int
[attach-meaning] #5408 arith 98
[mk-app] #5412 Int
[attach-meaning] #5412 arith 99
[attach-meaning] #5315 arith 100
[mk-app] #5416 Int
[attach-meaning] #5416 arith 101
[mk-app] #5430 Int
[attach-meaning] #5430 arith 102
[mk-app] #5325 Int
[attach-meaning] #5325 arith 103
[attach-meaning] #5327 arith 104
[mk-app] #5333 Int
[attach-meaning] #5333 arith 105
[mk-app] #5341 Int
[attach-meaning] #5341 arith 106
[mk-app] #5349 Int
[attach-meaning] #5349 arith 107
[attach-meaning] #5343 arith 108
[mk-app] #5357 Int
[attach-meaning] #5357 arith 109
[mk-app] #5363 Int
[attach-meaning] #5363 arith 110
[mk-app] #5367 Int
[attach-meaning] #5367 arith 111
[attach-meaning] #5360 arith 112
[mk-app] #5371 Int
[attach-meaning] #5371 arith 113
[mk-app] #5375 Int
[attach-meaning] #5375 arith 114
[mk-app] #5379 Int
[attach-meaning] #5379 arith 115
[attach-meaning] #5368 arith 116
[mk-app] #5383 Int
[attach-meaning] #5383 arith 117
[mk-app] #5387 Int
[attach-meaning] #5387 arith 118
[mk-app] #5391 Int
[attach-meaning] #5391 arith 119
[attach-meaning] #5374 arith 120
[mk-app] #5395 Int
[attach-meaning] #5395 arith 121
[mk-app] #5399 Int
[attach-meaning] #5399 arith 122
[mk-app] #5403 Int
[attach-meaning] #5403 arith 123
[attach-meaning] #2341 arith 124
[mk-app] #5407 Int
[attach-meaning] #5407 arith 125
[mk-app] #5411 Int
[attach-meaning] #5411 arith 126
[mk-app] #5415 Int
[attach-meaning] #5415 arith 127
[attach-meaning] #5294 arith 128
[mk-app] #5418 Int
[attach-meaning] #5418 arith 129
[mk-app] #5419 Int
[attach-meaning] #5419 arith 130
[mk-app] #5420 Int
[attach-meaning] #5420 arith 131
[attach-meaning] #5302 arith 132
[mk-app] #5421 Int
[attach-meaning] #5421 arith 133
[mk-app] #5422 Int
[attach-meaning] #5422 arith 134
[mk-app] #5423 Int
[attach-meaning] #5423 arith 135
[attach-meaning] #5310 arith 136
[mk-app] #5424 Int
[attach-meaning] #5424 arith 137
[mk-app] #5425 Int
[attach-meaning] #5425 arith 138
[mk-app] #5426 Int
[attach-meaning] #5426 arith 139
[attach-meaning] #5318 arith 140
[mk-app] #5427 Int
[attach-meaning] #5427 arith 141
[mk-app] #5428 Int
[attach-meaning] #5428 arith 142
[mk-app] #5258 Int
[attach-meaning] #5258 arith 143
[pop] 2 5
[attach-enode] #5120 0
[attach-enode] #5164 0
[attach-enode] #5139 0
[attach-enode] #5140 0
[attach-enode] #5141 0
[pop] 1 3
[push] 2
[mk-app] #5031 address<Int> #1558
[mk-app] #4199 mod #5031 #1503
[mk-app] #4205 = #4199 #36
[mk-app] #4210 not #4205
[mk-proof] #5109 asserted #4210
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4205 #2
[mk-proof] #5100 iff-false #5109 #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4205 #2
[mk-proof] #5100 iff-false #5109 #5099
[mk-app] #5099 ~ #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 rewrite #5099
[mk-proof] #5113 mp #5109 #5100 #4210
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[mk-app] #5099 = #4210 #4210
[mk-proof] #5100 refl #5099
[attach-enode] #5031 0
[attach-enode] #1503 0
[attach-enode] #4199 0
[attach-enode] #4205 0
[mk-app] #5099 <= #4199 #36
[mk-app] #5100 >= #4199 #36
[assign] (not #4205) justification -1: 
[mk-app] #5113 div #5031 #1503
[mk-app] #5440 < #1503 #36
[mk-app] #4983 - #36 #1503
[mk-app] #5108 if #5440 #4983 #1503
[mk-app] #5069 - #5108 #151
[inst-discovered] theory-solving 0x0 arith# ; #5440
[mk-app] #3655 = #5440 #3233
[mk-proof] #4513 rewrite #3655
[instance] 0x0 #3655
[end-of-instance]
[mk-app] #4634 = #5440 #2
[mk-proof] #4677 trans #4513 #3190 #4634
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #4983
[mk-app] #3372 = #4983 #3205
[mk-proof] #3406 rewrite #3372
[instance] 0x0 #3372
[end-of-instance]
[mk-app] #3345 = #4983 #4108
[mk-proof] #5111 trans #3406 #3152 #3345
[mk-app] #4755 if #2 #4108 #1503
[mk-app] #4569 = #5108 #4755
[mk-proof] #4014 monotonicity #4677 #5111 #4569
[inst-discovered] theory-solving 0x0 arith# ; #4755
[mk-app] #3266 = #4755 #1503
[mk-proof] #3267 rewrite #3266
[instance] 0x0 #3266
[end-of-instance]
[mk-app] #3093 = #5108 #1503
[mk-proof] #4613 trans #4014 #3267 #3093
[mk-app] #4733 - #1503 #151
[mk-app] #3065 = #5069 #4733
[mk-proof] #4018 monotonicity #4613 #3065
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #4733
[mk-app] #3642 = #4733 #4048
[mk-proof] #2937 rewrite #3642
[instance] 0x0 #3642
[end-of-instance]
[mk-app] #3518 = #5069 #4048
[mk-proof] #3560 trans #4018 #2937 #3518
[mk-app] #4008 = #5069 #4037
[mk-proof] #3992 trans #3560 #4000 #4008
[mk-app] #2964 = #1503 #36
[mk-app] #2965 * #1503 #5113
[mk-app] #3259 + #2965 #4199
[mk-app] #2967 = #3259 #5031
[mk-app] #3711 <= #4199 #4037
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #2964
[mk-app] #5440 = #2964 #2
[mk-proof] #3655 rewrite #5440
[instance] 0x0 #5440
[end-of-instance]
[attach-enode] #5113 0
[attach-enode] #2965 0
[attach-enode] #3259 0
[attach-enode] #2967 0
[mk-app] #4513 or #2964 #2967
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4513
[assign] #2967 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #2964
[mk-app] #5440 = #2964 #2
[mk-proof] #3655 rewrite #5440
[instance] 0x0 #5440
[end-of-instance]
[attach-enode] #5100 0
[mk-app] #4513 or #2964 #5100
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4513
[assign] #5100 justification -1: true
[end-of-instance]
[attach-meaning] #4108 arith (- 4)
[inst-discovered] theory-solving 0x0 arith# ; #2964
[mk-app] #5440 = #2964 #2
[mk-proof] #3655 rewrite #5440
[instance] 0x0 #5440
[end-of-instance]
[attach-enode] #3711 0
[mk-app] #4513 or #2964 #3711
[inst-discovered] theory-solving 0x0 arith#
[instance] 0x0 #4513
[assign] #3711 justification -1: true
[end-of-instance]
[mk-app] #4513 = #4205 #2
[mk-proof] #4634 iff-false #5109 #4513
[assign] (not #5099) clause (not p81) p80 (not p82)
  (not (<= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 
  (= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int) 
  (not (>= (mod (address<Int> idx_zero@6@01) 4::Int) 0::Int)) 

[new-match] 0x106809eb0 #1522 #1506 #36 #1545 ; #5031 (#1558 #1559)
[mk-app] #2964 = #5533 #5533
[mk-proof] #5440 refl #2964
[mk-app] #3655 not #1522
[mk-app] #4677 or #3655 #5533
[mk-proof] #4983 quant-inst #4677
[instance] 0x106809eb0 #4983 ; 1
[attach-enode] #3235 1
[attach-enode] #4105 1
[attach-enode] #176 1
[attach-enode] #5540 1
[attach-enode] #5522 1
[attach-enode] #5533 1
[mk-app] #3372 <= #5522 #1503
[mk-app] #3406 >= #5522 #1503
[assign] #5533 justification -1: p51
[end-of-instance]
[assign] #3372 clause p86 (not p85)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[assign] #3406 clause p87 (not p85)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 0::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 0::Int)))) 4::Int)) 

[mk-app] #2964 = #3259 #4105
[attach-meaning] #176 arith (- 1)
[mk-app] #5440 + #3259 #5540
[mk-app] #3345 <= #5440 #36
[mk-app] #5111 >= #5440 #36
[assign] #2964 justification -1: p83 p55
[attach-enode] #2964 0
[attach-enode] #5440 0
[assign] #3345 justification -1: p88
[assign] #5111 justification -1: p88
[new-match] 0x106817118 #1522 #1506 #151 #1545 ; #3235 (#1574 #2367)
[mk-app] #5108 = #5080 #5080
[mk-proof] #4755 refl #5108
[mk-app] #4569 or #3655 #5080
[mk-proof] #4014 quant-inst #4569
[instance] 0x106817118 #4014 ; 2
[attach-enode] #3162 2
[attach-enode] #4086 2
[attach-enode] #4087 2
[attach-enode] #3284 2
[attach-enode] #5012 2
[attach-enode] #5080 2
[mk-app] #3266 <= #5012 #1503
[mk-app] #3267 >= #5012 #1503
[assign] #5080 justification -1: p51
[end-of-instance]
[assign] #3266 clause p92 (not p91)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[assign] #3267 clause p93 (not p91)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 1::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 1::Int)))) 4::Int)) 

[mk-app] #5108 = #3235 #4087
[attach-meaning] #176 arith (- 1)
[mk-app] #4755 + #3235 #3284
[mk-app] #3093 <= #4755 #36
[mk-app] #4613 >= #4755 #36
[assign] #5108 justification -1: p58
[attach-enode] #5108 0
[attach-enode] #4755 0
[assign] #3093 justification -1: p94
[assign] #4613 justification -1: p94
[new-match] 0x106817980 #1495 #1483 #151 #1545 ; #3162 (#2367 #2367)
[mk-app] #5069 = #3162 #3955
[mk-app] #4733 = #3371 #5069
[mk-proof] #3065 monotonicity #3943 #4733
[mk-app] #4018 or #1563 #5069
[mk-app] #3642 or #1563 #3371
[mk-proof] #2937 quant-inst #3642
[mk-app] #3518 = #3642 #4018
[mk-proof] #3560 monotonicity #3065 #3518
[mk-app] #4008 = #4018 #4018
[mk-proof] #3992 rewrite #4008
[mk-proof] #4077 trans #3560 #3992 #3518
[mk-proof] #4632 mp #2937 #4077 #4018
[instance] 0x106817980 #2937 ; 3
[attach-enode] #3950 3
[attach-enode] #3955 3
[attach-enode] #5069 3
[assign] #5069 justification -1: p50
[end-of-instance]
[eq-expl] #3950 root
[new-match] 0x106817c40 #1477 #1476 #3950 #1545 ; #3955
[eq-expl] #3162 lit #5069 ; #3955
[eq-expl] #3955 root
[new-match] 0x106817c78 #1522 #1506 #3950 #1545 ; #4086 (#3162 #3955)
[mk-app] #5192 = #5088 #5088
[mk-proof] #5011 refl #5192
[mk-app] #5065 or #1576 #5088
[mk-proof] #5015 quant-inst #5065
[instance] 0x106817c40 #5015 ; 4
[attach-enode] #3384 4
[attach-enode] #5088 4
[assign] #5088 justification -1: p49
[end-of-instance]
[mk-app] #5192 = #3666 #3666
[mk-proof] #5011 refl #5192
[mk-app] #5022 or #3655 #3666
[mk-proof] #4834 quant-inst #5022
[instance] 0x106817c78 #4834 ; 4
[attach-enode] #3386 4
[attach-enode] #3387 4
[attach-enode] #3391 4
[attach-enode] #4847 4
[attach-enode] #3667 4
[attach-enode] #3666 4
[mk-app] #3210 <= #3667 #1503
[mk-app] #3285 >= #3667 #1503
[assign] #3666 justification -1: p51
[end-of-instance]
[assign] #3210 clause p100 (not p99)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[assign] #3285 clause p101 (not p99)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 2::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 2::Int)))) 4::Int)) 

[mk-app] #5192 = #3391 #4086
[attach-meaning] #176 arith (- 1)
[mk-app] #5011 * #176 #4086
[mk-app] #3971 + #3391 #5011
[mk-app] #3972 <= #3971 #36
[mk-app] #3537 >= #3971 #36
[assign] #5192 justification -1: p97
[attach-enode] #5192 0
[attach-enode] #5011 0
[attach-enode] #3971 0
[assign] #3972 justification -1: p102
[assign] #3537 justification -1: p102
[new-match] 0x1068186c0 #1495 #1483 #3950 #1545 ; #3386 (#3955 #3955)
[mk-app] #4638 = #3386 #4322
[mk-app] #4635 = #3682 #4638
[mk-proof] #4716 monotonicity #4324 #4635
[mk-app] #4602 or #1563 #4638
[mk-app] #3272 or #1563 #3682
[mk-proof] #5004 quant-inst #3272
[mk-app] #5003 = #3272 #4602
[mk-proof] #3482 monotonicity #4716 #5003
[mk-app] #4629 = #4602 #4602
[mk-proof] #4636 rewrite #4629
[mk-proof] #4698 trans #3482 #4636 #5003
[mk-proof] #4628 mp #5004 #4698 #4602
[instance] 0x1068186c0 #5004 ; 5
[attach-enode] #4037 5
[attach-enode] #4322 5
[attach-enode] #4638 5
[assign] #4638 justification -1: p50
[end-of-instance]
[eq-expl] #4037 root
[new-match] 0x106818960 #1477 #1476 #4037 #1545 ; #4322
[eq-expl] #3386 lit #4638 ; #4322
[eq-expl] #4322 root
[new-match] 0x106818998 #1522 #1506 #4037 #1545 ; #3387 (#3386 #4322)
[mk-app] #3341 = #4078 #4078
[mk-proof] #3331 refl #3341
[mk-app] #3513 or #1576 #4078
[mk-proof] #2947 quant-inst #3513
[instance] 0x106818960 #2947 ; 6
[attach-enode] #4342 6
[attach-enode] #4078 6
[assign] #4078 justification -1: p49
[end-of-instance]
[mk-app] #3341 + #3091 #4345
[inst-discovered] theory-solving 0x0 arith# ; #4003
[mk-app] #3331 = #4003 #3341
[mk-proof] #3357 rewrite #3331
[instance] 0x0 #3331
[end-of-instance]
[mk-app] #3098 = #3341 #1503
[mk-app] #3343 = #4749 #3098
[mk-proof] #3096 monotonicity #3357 #3343
[attach-meaning] #176 arith (- 1)
[mk-app] #3832 * #176 #4345
[mk-app] #3227 + #3488 #3832
[attach-meaning] #4108 arith (- 4)
[mk-app] #4138 = #3227 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3098
[mk-app] #3245 = #3098 #4138
[mk-proof] #5002 rewrite #3245
[instance] 0x0 #3245
[end-of-instance]
[mk-app] #5013 = #4749 #4138
[mk-proof] #4338 trans #3096 #5002 #5013
[mk-app] #4334 or #3655 #4138
[mk-app] #4373 or #3655 #4749
[mk-proof] #3535 quant-inst #4373
[mk-app] #4577 = #4373 #4334
[mk-proof] #3287 monotonicity #4338 #4577
[mk-app] #3530 = #4334 #4334
[mk-proof] #4637 rewrite #3530
[mk-proof] #3382 trans #3287 #4637 #4577
[mk-proof] #3751 mp #3535 #3382 #4334
[instance] 0x106818998 #3535 ; 6
[attach-enode] #3488 6
[attach-enode] #4344 6
[attach-enode] #4345 6
[attach-enode] #3832 6
[attach-enode] #3227 6
[attach-enode] #4108 6
[attach-enode] #4138 6
[mk-app] #3036 <= #3227 #4108
[mk-app] #3755 >= #3227 #4108
[assign] #4138 justification -1: p51
[end-of-instance]
[assign] #3036 clause p108 (not p107)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[assign] #3755 clause p109 (not p107)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 3::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 3::Int))))) -4::Int)) 

[mk-app] #3033 = #3387 #3488
[attach-meaning] #176 arith (- 1)
[mk-app] #2942 + #3387 #3091
[mk-app] #4356 <= #2942 #36
[mk-app] #3600 >= #2942 #36
[assign] #3033 justification -1: p105
[attach-enode] #3033 0
[attach-enode] #3091 0
[attach-enode] #2942 0
[assign] #4356 justification -1: p110
[assign] #3600 justification -1: p110
[new-match] 0x10681c4c0 #1495 #1483 #4037 #1545 ; #4344 (#4322 #4322)
[mk-app] #5104 = #4344 #4446
[mk-app] #5052 = #3130 #5104
[mk-proof] #4793 monotonicity #4545 #5052
[mk-app] #4812 or #1563 #5104
[mk-app] #4891 or #1563 #3130
[mk-proof] #4892 quant-inst #4891
[mk-app] #4901 = #4891 #4812
[mk-proof] #4889 monotonicity #4793 #4901
[mk-app] #4753 = #4812 #4812
[mk-proof] #4769 rewrite #4753
[mk-proof] #4811 trans #4889 #4769 #4901
[mk-proof] #4730 mp #4892 #4811 #4812
[instance] 0x10681c4c0 #4892 ; 7
[attach-enode] #4446 7
[attach-enode] #5104 7
[assign] #5104 justification -1: p50
[end-of-instance]
[eq-expl] #1503 root
[new-match] 0x10681c6d0 #1477 #1476 #1503 #1545 ; #4446
[eq-expl] #4344 lit #5104 ; #4446
[eq-expl] #4446 root
[new-match] 0x10681c708 #1522 #1506 #1503 #1545 ; #4345 (#4344 #4446)
[mk-app] #4676 = #3063 #3063
[mk-proof] #4694 refl #4676
[mk-app] #4123 or #1576 #3063
[mk-proof] #4514 quant-inst #4123
[instance] 0x10681c6d0 #4514 ; 8
[attach-enode] #2974 8
[attach-enode] #3063 8
[assign] #3063 justification -1: p49
[end-of-instance]
[mk-app] #4676 = #4987 #4987
[mk-proof] #4694 refl #4676
[mk-app] #3717 or #3655 #4987
[mk-proof] #3718 quant-inst #3717
[instance] 0x10681c708 #3718 ; 8
[attach-enode] #2976 8
[attach-enode] #3707 8
[attach-enode] #3710 8
[attach-enode] #3153 8
[attach-enode] #4988 8
[attach-enode] #4987 8
[mk-app] #3175 <= #4988 #1503
[mk-app] #3057 >= #4988 #1503
[assign] #4987 justification -1: p51
[end-of-instance]
[assign] #3175 clause p116 (not p115)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[assign] #3057 clause p117 (not p115)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 4::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 4::Int)))) 4::Int)) 

[mk-app] #4676 = #3710 #4345
[attach-meaning] #176 arith (- 1)
[mk-app] #4694 + #3710 #3832
[mk-app] #3310 <= #4694 #36
[mk-app] #4027 >= #4694 #36
[assign] #4676 justification -1: p113
[attach-enode] #4676 0
[attach-enode] #4694 0
[assign] #3310 justification -1: p118
[assign] #4027 justification -1: p118
[new-match] 0x10681d0c8 #1495 #1483 #1503 #1545 ; #2976 (#4446 #4446)
[mk-app] #4020 = #2976 #3398
[mk-app] #4021 = #4129 #4020
[mk-proof] #4295 monotonicity #3400 #4021
[mk-app] #3927 or #1563 #4020
[mk-app] #3843 or #1563 #4129
[mk-proof] #4595 quant-inst #3843
[mk-app] #3926 = #3843 #3927
[mk-proof] #4551 monotonicity #4295 #3926
[mk-app] #3003 = #3927 #3927
[mk-proof] #3922 rewrite #3003
[mk-proof] #4251 trans #4551 #3922 #3926
[mk-proof] #3330 mp #4595 #4251 #3927
[instance] 0x10681d0c8 #4595 ; 9
[attach-enode] #3395 9
[attach-enode] #3398 9
[attach-enode] #4020 9
[assign] #4020 justification -1: p50
[end-of-instance]
[eq-expl] #3395 root
[new-match] 0x10681d368 #1477 #1476 #3395 #1545 ; #3398
[eq-expl] #2976 lit #4020 ; #3398
[eq-expl] #3398 root
[new-match] 0x10681d3a0 #1522 #1506 #3395 #1545 ; #3707 (#2976 #3398)
[mk-app] #3593 = #3248 #3248
[mk-proof] #3254 refl #3593
[mk-app] #3125 or #1576 #3248
[mk-proof] #3123 quant-inst #3125
[instance] 0x10681d368 #3123 ; 10
[attach-enode] #3414 10
[attach-enode] #3248 10
[assign] #3248 justification -1: p49
[end-of-instance]
[mk-app] #3593 = #4590 #4590
[mk-proof] #3254 refl #3593
[mk-app] #3169 or #3655 #4590
[mk-proof] #3622 quant-inst #3169
[instance] 0x10681d3a0 #3622 ; 10
[attach-enode] #3418 10
[attach-enode] #3419 10
[attach-enode] #3848 10
[attach-enode] #3756 10
[attach-enode] #3242 10
[attach-enode] #4590 10
[mk-app] #3993 <= #3242 #1503
[mk-app] #3250 >= #3242 #1503
[assign] #4590 justification -1: p51
[end-of-instance]
[assign] #3993 clause p124 (not p123)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[assign] #3250 clause p125 (not p123)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 5::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 5::Int)))) 4::Int)) 

[mk-app] #3593 = #3707 #3848
[attach-meaning] #176 arith (- 1)
[mk-app] #3254 + #3707 #3756
[mk-app] #3988 <= #3254 #36
[mk-app] #3559 >= #3254 #36
[assign] #3593 justification -1: p121
[attach-enode] #3593 0
[attach-enode] #3254 0
[assign] #3988 justification -1: p126
[assign] #3559 justification -1: p126
[new-match] 0x106822990 #1495 #1483 #3395 #1545 ; #3418 (#3398 #3398)
[mk-app] #3739 = #3418 #2979
[mk-app] #3113 = #4973 #3739
[mk-proof] #4175 monotonicity #2981 #3113
[mk-app] #4176 or #1563 #3739
[mk-app] #2987 or #1563 #4973
[mk-proof] #3490 quant-inst #2987
[mk-app] #4088 = #2987 #4176
[mk-proof] #4094 monotonicity #4175 #4088
[mk-app] #3507 = #4176 #4176
[mk-proof] #3027 rewrite #3507
[mk-proof] #4174 trans #4094 #3027 #4088
[mk-proof] #3393 mp #3490 #4174 #4176
[instance] 0x106822990 #3490 ; 11
[attach-enode] #4579 11
[attach-enode] #2979 11
[attach-enode] #3739 11
[assign] #3739 justification -1: p50
[end-of-instance]
[eq-expl] #4579 root
[new-match] 0x106822c30 #1477 #1476 #4579 #1545 ; #2979
[eq-expl] #3418 lit #3739 ; #2979
[eq-expl] #2979 root
[new-match] 0x106822c68 #1522 #1506 #4579 #1545 ; #3419 (#3418 #2979)
[mk-app] #3229 = #4400 #4400
[mk-proof] #4311 refl #3229
[mk-app] #3904 or #1576 #4400
[mk-proof] #3431 quant-inst #3904
[instance] 0x106822c30 #3431 ; 12
[attach-enode] #3228 12
[attach-enode] #4400 12
[assign] #4400 justification -1: p49
[end-of-instance]
[mk-app] #3229 = #3657 #3657
[mk-proof] #4311 refl #3229
[mk-app] #4309 or #3655 #3657
[mk-proof] #4010 quant-inst #4309
[instance] 0x106822c68 #4010 ; 12
[attach-enode] #3230 12
[attach-enode] #3231 12
[attach-enode] #3237 12
[attach-enode] #3453 12
[attach-enode] #3043 12
[attach-enode] #3657 12
[mk-app] #3608 <= #3043 #1503
[mk-app] #4671 >= #3043 #1503
[assign] #3657 justification -1: p51
[end-of-instance]
[assign] #3608 clause p132 (not p131)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[assign] #4671 clause p133 (not p131)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 6::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 6::Int)))) 4::Int)) 

[mk-app] #3229 = #3237 #3419
[attach-meaning] #176 arith (- 1)
[mk-app] #4311 * #176 #3419
[mk-app] #4672 + #3237 #4311
[mk-app] #4917 <= #4672 #36
[mk-app] #4486 >= #4672 #36
[assign] #3229 justification -1: p129
[attach-enode] #3229 0
[attach-enode] #4311 0
[attach-enode] #4672 0
[assign] #4917 justification -1: p134
[assign] #4486 justification -1: p134
[new-match] 0x1068236b0 #1495 #1483 #4579 #1545 ; #3230 (#2979 #2979)
[mk-app] #3215 = #3230 #4131
[mk-app] #4584 = #3316 #3215
[mk-proof] #4800 monotonicity #4133 #4584
[mk-app] #4976 or #1563 #3215
[mk-app] #5254 or #1563 #3316
[mk-proof] #4956 quant-inst #5254
[mk-app] #5281 = #5254 #4976
[mk-proof] #5548 monotonicity #4800 #5281
[mk-app] #5176 = #4976 #4976
[mk-proof] #4789 rewrite #5176
[mk-proof] #4937 trans #5548 #4789 #5281
[mk-proof] #4128 mp #4956 #4937 #4976
[instance] 0x1068236b0 #4956 ; 13
[attach-enode] #3760 13
[attach-enode] #4131 13
[attach-enode] #3215 13
[assign] #3215 justification -1: p50
[end-of-instance]
[eq-expl] #3760 root
[new-match] 0x106823950 #1477 #1476 #3760 #1545 ; #4131
[eq-expl] #3230 lit #3215 ; #4131
[eq-expl] #4131 root
[new-match] 0x106823988 #1522 #1506 #3760 #1545 ; #3231 (#3230 #4131)
[mk-app] #4683 = #3004 #3004
[mk-proof] #4904 refl #4683
[mk-app] #4898 or #1576 #3004
[mk-proof] #4787 quant-inst #4898
[instance] 0x106823950 #4787 ; 14
[attach-enode] #4147 14
[attach-enode] #3004 14
[assign] #3004 justification -1: p49
[end-of-instance]
[mk-app] #4683 = #4252 #4252
[mk-proof] #4904 refl #4683
[mk-app] #4493 or #3655 #4252
[mk-proof] #4115 quant-inst #4493
[instance] 0x106823988 #4115 ; 14
[attach-enode] #4149 14
[attach-enode] #4151 14
[attach-enode] #4154 14
[attach-enode] #3007 14
[attach-enode] #3987 14
[attach-enode] #4252 14
[mk-app] #3203 <= #3987 #1503
[mk-app] #4043 >= #3987 #1503
[assign] #4252 justification -1: p51
[end-of-instance]
[assign] #3203 clause p140 (not p139)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[assign] #4043 clause p141 (not p139)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 7::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 7::Int)))) 4::Int)) 

[mk-app] #4683 = #3231 #4154
[attach-meaning] #176 arith (- 1)
[mk-app] #4904 + #3231 #3007
[mk-app] #4044 <= #4904 #36
[mk-app] #3321 >= #4904 #36
[assign] #4683 justification -1: p137
[attach-enode] #4683 0
[attach-enode] #4904 0
[assign] #4044 justification -1: p142
[assign] #3321 justification -1: p142
[new-match] 0x106824348 #1495 #1483 #3760 #1545 ; #4149 (#4131 #4131)
[mk-app] #3319 = #4149 #4562
[mk-app] #3313 = #3744 #3319
[mk-proof] #3290 monotonicity #3249 #3313
[mk-app] #4045 or #1563 #3319
[mk-app] #3587 or #1563 #3744
[mk-proof] #3946 quant-inst #3587
[mk-app] #3930 = #3587 #4045
[mk-proof] #3874 monotonicity #3290 #3930
[mk-app] #4470 = #4045 #4045
[mk-proof] #3897 rewrite #4470
[mk-proof] #3527 trans #3874 #3897 #3930
[mk-proof] #4095 mp #3946 #3527 #4045
[instance] 0x106824348 #3946 ; 15
[attach-enode] #3958 15
[attach-enode] #4562 15
[attach-enode] #3319 15
[assign] #3319 justification -1: p50
[end-of-instance]
[eq-expl] #3958 root
[new-match] 0x1068245e8 #1477 #1476 #3958 #1545 ; #4562
[eq-expl] #4149 lit #3319 ; #4562
[eq-expl] #4562 root
[new-match] 0x106824620 #1522 #1506 #3958 #1545 ; #4151 (#4149 #4562)
[mk-app] #4035 = #3735 #3735
[mk-proof] #3010 refl #4035
[mk-app] #2953 or #1576 #3735
[mk-proof] #3639 quant-inst #2953
[instance] 0x1068245e8 #3639 ; 16
[attach-enode] #3262 16
[attach-enode] #3735 16
[assign] #3735 justification -1: p49
[end-of-instance]
[mk-app] #4035 = #4167 #4167
[mk-proof] #3010 refl #4035
[mk-app] #4012 or #3655 #4167
[mk-proof] #3721 quant-inst #4012
[instance] 0x106824620 #3721 ; 16
[attach-enode] #3264 16
[attach-enode] #3268 16
[attach-enode] #3271 16
[attach-enode] #3738 16
[attach-enode] #3838 16
[attach-enode] #4167 16
[mk-app] #3016 <= #3838 #1503
[mk-app] #4234 >= #3838 #1503
[assign] #4167 justification -1: p51
[end-of-instance]
[assign] #3016 clause p148 (not p147)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[assign] #4234 clause p149 (not p147)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 8::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 8::Int)))) 4::Int)) 

[mk-app] #4035 = #3271 #4151
[attach-meaning] #176 arith (- 1)
[mk-app] #3010 * #176 #4151
[mk-app] #3784 + #3271 #3010
[mk-app] #4308 <= #3784 #36
[mk-app] #4058 >= #3784 #36
[assign] #4035 justification -1: p145
[attach-enode] #4035 0
[attach-enode] #3010 0
[attach-enode] #3784 0
[assign] #4308 justification -1: p150
[assign] #4058 justification -1: p150
[new-match] 0x10682c6b8 #1495 #1483 #3958 #1545 ; #3264 (#4562 #4562)
[mk-app] #4059 = #3264 #4156
[mk-app] #4060 = #3502 #4059
[mk-proof] #3712 monotonicity #4162 #4060
[mk-app] #3713 or #1563 #4059
[mk-app] #4079 or #1563 #3502
[mk-proof] #3746 quant-inst #4079
[mk-app] #3029 = #4079 #3713
[mk-proof] #4073 monotonicity #3712 #3029
[mk-app] #3385 = #3713 #3713
[mk-proof] #3949 rewrite #3385
[mk-proof] #4106 trans #4073 #3949 #3029
[mk-proof] #3022 mp #3746 #4106 #3713
[instance] 0x10682c6b8 #3746 ; 17
[attach-enode] #3767 17
[attach-enode] #4156 17
[attach-enode] #4059 17
[assign] #4059 justification -1: p50
[end-of-instance]
[eq-expl] #3767 root
[new-match] 0x10682c958 #1477 #1476 #3767 #1545 ; #4156
[eq-expl] #3264 lit #4059 ; #4156
[eq-expl] #4156 root
[new-match] 0x10682c990 #1522 #1506 #3767 #1545 ; #3268 (#3264 #4156)
[mk-app] #3555 = #3609 #3609
[mk-proof] #3556 refl #3555
[mk-app] #4242 or #1576 #3609
[mk-proof] #3028 quant-inst #4242
[instance] 0x10682c958 #3028 ; 18
[attach-enode] #4181 18
[attach-enode] #3609 18
[assign] #3609 justification -1: p49
[end-of-instance]
[mk-app] #3555 + #3475 #4184
[inst-discovered] theory-solving 0x0 arith# ; #4388
[mk-app] #3556 = #4388 #3555
[mk-proof] #4557 rewrite #3556
[instance] 0x0 #3556
[end-of-instance]
[mk-app] #3506 = #3555 #1503
[mk-app] #4556 = #4585 #3506
[mk-proof] #3497 monotonicity #4557 #4556
[attach-meaning] #176 arith (- 1)
[mk-app] #3709 * #176 #4184
[mk-app] #3846 + #3618 #3709
[attach-meaning] #4108 arith (- 4)
[mk-app] #3491 = #3846 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3506
[mk-app] #3389 = #3506 #3491
[mk-proof] #3413 rewrite #3389
[instance] 0x0 #3389
[end-of-instance]
[mk-app] #3415 = #4585 #3491
[mk-proof] #3416 trans #3497 #3413 #3415
[mk-app] #3489 or #3655 #3491
[mk-app] #4353 or #3655 #4585
[mk-proof] #2982 quant-inst #4353
[mk-app] #4140 = #4353 #3489
[mk-proof] #4141 monotonicity #3416 #4140
[mk-app] #4142 = #3489 #3489
[mk-proof] #4143 rewrite #4142
[mk-proof] #4153 trans #4141 #4143 #4140
[mk-proof] #3688 mp #2982 #4153 #3489
[instance] 0x10682c990 #2982 ; 18
[attach-enode] #3618 18
[attach-enode] #4183 18
[attach-enode] #4184 18
[attach-enode] #3709 18
[attach-enode] #3846 18
[attach-enode] #3491 18
[mk-app] #4169 <= #3846 #4108
[mk-app] #4163 >= #3846 #4108
[assign] #3491 justification -1: p51
[end-of-instance]
[assign] #4169 clause p156 (not p155)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[assign] #4163 clause p157 (not p155)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 9::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 9::Int))))) -4::Int)) 

[mk-app] #3082 = #3268 #3618
[attach-meaning] #176 arith (- 1)
[mk-app] #3614 + #3268 #3475
[mk-app] #3496 <= #3614 #36
[mk-app] #3499 >= #3614 #36
[assign] #3082 justification -1: p153
[attach-enode] #3082 0
[attach-enode] #3475 0
[attach-enode] #3614 0
[assign] #3496 justification -1: p158
[assign] #3499 justification -1: p158
[new-match] 0x10682d3d8 #1495 #1483 #3767 #1545 ; #4183 (#4156 #4156)
[mk-app] #4508 = #4183 #3698
[mk-app] #3081 = #3320 #4508
[mk-proof] #3615 monotonicity #4564 #3081
[mk-app] #3613 or #1563 #4508
[mk-app] #3616 or #1563 #3320
[mk-proof] #3114 quant-inst #3616
[mk-app] #3115 = #3616 #3613
[mk-proof] #3359 monotonicity #3615 #3115
[mk-app] #4050 = #3613 #3613
[mk-proof] #2972 rewrite #4050
[mk-proof] #4056 trans #3359 #2972 #3115
[mk-proof] #3411 mp #3114 #4056 #3613
[instance] 0x10682d3d8 #3114 ; 19
[attach-enode] #3695 19
[attach-enode] #3698 19
[attach-enode] #4508 19
[assign] #4508 justification -1: p50
[end-of-instance]
[eq-expl] #3695 root
[new-match] 0x10682d678 #1477 #1476 #3695 #1545 ; #3698
[eq-expl] #4183 lit #4508 ; #3698
[eq-expl] #3698 root
[new-match] 0x10682d6b0 #1522 #1506 #3695 #1545 ; #4184 (#4183 #3698)
[mk-app] #4225 = #4471 #4471
[mk-proof] #2984 refl #4225
[mk-app] #4219 or #1576 #4471
[mk-proof] #4220 quant-inst #4219
[instance] 0x10682d678 #4220 ; 20
[attach-enode] #3083 20
[attach-enode] #4471 20
[assign] #4471 justification -1: p49
[end-of-instance]
[mk-app] #4225 = #4546 #4546
[mk-proof] #2984 refl #4225
[mk-app] #4223 or #3655 #4546
[mk-proof] #4224 quant-inst #4223
[instance] 0x10682d6b0 #4224 ; 20
[attach-enode] #3085 20
[attach-enode] #3086 20
[attach-enode] #3089 20
[attach-enode] #3551 20
[attach-enode] #4380 20
[attach-enode] #4546 20
[mk-app] #3002 <= #4380 #1503
[mk-app] #3913 >= #4380 #1503
[assign] #4546 justification -1: p51
[end-of-instance]
[assign] #3002 clause p164 (not p163)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[assign] #3913 clause p165 (not p163)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 10::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 10::Int)))) 4::Int)) 

[mk-app] #4225 = #3089 #4184
[attach-meaning] #176 arith (- 1)
[mk-app] #2984 + #3089 #3709
[mk-app] #4135 <= #2984 #36
[mk-app] #3915 >= #2984 #36
[assign] #4225 justification -1: p161
[attach-enode] #4225 0
[attach-enode] #2984 0
[assign] #4135 justification -1: p166
[assign] #3915 justification -1: p166
[new-match] 0x1068320e0 #1495 #1483 #3695 #1545 ; #3085 (#3698 #3698)
[mk-app] #3005 = #3085 #3111
[mk-app] #4559 = #3571 #3005
[mk-proof] #3034 monotonicity #3110 #4559
[mk-app] #3994 or #1563 #3005
[mk-app] #4007 or #1563 #3571
[mk-proof] #3279 quant-inst #4007
[mk-app] #4588 = #4007 #3994
[mk-proof] #4589 monotonicity #3034 #4588
[mk-app] #4282 = #3994 #3994
[mk-proof] #4180 rewrite #4282
[mk-proof] #4288 trans #4589 #4180 #4588
[mk-proof] #3825 mp #3279 #4288 #3994
[instance] 0x1068320e0 #3279 ; 21
[attach-enode] #3107 21
[attach-enode] #3111 21
[attach-enode] #3005 21
[assign] #3005 justification -1: p50
[end-of-instance]
[eq-expl] #3107 root
[new-match] 0x106832380 #1477 #1476 #3107 #1545 ; #3111
[eq-expl] #3085 lit #3005 ; #3111
[eq-expl] #3111 root
[new-match] 0x1068323b8 #1522 #1506 #3107 #1545 ; #3086 (#3085 #3111)
[mk-app] #3836 = #4052 #4052
[mk-proof] #3168 refl #3836
[mk-app] #3147 or #1576 #4052
[mk-proof] #3171 quant-inst #3147
[instance] 0x106832380 #3171 ; 22
[attach-enode] #4051 22
[attach-enode] #4052 22
[assign] #4052 justification -1: p49
[end-of-instance]
[mk-app] #3836 = #4578 #4578
[mk-proof] #3168 refl #3836
[mk-app] #3611 or #3655 #4578
[mk-proof] #3612 quant-inst #3611
[instance] 0x1068323b8 #3612 ; 22
[attach-enode] #4053 22
[attach-enode] #4054 22
[attach-enode] #4057 22
[attach-enode] #3619 22
[attach-enode] #3620 22
[attach-enode] #4578 22
[mk-app] #3515 <= #3620 #1503
[mk-app] #3617 >= #3620 #1503
[assign] #4578 justification -1: p51
[end-of-instance]
[assign] #3515 clause p172 (not p171)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[assign] #3617 clause p173 (not p171)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 11::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 11::Int)))) 4::Int)) 

[mk-app] #3836 = #3086 #4057
[attach-meaning] #176 arith (- 1)
[mk-app] #3168 + #3086 #3619
[mk-app] #4460 <= #3168 #36
[mk-app] #4467 >= #3168 #36
[assign] #3836 justification -1: p169
[attach-enode] #3836 0
[attach-enode] #3168 0
[assign] #4460 justification -1: p174
[assign] #4467 justification -1: p174
[new-match] 0x106832d78 #1495 #1483 #3107 #1545 ; #4053 (#3111 #3111)
[mk-app] #4248 = #4053 #3326
[mk-app] #3809 = #3373 #4248
[mk-proof] #3808 monotonicity #3328 #3809
[mk-app] #4362 or #1563 #4248
[mk-app] #4363 or #1563 #3373
[mk-proof] #3351 quant-inst #4363
[mk-app] #4475 = #4363 #4362
[mk-proof] #4476 monotonicity #3808 #4475
[mk-app] #3810 = #4362 #4362
[mk-proof] #4247 rewrite #3810
[mk-proof] #4250 trans #4476 #4247 #4475
[mk-proof] #4226 mp #3351 #4250 #4362
[instance] 0x106832d78 #3351 ; 23
[attach-enode] #4510 23
[attach-enode] #3326 23
[attach-enode] #4248 23
[assign] #4248 justification -1: p50
[end-of-instance]
[eq-expl] #4510 root
[new-match] 0x106833018 #1477 #1476 #4510 #1545 ; #3326
[eq-expl] #4053 lit #4248 ; #3326
[eq-expl] #3326 root
[new-match] 0x106833050 #1522 #1506 #4510 #1545 ; #4054 (#4053 #3326)
[mk-app] #3584 = #4325 #4325
[mk-proof] #3449 refl #3584
[mk-app] #3578 or #1576 #4325
[mk-proof] #3048 quant-inst #3578
[instance] 0x106833018 #3048 ; 24
[attach-enode] #3344 24
[attach-enode] #4325 24
[assign] #4325 justification -1: p49
[end-of-instance]
[mk-app] #3584 = #3498 #3498
[mk-proof] #3449 refl #3584
[mk-app] #4269 or #3655 #3498
[mk-proof] #4258 quant-inst #4269
[instance] 0x106833050 #4258 ; 24
[attach-enode] #3346 24
[attach-enode] #3347 24
[attach-enode] #3353 24
[attach-enode] #4326 24
[attach-enode] #4330 24
[attach-enode] #3498 24
[mk-app] #3447 <= #4330 #1503
[mk-app] #4399 >= #4330 #1503
[assign] #3498 justification -1: p51
[end-of-instance]
[assign] #3447 clause p180 (not p179)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[assign] #4399 clause p181 (not p179)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 12::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 12::Int)))) 4::Int)) 

[mk-app] #3584 = #3353 #4054
[attach-meaning] #176 arith (- 1)
[mk-app] #3449 * #176 #4054
[mk-app] #4397 + #3353 #3449
[mk-app] #4264 <= #4397 #36
[mk-app] #4259 >= #4397 #36
[assign] #3584 justification -1: p177
[attach-enode] #3584 0
[attach-enode] #3449 0
[attach-enode] #4397 0
[assign] #4264 justification -1: p182
[assign] #4259 justification -1: p182
[new-match] 0x106833a98 #1495 #1483 #4510 #1545 ; #3346 (#3326 #3326)
[mk-app] #4260 = #3346 #3788
[mk-app] #4526 = #3412 #4260
[mk-proof] #4527 monotonicity #4216 #4526
[mk-app] #3628 or #1563 #4260
[mk-app] #3575 or #1563 #3412
[mk-proof] #3844 quant-inst #3575
[mk-app] #4594 = #3575 #3628
[mk-proof] #4537 monotonicity #4527 #4594
[mk-app] #4553 = #3628 #3628
[mk-proof] #3059 rewrite #4553
[mk-proof] #3060 trans #4537 #3059 #4594
[mk-proof] #3067 mp #3844 #3060 #3628
[instance] 0x106833a98 #3844 ; 25
[attach-enode] #3785 25
[attach-enode] #3788 25
[attach-enode] #4260 25
[assign] #4260 justification -1: p50
[end-of-instance]
[eq-expl] #3785 root
[new-match] 0x106833d38 #1477 #1476 #3785 #1545 ; #3788
[eq-expl] #3346 lit #4260 ; #3788
[eq-expl] #3788 root
[new-match] 0x106833d70 #1522 #1506 #3785 #1545 ; #3347 (#3346 #3788)
[mk-app] #3610 = #4136 #4136
[mk-proof] #4536 refl #3610
[mk-app] #3056 or #1576 #4136
[mk-proof] #3176 quant-inst #3056
[instance] 0x106833d38 #3176 ; 26
[attach-enode] #4233 26
[attach-enode] #4136 26
[assign] #4136 justification -1: p49
[end-of-instance]
[mk-app] #3610 = #3689 #3689
[mk-proof] #4536 refl #3610
[mk-app] #3742 or #3655 #3689
[mk-proof] #4026 quant-inst #3742
[instance] 0x106833d70 #4026 ; 26
[attach-enode] #4235 26
[attach-enode] #4237 26
[attach-enode] #4240 26
[attach-enode] #4137 26
[attach-enode] #4152 26
[attach-enode] #3689 26
[mk-app] #4033 <= #4152 #1503
[mk-app] #4032 >= #4152 #1503
[assign] #3689 justification -1: p51
[end-of-instance]
[assign] #4033 clause p188 (not p187)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[assign] #4032 clause p189 (not p187)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 13::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 13::Int)))) 4::Int)) 

[mk-app] #3610 = #3347 #4240
[attach-meaning] #176 arith (- 1)
[mk-app] #4536 + #3347 #4137
[mk-app] #4019 <= #4536 #36
[mk-app] #3305 >= #4536 #36
[assign] #3610 justification -1: p185
[attach-enode] #3610 0
[attach-enode] #4536 0
[assign] #4019 justification -1: p190
[assign] #3305 justification -1: p190
[new-match] 0x10683b398 #1495 #1483 #3785 #1545 ; #4235 (#3788 #3788)
[mk-app] #3298 = #4235 #2957
[mk-app] #4452 = #3495 #3298
[mk-proof] #4457 monotonicity #2959 #4452
[mk-app] #3542 or #1563 #3298
[mk-app] #3539 or #1563 #3495
[mk-proof] #3597 quant-inst #3539
[mk-app] #3598 = #3539 #3542
[mk-proof] #3963 monotonicity #4457 #3598
[mk-app] #4371 = #3542 #3542
[mk-proof] #3964 rewrite #4371
[mk-proof] #2995 trans #3963 #3964 #3598
[mk-proof] #3001 mp #3597 #2995 #3542
[instance] 0x10683b398 #3597 ; 27
[attach-enode] #2954 27
[attach-enode] #2957 27
[attach-enode] #3298 27
[assign] #3298 justification -1: p50
[end-of-instance]
[eq-expl] #2954 root
[new-match] 0x10683b638 #1477 #1476 #2954 #1545 ; #2957
[eq-expl] #4235 lit #3298 ; #2957
[eq-expl] #2957 root
[new-match] 0x10683b670 #1522 #1506 #2954 #1545 ; #4237 (#4235 #2957)
[mk-app] #3714 = #4218 #4218
[mk-proof] #3720 refl #3714
[mk-app] #3965 or #1576 #4218
[mk-proof] #4255 quant-inst #3965
[instance] 0x10683b638 #4255 ; 28
[attach-enode] #3638 28
[attach-enode] #4218 28
[assign] #4218 justification -1: p49
[end-of-instance]
[mk-app] #3714 = #2973 #2973
[mk-proof] #3720 refl #3714
[mk-app] #4304 or #3655 #2973
[mk-proof] #4110 quant-inst #4304
[instance] 0x10683b670 #4110 ; 28
[attach-enode] #3640 28
[attach-enode] #3641 28
[attach-enode] #4500 28
[attach-enode] #2971 28
[attach-enode] #4049 28
[attach-enode] #2973 28
[mk-app] #3753 <= #4049 #1503
[mk-app] #4656 >= #4049 #1503
[assign] #2973 justification -1: p51
[end-of-instance]
[assign] #3753 clause p196 (not p195)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[assign] #4656 clause p197 (not p195)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 14::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 14::Int)))) 4::Int)) 

[mk-app] #3714 = #4237 #4500
[attach-meaning] #176 arith (- 1)
[mk-app] #3720 + #4237 #2971
[mk-app] #4620 <= #3720 #36
[mk-app] #3671 >= #3720 #36
[assign] #3714 justification -1: p193
[attach-enode] #3714 0
[attach-enode] #3720 0
[assign] #4620 justification -1: p198
[assign] #3671 justification -1: p198
[new-match] 0x10683c030 #1495 #1483 #2954 #1545 ; #3640 (#2957 #2957)
[mk-app] #4653 = #3640 #3910
[mk-app] #4654 = #3352 #4653
[mk-proof] #4655 monotonicity #3912 #4654
[mk-app] #4621 or #1563 #4653
[mk-app] #4651 or #1563 #3352
[mk-proof] #4652 quant-inst #4651
[mk-app] #4657 = #4651 #4621
[mk-proof] #4658 monotonicity #4655 #4657
[mk-app] #4659 = #4621 #4621
[mk-proof] #4408 rewrite #4659
[mk-proof] #4731 trans #4658 #4408 #4657
[mk-proof] #4739 mp #4652 #4731 #4621
[instance] 0x10683c030 #4652 ; 29
[attach-enode] #3572 29
[attach-enode] #3910 29
[attach-enode] #4653 29
[assign] #4653 justification -1: p50
[end-of-instance]
[eq-expl] #3572 root
[new-match] 0x10683c2d0 #1477 #1476 #3572 #1545 ; #3910
[eq-expl] #3640 lit #4653 ; #3910
[eq-expl] #3910 root
[new-match] 0x10683c308 #1522 #1506 #3572 #1545 ; #3641 (#3640 #3910)
[mk-app] #4740 = #3914 #3914
[mk-proof] #4775 refl #4740
[mk-app] #4823 or #1576 #3914
[mk-proof] #4271 quant-inst #4823
[instance] 0x10683c2d0 #4271 ; 30
[attach-enode] #3009 30
[attach-enode] #3914 30
[assign] #3914 justification -1: p49
[end-of-instance]
[mk-app] #4740 = #3995 #3995
[mk-proof] #4775 refl #4740
[mk-app] #4754 or #3655 #3995
[mk-proof] #4768 quant-inst #4754
[instance] 0x10683c308 #4768 ; 30
[attach-enode] #3011 30
[attach-enode] #3012 30
[attach-enode] #3015 30
[attach-enode] #3006 30
[attach-enode] #3014 30
[attach-enode] #3995 30
[mk-app] #4774 <= #3014 #1503
[mk-app] #4824 >= #3014 #1503
[assign] #3995 justification -1: p51
[end-of-instance]
[assign] #4774 clause p204 (not p203)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[assign] #4824 clause p205 (not p203)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 15::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 15::Int)))) 4::Int)) 

[mk-app] #4740 = #3015 #3641
[attach-meaning] #176 arith (- 1)
[mk-app] #4775 * #176 #3641
[mk-app] #4807 + #3015 #4775
[mk-app] #4832 <= #4807 #36
[mk-app] #4850 >= #4807 #36
[assign] #4740 justification -1: p201
[attach-enode] #4740 0
[attach-enode] #4775 0
[attach-enode] #4807 0
[assign] #4832 justification -1: p206
[assign] #4850 justification -1: p206
[new-match] 0x106840f68 #1495 #1483 #3572 #1545 ; #3011 (#3910 #3910)
[mk-app] #4818 = #3011 #3725
[mk-app] #4427 = #4275 #4818
[mk-proof] #4857 monotonicity #3727 #4427
[mk-app] #4871 or #1563 #4818
[mk-app] #4929 or #1563 #4275
[mk-proof] #4934 quant-inst #4929
[mk-app] #4964 = #4929 #4871
[mk-proof] #4965 monotonicity #4857 #4964
[mk-app] #4966 = #4871 #4871
[mk-proof] #4969 rewrite #4966
[mk-proof] #4968 trans #4965 #4969 #4964
[mk-proof] #4963 mp #4934 #4968 #4871
[instance] 0x106840f68 #4934 ; 31
[attach-enode] #3722 31
[attach-enode] #3725 31
[attach-enode] #4818 31
[assign] #4818 justification -1: p50
[end-of-instance]
[eq-expl] #3722 root
[new-match] 0x106841208 #1477 #1476 #3722 #1545 ; #3725
[eq-expl] #3011 lit #4818 ; #3725
[eq-expl] #3725 root
[new-match] 0x106841240 #1522 #1506 #3722 #1545 ; #3012 (#3011 #3725)
[mk-app] #4979 = #4083 #4083
[mk-proof] #5006 refl #4979
[mk-app] #3297 or #1576 #4083
[mk-proof] #5047 quant-inst #3297
[instance] 0x106841208 #5047 ; 32
[attach-enode] #4002 32
[attach-enode] #4083 32
[assign] #4083 justification -1: p49
[end-of-instance]
[mk-app] #4979 = #3516 #3516
[mk-proof] #5006 refl #4979
[mk-app] #5096 or #3655 #3516
[mk-proof] #3776 quant-inst #5096
[instance] 0x106841240 #3776 ; 32
[attach-enode] #4004 32
[attach-enode] #4005 32
[attach-enode] #4009 32
[attach-enode] #4565 32
[attach-enode] #3524 32
[attach-enode] #3516 32
[mk-app] #5091 <= #3524 #1503
[mk-app] #5089 >= #3524 #1503
[assign] #3516 justification -1: p51
[end-of-instance]
[assign] #5091 clause p212 (not p211)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[assign] #5089 clause p213 (not p211)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 16::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 16::Int)))) 4::Int)) 

[mk-app] #4979 = #3012 #4009
[attach-meaning] #176 arith (- 1)
[mk-app] #5006 + #3012 #4565
[mk-app] #4195 <= #5006 #36
[mk-app] #5097 >= #5006 #36
[assign] #4979 justification -1: p209
[attach-enode] #4979 0
[attach-enode] #5006 0
[assign] #4195 justification -1: p214
[assign] #5097 justification -1: p214
[new-match] 0x106841c00 #1495 #1483 #3722 #1545 ; #4004 (#3725 #3725)
[mk-app] #3687 = #4004 #3633
[mk-app] #3890 = #4249 #3687
[mk-proof] #3892 monotonicity #3631 #3890
[mk-app] #3893 or #1563 #3687
[mk-app] #3601 or #1563 #4249
[mk-proof] #2989 quant-inst #3601
[mk-app] #3891 = #3601 #3893
[mk-proof] #3647 monotonicity #3892 #3891
[mk-app] #4518 = #3893 #3893
[mk-proof] #4354 rewrite #4518
[mk-proof] #3246 trans #3647 #4354 #3891
[mk-proof] #3241 mp #2989 #3246 #3893
[instance] 0x106841c00 #2989 ; 33
[attach-enode] #3632 33
[attach-enode] #3633 33
[attach-enode] #3687 33
[assign] #3687 justification -1: p50
[end-of-instance]
[eq-expl] #3632 root
[new-match] 0x106841ea0 #1477 #1476 #3632 #1545 ; #3633
[eq-expl] #4004 lit #3687 ; #3633
[eq-expl] #3633 root
[new-match] 0x106841ed8 #1522 #1506 #3632 #1545 ; #4005 (#4004 #3633)
[mk-app] #4069 = #2922 #2922
[mk-proof] #3187 refl #4069
[mk-app] #4070 or #1576 #2922
[mk-proof] #3364 quant-inst #4070
[instance] 0x106841ea0 #3364 ; 34
[attach-enode] #3596 34
[attach-enode] #2922 34
[assign] #2922 justification -1: p49
[end-of-instance]
[mk-app] #4069 = #4522 #4522
[mk-proof] #3187 refl #4069
[mk-app] #3156 or #3655 #4522
[mk-proof] #3829 quant-inst #3156
[instance] 0x106841ed8 #3829 ; 34
[attach-enode] #4533 34
[attach-enode] #3367 34
[attach-enode] #3370 34
[attach-enode] #4592 34
[attach-enode] #3774 34
[attach-enode] #4522 34
[mk-app] #3754 <= #3774 #1503
[mk-app] #3037 >= #3774 #1503
[assign] #4522 justification -1: p51
[end-of-instance]
[assign] #3754 clause p220 (not p219)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[assign] #3037 clause p221 (not p219)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 17::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 17::Int)))) 4::Int)) 

[mk-app] #4069 = #3370 #4005
[attach-meaning] #176 arith (- 1)
[mk-app] #3187 * #176 #4005
[mk-app] #3656 + #3370 #3187
[mk-app] #3155 <= #3656 #36
[mk-app] #3149 >= #3656 #36
[assign] #4069 justification -1: p217
[attach-enode] #4069 0
[attach-enode] #3187 0
[attach-enode] #3656 0
[assign] #3155 justification -1: p222
[assign] #3149 justification -1: p222
[new-match] 0x106842920 #1495 #1483 #3632 #1545 ; #4533 (#3633 #3633)
[mk-app] #3150 = #4533 #3803
[mk-app] #3145 = #3051 #3150
[mk-proof] #4616 monotonicity #4273 #3145
[mk-app] #4080 or #1563 #3150
[mk-app] #4081 or #1563 #3051
[mk-proof] #4478 quant-inst #4081
[mk-app] #4479 = #4081 #4080
[mk-proof] #4369 monotonicity #4616 #4479
[mk-app] #4377 = #4080 #4080
[mk-proof] #4668 rewrite #4377
[mk-proof] #4675 trans #4369 #4668 #4479
[mk-proof] #3939 mp #4478 #4675 #4080
[instance] 0x106842920 #4478 ; 35
[attach-enode] #3800 35
[attach-enode] #3803 35
[attach-enode] #3150 35
[assign] #3150 justification -1: p50
[end-of-instance]
[eq-expl] #3800 root
[new-match] 0x106842bc0 #1477 #1476 #3800 #1545 ; #3803
[eq-expl] #4533 lit #3150 ; #3803
[eq-expl] #3803 root
[new-match] 0x106827e10 #1522 #1506 #3800 #1545 ; #3367 (#4533 #3803)
[mk-app] #4667 = #4270 #4270
[mk-proof] #3865 refl #4667
[mk-app] #3860 or #1576 #4270
[mk-proof] #3862 quant-inst #3860
[instance] 0x106842bc0 #3862 ; 36
[attach-enode] #4289 36
[attach-enode] #4270 36
[assign] #4270 justification -1: p49
[end-of-instance]
[mk-app] #4667 = #3458 #3458
[mk-proof] #3865 refl #4667
[mk-app] #4700 or #3655 #3458
[mk-proof] #3484 quant-inst #4700
[instance] 0x106827e10 #3484 ; 36
[attach-enode] #4292 36
[attach-enode] #4293 36
[attach-enode] #4297 36
[attach-enode] #3460 36
[attach-enode] #3378 36
[attach-enode] #3458 36
[mk-app] #3077 <= #3378 #1503
[mk-app] #3881 >= #3378 #1503
[assign] #3458 justification -1: p51
[end-of-instance]
[assign] #3077 clause p228 (not p227)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[assign] #3881 clause p229 (not p227)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 18::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 18::Int)))) 4::Int)) 

[mk-app] #4667 = #3367 #4297
[attach-meaning] #176 arith (- 1)
[mk-app] #3865 + #3367 #3460
[mk-app] #3882 <= #3865 #36
[mk-app] #3779 >= #3865 #36
[assign] #4667 justification -1: p225
[attach-enode] #4667 0
[attach-enode] #3865 0
[assign] #3882 justification -1: p230
[assign] #3779 justification -1: p230
[new-match] 0x1068287d0 #1495 #1483 #3800 #1545 ; #4292 (#3803 #3803)
[mk-app] #3780 = #4292 #3118
[mk-app] #3777 = #3066 #3780
[mk-proof] #3323 monotonicity #3120 #3777
[mk-app] #3661 or #1563 #3780
[mk-app] #4599 or #1563 #3066
[mk-proof] #4130 quant-inst #4599
[mk-app] #3211 = #4599 #3661
[mk-proof] #3212 monotonicity #3323 #3211
[mk-app] #3658 = #3661 #3661
[mk-proof] #4600 rewrite #3658
[mk-proof] #4487 trans #3212 #4600 #3211
[mk-proof] #4488 mp #4130 #4487 #3661
[instance] 0x1068287d0 #4130 ; 37
[attach-enode] #4573 37
[attach-enode] #3118 37
[attach-enode] #3780 37
[assign] #3780 justification -1: p50
[end-of-instance]
[eq-expl] #4573 root
[new-match] 0x106828a70 #1477 #1476 #4573 #1545 ; #3118
[eq-expl] #4292 lit #3780 ; #3118
[eq-expl] #3118 root
[new-match] 0x106828aa8 #1522 #1506 #4573 #1545 ; #4293 (#4292 #3118)
[mk-app] #4639 = #4024 #4024
[mk-proof] #4817 refl #4639
[mk-app] #4752 or #1576 #4024
[mk-proof] #4758 quant-inst #4752
[instance] 0x106828a70 #4758 ; 38
[attach-enode] #3133 38
[attach-enode] #4024 38
[assign] #4024 justification -1: p49
[end-of-instance]
[mk-app] #4639 = #3299 #3299
[mk-proof] #4817 refl #4639
[mk-app] #4794 or #3655 #3299
[mk-proof] #4924 quant-inst #4794
[instance] 0x106828aa8 #4924 ; 38
[attach-enode] #3135 38
[attach-enode] #3136 38
[attach-enode] #3140 38
[attach-enode] #4025 38
[attach-enode] #3304 38
[attach-enode] #3299 38
[mk-app] #5157 <= #3304 #1503
[mk-app] #4797 >= #3304 #1503
[assign] #3299 justification -1: p51
[end-of-instance]
[assign] #5157 clause p236 (not p235)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[assign] #4797 clause p237 (not p235)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 19::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 19::Int)))) 4::Int)) 

[mk-app] #4639 = #3140 #4293
[attach-meaning] #176 arith (- 1)
[mk-app] #4817 * #176 #4293
[mk-app] #4830 + #3140 #4817
[mk-app] #5029 <= #4830 #36
[mk-app] #4946 >= #4830 #36
[assign] #4639 justification -1: p233
[attach-enode] #4639 0
[attach-enode] #4817 0
[attach-enode] #4830 0
[assign] #5029 justification -1: p238
[assign] #4946 justification -1: p238
[new-match] 0x1068294f0 #1495 #1483 #4573 #1545 ; #3135 (#3118 #3118)
[mk-app] #4911 = #3135 #3165
[mk-app] #4912 = #4571 #4911
[mk-proof] #4888 monotonicity #3167 #4912
[mk-app] #5028 or #1563 #4911
[mk-app] #4947 or #1563 #4571
[mk-proof] #4990 quant-inst #4947
[mk-app] #4985 = #4947 #5028
[mk-proof] #4160 monotonicity #4888 #4985
[mk-app] #4161 = #5028 #5028
[mk-proof] #4165 rewrite #4161
[mk-proof] #4931 trans #4160 #4165 #4985
[mk-proof] #4171 mp #4990 #4931 #5028
[instance] 0x1068294f0 #4990 ; 39
[attach-enode] #3161 39
[attach-enode] #3165 39
[attach-enode] #4911 39
[assign] #4911 justification -1: p50
[end-of-instance]
[eq-expl] #3161 root
[new-match] 0x106829790 #1477 #1476 #3161 #1545 ; #3165
[eq-expl] #3135 lit #4911 ; #3165
[eq-expl] #3165 root
[new-match] 0x1068297c8 #1522 #1506 #3161 #1545 ; #3136 (#3135 #3165)
[mk-app] #4865 = #3188 #3188
[mk-proof] #4826 refl #4865
[mk-app] #5093 or #1576 #3188
[mk-proof] #5054 quant-inst #5093
[instance] 0x106829790 #5054 ; 40
[attach-enode] #3745 40
[attach-enode] #3188 40
[assign] #3188 justification -1: p49
[end-of-instance]
[mk-app] #4865 = #4315 #4315
[mk-proof] #4826 refl #4865
[mk-app] #3906 or #3655 #4315
[mk-proof] #4367 quant-inst #3906
[instance] 0x1068297c8 #4367 ; 40
[attach-enode] #3747 40
[attach-enode] #3748 40
[attach-enode] #4076 40
[attach-enode] #3189 40
[attach-enode] #3207 40
[attach-enode] #4315 40
[mk-app] #3676 <= #3207 #1503
[mk-app] #3467 >= #3207 #1503
[assign] #4315 justification -1: p51
[end-of-instance]
[assign] #3676 clause p244 (not p243)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[assign] #3467 clause p245 (not p243)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 20::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 20::Int)))) 4::Int)) 

[mk-app] #4865 = #3136 #4076
[attach-meaning] #176 arith (- 1)
[mk-app] #4826 + #3136 #3189
[mk-app] #3355 <= #4826 #36
[mk-app] #5050 >= #4826 #36
[assign] #4865 justification -1: p241
[attach-enode] #4865 0
[attach-enode] #4826 0
[assign] #3355 justification -1: p246
[assign] #5050 justification -1: p246
[new-match] 0x106859bb8 #1495 #1483 #3161 #1545 ; #3747 (#3165 #3165)
[mk-app] #3793 = #3747 #4100
[mk-app] #4365 = #3670 #3793
[mk-proof] #4366 monotonicity #4102 #4365
[mk-app] #3905 or #1563 #3793
[mk-app] #3857 or #1563 #3670
[mk-proof] #4300 quant-inst #3857
[mk-app] #3799 = #3857 #3905
[mk-proof] #5049 monotonicity #4366 #3799
[mk-app] #2935 = #3905 #3905
[mk-proof] #4173 rewrite #2935
[mk-proof] #5051 trans #5049 #4173 #3799
[mk-proof] #5058 mp #4300 #5051 #3905
[instance] 0x106859bb8 #4300 ; 41
[attach-enode] #4096 41
[attach-enode] #4100 41
[attach-enode] #3793 41
[assign] #3793 justification -1: p50
[end-of-instance]
[eq-expl] #4096 root
[new-match] 0x106859e58 #1477 #1476 #4096 #1545 ; #4100
[eq-expl] #3747 lit #3793 ; #4100
[eq-expl] #4100 root
[new-match] 0x106859e90 #1522 #1506 #4096 #1545 ; #3748 (#3747 #4100)
[mk-app] #4243 = #4660 #4660
[mk-proof] #4244 refl #4243
[mk-app] #5086 or #1576 #4660
[mk-proof] #3239 quant-inst #5086
[instance] 0x106859e58 #3239 ; 42
[attach-enode] #3520 42
[attach-enode] #4660 42
[assign] #4660 justification -1: p49
[end-of-instance]
[mk-app] #4243 = #4784 #4784
[mk-proof] #4244 refl #4243
[mk-app] #3980 or #3655 #4784
[mk-proof] #3501 quant-inst #3980
[instance] 0x106859e90 #3501 ; 42
[attach-enode] #3522 42
[attach-enode] #3523 42
[attach-enode] #3526 42
[attach-enode] #3454 42
[attach-enode] #3455 42
[attach-enode] #4784 42
[mk-app] #3390 <= #3455 #1503
[mk-app] #3812 >= #3455 #1503
[assign] #4784 justification -1: p51
[end-of-instance]
[assign] #3390 clause p252 (not p251)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[assign] #3812 clause p253 (not p251)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 21::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 21::Int)))) 4::Int)) 

[mk-app] #4243 = #3526 #3748
[attach-meaning] #176 arith (- 1)
[mk-app] #4244 * #176 #3748
[mk-app] #3813 + #3526 #4244
[mk-app] #3504 <= #3813 #36
[mk-app] #3508 >= #3813 #36
[assign] #4243 justification -1: p249
[attach-enode] #4243 0
[attach-enode] #4244 0
[attach-enode] #3813 0
[assign] #3504 justification -1: p254
[assign] #3508 justification -1: p254
[new-match] 0x10685a8d8 #1495 #1483 #4096 #1545 ; #3522 (#4100 #4100)
[mk-app] #2934 = #3522 #3901
[mk-app] #3509 = #4268 #2934
[mk-proof] #3405 monotonicity #4448 #3509
[mk-app] #3410 or #1563 #2934
[mk-app] #3244 or #1563 #4268
[mk-proof] #4134 quant-inst #3244
[mk-app] #3260 = #3244 #3410
[mk-proof] #3095 monotonicity #3405 #3260
[mk-app] #3332 = #3410 #3410
[mk-proof] #3736 rewrite #3332
[mk-proof] #3340 trans #3095 #3736 #3260
[mk-proof] #4538 mp #4134 #3340 #3410
[instance] 0x10685a8d8 #4134 ; 43
[attach-enode] #3898 43
[attach-enode] #3901 43
[attach-enode] #2934 43
[assign] #2934 justification -1: p50
[end-of-instance]
[eq-expl] #3898 root
[new-match] 0x10685ab78 #1477 #1476 #3898 #1545 ; #3901
[eq-expl] #3522 lit #2934 ; #3901
[eq-expl] #3901 root
[new-match] 0x10685abb0 #1522 #1506 #3898 #1545 ; #3523 (#3522 #3901)
[mk-app] #4539 = #4895 #4895
[mk-proof] #3342 refl #4539
[mk-app] #3702 or #1576 #4895
[mk-proof] #3701 quant-inst #3702
[instance] 0x10685ab78 #3701 ; 44
[attach-enode] #4462 44
[attach-enode] #4895 44
[assign] #4895 justification -1: p49
[end-of-instance]
[mk-app] #4539 = #4893 #4893
[mk-proof] #3342 refl #4539
[mk-app] #3594 or #3655 #4893
[mk-proof] #3595 quant-inst #3594
[instance] 0x10685abb0 #3595 ; 44
[attach-enode] #4464 44
[attach-enode] #4465 44
[attach-enode] #4469 44
[attach-enode] #4896 44
[attach-enode] #4856 44
[attach-enode] #4893 44
[mk-app] #3590 <= #4856 #1503
[mk-app] #3368 >= #4856 #1503
[assign] #4893 justification -1: p51
[end-of-instance]
[assign] #3590 clause p260 (not p259)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[assign] #3368 clause p261 (not p259)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 22::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 22::Int)))) 4::Int)) 

[mk-app] #4539 = #3523 #4469
[attach-meaning] #176 arith (- 1)
[mk-app] #3342 + #3523 #4896
[mk-app] #3369 <= #3342 #36
[mk-app] #3121 >= #3342 #36
[assign] #4539 justification -1: p257
[attach-enode] #4539 0
[attach-enode] #3342 0
[assign] #3369 justification -1: p262
[assign] #3121 justification -1: p262
[new-match] 0x10685b570 #1495 #1483 #3898 #1545 ; #4464 (#3901 #3901)
[mk-app] #3358 = #4464 #3435
[mk-app] #4015 = #4930 #3358
[mk-proof] #2925 monotonicity #3437 #4015
[mk-app] #3546 or #1563 #3358
[mk-app] #3547 or #1563 #4930
[mk-proof] #3540 quant-inst #3547
[mk-app] #3541 = #3547 #3546
[mk-proof] #2926 monotonicity #2925 #3541
[mk-app] #3635 = #3546 #3546
[mk-proof] #3626 rewrite #3635
[mk-proof] #3374 trans #2926 #3626 #3541
[mk-proof] #4403 mp #3540 #3374 #3546
[instance] 0x10685b570 #3540 ; 45
[attach-enode] #3432 45
[attach-enode] #3435 45
[attach-enode] #3358 45
[assign] #3358 justification -1: p50
[end-of-instance]
[eq-expl] #3432 root
[new-match] 0x106862858 #1477 #1476 #3432 #1545 ; #3435
[eq-expl] #4464 lit #3358 ; #3435
[eq-expl] #3435 root
[new-match] 0x106862890 #1522 #1506 #3432 #1545 ; #4465 (#4464 #3435)
[mk-app] #4395 = #5057 #5057
[mk-proof] #4531 refl #4395
[mk-app] #4402 or #1576 #5057
[mk-proof] #3302 quant-inst #4402
[instance] 0x106862858 #3302 ; 46
[attach-enode] #3856 46
[attach-enode] #5057 46
[assign] #5057 justification -1: p49
[end-of-instance]
[mk-app] #4395 = #5090 #5090
[mk-proof] #4531 refl #4395
[mk-app] #4207 or #3655 #5090
[mk-proof] #4404 quant-inst #4207
[instance] 0x106862890 #4404 ; 46
[attach-enode] #3858 46
[attach-enode] #3859 46
[attach-enode] #4364 46
[attach-enode] #5084 46
[attach-enode] #5085 46
[attach-enode] #5090 46
[mk-app] #4405 <= #5085 #1503
[mk-app] #4407 >= #5085 #1503
[assign] #5090 justification -1: p51
[end-of-instance]
[assign] #4405 clause p268 (not p267)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[assign] #4407 clause p269 (not p267)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 23::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 23::Int)))) 4::Int)) 

[mk-app] #4395 = #4364 #4465
[attach-meaning] #176 arith (- 1)
[mk-app] #4531 * #176 #4465
[mk-app] #4419 + #4364 #4531
[mk-app] #4424 <= #4419 #36
[mk-app] #4090 >= #4419 #36
[assign] #4395 justification -1: p265
[attach-enode] #4395 0
[attach-enode] #4531 0
[attach-enode] #4419 0
[assign] #4424 justification -1: p270
[assign] #4090 justification -1: p270
[new-match] 0x1068632d8 #1495 #1483 #3432 #1545 ; #3858 (#3435 #3435)
[mk-app] #4415 = #3858 #4385
[mk-app] #4418 = #3686 #4415
[mk-proof] #4091 monotonicity #4580 #4418
[mk-app] #3534 or #1563 #4415
[mk-app] #4039 or #1563 #3686
[mk-proof] #3428 quant-inst #4039
[mk-app] #4203 = #4039 #3534
[mk-proof] #4209 monotonicity #4091 #4203
[mk-app] #4555 = #3534 #3534
[mk-proof] #2911 rewrite #4555
[mk-proof] #4482 trans #4209 #2911 #4203
[mk-proof] #4505 mp #3428 #4482 #3534
[instance] 0x1068632d8 #3428 ; 47
[attach-enode] #4382 47
[attach-enode] #4385 47
[attach-enode] #4415 47
[assign] #4415 justification -1: p50
[end-of-instance]
[eq-expl] #4382 root
[new-match] 0x106863578 #1477 #1476 #4382 #1545 ; #4385
[eq-expl] #3858 lit #4415 ; #4385
[eq-expl] #4385 root
[new-match] 0x1068635b0 #1522 #1506 #4382 #1545 ; #3859 (#3858 #4385)
[mk-app] #4113 = #3691 #3691
[mk-proof] #4554 refl #4113
[mk-app] #4887 or #1576 #3691
[mk-proof] #4816 quant-inst #4887
[instance] 0x106863578 #4816 ; 48
[attach-enode] #3550 48
[attach-enode] #3691 48
[assign] #3691 justification -1: p49
[end-of-instance]
[mk-app] #4113 = #3362 #3362
[mk-proof] #4554 refl #4113
[mk-app] #4691 or #3655 #3362
[mk-proof] #4809 quant-inst #4691
[instance] 0x1068635b0 #4809 ; 48
[attach-enode] #3552 48
[attach-enode] #3553 48
[attach-enode] #3903 48
[attach-enode] #3692 48
[attach-enode] #4062 48
[attach-enode] #3362 48
[mk-app] #3481 <= #4062 #1503
[mk-app] #4948 >= #4062 #1503
[assign] #3362 justification -1: p51
[end-of-instance]
[assign] #3481 clause p276 (not p275)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[assign] #4948 clause p277 (not p275)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 24::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 24::Int)))) 4::Int)) 

[mk-app] #4113 = #3859 #3903
[attach-meaning] #176 arith (- 1)
[mk-app] #4554 + #3859 #3692
[mk-app] #4890 <= #4554 #36
[mk-app] #4046 >= #4554 #36
[assign] #4113 justification -1: p273
[attach-enode] #4113 0
[attach-enode] #4554 0
[assign] #4890 justification -1: p278
[assign] #4046 justification -1: p278
[new-match] 0x106863f70 #1495 #1483 #4382 #1545 ; #3552 (#4385 #4385)
[mk-app] #4933 = #3552 #3805
[mk-app] #4940 = #3038 #4933
[mk-proof] #4941 monotonicity #3807 #4940
[mk-app] #4932 or #1563 #4933
[mk-app] #3877 or #1563 #3038
[mk-proof] #5081 quant-inst #3877
[mk-app] #4358 = #3877 #4932
[mk-proof] #4099 monotonicity #4941 #4358
[mk-app] #3564 = #4932 #4932
[mk-proof] #2948 rewrite #3564
[mk-proof] #3763 trans #4099 #2948 #4358
[mk-proof] #4601 mp #5081 #3763 #4932
[instance] 0x106863f70 #5081 ; 49
[attach-enode] #4548 49
[attach-enode] #3805 49
[attach-enode] #4933 49
[assign] #4933 justification -1: p50
[end-of-instance]
[eq-expl] #4548 root
[new-match] 0x106864210 #1477 #1476 #4548 #1545 ; #3805
[eq-expl] #3552 lit #4933 ; #3805
[eq-expl] #3805 root
[new-match] 0x106864248 #1522 #1506 #4548 #1545 ; #3553 (#3552 #3805)
[mk-app] #3097 = #4617 #4617
[mk-proof] #2950 refl #3097
[mk-app] #3827 or #1576 #4617
[mk-proof] #3375 quant-inst #3827
[instance] 0x106864210 #3375 ; 50
[attach-enode] #4256 50
[attach-enode] #4617 50
[assign] #4617 justification -1: p49
[end-of-instance]
[mk-app] #3097 = #4695 #4695
[mk-proof] #2950 refl #3097
[mk-app] #3937 or #3655 #4695
[mk-proof] #3941 quant-inst #3937
[instance] 0x106864248 #3941 ; 50
[attach-enode] #4302 50
[attach-enode] #4303 50
[attach-enode] #4307 50
[attach-enode] #4612 50
[attach-enode] #4615 50
[attach-enode] #4695 50
[mk-app] #3420 <= #4615 #1503
[mk-app] #3425 >= #4615 #1503
[assign] #4695 justification -1: p51
[end-of-instance]
[assign] #3420 clause p284 (not p283)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[assign] #3425 clause p285 (not p283)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 25::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 25::Int)))) 4::Int)) 

[mk-app] #3097 = #3553 #4307
[attach-meaning] #176 arith (- 1)
[mk-app] #2950 + #3553 #4612
[mk-app] #4791 <= #2950 #36
[mk-app] #4833 >= #2950 #36
[assign] #3097 justification -1: p281
[attach-enode] #3097 0
[attach-enode] #2950 0
[assign] #4791 justification -1: p286
[assign] #4833 justification -1: p286
[new-match] 0x106867618 #1495 #1483 #4548 #1545 ; #4302 (#3805 #3805)
[mk-app] #3976 = #4302 #2919
[mk-app] #3209 = #4313 #3976
[mk-proof] #4750 monotonicity #2921 #3209
[mk-app] #4742 or #1563 #3976
[mk-app] #4986 or #1563 #4313
[mk-proof] #4829 quant-inst #4986
[mk-app] #4063 = #4986 #4742
[mk-proof] #3021 monotonicity #4750 #4063
[mk-app] #4722 = #4742 #4742
[mk-proof] #4709 rewrite #4722
[mk-proof] #3101 trans #3021 #4709 #4063
[mk-proof] #5023 mp #4829 #3101 #4742
[instance] 0x106867618 #4829 ; 51
[attach-enode] #2916 51
[attach-enode] #2919 51
[attach-enode] #3976 51
[assign] #3976 justification -1: p50
[end-of-instance]
[eq-expl] #2916 root
[new-match] 0x1068678b8 #1477 #1476 #2916 #1545 ; #2919
[eq-expl] #4302 lit #3976 ; #2919
[eq-expl] #2919 root
[new-match] 0x1068678f0 #1522 #1506 #2916 #1545 ; #4303 (#4302 #2919)
[mk-app] #4944 = #4738 #4738
[mk-proof] #4984 refl #4944
[mk-app] #4127 or #1576 #4738
[mk-proof] #4633 quant-inst #4127
[instance] 0x1068678b8 #4633 ; 52
[attach-enode] #3685 52
[attach-enode] #4738 52
[assign] #4738 justification -1: p49
[end-of-instance]
[mk-app] #4944 = #4737 #4737
[mk-proof] #4984 refl #4944
[mk-app] #2915 or #3655 #4737
[mk-proof] #4257 quant-inst #2915
[instance] 0x1068678f0 #4257 ; 52
[attach-enode] #3771 52
[attach-enode] #3772 52
[attach-enode] #3775 52
[attach-enode] #4745 52
[attach-enode] #4736 52
[attach-enode] #4737 52
[mk-app] #3020 <= #4736 #1503
[mk-app] #3392 >= #4736 #1503
[assign] #4737 justification -1: p51
[end-of-instance]
[assign] #3020 clause p292 (not p291)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[assign] #3392 clause p293 (not p291)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 26::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 26::Int)))) 4::Int)) 

[mk-app] #4944 = #3775 #4303
[attach-meaning] #176 arith (- 1)
[mk-app] #4984 * #176 #4303
[mk-app] #3084 + #3775 #4984
[mk-app] #4331 <= #3084 #36
[mk-app] #3018 >= #3084 #36
[assign] #4944 justification -1: p289
[attach-enode] #4944 0
[attach-enode] #4984 0
[attach-enode] #3084 0
[assign] #4331 justification -1: p294
[assign] #3018 justification -1: p294
[new-match] 0x106868338 #1495 #1483 #2916 #1545 ; #3771 (#2919 #2919)
[mk-app] #3019 = #3771 #4561
[mk-app] #3030 = #4756 #3019
[mk-proof] #4107 monotonicity #3917 #3030
[mk-app] #4341 or #1563 #3019
[mk-app] #4333 or #1563 #4756
[mk-proof] #2966 quant-inst #4333
[mk-app] #2963 = #4333 #4341
[mk-proof] #3280 monotonicity #4107 #2963
[mk-app] #4168 = #4341 #4341
[mk-proof] #3148 rewrite #4168
[mk-proof] #3533 trans #3280 #3148 #2963
[mk-proof] #3338 mp #2966 #3533 #4341
[instance] 0x106868338 #2966 ; 53
[attach-enode] #3947 53
[attach-enode] #4561 53
[attach-enode] #3019 53
[assign] #3019 justification -1: p50
[end-of-instance]
[eq-expl] #3947 root
[new-match] 0x1068685d8 #1477 #1476 #3947 #1545 ; #4561
[eq-expl] #3771 lit #3019 ; #4561
[eq-expl] #4561 root
[new-match] 0x106868610 #1522 #1506 #3947 #1545 ; #3772 (#3771 #4561)
[mk-app] #2938 = #4757 #4757
[mk-proof] #3334 refl #2938
[mk-app] #3329 or #1576 #4757
[mk-proof] #3740 quant-inst #3329
[instance] 0x1068685d8 #3740 ; 54
[attach-enode] #3581 54
[attach-enode] #4757 54
[assign] #4757 justification -1: p49
[end-of-instance]
[mk-app] #2938 + #4713 #4529
[inst-discovered] theory-solving 0x0 arith# ; #4751
[mk-app] #3334 = #4751 #2938
[mk-proof] #3339 rewrite #3334
[instance] 0x0 #3334
[end-of-instance]
[mk-app] #4566 = #2938 #1503
[mk-app] #4567 = #4796 #4566
[mk-proof] #4238 monotonicity #3339 #4567
[attach-meaning] #176 arith (- 1)
[mk-app] #4239 * #176 #4529
[mk-app] #3637 + #3585 #4239
[attach-meaning] #4108 arith (- 4)
[mk-app] #4016 = #3637 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4566
[mk-app] #3989 = #4566 #4016
[mk-proof] #3124 rewrite #3989
[instance] 0x0 #3989
[end-of-instance]
[mk-app] #4453 = #4796 #4016
[mk-proof] #3525 trans #4238 #3124 #4453
[mk-app] #3512 or #3655 #4016
[mk-app] #3519 or #3655 #4796
[mk-proof] #3532 quant-inst #3519
[mk-app] #3543 = #3519 #3512
[mk-proof] #4263 monotonicity #3525 #3543
[mk-app] #3840 = #3512 #3512
[mk-proof] #3045 rewrite #3840
[mk-proof] #3842 trans #4263 #3045 #3543
[mk-proof] #4428 mp #3532 #3842 #3512
[instance] 0x106868610 #3532 ; 54
[attach-enode] #3585 54
[attach-enode] #4528 54
[attach-enode] #4529 54
[attach-enode] #4239 54
[attach-enode] #3637 54
[attach-enode] #4016 54
[mk-app] #4262 <= #3637 #4108
[mk-app] #3841 >= #3637 #4108
[assign] #4016 justification -1: p51
[end-of-instance]
[assign] #4262 clause p300 (not p299)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[assign] #3841 clause p301 (not p299)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 27::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 27::Int))))) -4::Int)) 

[mk-app] #4430 = #3585 #3772
[attach-meaning] #176 arith (- 1)
[mk-app] #3471 * #176 #3772
[mk-app] #3472 + #3585 #3471
[mk-app] #4431 <= #3472 #36
[mk-app] #4432 >= #3472 #36
[assign] #4430 justification -1: p297
[attach-enode] #4430 0
[attach-enode] #3471 0
[attach-enode] #3472 0
[assign] #4431 justification -1: p302
[assign] #4432 justification -1: p302
[new-match] 0x106869058 #1495 #1483 #3947 #1545 ; #4528 (#4561 #4561)
[mk-app] #3303 = #4528 #4392
[mk-app] #3309 = #3603 #3303
[mk-proof] #2996 monotonicity #4394 #3309
[mk-app] #2999 or #1563 #3303
[mk-app] #4701 or #1563 #3603
[mk-proof] #4706 quant-inst #4701
[mk-app] #4489 = #4701 #2999
[mk-proof] #4598 monotonicity #2996 #4489
[mk-app] #4614 = #2999 #2999
[mk-proof] #4715 rewrite #4614
[mk-proof] #5046 trans #4598 #4715 #4489
[mk-proof] #5018 mp #4706 #5046 #2999
[instance] 0x106869058 #4706 ; 55
[attach-enode] #4389 55
[attach-enode] #4392 55
[attach-enode] #3303 55
[assign] #3303 justification -1: p50
[end-of-instance]
[eq-expl] #4389 root
[new-match] 0x106847b60 #1477 #1476 #4389 #1545 ; #4392
[eq-expl] #4528 lit #3303 ; #4392
[eq-expl] #4392 root
[new-match] 0x106847b98 #1522 #1506 #4389 #1545 ; #4529 (#4528 #4392)
[mk-app] #4848 = #4290 #4290
[mk-proof] #4849 refl #4848
[mk-app] #4852 or #1576 #4290
[mk-proof] #5045 quant-inst #4852
[instance] 0x106847b60 #5045 ; 56
[attach-enode] #4409 56
[attach-enode] #4290 56
[assign] #4290 justification -1: p49
[end-of-instance]
[mk-app] #4848 + #3134 #4582
[inst-discovered] theory-solving 0x0 arith# ; #4572
[mk-app] #4849 = #4572 #4848
[mk-proof] #5105 rewrite #4849
[instance] 0x0 #4849
[end-of-instance]
[mk-app] #3265 = #4848 #1503
[mk-app] #3103 = #3354 #3265
[mk-proof] #3040 monotonicity #5105 #3103
[attach-meaning] #176 arith (- 1)
[mk-app] #3933 * #176 #4582
[mk-app] #3864 + #3791 #3933
[attach-meaning] #4108 arith (- 4)
[mk-app] #4089 = #3864 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3265
[mk-app] #4372 = #3265 #4089
[mk-proof] #3863 rewrite #4372
[instance] 0x0 #4372
[end-of-instance]
[mk-app] #3845 = #3354 #4089
[mk-proof] #4568 trans #3040 #3863 #3845
[mk-app] #4678 or #3655 #4089
[mk-app] #4719 or #3655 #3354
[mk-proof] #4913 quant-inst #4719
[mk-app] #4914 = #4719 #4678
[mk-proof] #5062 monotonicity #4568 #4914
[mk-app] #5190 = #4678 #4678
[mk-proof] #5061 rewrite #5190
[mk-proof] #3474 trans #5062 #5061 #4914
[mk-proof] #3792 mp #4913 #3474 #4678
[instance] 0x106847b98 #4913 ; 56
[attach-enode] #3791 56
[attach-enode] #4411 56
[attach-enode] #4582 56
[attach-enode] #3933 56
[attach-enode] #3864 56
[attach-enode] #4089 56
[mk-app] #3035 <= #3864 #4108
[mk-app] #3990 >= #3864 #4108
[assign] #4089 justification -1: p51
[end-of-instance]
[assign] #3035 clause p308 (not p307)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[assign] #3990 clause p309 (not p307)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 28::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 28::Int))))) -4::Int)) 

[mk-app] #3700 = #3791 #4529
[attach-meaning] #176 arith (- 1)
[mk-app] #4593 + #3791 #4239
[mk-app] #3087 <= #4593 #36
[mk-app] #3088 >= #4593 #36
[assign] #3700 justification -1: p305
[attach-enode] #3700 0
[attach-enode] #4593 0
[assign] #3087 justification -1: p310
[assign] #3088 justification -1: p310
[new-match] 0x106848558 #1495 #1483 #4389 #1545 ; #4411 (#4392 #4392)
[mk-app] #3008 = #4411 #3923
[mk-app] #3013 = #3243 #3008
[mk-proof] #4082 monotonicity #3925 #3013
[mk-app] #4104 or #1563 #3008
[mk-app] #3122 or #1563 #3243
[mk-proof] #3129 quant-inst #3122
[mk-app] #4498 = #3122 #4104
[mk-proof] #4618 monotonicity #4082 #4498
[mk-app] #4515 = #4104 #4104
[mk-proof] #4623 rewrite #4515
[mk-proof] #3557 trans #4618 #4623 #4498
[mk-proof] #4158 mp #3129 #3557 #4104
[instance] 0x106848558 #3129 ; 57
[attach-enode] #3887 57
[attach-enode] #3923 57
[attach-enode] #3008 57
[assign] #3008 justification -1: p50
[end-of-instance]
[eq-expl] #3887 root
[new-match] 0x1068487f8 #1477 #1476 #3887 #1545 ; #3923
[eq-expl] #4411 lit #3008 ; #3923
[eq-expl] #3923 root
[new-match] 0x106848830 #1522 #1506 #3887 #1545 ; #4582 (#4411 #3923)
[mk-app] #5083 = #3591 #3591
[mk-proof] #3062 refl #5083
[mk-app] #3975 or #1576 #3591
[mk-proof] #2945 quant-inst #3975
[instance] 0x1068487f8 #2945 ; 58
[attach-enode] #3466 58
[attach-enode] #3591 58
[assign] #3591 justification -1: p49
[end-of-instance]
[mk-app] #5083 = #3376 #3376
[mk-proof] #3062 refl #5083
[mk-app] #5060 or #3655 #3376
[mk-proof] #5256 quant-inst #5060
[instance] 0x106848830 #5256 ; 58
[attach-enode] #3468 58
[attach-enode] #3469 58
[attach-enode] #3473 58
[attach-enode] #3991 58
[attach-enode] #3986 58
[attach-enode] #3376 58
[mk-app] #4644 <= #3986 #1503
[mk-app] #4820 >= #3986 #1503
[assign] #3376 justification -1: p51
[end-of-instance]
[assign] #4644 clause p316 (not p315)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[assign] #4820 clause p317 (not p315)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 29::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 29::Int)))) 4::Int)) 

[mk-app] #5083 = #3473 #4582
[attach-meaning] #176 arith (- 1)
[mk-app] #3062 + #3473 #3933
[mk-app] #3664 <= #3062 #36
[mk-app] #4126 >= #3062 #36
[assign] #5083 justification -1: p313
[attach-enode] #5083 0
[attach-enode] #3062 0
[assign] #3664 justification -1: p318
[assign] #4126 justification -1: p318
[new-match] 0x1068491f0 #1495 #1483 #3887 #1545 ; #3468 (#3923 #3923)
[mk-app] #5260 = #3468 #3870
[mk-app] #5221 = #3549 #5260
[mk-proof] #5073 monotonicity #3872 #5221
[mk-app] #5021 or #1563 #5260
[mk-app] #4703 or #1563 #3549
[mk-proof] #4434 quant-inst #4703
[mk-app] #3201 = #4703 #5021
[mk-proof] #3202 monotonicity #5073 #3201
[mk-app] #3876 = #5021 #5021
[mk-proof] #4711 rewrite #3876
[mk-proof] #4298 trans #3202 #4711 #3201
[mk-proof] #4299 mp #4434 #4298 #5021
[instance] 0x1068491f0 #4434 ; 59
[attach-enode] #3867 59
[attach-enode] #3870 59
[attach-enode] #5260 59
[assign] #5260 justification -1: p50
[end-of-instance]
[eq-expl] #3867 root
[new-match] 0x106849490 #1477 #1476 #3867 #1545 ; #3870
[eq-expl] #3468 lit #5260 ; #3870
[eq-expl] #3870 root
[new-match] 0x1068494c8 #1522 #1506 #3867 #1545 ; #3469 (#3468 #3870)
[mk-app] #3794 = #3531 #3531
[mk-proof] #3017 refl #3794
[mk-app] #3031 or #1576 #3531
[mk-proof] #3273 quant-inst #3031
[instance] 0x106849490 #3273 ; 60
[attach-enode] #4433 60
[attach-enode] #3531 60
[assign] #3531 justification -1: p49
[end-of-instance]
[mk-app] #3794 + #4425 #4575
[inst-discovered] theory-solving 0x0 arith# ; #4530
[mk-app] #3017 = #4530 #3794
[mk-proof] #3851 rewrite #3017
[instance] 0x0 #3017
[end-of-instance]
[mk-app] #3417 = #3794 #1503
[mk-app] #4172 = #4396 #3417
[mk-proof] #4501 monotonicity #3851 #4172
[attach-meaning] #176 arith (- 1)
[mk-app] #3223 * #176 #4575
[mk-app] #4146 + #3606 #3223
[attach-meaning] #4108 arith (- 4)
[mk-app] #3888 = #4146 #4108
[inst-discovered] theory-solving 0x0 arith# ; #3417
[mk-app] #3889 = #3417 #3888
[mk-proof] #3240 rewrite #3889
[instance] 0x0 #3889
[end-of-instance]
[mk-app] #2983 = #4396 #3888
[mk-proof] #4351 trans #4501 #3240 #2983
[mk-app] #3224 or #3655 #3888
[mk-app] #3232 or #3655 #4396
[mk-proof] #2929 quant-inst #3232
[mk-app] #4540 = #3232 #3224
[mk-proof] #4170 monotonicity #4351 #4540
[mk-app] #3837 = #3224 #3224
[mk-proof] #3703 rewrite #3837
[mk-proof] #3225 trans #4170 #3703 #4540
[mk-proof] #3643 mp #2929 #3225 #3224
[instance] 0x1068494c8 #2929 ; 60
[attach-enode] #3606 60
[attach-enode] #4574 60
[attach-enode] #4575 60
[attach-enode] #3223 60
[attach-enode] #4146 60
[attach-enode] #3888 60
[mk-app] #3139 <= #4146 #4108
[mk-app] #3174 >= #4146 #4108
[assign] #3888 justification -1: p51
[end-of-instance]
[assign] #3139 clause p324 (not p323)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[assign] #3174 clause p325 (not p323)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 30::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 30::Int))))) -4::Int)) 

[mk-app] #3592 = #3469 #3606
[attach-meaning] #176 arith (- 1)
[mk-app] #3170 + #3469 #4425
[mk-app] #3172 <= #3170 #36
[mk-app] #3137 >= #3170 #36
[assign] #3592 justification -1: p321
[attach-enode] #3592 0
[attach-enode] #4425 0
[attach-enode] #3170 0
[assign] #3172 justification -1: p326
[assign] #3137 justification -1: p326
[new-match] 0x106887f30 #1495 #1483 #3867 #1545 ; #4574 (#3870 #3870)
[mk-app] #3743 = #4574 #3733
[mk-app] #4064 = #4690 #3743
[mk-proof] #3854 monotonicity #4017 #4064
[mk-app] #3438 or #1563 #3743
[mk-app] #3439 or #1563 #4690
[mk-proof] #3855 quant-inst #3439
[mk-app] #3706 = #3439 #3438
[mk-proof] #4231 monotonicity #3854 #3706
[mk-app] #4398 = #3438 #3438
[mk-proof] #3795 rewrite #4398
[mk-proof] #3479 trans #4231 #3795 #3706
[mk-proof] #3480 mp #3855 #3479 #3438
[instance] 0x106887f30 #3855 ; 61
[attach-enode] #3730 61
[attach-enode] #3733 61
[attach-enode] #3743 61
[assign] #3743 justification -1: p50
[end-of-instance]
[eq-expl] #3730 root
[new-match] 0x1068881d0 #1477 #1476 #3730 #1545 ; #3733
[eq-expl] #4574 lit #3743 ; #3733
[eq-expl] #3733 root
[new-match] 0x106888208 #1522 #1506 #3730 #1545 ; #4575 (#4574 #3733)
[mk-app] #3463 = #4949 #4949
[mk-proof] #3928 refl #3463
[mk-app] #3929 or #1576 #4949
[mk-proof] #4294 quant-inst #3929
[instance] 0x1068881d0 #4294 ; 62
[attach-enode] #4034 62
[attach-enode] #4949 62
[assign] #4949 justification -1: p49
[end-of-instance]
[mk-app] #3463 = #3970 #3970
[mk-proof] #3928 refl #3463
[mk-app] #4074 or #3655 #3970
[mk-proof] #3070 quant-inst #4074
[instance] 0x106888208 #3070 ; 62
[attach-enode] #4036 62
[attach-enode] #4038 62
[attach-enode] #4041 62
[attach-enode] #5009 62
[attach-enode] #5010 62
[attach-enode] #3970 62
[mk-app] #3068 <= #5010 #1503
[mk-app] #3069 >= #5010 #1503
[assign] #3970 justification -1: p51
[end-of-instance]
[assign] #3068 clause p332 (not p331)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[assign] #3069 clause p333 (not p331)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 31::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 31::Int)))) 4::Int)) 

[mk-app] #3463 = #4041 #4575
[attach-meaning] #176 arith (- 1)
[mk-app] #3928 + #4041 #3223
[mk-app] #3071 <= #3928 #36
[mk-app] #3514 >= #3928 #36
[assign] #3463 justification -1: p329
[attach-enode] #3463 0
[attach-enode] #3928 0
[assign] #3071 justification -1: p334
[assign] #3514 justification -1: p334
[new-match] 0x106888bc8 #1495 #1483 #3730 #1545 ; #4036 (#3733 #3733)
[mk-app] #3441 = #4036 #3294
[mk-app] #3821 = #2944 #3441
[mk-proof] #3967 monotonicity #3296 #3821
[mk-app] #3716 or #1563 #3441
[mk-app] #4587 or #1563 #2944
[mk-proof] #4732 quant-inst #4587
[mk-app] #4504 = #4587 #3716
[mk-proof] #3921 monotonicity #3967 #4504
[mk-app] #3579 = #3716 #3716
[mk-proof] #4586 rewrite #3579
[mk-proof] #4714 trans #3921 #4586 #4504
[mk-proof] #4692 mp #4732 #4714 #3716
[instance] 0x106888bc8 #4732 ; 63
[attach-enode] #3291 63
[attach-enode] #3294 63
[attach-enode] #3441 63
[assign] #3441 justification -1: p50
[end-of-instance]
[eq-expl] #3291 root
[new-match] 0x106888e68 #1477 #1476 #3291 #1545 ; #3294
[eq-expl] #4036 lit #3441 ; #3294
[eq-expl] #3294 root
[new-match] 0x106888ea0 #1522 #1506 #3291 #1545 ; #4038 (#4036 #3294)
[mk-app] #4693 = #3934 #3934
[mk-proof] #4734 refl #4693
[mk-app] #4729 or #1576 #3934
[mk-proof] #4776 quant-inst #4729
[instance] 0x106888e68 #4776 ; 64
[attach-enode] #3312 64
[attach-enode] #3934 64
[assign] #3934 justification -1: p49
[end-of-instance]
[mk-app] #4693 = #3942 #3942
[mk-proof] #4734 refl #4693
[mk-app] #4778 or #3655 #3942
[mk-proof] #4785 quant-inst #4778
[instance] 0x106888ea0 #4785 ; 64
[attach-enode] #3314 64
[attach-enode] #3315 64
[attach-enode] #3318 64
[attach-enode] #4795 64
[attach-enode] #4790 64
[attach-enode] #3942 64
[mk-app] #4902 <= #4790 #1503
[mk-app] #3053 >= #4790 #1503
[assign] #3942 justification -1: p51
[end-of-instance]
[assign] #4902 clause p340 (not p339)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[assign] #3053 clause p341 (not p339)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 32::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 32::Int)))) 4::Int)) 

[mk-app] #4693 = #3318 #4038
[attach-meaning] #176 arith (- 1)
[mk-app] #4734 * #176 #4038
[mk-app] #3815 + #3318 #4734
[mk-app] #3394 <= #3815 #36
[mk-app] #5008 >= #3815 #36
[assign] #4693 justification -1: p337
[attach-enode] #4693 0
[attach-enode] #4734 0
[attach-enode] #3815 0
[assign] #3394 justification -1: p342
[assign] #5008 justification -1: p342
[new-match] 0x1068898e8 #1495 #1483 #3291 #1545 ; #3314 (#3294 #3294)
[mk-app] #5042 = #3314 #4190
[mk-app] #5043 = #4989 #5042
[mk-proof] #5044 monotonicity #4192 #5043
[mk-app] #3159 or #1563 #5042
[mk-app] #4085 or #1563 #4989
[mk-proof] #3817 quant-inst #4085
[mk-app] #4316 = #4085 #3159
[mk-proof] #3953 monotonicity #5044 #4316
[mk-app] #3277 = #3159 #3159
[mk-proof] #2940 rewrite #3277
[mk-proof] #3146 trans #3953 #2940 #4316
[mk-proof] #3379 mp #3817 #3146 #3159
[instance] 0x1068898e8 #3817 ; 65
[attach-enode] #4187 65
[attach-enode] #4190 65
[attach-enode] #5042 65
[assign] #5042 justification -1: p50
[end-of-instance]
[eq-expl] #4187 root
[new-match] 0x1068907e8 #1477 #1476 #4187 #1545 ; #4190
[eq-expl] #3314 lit #5042 ; #4190
[eq-expl] #4190 root
[new-match] 0x106890820 #1522 #1506 #4187 #1545 ; #3315 (#3314 #4190)
[mk-app] #3377 = #4605 #4605
[mk-proof] #4853 refl #3377
[mk-app] #4874 or #1576 #4605
[mk-proof] #3322 quant-inst #4874
[instance] 0x1068907e8 #3322 ; 66
[attach-enode] #4211 66
[attach-enode] #4605 66
[assign] #4605 justification -1: p49
[end-of-instance]
[mk-app] #3377 = #4625 #4625
[mk-proof] #4853 refl #3377
[mk-app] #4047 or #3655 #4625
[mk-proof] #3286 quant-inst #4047
[instance] 0x106890820 #3286 ; 66
[attach-enode] #4213 66
[attach-enode] #4214 66
[attach-enode] #4591 66
[attach-enode] #3931 66
[attach-enode] #4670 66
[attach-enode] #4625 66
[mk-app] #4835 <= #4670 #1503
[mk-app] #4875 >= #4670 #1503
[assign] #4625 justification -1: p51
[end-of-instance]
[assign] #4835 clause p348 (not p347)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[assign] #4875 clause p349 (not p347)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 33::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 33::Int)))) 4::Int)) 

[mk-app] #3377 = #3315 #4591
[attach-meaning] #176 arith (- 1)
[mk-app] #4853 + #3315 #3931
[mk-app] #4854 <= #4853 #36
[mk-app] #4855 >= #4853 #36
[assign] #3377 justification -1: p345
[attach-enode] #3377 0
[attach-enode] #4853 0
[assign] #4854 justification -1: p350
[assign] #4855 justification -1: p350
[new-match] 0x1068911e0 #1495 #1483 #4187 #1545 ; #4213 (#4190 #4190)
[mk-app] #5146 = #4213 #4495
[mk-app] #4967 = #3090 #5146
[mk-proof] #4925 monotonicity #3819 #4967
[mk-app] #3383 or #1563 #5146
[mk-app] #3263 or #1563 #3090
[mk-proof] #3388 quant-inst #3263
[mk-app] #3261 = #3263 #3383
[mk-proof] #3283 monotonicity #4925 #3261
[mk-app] #3704 = #3383 #3383
[mk-proof] #3281 rewrite #3704
[mk-proof] #3276 trans #3283 #3281 #3261
[mk-proof] #2961 mp #3388 #3276 #3383
[instance] 0x1068911e0 #3388 ; 67
[attach-enode] #3677 67
[attach-enode] #4495 67
[attach-enode] #5146 67
[assign] #5146 justification -1: p50
[end-of-instance]
[eq-expl] #3677 root
[new-match] 0x106891480 #1477 #1476 #3677 #1545 ; #4495
[eq-expl] #4213 lit #5146 ; #4495
[eq-expl] #4495 root
[new-match] 0x1068914b8 #1522 #1506 #3677 #1545 ; #4214 (#4213 #4495)
[mk-app] #3278 = #3503 #3503
[mk-proof] #3705 refl #3278
[mk-app] #3443 or #1576 #3503
[mk-proof] #4468 quant-inst #3443
[instance] 0x106891480 #4468 ; 68
[attach-enode] #3602 68
[attach-enode] #3503 68
[assign] #3503 justification -1: p49
[end-of-instance]
[mk-app] #3278 + #2968 #4535
[inst-discovered] theory-solving 0x0 arith# ; #3258
[mk-app] #3705 = #3258 #3278
[mk-proof] #4103 rewrite #3705
[instance] 0x0 #3705
[end-of-instance]
[mk-app] #4075 = #3278 #1503
[mk-app] #3421 = #3741 #4075
[mk-proof] #4215 monotonicity #4103 #3421
[attach-meaning] #176 arith (- 1)
[mk-app] #4521 * #176 #4535
[mk-app] #4814 + #2991 #4521
[attach-meaning] #4108 arith (- 4)
[mk-app] #4815 = #4814 #4108
[inst-discovered] theory-solving 0x0 arith# ; #4075
[mk-app] #3648 = #4075 #4815
[mk-proof] #3380 rewrite #3648
[instance] 0x0 #3648
[end-of-instance]
[mk-app] #3206 = #3741 #4815
[mk-proof] #3878 trans #4215 #3380 #3206
[mk-app] #3672 or #3655 #4815
[mk-app] #4350 or #3655 #3741
[mk-proof] #4301 quant-inst #4350
[mk-app] #4552 = #4350 #3672
[mk-proof] #3424 monotonicity #3878 #4552
[mk-app] #4547 = #3672 #3672
[mk-proof] #3536 rewrite #4547
[mk-proof] #4641 trans #3424 #3536 #4552
[mk-proof] #4952 mp #4301 #4641 #3672
[instance] 0x1068914b8 #4301 ; 68
[attach-enode] #2991 68
[attach-enode] #4534 68
[attach-enode] #4535 68
[attach-enode] #4521 68
[attach-enode] #4814 68
[attach-enode] #4815 68
[mk-app] #4872 <= #4814 #4108
[mk-app] #4943 >= #4814 #4108
[assign] #4815 justification -1: p51
[end-of-instance]
[assign] #4872 clause p356 (not p355)
  (<= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[assign] #4943 clause p357 (not p355)
  (>= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int) 
  (not (= (+ (address<Int> (offset<Ptr32> x@1@01 34::Int)) (* -1::Int (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 34::Int))))) -4::Int)) 

[mk-app] #4905 = #2991 #4214
[attach-meaning] #176 arith (- 1)
[mk-app] #4164 * #176 #4214
[mk-app] #4166 + #2991 #4164
[mk-app] #4319 <= #4166 #36
[mk-app] #4503 >= #4166 #36
[assign] #4905 justification -1: p353
[attach-enode] #4905 0
[attach-enode] #4164 0
[attach-enode] #4166 0
[assign] #4319 justification -1: p358
[assign] #4503 justification -1: p358
[new-match] 0x106891f00 #1495 #1483 #3677 #1545 ; #4534 (#4495 #4495)
[mk-app] #2932 = #4534 #3984
[mk-app] #2933 = #3451 #2932
[mk-proof] #2930 monotonicity #4520 #2933
[mk-app] #2931 or #1563 #2932
[mk-app] #4286 or #1563 #3451
[mk-proof] #4287 quant-inst #4286
[mk-app] #4496 = #4286 #2931
[mk-proof] #3629 monotonicity #2930 #4496
[mk-app] #3452 = #2931 #2931
[mk-proof] #3936 rewrite #3452
[mk-proof] #4194 trans #3629 #3936 #4496
[mk-proof] #4204 mp #4287 #4194 #2931
[instance] 0x106891f00 #4287 ; 69
[attach-enode] #3981 69
[attach-enode] #3984 69
[attach-enode] #2932 69
[assign] #2932 justification -1: p50
[end-of-instance]
[eq-expl] #3981 root
[new-match] 0x1068921a0 #1477 #1476 #3981 #1545 ; #3984
[eq-expl] #4534 lit #2932 ; #3984
[eq-expl] #3984 root
[new-match] 0x1068921d8 #1522 #1506 #3981 #1545 ; #4535 (#4534 #3984)
[mk-app] #4846 = #3072 #3072
[mk-proof] #4497 refl #4846
[mk-app] #4831 or #1576 #3072
[mk-proof] #4661 quant-inst #4831
[instance] 0x1068921a0 #4661 ; 70
[attach-enode] #3192 70
[attach-enode] #3072 70
[assign] #3072 justification -1: p49
[end-of-instance]
[mk-app] #4846 = #3191 #3191
[mk-proof] #4497 refl #4846
[mk-app] #4662 or #3655 #3191
[mk-proof] #4851 quant-inst #4662
[instance] 0x1068921d8 #4851 ; 70
[attach-enode] #3194 70
[attach-enode] #3195 70
[attach-enode] #3198 70
[attach-enode] #4022 70
[attach-enode] #4023 70
[attach-enode] #3191 70
[mk-app] #3566 <= #4023 #1503
[mk-app] #3094 >= #4023 #1503
[assign] #3191 justification -1: p51
[end-of-instance]
[assign] #3566 clause p364 (not p363)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[assign] #3094 clause p365 (not p363)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 35::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 35::Int)))) 4::Int)) 

[mk-app] #4846 = #3198 #4535
[attach-meaning] #176 arith (- 1)
[mk-app] #4497 + #3198 #4521
[mk-app] #3099 <= #4497 #36
[mk-app] #3567 >= #4497 #36
[assign] #4846 justification -1: p361
[attach-enode] #4846 0
[attach-enode] #4497 0
[assign] #3099 justification -1: p366
[assign] #3567 justification -1: p366
[new-match] 0x10689a9f8 #1495 #1483 #3981 #1545 ; #3194 (#3984 #3984)
[mk-app] #3634 = #3194 #3217
[mk-app] #4907 = #3752 #3634
[mk-proof] #4950 monotonicity #3221 #4907
[mk-app] #4951 or #1563 #3634
[mk-app] #3505 or #1563 #3752
[mk-proof] #3835 quant-inst #3505
[mk-app] #5475 = #3505 #4951
[mk-proof] #4761 monotonicity #4950 #5475
[mk-app] #4982 = #4951 #4951
[mk-proof] #4410 rewrite #4982
[mk-proof] #3529 trans #4761 #4410 #5475
[mk-proof] #3521 mp #3835 #3529 #4951
[instance] 0x10689a9f8 #3835 ; 71
[attach-enode] #3216 71
[attach-enode] #3217 71
[attach-enode] #3634 71
[assign] #3634 justification -1: p50
[end-of-instance]
[eq-expl] #3216 root
[new-match] 0x10689ac98 #1477 #1476 #3216 #1545 ; #3217
[eq-expl] #3194 lit #3634 ; #3217
[eq-expl] #3217 root
[new-match] 0x10689acd0 #1522 #1506 #3216 #1545 ; #3195 (#3194 #3217)
[mk-app] #3586 = #5019 #5019
[mk-proof] #5243 refl #3586
[mk-app] #5133 or #1576 #5019
[mk-proof] #3476 quant-inst #5133
[instance] 0x10689ac98 #3476 ; 72
[attach-enode] #4114 72
[attach-enode] #5019 72
[assign] #5019 justification -1: p49
[end-of-instance]
[mk-app] #3586 = #5087 #5087
[mk-proof] #5243 refl #3586
[mk-app] #4748 or #3655 #5087
[mk-proof] #2912 quant-inst #4748
[instance] 0x10689acd0 #2912 ; 72
[attach-enode] #4116 72
[attach-enode] #4121 72
[attach-enode] #4124 72
[attach-enode] #5026 72
[attach-enode] #5027 72
[attach-enode] #5087 72
[mk-app] #3076 <= #5027 #1503
[mk-app] #3680 >= #5027 #1503
[assign] #5087 justification -1: p51
[end-of-instance]
[assign] #3076 clause p372 (not p371)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[assign] #3680 clause p373 (not p371)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 36::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 36::Int)))) 4::Int)) 

[mk-app] #3586 = #3195 #4124
[attach-meaning] #176 arith (- 1)
[mk-app] #5243 + #3195 #5026
[mk-app] #2924 <= #5243 #36
[mk-app] #4245 >= #5243 #36
[assign] #3586 justification -1: p369
[attach-enode] #3586 0
[attach-enode] #5243 0
[assign] #2924 justification -1: p374
[assign] #4245 justification -1: p374
[new-match] 0x10689b690 #1495 #1483 #3216 #1545 ; #4116 (#3217 #3217)
[mk-app] #4068 = #4116 #3652
[mk-app] #4512 = #4084 #4068
[mk-proof] #3270 monotonicity #3654 #4512
[mk-app] #3073 or #1563 #4068
[mk-app] #3839 or #1563 #4084
[mk-proof] #3599 quant-inst #3839
[mk-app] #3061 = #3839 #3073
[mk-proof] #3683 monotonicity #3270 #3061
[mk-app] #4306 = #3073 #3073
[mk-proof] #3773 rewrite #4306
[mk-proof] #3182 trans #3683 #3773 #3061
[mk-proof] #3679 mp #3599 #3182 #3073
[instance] 0x10689b690 #3599 ; 73
[attach-enode] #4506 73
[attach-enode] #3652 73
[attach-enode] #4068 73
[assign] #4068 justification -1: p50
[end-of-instance]
[eq-expl] #4506 root
[new-match] 0x10689b930 #1477 #1476 #4506 #1545 ; #3652
[eq-expl] #4116 lit #4068 ; #3652
[eq-expl] #3652 root
[new-match] 0x10689b968 #1522 #1506 #4506 #1545 ; #4121 (#4116 #3652)
[mk-app] #3828 = #3886 #3886
[mk-proof] #3583 refl #3828
[mk-app] #2927 or #1576 #3886
[mk-proof] #4459 quant-inst #2927
[instance] 0x10689b930 #4459 ; 74
[attach-enode] #4492 74
[attach-enode] #3886 74
[assign] #3886 justification -1: p49
[end-of-instance]
[mk-app] #3828 = #3487 #3487
[mk-proof] #3583 refl #3828
[mk-app] #4336 or #3655 #3487
[mk-proof] #4862 quant-inst #4336
[instance] 0x10689b968 #4862 ; 74
[attach-enode] #4491 74
[attach-enode] #4596 74
[attach-enode] #4597 74
[attach-enode] #5112 74
[attach-enode] #4339 74
[attach-enode] #3487 74
[mk-app] #5101 <= #4339 #1503
[mk-app] #4337 >= #4339 #1503
[assign] #3487 justification -1: p51
[end-of-instance]
[assign] #5101 clause p380 (not p379)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[assign] #4337 clause p381 (not p379)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 37::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 37::Int)))) 4::Int)) 

[mk-app] #3828 = #4121 #4597
[attach-meaning] #176 arith (- 1)
[mk-app] #3583 + #4121 #5112
[mk-app] #3673 <= #3583 #36
[mk-app] #3969 >= #3583 #36
[assign] #3828 justification -1: p377
[attach-enode] #3828 0
[attach-enode] #3583 0
[assign] #3673 justification -1: p382
[assign] #3969 justification -1: p382
[new-match] 0x10689c328 #1495 #1483 #4506 #1545 ; #4491 (#3652 #3652)
[mk-app] #4971 = #4491 #4609
[mk-app] #4974 = #3408 #4971
[mk-proof] #3811 monotonicity #4611 #4974
[mk-app] #3154 or #1563 #4971
[mk-app] #5007 or #1563 #3408
[mk-proof] #4970 quant-inst #5007
[mk-app] #3715 = #5007 #3154
[mk-proof] #3902 monotonicity #3811 #3715
[mk-app] #3750 = #3154 #3154
[mk-proof] #3197 rewrite #3750
[mk-proof] #3822 trans #3902 #3197 #3715
[mk-proof] #3311 mp #4970 #3822 #3154
[instance] 0x10689c328 #4970 ; 75
[attach-enode] #4606 75
[attach-enode] #4609 75
[attach-enode] #4971 75
[assign] #4971 justification -1: p50
[end-of-instance]
[eq-expl] #4606 root
[new-match] 0x10684f5e8 #1477 #1476 #4606 #1545 ; #4609
[eq-expl] #4491 lit #4971 ; #4609
[eq-expl] #4609 root
[new-match] 0x10684f620 #1522 #1506 #4606 #1545 ; #4596 (#4491 #4609)
[mk-app] #4451 = #3450 #3450
[mk-proof] #4449 refl #4451
[mk-app] #4455 or #1576 #3450
[mk-proof] #4253 quant-inst #4455
[instance] 0x10684f5e8 #4253 ; 76
[attach-enode] #4624 76
[attach-enode] #3450 76
[assign] #3450 justification -1: p49
[end-of-instance]
[mk-app] #4451 = #4885 #4885
[mk-proof] #4449 refl #4451
[mk-app] #2923 or #3655 #4885
[mk-proof] #3445 quant-inst #2923
[instance] 0x10684f620 #3445 ; 76
[attach-enode] #4626 76
[attach-enode] #4627 76
[attach-enode] #4630 76
[attach-enode] #3554 76
[attach-enode] #4040 76
[attach-enode] #4885 76
[mk-app] #4454 <= #4040 #1503
[mk-app] #4144 >= #4040 #1503
[assign] #4885 justification -1: p51
[end-of-instance]
[assign] #4454 clause p388 (not p387)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[assign] #4144 clause p389 (not p387)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 38::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 38::Int)))) 4::Int)) 

[mk-app] #4451 = #4596 #4630
[attach-meaning] #176 arith (- 1)
[mk-app] #4449 + #4596 #3554
[mk-app] #2986 <= #4449 #36
[mk-app] #4332 >= #4449 #36
[assign] #4451 justification -1: p385
[attach-enode] #4451 0
[attach-enode] #4449 0
[assign] #2986 justification -1: p390
[assign] #4332 justification -1: p390
[new-match] 0x10684ffe0 #1495 #1483 #4606 #1545 ; #4626 (#4609 #4609)
[mk-app] #3236 = #4626 #4648
[mk-app] #3409 = #4886 #3236
[mk-proof] #3492 monotonicity #4650 #3409
[mk-app] #3493 or #1563 #3236
[mk-app] #3193 or #1563 #4886
[mk-proof] #4212 quant-inst #3193
[mk-app] #4186 = #3193 #3493
[mk-proof] #3588 monotonicity #3492 #4186
[mk-app] #4788 = #3493 #3493
[mk-proof] #3582 rewrite #4788
[mk-proof] #3141 trans #3588 #3582 #4186
[mk-proof] #3142 mp #4212 #3141 #3493
[instance] 0x10684ffe0 #4212 ; 77
[attach-enode] #4645 77
[attach-enode] #4648 77
[attach-enode] #3236 77
[assign] #3236 justification -1: p50
[end-of-instance]
[eq-expl] #4645 root
[new-match] 0x106850280 #1477 #1476 #4645 #1545 ; #4648
[eq-expl] #4626 lit #3236 ; #4648
[eq-expl] #4648 root
[new-match] 0x1068502b8 #1522 #1506 #4645 #1545 ; #4627 (#4626 #4648)
[mk-app] #4463 = #5476 #5476
[mk-proof] #3528 refl #4463
[mk-app] #3729 or #1576 #5476
[mk-proof] #3607 quant-inst #3729
[instance] 0x106850280 #3607 ; 78
[attach-enode] #4663 78
[attach-enode] #5476 78
[assign] #5476 justification -1: p49
[end-of-instance]
[mk-app] #4463 = #5270 #5270
[mk-proof] #3528 refl #4463
[mk-app] #3160 or #3655 #5270
[mk-proof] #3144 quant-inst #3160
[instance] 0x1068502b8 #3144 ; 78
[attach-enode] #4665 78
[attach-enode] #4666 78
[attach-enode] #4669 78
[attach-enode] #5173 78
[attach-enode] #4664 78
[attach-enode] #5270 78
[mk-app] #3849 <= #4664 #1503
[mk-app] #3850 >= #4664 #1503
[assign] #5270 justification -1: p51
[end-of-instance]
[assign] #3849 clause p396 (not p395)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[assign] #3850 clause p397 (not p395)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 39::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 39::Int)))) 4::Int)) 

[mk-app] #4463 = #4627 #4669
[attach-meaning] #176 arith (- 1)
[mk-app] #3528 + #4627 #5173
[mk-app] #2975 <= #3528 #36
[mk-app] #4443 >= #3528 #36
[assign] #4463 justification -1: p393
[attach-enode] #4463 0
[attach-enode] #3528 0
[assign] #2975 justification -1: p398
[assign] #4443 justification -1: p398
[new-match] 0x106850c78 #1495 #1483 #4645 #1545 ; #4665 (#4648 #4648)
[mk-app] #3404 = #4665 #4687
[mk-app] #2969 = #3875 #3404
[mk-proof] #3511 monotonicity #4689 #2969
[mk-app] #4182 or #1563 #3404
[mk-app] #2970 or #1563 #3875
[mk-proof] #3708 quant-inst #2970
[mk-app] #3847 = #2970 #4182
[mk-proof] #4178 monotonicity #3511 #3847
[mk-app] #2928 = #4182 #4182
[mk-proof] #3251 rewrite #2928
[mk-proof] #3252 trans #4178 #3251 #3847
[mk-proof] #4509 mp #3708 #3252 #4182
[instance] 0x106850c78 #3708 ; 79
[attach-enode] #4684 79
[attach-enode] #4687 79
[attach-enode] #3404 79
[assign] #3404 justification -1: p50
[end-of-instance]
[eq-expl] #4684 root
[new-match] 0x106850f18 #1477 #1476 #4684 #1545 ; #4687
[eq-expl] #4665 lit #3404 ; #4687
[eq-expl] #4687 root
[new-match] 0x106850f50 #1522 #1506 #4684 #1545 ; #4666 (#4665 #4687)
[mk-app] #3510 = #3274 #3274
[mk-proof] #3360 refl #3510
[mk-app] #4221 or #1576 #3274
[mk-proof] #3644 quant-inst #4221
[instance] 0x106850f18 #3644 ; 80
[attach-enode] #4702 80
[attach-enode] #3274 80
[assign] #3274 justification -1: p49
[end-of-instance]
[mk-app] #3510 = #3234 #3234
[mk-proof] #3360 refl #3510
[mk-app] #4055 or #3655 #3234
[mk-proof] #4222 quant-inst #4055
[instance] 0x106850f50 #4222 ; 80
[attach-enode] #4704 80
[attach-enode] #4705 80
[attach-enode] #4708 80
[attach-enode] #4155 80
[attach-enode] #4516 80
[attach-enode] #3234 80
[mk-app] #4217 <= #4516 #1503
[mk-app] #4280 >= #4516 #1503
[assign] #3234 justification -1: p51
[end-of-instance]
[assign] #4217 clause p404 (not p403)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[assign] #4280 clause p405 (not p403)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 40::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 40::Int)))) 4::Int)) 

[mk-app] #3510 = #4666 #4708
[attach-meaning] #176 arith (- 1)
[mk-app] #3360 + #4666 #4155
[mk-app] #4281 <= #3360 #36
[mk-app] #3996 >= #3360 #36
[assign] #3510 justification -1: p401
[attach-enode] #3510 0
[attach-enode] #3360 0
[assign] #4281 justification -1: p406
[assign] #3996 justification -1: p406
[new-match] 0x10686e758 #1495 #1483 #4684 #1545 ; #4704 (#4687 #4687)
[mk-app] #3255 = #4704 #4726
[mk-app] #4276 = #2962 #3255
[mk-proof] #4279 monotonicity #4728 #4276
[mk-app] #4274 or #1563 #3255
[mk-app] #4456 or #1563 #2962
[mk-proof] #3444 quant-inst #4456
[mk-app] #3517 = #4456 #4274
[mk-proof] #3737 monotonicity #4279 #3517
[mk-app] #3440 = #4274 #4274
[mk-proof] #3442 rewrite #3440
[mk-proof] #3049 trans #3737 #3442 #3517
[mk-proof] #3044 mp #3444 #3049 #4274
[instance] 0x10686e758 #3444 ; 81
[attach-enode] #4723 81
[attach-enode] #4726 81
[attach-enode] #3255 81
[assign] #3255 justification -1: p50
[end-of-instance]
[eq-expl] #4723 root
[new-match] 0x10686e9f8 #1477 #1476 #4723 #1545 ; #4726
[eq-expl] #4704 lit #3255 ; #4726
[eq-expl] #4726 root
[new-match] 0x10686ea30 #1522 #1506 #4723 #1545 ; #4705 (#4704 #4726)
[mk-app] #3918 = #4177 #4177
[mk-proof] #3919 refl #3918
[mk-app] #4558 or #1576 #4177
[mk-proof] #3047 quant-inst #4558
[instance] 0x10686e9f8 #3047 ; 82
[attach-enode] #4741 82
[attach-enode] #4177 82
[assign] #4177 justification -1: p49
[end-of-instance]
[mk-app] #3918 = #2960 #2960
[mk-proof] #3919 refl #3918
[mk-app] #3050 or #3655 #2960
[mk-proof] #3126 quant-inst #3050
[instance] 0x10686ea30 #3126 ; 82
[attach-enode] #4743 82
[attach-enode] #4744 82
[attach-enode] #4747 82
[attach-enode] #4541 82
[attach-enode] #3494 82
[attach-enode] #2960 82
[mk-app] #3604 <= #3494 #1503
[mk-app] #3459 >= #3494 #1503
[assign] #2960 justification -1: p51
[end-of-instance]
[assign] #3604 clause p412 (not p411)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[assign] #3459 clause p413 (not p411)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 41::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 41::Int)))) 4::Int)) 

[mk-app] #3918 = #4705 #4747
[attach-meaning] #176 arith (- 1)
[mk-app] #3919 + #4705 #4541
[mk-app] #3131 <= #3919 #36
[mk-app] #3605 >= #3919 #36
[assign] #3918 justification -1: p409
[attach-enode] #3918 0
[attach-enode] #3919 0
[assign] #3131 justification -1: p414
[assign] #3605 justification -1: p414
[new-match] 0x10686f3f0 #1495 #1483 #4723 #1545 ; #4743 (#4726 #4726)
[mk-app] #3052 = #4743 #4765
[mk-app] #3880 = #3574 #3052
[mk-proof] #3824 monotonicity #4767 #3880
[mk-app] #3300 or #1563 #3052
[mk-app] #4450 or #1563 #3574
[mk-proof] #4370 quant-inst #4450
[mk-app] #3961 = #4450 #3300
[mk-proof] #3823 monotonicity #3824 #3961
[mk-app] #3222 = #3300 #3300
[mk-proof] #3749 rewrite #3222
[mk-proof] #3681 trans #3823 #3749 #3961
[mk-proof] #4109 mp #4370 #3681 #3300
[instance] 0x10686f3f0 #4370 ; 83
[attach-enode] #4762 83
[attach-enode] #4765 83
[attach-enode] #3052 83
[assign] #3052 justification -1: p50
[end-of-instance]
[eq-expl] #4762 root
[new-match] 0x10686f690 #1477 #1476 #4762 #1545 ; #4765
[eq-expl] #4743 lit #3052 ; #4765
[eq-expl] #4765 root
[new-match] 0x10686f6c8 #1522 #1506 #4762 #1545 ; #4744 (#4743 #4765)
[mk-app] #3668 = #4065 #4065
[mk-proof] #3669 refl #3668
[mk-app] #4779 or #1576 #4065
[mk-proof] #4265 quant-inst #4779
[instance] 0x10686f690 #4265 ; 84
[attach-enode] #4780 84
[attach-enode] #4065 84
[assign] #4065 justification -1: p49
[end-of-instance]
[mk-app] #3668 = #4232 #4232
[mk-proof] #3669 refl #3668
[mk-app] #4746 or #3655 #4232
[mk-proof] #4735 quant-inst #4746
[instance] 0x10686f6c8 #4735 ; 84
[attach-enode] #4782 84
[attach-enode] #4783 84
[attach-enode] #4786 84
[attach-enode] #3333 84
[attach-enode] #3935 84
[attach-enode] #4232 84
[mk-app] #4772 <= #3935 #1503
[mk-app] #4773 >= #3935 #1503
[assign] #4232 justification -1: p51
[end-of-instance]
[assign] #4772 clause p420 (not p419)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[assign] #4773 clause p421 (not p419)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 42::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 42::Int)))) 4::Int)) 

[mk-app] #3668 = #4744 #4786
[attach-meaning] #176 arith (- 1)
[mk-app] #3669 + #4744 #3333
[mk-app] #4267 <= #3669 #36
[mk-app] #4935 >= #3669 #36
[assign] #3668 justification -1: p417
[attach-enode] #3668 0
[attach-enode] #3669 0
[assign] #4267 justification -1: p422
[assign] #4935 justification -1: p422
[new-match] 0x106870088 #1495 #1483 #4762 #1545 ; #4782 (#4765 #4765)
[mk-app] #4909 = #4782 #4804
[mk-app] #4894 = #3462 #4909
[mk-proof] #4928 monotonicity #4806 #4894
[mk-app] #4910 or #1563 #4909
[mk-app] #4927 or #1563 #3462
[mk-proof] #3816 quant-inst #4927
[mk-app] #2936 = #4927 #4910
[mk-proof] #4201 monotonicity #4928 #2936
[mk-app] #4202 = #4910 #4910
[mk-proof] #4006 rewrite #4202
[mk-proof] #3814 trans #4201 #4006 #2936
[mk-proof] #3962 mp #3816 #3814 #4910
[instance] 0x106870088 #3816 ; 85
[attach-enode] #4801 85
[attach-enode] #4804 85
[attach-enode] #4909 85
[assign] #4909 justification -1: p50
[end-of-instance]
[eq-expl] #4801 root
[new-match] 0x1068b1960 #1477 #1476 #4801 #1545 ; #4804
[eq-expl] #4782 lit #4909 ; #4804
[eq-expl] #4804 root
[new-match] 0x1068b1998 #1522 #1506 #4801 #1545 ; #4783 (#4782 #4804)
[mk-app] #3365 = #4206 #4206
[mk-proof] #4246 refl #3365
[mk-app] #3363 or #1576 #4206
[mk-proof] #4061 quant-inst #3363
[instance] 0x1068b1960 #4061 ; 86
[attach-enode] #4819 86
[attach-enode] #4206 86
[assign] #4206 justification -1: p49
[end-of-instance]
[mk-app] #3365 = #3879 #3879
[mk-proof] #4246 refl #3365
[mk-app] #2949 or #3655 #3879
[mk-proof] #3032 quant-inst #2949
[instance] 0x1068b1998 #3032 ; 86
[attach-enode] #4821 86
[attach-enode] #4822 86
[attach-enode] #4825 86
[attach-enode] #3820 86
[attach-enode] #3317 86
[attach-enode] #3879 86
[mk-app] #3907 <= #3317 #1503
[mk-app] #3908 >= #3317 #1503
[assign] #3879 justification -1: p51
[end-of-instance]
[assign] #3907 clause p428 (not p427)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[assign] #3908 clause p429 (not p427)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 43::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 43::Int)))) 4::Int)) 

[mk-app] #3365 = #4783 #4825
[attach-meaning] #176 arith (- 1)
[mk-app] #4246 + #4783 #3820
[mk-app] #3861 <= #4246 #36
[mk-app] #4368 >= #4246 #36
[assign] #3365 justification -1: p425
[attach-enode] #3365 0
[attach-enode] #4246 0
[assign] #3861 justification -1: p430
[assign] #4368 justification -1: p430
[new-match] 0x1068b2358 #1495 #1483 #4801 #1545 ; #4821 (#4804 #4804)
[mk-app] #4481 = #4821 #4843
[mk-app] #4312 = #3576 #4481
[mk-proof] #3781 monotonicity #4845 #4312
[mk-app] #4576 or #1563 #4481
[mk-app] #3659 or #1563 #3576
[mk-proof] #3660 quant-inst #3659
[mk-app] #3973 = #3659 #4576
[mk-proof] #3974 monotonicity #3781 #3973
[mk-app] #4718 = #4576 #4576
[mk-proof] #5034 rewrite #4718
[mk-proof] #4878 trans #3974 #5034 #3973
[mk-proof] #4827 mp #3660 #4878 #4576
[instance] 0x1068b2358 #3660 ; 87
[attach-enode] #4840 87
[attach-enode] #4843 87
[attach-enode] #4481 87
[assign] #4481 justification -1: p50
[end-of-instance]
[eq-expl] #4840 root
[new-match] 0x1068b25f8 #1477 #1476 #4840 #1545 ; #4843
[eq-expl] #4821 lit #4481 ; #4843
[eq-expl] #4843 root
[new-match] 0x1068b2630 #1522 #1506 #4840 #1545 ; #4822 (#4821 #4843)
[mk-app] #4828 = #4777 #4777
[mk-proof] #3979 refl #4828
[mk-app] #4980 or #1576 #4777
[mk-proof] #2994 quant-inst #4980
[instance] 0x1068b25f8 #2994 ; 88
[attach-enode] #4858 88
[attach-enode] #4777 88
[assign] #4777 justification -1: p49
[end-of-instance]
[mk-app] #4828 = #4792 #4792
[mk-proof] #3979 refl #4828
[mk-app] #3623 or #3655 #4792
[mk-proof] #3636 quant-inst #3623
[instance] 0x1068b2630 #3636 ; 88
[attach-enode] #4860 88
[attach-enode] #4861 88
[attach-enode] #4864 88
[attach-enode] #4770 88
[attach-enode] #4771 88
[attach-enode] #4792 88
[mk-app] #3833 <= #4771 #1503
[mk-app] #4439 >= #4771 #1503
[assign] #4792 justification -1: p51
[end-of-instance]
[assign] #3833 clause p436 (not p435)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[assign] #4439 clause p437 (not p435)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 44::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 44::Int)))) 4::Int)) 

[mk-app] #4828 = #4822 #4864
[attach-meaning] #176 arith (- 1)
[mk-app] #3979 + #4822 #4770
[mk-app] #3646 <= #3979 #36
[mk-app] #4519 >= #3979 #36
[assign] #4828 justification -1: p433
[attach-enode] #4828 0
[attach-enode] #3979 0
[assign] #3646 justification -1: p438
[assign] #4519 justification -1: p438
[new-match] 0x1068b2ff0 #1495 #1483 #4840 #1545 ; #4860 (#4843 #4843)
[mk-app] #3361 = #4860 #4882
[mk-app] #3558 = #5005 #3361
[mk-proof] #3127 monotonicity #4884 #3558
[mk-app] #3128 or #1563 #3361
[mk-app] #3422 or #1563 #5005
[mk-proof] #3548 quant-inst #3422
[mk-app] #4122 = #3422 #3128
[mk-proof] #3665 monotonicity #3127 #4122
[mk-app] #3457 = #3128 #3128
[mk-proof] #4696 rewrite #3457
[mk-proof] #4697 trans #3665 #4696 #4122
[mk-proof] #4619 mp #3548 #4697 #3128
[instance] 0x1068b2ff0 #3548 ; 89
[attach-enode] #4879 89
[attach-enode] #4882 89
[attach-enode] #3361 89
[assign] #3361 justification -1: p50
[end-of-instance]
[eq-expl] #4879 root
[new-match] 0x1068b3290 #1477 #1476 #4879 #1545 ; #4882
[eq-expl] #4860 lit #3361 ; #4882
[eq-expl] #4882 root
[new-match] 0x1068b32c8 #1522 #1506 #4879 #1545 ; #4861 (#4860 #4882)
[mk-app] #3100 = #3247 #3247
[mk-proof] #3852 refl #3100
[mk-app] #5066 or #1576 #3247
[mk-proof] #4357 quant-inst #5066
[instance] 0x1068b3290 #4357 ; 90
[attach-enode] #4897 90
[attach-enode] #3247 90
[assign] #3247 justification -1: p49
[end-of-instance]
[mk-app] #3100 = #3151 #3151
[mk-proof] #3852 refl #3100
[mk-app] #3649 or #3655 #3151
[mk-proof] #2943 quant-inst #3649
[instance] 0x1068b32c8 #2943 ; 90
[attach-enode] #4899 90
[attach-enode] #4900 90
[attach-enode] #4903 90
[attach-enode] #3690 90
[attach-enode] #3282 90
[attach-enode] #3151 90
[mk-app] #4674 <= #3282 #1503
[mk-app] #4640 >= #3282 #1503
[assign] #3151 justification -1: p51
[end-of-instance]
[assign] #4674 clause p444 (not p443)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[assign] #4640 clause p445 (not p443)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 45::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 45::Int)))) 4::Int)) 

[mk-app] #3100 = #4861 #4903
[attach-meaning] #176 arith (- 1)
[mk-app] #3852 + #4861 #3690
[mk-app] #3078 <= #3852 #36
[mk-app] #4869 >= #3852 #36
[assign] #3100 justification -1: p441
[attach-enode] #3100 0
[attach-enode] #3852 0
[assign] #3078 justification -1: p446
[assign] #4869 justification -1: p446
[new-match] 0x1068baaa8 #1495 #1483 #4879 #1545 ; #4899 (#4882 #4882)
[mk-app] #4873 = #4899 #4921
[mk-app] #4159 = #3778 #4873
[mk-proof] #4953 monotonicity #4923 #4159
[mk-app] #4485 or #1563 #4873
[mk-app] #4013 or #1563 #3778
[mk-proof] #3932 quant-inst #4013
[mk-app] #3770 = #4013 #4485
[mk-proof] #4532 monotonicity #4953 #3770
[mk-app] #3625 = #4485 #4485
[mk-proof] #4581 rewrite #3625
[mk-proof] #3446 trans #4532 #4581 #3770
[mk-proof] #3853 mp #3932 #3446 #4485
[instance] 0x1068baaa8 #3932 ; 91
[attach-enode] #4918 91
[attach-enode] #4921 91
[attach-enode] #4873 91
[assign] #4873 justification -1: p50
[end-of-instance]
[eq-expl] #4918 root
[new-match] 0x1068bad48 #1477 #1476 #4918 #1545 ; #4921
[eq-expl] #4899 lit #4873 ; #4921
[eq-expl] #4921 root
[new-match] 0x1068bad80 #1522 #1506 #4918 #1545 ; #4900 (#4899 #4921)
[mk-app] #3544 = #4926 #4926
[mk-proof] #3545 refl #3544
[mk-app] #4314 or #1576 #4926
[mk-proof] #3684 quant-inst #4314
[instance] 0x1068bad48 #3684 ; 92
[attach-enode] #4936 92
[attach-enode] #4926 92
[assign] #4926 justification -1: p49
[end-of-instance]
[mk-app] #3544 = #3957 #3957
[mk-proof] #3545 refl #3544
[mk-app] #3000 or #3655 #3957
[mk-proof] #3180 quant-inst #3000
[instance] 0x1068bad80 #3180 ; 92
[attach-enode] #4938 92
[attach-enode] #4939 92
[attach-enode] #4942 92
[attach-enode] #4859 92
[attach-enode] #4839 92
[attach-enode] #3957 92
[mk-app] #3196 <= #4839 #1503
[mk-app] #2990 >= #4839 #1503
[assign] #3957 justification -1: p51
[end-of-instance]
[assign] #3196 clause p452 (not p451)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[assign] #2990 clause p453 (not p451)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 46::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 46::Int)))) 4::Int)) 

[mk-app] #3544 = #4900 #4942
[attach-meaning] #176 arith (- 1)
[mk-app] #3545 + #4900 #4859
[mk-app] #3181 <= #3545 #36
[mk-app] #3208 >= #3545 #36
[assign] #3544 justification -1: p449
[attach-enode] #3544 0
[attach-enode] #3545 0
[assign] #3181 justification -1: p454
[assign] #3208 justification -1: p454
[new-match] 0x1068bb740 #1495 #1483 #4918 #1545 ; #4938 (#4921 #4921)
[mk-app] #4374 = #4938 #4960
[mk-app] #4375 = #3894 #4374
[mk-proof] #4066 monotonicity #4962 #4375
[mk-app] #4067 or #1563 #4374
[mk-app] #3538 or #1563 #3894
[mk-proof] #3423 quant-inst #3538
[mk-app] #3356 = #3538 #4067
[mk-proof] #4517 monotonicity #4066 #3356
[mk-app] #2992 = #4067 #4067
[mk-proof] #2993 rewrite #2992
[mk-proof] #4148 trans #4517 #2993 #3356
[mk-proof] #3500 mp #3423 #4148 #4067
[instance] 0x1068bb740 #3423 ; 93
[attach-enode] #4957 93
[attach-enode] #4960 93
[attach-enode] #4374 93
[assign] #4374 justification -1: p50
[end-of-instance]
[eq-expl] #4957 root
[new-match] 0x1068bb9e0 #1477 #1476 #4957 #1545 ; #4960
[eq-expl] #4938 lit #4374 ; #4960
[eq-expl] #4960 root
[new-match] 0x1068bba18 #1522 #1506 #4957 #1545 ; #4939 (#4938 #4960)
[mk-app] #4863 = #4458 #4458
[mk-proof] #4810 refl #4863
[mk-app] #4622 or #1576 #4458
[mk-proof] #3186 quant-inst #4622
[instance] 0x1068bb9e0 #3186 ; 94
[attach-enode] #4975 94
[attach-enode] #4458 94
[assign] #4458 justification -1: p49
[end-of-instance]
[mk-app] #4863 = #3177 #3177
[mk-proof] #4810 refl #4863
[mk-app] #4813 or #3655 #3177
[mk-proof] #4870 quant-inst #4813
[instance] 0x1068bba18 #4870 ; 94
[attach-enode] #4977 94
[attach-enode] #4978 94
[attach-enode] #4981 94
[attach-enode] #4208 94
[attach-enode] #4200 94
[attach-enode] #3177 94
[mk-app] #4781 <= #4200 #1503
[mk-app] #4866 >= #4200 #1503
[assign] #3177 justification -1: p51
[end-of-instance]
[assign] #4781 clause p460 (not p459)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[assign] #4866 clause p461 (not p459)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 47::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 47::Int)))) 4::Int)) 

[mk-app] #4863 = #4939 #4981
[attach-meaning] #176 arith (- 1)
[mk-app] #4810 + #4939 #4208
[mk-app] #5207 <= #4810 #36
[mk-app] #4906 >= #4810 #36
[assign] #4863 justification -1: p457
[attach-enode] #4863 0
[attach-enode] #4810 0
[assign] #5207 justification -1: p462
[assign] #4906 justification -1: p462
[new-match] 0x1068bc3d8 #1495 #1483 #4957 #1545 ; #4977 (#4960 #4960)
[mk-app] #4867 = #4977 #4999
[mk-app] #4710 = #5082 #4867
[mk-proof] #3023 monotonicity #5001 #4710
[mk-app] #3766 or #1563 #4867
[mk-app] #4490 or #1563 #5082
[mk-proof] #3199 quant-inst #4490
[mk-app] #3275 = #4490 #3766
[mk-proof] #3621 monotonicity #3023 #3275
[mk-app] #4277 = #3766 #3766
[mk-proof] #4278 rewrite #4277
[mk-proof] #2985 trans #3621 #4278 #3275
[mk-proof] #2988 mp #3199 #2985 #3766
[instance] 0x1068bc3d8 #3199 ; 95
[attach-enode] #4996 95
[attach-enode] #4999 95
[attach-enode] #4867 95
[assign] #4867 justification -1: p50
[end-of-instance]
[eq-expl] #4996 root
[new-match] 0x1068cdc90 #1477 #1476 #4996 #1545 ; #4999
[eq-expl] #4977 lit #4867 ; #4999
[eq-expl] #4999 root
[new-match] 0x1068cdcc8 #1522 #1506 #4996 #1545 ; #4978 (#4977 #4999)
[mk-app] #3253 = #4679 #4679
[mk-proof] #4001 refl #3253
[mk-app] #3796 or #1576 #4679
[mk-proof] #4583 quant-inst #3796
[instance] 0x1068cdc90 #4583 ; 96
[attach-enode] #5014 96
[attach-enode] #4679 96
[assign] #4679 justification -1: p49
[end-of-instance]
[mk-app] #3253 = #5195 #5195
[mk-proof] #4001 refl #3253
[mk-app] #3920 or #3655 #5195
[mk-proof] #3577 quant-inst #3920
[instance] 0x1068cdcc8 #3577 ; 96
[attach-enode] #5016 96
[attach-enode] #5017 96
[attach-enode] #5020 96
[attach-enode] #3204 96
[attach-enode] #4673 96
[attach-enode] #5195 96
[mk-app] #3790 <= #4673 #1503
[mk-app] #4550 >= #4673 #1503
[assign] #5195 justification -1: p51
[end-of-instance]
[assign] #3790 clause p468 (not p467)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[assign] #4550 clause p469 (not p467)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 48::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 48::Int)))) 4::Int)) 

[mk-app] #3253 = #4978 #5020
[attach-meaning] #176 arith (- 1)
[mk-app] #4001 + #4978 #3204
[mk-app] #3719 <= #4001 #36
[mk-app] #3968 >= #4001 #36
[assign] #3253 justification -1: p465
[attach-enode] #3253 0
[attach-enode] #4001 0
[assign] #3719 justification -1: p470
[assign] #3968 justification -1: p470
[new-match] 0x1068ce688 #1495 #1483 #4996 #1545 ; #5016 (#4999 #4999)
[mk-app] #4570 = #5016 #5038
[mk-app] #3966 = #3106 #4570
[mk-proof] #4254 monotonicity #5040 #3966
[mk-app] #4523 or #1563 #4570
[mk-app] #3058 or #1563 #3106
[mk-proof] #4972 quant-inst #3058
[mk-app] #3054 = #3058 #4523
[mk-proof] #3055 monotonicity #4254 #3054
[mk-app] #5048 = #4523 #4523
[mk-proof] #5041 rewrite #5048
[mk-proof] #3381 trans #3055 #5041 #3054
[mk-proof] #3883 mp #4972 #3381 #4523
[instance] 0x1068ce688 #4972 ; 97
[attach-enode] #5035 97
[attach-enode] #5038 97
[attach-enode] #4570 97
[assign] #4570 justification -1: p50
[end-of-instance]
[eq-expl] #5035 root
[new-match] 0x1068ce928 #1477 #1476 #5035 #1545 ; #5038
[eq-expl] #5016 lit #4570 ; #5038
[eq-expl] #5038 root
[new-match] 0x1068ce960 #1522 #1506 #5035 #1545 ; #5017 (#5016 #5038)
[mk-app] #4112 = #3173 #3173
[mk-proof] #3039 refl #4112
[mk-app] #3478 or #1576 #3173
[mk-proof] #3075 quant-inst #3478
[instance] 0x1068ce928 #3075 ; 98
[attach-enode] #5053 98
[attach-enode] #3173 98
[assign] #3173 justification -1: p49
[end-of-instance]
[mk-app] #4112 = #3448 #3448
[mk-proof] #3039 refl #4112
[mk-app] #3256 or #3655 #3448
[mk-proof] #3226 quant-inst #3256
[instance] 0x1068ce960 #3226 ; 98
[attach-enode] #5055 98
[attach-enode] #5056 98
[attach-enode] #5059 98
[attach-enode] #3132 98
[attach-enode] #3046 98
[attach-enode] #3448 98
[mk-app] #3759 <= #3046 #1503
[mk-app] #3238 >= #3046 #1503
[assign] #3448 justification -1: p51
[end-of-instance]
[assign] #3759 clause p476 (not p475)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[assign] #3238 clause p477 (not p475)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 49::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 49::Int)))) 4::Int)) 

[mk-app] #4112 = #5017 #5059
[attach-meaning] #176 arith (- 1)
[mk-app] #3039 + #5017 #3132
[mk-app] #4139 <= #3039 #36
[mk-app] #3257 >= #3039 #36
[assign] #4112 justification -1: p473
[attach-enode] #4112 0
[attach-enode] #3039 0
[assign] #4139 justification -1: p478
[assign] #3257 justification -1: p478
[new-match] 0x1068cf320 #1495 #1483 #5035 #1545 ; #5055 (#5038 #5038)
[mk-app] #4699 = #5055 #5077
[mk-app] #4808 = #4707 #4699
[mk-proof] #3178 monotonicity #5079 #4808
[mk-app] #3179 or #1563 #4699
[mk-app] #3483 or #1563 #4707
[mk-proof] #3477 quant-inst #3483
[mk-app] #4631 = #3483 #3179
[mk-proof] #3694 monotonicity #3178 #4631
[mk-app] #4945 = #3179 #3179
[mk-proof] #4995 rewrite #4945
[mk-proof] #4343 trans #3694 #4995 #4631
[mk-proof] #3092 mp #3477 #4343 #3179
[instance] 0x1068cf320 #3477 ; 99
[attach-enode] #5074 99
[attach-enode] #5077 99
[attach-enode] #4699 99
[assign] #4699 justification -1: p50
[end-of-instance]
[eq-expl] #5074 root
[new-match] 0x1068cf5c0 #1477 #1476 #5074 #1545 ; #5077
[eq-expl] #5055 lit #4699 ; #5077
[eq-expl] #5077 root
[new-match] 0x1068cf5f8 #1522 #1506 #5074 #1545 ; #5056 (#5055 #5077)
[mk-app] #3324 = #4908 #4908
[mk-proof] #4193 refl #3324
[mk-app] #3456 or #1576 #4908
[mk-proof] #3461 quant-inst #3456
[instance] 0x1068cf5c0 #3461 ; 100
[attach-enode] #5092 100
[attach-enode] #4908 100
[assign] #4908 justification -1: p49
[end-of-instance]
[mk-app] #3324 = #3407 #3407
[mk-proof] #4193 refl #3324
[mk-app] #2997 or #3655 #3407
[mk-proof] #2998 quant-inst #2997
[instance] 0x1068cf5f8 #2998 ; 100
[attach-enode] #5094 100
[attach-enode] #5095 100
[attach-enode] #5098 100
[attach-enode] #4717 100
[attach-enode] #4712 100
[attach-enode] #3407 100
[mk-app] #3269 <= #4712 #1503
[mk-app] #3873 >= #4712 #1503
[assign] #3407 justification -1: p51
[end-of-instance]
[assign] #3269 clause p484 (not p483)
  (<= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[assign] #3873 clause p485 (not p483)
  (>= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int) 
  (not (= (+ (address<Int> (next<Ptr32> (offset<Ptr32> x@1@01 50::Int))) (* -1::Int (address<Int> (offset<Ptr32> x@1@01 50::Int)))) 4::Int)) 

[mk-app] #3324 = #5056 #5098
[attach-meaning] #176 arith (- 1)
[mk-app] #4193 + #5056 #4717
[mk-app] #3834 <= #4193 #36
[mk-app] #3645 >= #4193 #36
[assign] #3324 justification -1: p481
[attach-enode] #3324 0
[attach-enode] #4193 0
[assign] #3834 justification -1: p486
[assign] #3645 justification -1: p486
[new-match] 0x1068e2dd8 #1495 #1483 #5074 #1545 ; #5094 (#5077 #5077)
[push] 3
[mk-app] #4414 + #3402 #151
[mk-app] #3589 = #5175 #4414
[mk-app] #5538 not #3589
[mk-proof] #4680 asserted #5538
[mk-app] #5025 + #151 #3402
[inst-discovered] theory-solving 0x0 arith# ; #4414
[mk-app] #4991 = #4414 #5025
[mk-proof] #3826 rewrite #4991
[instance] 0x0 #4991
[end-of-instance]
[mk-app] #3079 = #5175 #5025
[mk-app] #3565 = #3589 #3079
[mk-proof] #2939 monotonicity #3826 #3565
[attach-meaning] #176 arith (- 1)
[mk-app] #3074 + #5110 #5175
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3079
[mk-app] #3074 = #3079 #5184
[mk-proof] #3940 rewrite #3074
[instance] 0x0 #3074
[end-of-instance]
[mk-app] #5471 = #3589 #5184
[mk-proof] #5124 trans #2939 #3940 #5471
[mk-app] #5268 not #5184
[mk-app] #5263 = #5538 #5268
[mk-proof] #4868 monotonicity #5124 #5263
[mk-proof] #5024 mp #4680 #4868 #5268
[begin-check] 4
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5184 #2
[mk-proof] #5115 iff-false #5024 #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5184 #2
[mk-proof] #5115 iff-false #5024 #4836
[mk-app] #4836 ~ #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 rewrite #4836
[mk-proof] #5116 mp #5024 #5115 #5268
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[mk-app] #4836 = #5268 #5268
[mk-proof] #5115 refl #4836
[attach-enode] #5175 0
[attach-enode] #5179 0
[attach-enode] #5128 0
[attach-enode] #5184 0
[mk-app] #4836 <= #5128 #176
[mk-app] #5115 >= #5128 #176
[assign] (not #5184) justification -1: 
[mk-app] #5116 = #5184 #2
[mk-proof] #5064 iff-false #5024 #5116
[new-match] 0x1068e3238 #124 #118 #1528 ; #3402
[new-match] 0x1068e3268 #143 #118 #1528 ; #3402
[new-match] 0x1068e3298 #2726 #167 #2191 #1528 ; #5175 (#2187 #1529)
[new-match] 0x1068e32d0 #124 #118 #2187 ; #5175
[new-match] 0x1068e3300 #143 #118 #2187 ; #5175
[mk-app] #5510 >= #3402 #36
[mk-app] #5251 = #5510 #5510
[mk-proof] #5526 refl #5251
[mk-app] #5580 or #1546 #5510
[mk-proof] #5466 quant-inst #5580
[instance] 0x1068e3238 #5466 ; 3
[assign] #5510 justification -1: p13
[end-of-instance]
[mk-app] #5251 or #5455 #2172
[mk-app] #5526 = #5251 #5251
[mk-proof] #5283 refl #5526
[mk-app] #5186 or #2307 #5455 #2172
[mk-app] #3580 or #2307 #5251
[mk-proof] #4499 quant-inst #3580
[mk-app] #3301 = #3580 #5186
[mk-proof] #5265 rewrite #3301
[mk-proof] #5432 mp #4499 #5265 #5186
[instance] 0x1068e3268 #4499 ; 3
[attach-enode] #5191 3
[mk-app] #5269 <= #3402 #36
[end-of-instance]
[inst-discovered] theory-solving 0x0 basic# ; #5278
[instance] 0x0 #5271
[end-of-instance]
[instance] 0x1068e3298 #5244 ; 1
[attach-enode] #5139 1
[attach-enode] #5140 1
[attach-enode] #5226 1
[attach-enode] #5229 1
[mk-app] #5526 >= #5226 #36
[end-of-instance]
[mk-app] #5283 >= #5139 #36
[mk-app] #5215 = #5283 #5283
[mk-proof] #5237 refl #5215
[mk-app] #5177 or #1546 #5283
[mk-proof] #5238 quant-inst #5177
[instance] 0x1068e32d0 #5238 ; 1
[assign] #5283 justification -1: p13
[end-of-instance]
[mk-app] #5215 not #5255
[mk-app] #5237 or #5215 #5259
[mk-app] #5225 = #5237 #5237
[mk-proof] #5119 refl #5225
[mk-app] #5288 or #2307 #5215 #5259
[mk-app] #5287 or #2307 #5237
[mk-proof] #5459 quant-inst #5287
[mk-app] #5262 = #5287 #5288
[mk-proof] #5212 rewrite #5262
[mk-proof] #5220 mp #5459 #5212 #5288
[instance] 0x1068e3300 #5459 ; 1
[attach-enode] #5255 1
[mk-app] #5543 <= #5139 #36
[attach-enode] #5259 1
[end-of-instance]
[mk-app] #5225 = #5139 #5175
[attach-meaning] #176 arith (- 1)
[mk-app] #5119 + #5139 #5179
[mk-app] #5068 <= #5119 #36
[mk-app] #5067 >= #5119 #36
[assign] #5225 justification -1: p62
[attach-enode] #5225 0
[attach-enode] #5119 0
[assign] #5068 justification -1: p502
[assign] #5067 justification -1: p502
[decide-and-or] #2170 #2177
[push] 4
[assign] (not #2353) decision axiom
[decide-and-or] #2168 #2294
[push] 5
[assign] (not #2172) decision axiom
[assign] (not #4327) clause (not p79) p68 p66
  (not (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int)))) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] (not #5191) clause (not p493) p68
  (not (= (Seq_length $t@2@01) 0::Int)) 
  (= $t@2@01 Seq_empty) 

[assign] #5229 clause p495 p68 p66
  (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 

[assign] #4355 clause p77 p79
  (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int)) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] #4348 clause p78 p79
  (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int) 
  (or (not (= (Seq_index (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_add 0::Int (Seq_length $t@2@01))) (Seq_index (Seq_singleton 0::Int) 0::Int))) (not (= (Seq_sub (Seq_add 0::Int (Seq_length $t@2@01)) (Seq_length $t@2@01)) 0::Int))) 

[assign] (not #5269) clause (not p494) p493
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #5250 clause p496 (not p495)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5526 clause p497 (not p495)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 

[assign] #5115 clause p491 (not p497) (not p74) (not p504)
  (>= (+ (Seq_length $t@2@01) (* -1::Int (Seq_length seq@8@01))) -1::Int) 
  (not (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (not (<= (Seq_length (Seq_singleton 0::Int)) 1::Int)) 
  (not (>= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 

[assign] #4836 clause p490 (not p496) (not p75) (not p503)
  (<= (+ (Seq_length $t@2@01) (* -1::Int (Seq_length seq@8@01))) -1::Int) 
  (not (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (not (>= (Seq_length (Seq_singleton 0::Int)) 1::Int)) 
  (not (<= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 

[assign] (not #5543) clause (not p500) p494 (not p496) (not p63)
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (<= (Seq_length $t@2@01) 0::Int) 
  (not (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int)) 
  (not (>= (Seq_length (Seq_singleton 0::Int)) 0::Int)) 

[eq-expl] #3403 root
[new-match] 0x1068e4168 #263 #246 #3402 #3403 ; #4347
[new-match] 0x1068e41a0 #1674 #1173 #3403 #1529 ; #4352
[new-match] 0x1068e41d8 #1917 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4218 #1854 #283 #3403 #2191 #1528 ; #4352 (#1529 #1529)
[new-match] 0x1068e4258 #237 #229 #3402 #36 ; #3403
[mk-app] #5242 * #176 #4347
[mk-app] #5197 + #3403 #5110 #5242
[mk-app] #5436 = #5197 #36
[mk-app] #5452 + #5110 #3403 #5242
[inst-discovered] theory-solving 0x0 arith# ; #5197
[mk-app] #5174 = #5197 #5452
[mk-proof] #5275 rewrite #5174
[instance] 0x0 #5174
[end-of-instance]
[mk-app] #5467 = #5452 #36
[mk-app] #5586 = #5436 #5467
[mk-proof] #5448 monotonicity #5275 #5586
[attach-meaning] #176 arith (- 1)
[mk-app] #5587 + #3402 #5120 #4347
[mk-app] #5585 = #5587 #36
[inst-discovered] theory-solving 0x0 arith# ; #5467
[mk-app] #5211 = #5467 #5585
[mk-proof] #5153 rewrite #5211
[instance] 0x0 #5211
[end-of-instance]
[mk-app] #5560 = #5436 #5585
[mk-proof] #5589 trans #5448 #5153 #5560
[mk-app] #5152 not #263
[mk-app] #5590 or #5152 #5585
[mk-app] #5591 or #5152 #5436
[mk-proof] #5511 quant-inst #5591
[mk-app] #5532 = #5591 #5590
[mk-proof] #5460 monotonicity #5589 #5532
[mk-app] #5525 = #5590 #5590
[mk-proof] #2321 rewrite #5525
[mk-proof] #5524 trans #5460 #2321 #5532
[mk-proof] #5517 mp #5511 #5524 #5590
[instance] 0x1068e4168 #5511 ; 3
[attach-enode] #5120 3
[attach-enode] #5587 3
[attach-enode] #5585 3
[mk-app] #2292 <= #5587 #36
[mk-app] #5218 >= #5587 #36
[assign] #5585 justification -1: p21
[end-of-instance]
[mk-app] #5267 or #5142 #5144 #5145
[inst-discovered] theory-solving 0x0 basic# ; #5267
[mk-app] #5185 = #5267 #5267
[mk-proof] #5512 rewrite #5185
[instance] 0x0 #5185
[end-of-instance]
[mk-app] #5450 or #4423 #5142 #5144 #5145
[mk-app] #5134 or #4423 #5267
[mk-proof] #5535 quant-inst #5134
[mk-app] #5431 = #5134 #5450
[mk-proof] #5554 rewrite #5431
[mk-proof] #5584 mp #5535 #5554 #5450
[instance] 0x1068e41a0 #5535 ; 3
[attach-enode] #5141 3
[attach-enode] #5145 3
[end-of-instance]
[mk-app] #5185 or #2353 #2172 #5148 #5156 #5144
[mk-app] #5512 or #2353 #2172 #5148 #5165 #5144
[mk-app] #2300 = #5185 #5512
[mk-proof] #5513 monotonicity #5169 #2300
[mk-app] #5257 or #2172 #2353 #5144 #5148 #5165
[inst-discovered] theory-solving 0x0 basic# ; #5512
[mk-app] #5625 = #5512 #5257
[mk-proof] #5610 rewrite #5625
[instance] 0x0 #5625
[end-of-instance]
[mk-app] #5439 = #5185 #5257
[mk-proof] #5579 trans #5513 #5610 #5439
[mk-app] #5213 not #1917
[mk-app] #5531 or #5213 #2172 #2353 #5144 #5148 #5165
[mk-app] #5453 or #5213 #5185
[mk-proof] #5474 quant-inst #5453
[mk-app] #5553 or #5213 #5257
[mk-app] #5623 = #5453 #5553
[mk-proof] #5558 monotonicity #5579 #5623
[mk-app] #5477 = #5553 #5531
[mk-proof] #5559 rewrite #5477
[mk-app] #5216 = #5453 #5531
[mk-proof] #5441 trans #5558 #5559 #5216
[mk-proof] #5434 mp #5474 #5441 #5531
[instance] 0x1068e41d8 #5474 ; 3
[attach-enode] #5147 3
[attach-enode] #5148 3
[attach-enode] #5164 3
[end-of-instance]
[instance] 0x1068e4258 #5182 ; 3
[attach-enode] #5253 3
[assign] #5253 justification -1: p20
[end-of-instance]
[resolve-process] true
[resolve-lit] 0 (not #4836)
[resolve-lit] 0 (not #5115)
[resolve-process] (not #4836)
[resolve-lit] 0 (not #5250)
[resolve-process] (not #5115)
[resolve-lit] 0 (not #5526)
[resolve-process] (not #5526)
[resolve-lit] 0 (not #5229)
[resolve-process] (not #5250)
[mk-proof] #5443 monotonicity #1535 #5225
[mk-app] #5208 not #5225
[mk-app] #5465 or #5208 #5067
[mk-proof] #5464 th-lemma #5465
[mk-proof] #5170 unit-resolution #5464 #5443 #5067
[mk-app] #5188 or #5599 #2135
[mk-proof] #5222 th-lemma #5188
[mk-proof] #5203 unit-resolution #5222 #2186 #2135
[mk-proof] #5189 hypothesis #5229
[mk-app] #5555 or #5604 #5526
[mk-proof] #5438 th-lemma #5555
[mk-proof] #5180 unit-resolution #5438 #5189 #5526
[mk-app] #5595 not #5067
[mk-app] #5614 not #2135
[mk-app] #5615 not #5526
[mk-app] #5594 or #5115 #5595 #5614 #5615
[mk-proof] #5616 th-lemma #5594
[mk-proof] #5447 unit-resolution #5616 #5180 #5203 #5170 #5115
[mk-app] #5469 or #5208 #5068
[mk-proof] #5239 th-lemma #5469
[mk-proof] #5557 unit-resolution #5239 #5443 #5068
[mk-proof] #5236 unit-resolution #5621 #5189 #5250
[mk-app] #5608 not #5068
[mk-app] #5542 not #2136
[mk-app] #5550 not #5250
[mk-app] #5442 or #4836 #5608 #5542 #5550
[mk-proof] #5546 th-lemma #5442
[mk-proof] #5444 unit-resolution #5546 #5236 #5619 #5557 #4836
[mk-app] #5435 not #4836
[mk-app] #5551 not #5115
[mk-app] #5545 or #5184 #5435 #5551
[mk-proof] #5445 th-lemma #5545
[mk-app] #5596 or #5435 #5551
[mk-proof] #5597 unit-resolution #5445 #5024 #5596
[mk-proof] #5598 unit-resolution #5597 #5444 #5447 #2
[mk-proof] #5556 lemma #5598 #5604
[conflict] (not #5229)
[pop] 2 6
[assign] (not #5229) justification -1: 
[decide-and-or] #2170 #2177
[push] 4
[assign] (not #2353) decision axiom
[assign] #2172 clause p68 p66 p495
  (= $t@2@01 Seq_empty) 
  (= (Seq_singleton 0::Int) Seq_empty) 
  (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] #2167 clause p69 (not p68) (not p70)
  (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int)) 
  (not (= $t@2@01 Seq_empty)) 
  (not (or (not (= $t@2@01 Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) (Seq_singleton 0::Int)))) 

[assign] #5191 justification -1: p14 p68
[assign] (not #5259) justification -1: (not p66) p69
[assign] (not #2178) justification -1: (not p66) p69 p68
[assign] (not #5255) justification -1: (not p64) p62 p69 p62
[mk-app] #5152 = #131 #3402
[attach-meaning] #176 arith (- 1)
[mk-app] #5591 + #131 #5110
[mk-app] #5511 <= #5591 #36
[mk-app] #5452 >= #5591 #36
[assign] #5152 justification -1: p68
[attach-enode] #5152 0
[attach-enode] #5110 0
[attach-enode] #5591 0
[assign] #5511 justification -1: p505
[assign] #5452 justification -1: p505
[mk-app] #5174 = #2347 #5175
[attach-meaning] #176 arith (- 1)
[mk-app] #5275 + #2347 #5179
[mk-app] #5467 <= #5275 #36
[mk-app] #5586 >= #5275 #36
[assign] #5174 justification -1: p62 p69
[attach-enode] #5174 0
[attach-enode] #5275 0
[assign] #5467 justification -1: p508
[assign] #5586 justification -1: p508
[eq-expl] #1528 lit #2172 ; #130
[eq-expl] #2191 lit #2167 ; #1529
[new-match] 0x1068e47f8 #1917 #283 #36 #2191 #1528 ; #2304 (#2191 #1529)
[new-match] 0x1068e4838 #1854 #283 #36 #2191 #1528 ; #2304 (#2191 #1529)
[assign] #5269 clause p494 (not p493)
  (<= (Seq_length $t@2@01) 0::Int) 
  (not (= (Seq_length $t@2@01) 0::Int)) 

[assign] (not #5543) clause (not p500) p499
  (not (<= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int)) 
  (= (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) 0::Int) 

[assign] #5250 clause p496 (not p494) (not p504) (not p509)
  (<= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (not (>= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 
  (not (<= (+ (Seq_length (Seq_singleton 0::Int)) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 

[assign] #5526 clause p497 (not p510) (not p503) (not p492)
  (>= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 
  (not (>= (+ (Seq_length (Seq_singleton 0::Int)) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 
  (not (<= (+ (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))) (* -1::Int (Seq_length seq@8@01))) 0::Int)) 
  (not (>= (Seq_length $t@2@01) 0::Int)) 

[resolve-process] true
[resolve-lit] 0 (not #5526)
[resolve-lit] 0 (not #5250)
[resolve-process] (not #5526)
[resolve-lit] 0 (not #5586)
[resolve-process] (not #5250)
[resolve-lit] 0 (not #5269)
[resolve-lit] 0 (not #5467)
[resolve-process] (not #5269)
[resolve-lit] 0 (not #5191)
[resolve-process] (not #5586)
[resolve-lit] 0 (not #5174)
[resolve-process] (not #5467)
[resolve-process] (not #5174)
[resolve-lit] 0 (not #2167)
[resolve-process] (not #5191)
[resolve-lit] 0 (not #2172)
[resolve-process] (not #2167)
[mk-proof] #5448 unit-resolution #2335 #2246 #2163
[mk-proof] #5587 unit-resolution #2142 #5448 #2168
[mk-proof] #5585 hypothesis #2172
[mk-proof] #5211 unit-resolution #2151 #5585 #5587 #2167
[mk-app] #5153 = #2191 #1529
[mk-proof] #5560 symm #5211 #5153
[mk-app] #5589 = #2187 #2191
[mk-proof] #5590 trans* #1532 #5211 #5589
[mk-app] #5532 = #5175 #2347
[mk-proof] #5460 monotonicity #5590 #5532
[mk-proof] #5525 symm #5460 #5174
[mk-app] #2321 not #5174
[mk-app] #5524 or #2321 #5467
[mk-proof] #5517 th-lemma #5524
[mk-proof] #5134 unit-resolution #5517 #5525 #5467
[mk-app] #5535 = #3402 #131
[mk-proof] #5450 monotonicity #5585 #5535
[mk-proof] #5431 trans* #5450 #133 #5191
[mk-app] #5554 or #5455 #5269
[mk-proof] #5584 th-lemma #5554
[mk-proof] #5213 unit-resolution #5584 #5431 #5269
[mk-app] #5453 not #5467
[mk-app] #5474 not #5269
[mk-app] #5512 or #5250 #5453 #5595 #5474
[mk-proof] #2300 th-lemma #5512
[mk-proof] #5513 unit-resolution #2300 #5213 #5170 #5134 #5250
[mk-proof] #5257 unit-resolution #5466 #2880 #5510
[mk-app] #5625 or #2321 #5586
[mk-proof] #5610 th-lemma #5625
[mk-proof] #5439 unit-resolution #5610 #5525 #5586
[mk-app] #5579 not #5586
[mk-app] #5553 not #5510
[mk-app] #5623 or #5526 #5579 #5608 #5553
[mk-proof] #5558 th-lemma #5623
[mk-proof] #5531 unit-resolution #5558 #5439 #5557 #5257 #5526
[mk-app] #5477 or #5229 #5550 #5615
[mk-proof] #5559 th-lemma #5477
[mk-proof] #5216 unit-resolution #5559 #5531 #5513 #5556 #2
[mk-proof] #5441 lemma #5216 #2294
[conflict] (not #2172)
[pop] 1 5
[attach-enode] #5275 0
[assign] (not #2172) justification -1: 
[assign] (not #5191) clause (not p493) p68
  (not (= (Seq_length $t@2@01) 0::Int)) 
  (= $t@2@01 Seq_empty) 

[assign] #2353 clause p66 p68 p495
  (= (Seq_singleton 0::Int) Seq_empty) 
  (= $t@2@01 Seq_empty) 
  (= (+ (Seq_length (Seq_singleton 0::Int)) (Seq_length $t@2@01) (* -1::Int (Seq_length (Seq_append $t@2@01 (Seq_singleton 0::Int))))) 0::Int) 

[assign] (not #5269) clause (not p494) p493
  (not (<= (Seq_length $t@2@01) 0::Int)) 
  (= (Seq_length $t@2@01) 0::Int) 

[assign] #2178 clause p71 (not p66) (not p72)
  (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01) 
  (not (= (Seq_singleton 0::Int) Seq_empty)) 
  (not (or (not (= (Seq_singleton 0::Int) Seq_empty)) (= (Seq_append $t@2@01 (Seq_singleton 0::Int)) $t@2@01))) 

[mk-proof] #5152 unit-resolution #5249 #2731 #5246
[mk-proof] #5591 unit-resolution #5152 #5441 #5556 #2353
[mk-app] #5511 = #151 #2347
[mk-proof] #5452 symm #2186 #5511
[mk-app] #5153 = #2347 #131
[mk-proof] #5560 monotonicity #5591 #5153
[mk-app] #5434 = #151 #36
[mk-proof] #5549 trans* #5452 #5560 #133 #5434
[mk-app] #5463 = #5434 #2
[mk-proof] #5182 rewrite #5463
[mk-proof] #5253 mp #5549 #5182 #2
[pop] 1 4
[mk-proof] #5116 asserted #3589
[inst-discovered] theory-solving 0x0 arith# ; #4414
[instance] 0x0 #4991
[end-of-instance]
[attach-meaning] #176 arith (- 1)
[mk-app] #5064 + #5110 #5175
[attach-meaning] #176 arith (- 1)
[attach-meaning] #176 arith (- 1)
[inst-discovered] theory-solving 0x0 arith# ; #3079
[instance] 0x0 #3074
[end-of-instance]
